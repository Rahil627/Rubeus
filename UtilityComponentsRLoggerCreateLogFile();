[1mdiff --git a/RubeusCore/CMakeLists.txt b/RubeusCore/CMakeLists.txt[m
[1mindex e7e6f8a..1e65cdf 100644[m
[1m--- a/RubeusCore/CMakeLists.txt[m
[1m+++ b/RubeusCore/CMakeLists.txt[m
[36m@@ -24,10 +24,17 @@[m [mfile(GLOB_RECURSE VENDOR_LINUX_LIBRARIES[m
 [m
 add_definitions(-DGLEW_STATIC)[m
 add_definitions(-DGLFW_DLL)[m
[31m-[m
[32m+[m[32madd_definitions(-DIMGUI_IMPL_OPENGL_LOADER_GLEW)[m
 # This adds the source to this project's executable.[m
 add_executable (RubeusCore "RubeusCore.cpp" "RubeusCore.h" ${RUBEUS_SOURCES} ${HEADERS})[m
 [m
[32m+[m
[32m+[m[32minclude_directories(PUBLIC[m
[32m+[m[32m    ${OPENGL_INCLUDE_DIRS}[m
[32m+[m[32m    ../vendor/include/[m
[32m+[m	[32m../vendor/source/[m
[32m+[m[32m)[m
[32m+[m
 target_include_directories(RubeusCore PUBLIC[m
     ./Game[m
     ./Source/Architecture[m
[36m@@ -42,6 +49,25 @@[m [mtarget_include_directories(RubeusCore PUBLIC[m
     ../vendor/include/[m
 )[m
 [m
[32m+[m
[32m+[m[32mset(imgui_root ../vendor/source/ImGui)[m
[32m+[m[32madd_library(imgui STATIC[m
[32m+[m[32m    ${imgui_root}/imgui.h[m
[32m+[m[32m    ${imgui_root}/imstb_rectpack.h[m[41m [m
[32m+[m[32m    ${imgui_root}/imstb_textedit.h[m[41m [m
[32m+[m[32m    ${imgui_root}/imstb_truetype.h[m
[32m+[m[32m    ${imgui_root}/imgui_internal.h[m
[32m+[m[32m    ${imgui_root}/imgui.cpp[m
[32m+[m[32m    ${imgui_root}/imgui_demo.cpp[m
[32m+[m[32m    ${imgui_root}/imgui_draw.cpp[m
[32m+[m[32m    ${imgui_root}/imgui_widgets.cpp[m
[32m+[m[32m    ${imgui_root}/imgui_impl_glfw.cpp[m
[32m+[m[32m    ${imgui_root}/imgui_impl_glfw.h[m
[32m+[m	[32m${imgui_root}/imgui_impl_opengl3.cpp[m
[32m+[m[32m    ${imgui_root}/imgui_impl_opengl3.h[m
[32m+[m	[32m../vendor/include/[m
[32m+[m[32m)[m
[32m+[m
 if(WIN32)[m
     # Remove this line if you want to remove Visual Leak Detection(VLD) reports in Debug mode.[m
     # Keep this line if you want to have VLD reports to detect memory leaks  [m
[36m@@ -51,6 +77,7 @@[m [mif(WIN32)[m
         ${OPENGL_LIBRARIES}[m
 		${VENDOR_WIN_LIBRARIES}[m
         -lstdc++fs[m
[32m+[m		[32mimgui[m
     )[m
 [m
 	add_custom_command(TARGET RubeusCore POST_BUILD[m
[36m@@ -71,6 +98,7 @@[m [mif(UNIX)[m
         ${ILU_LIBRARIES}[m
         ${VENDOR_LINUX_LIBRARIES}[m
         -lstdc++fs[m
[32m+[m		[32mimgui[m
     )[m
 endif(UNIX)[m
 [m
[1mdiff --git a/RubeusCore/ProjectManager.vcxproj b/RubeusCore/ProjectManager.vcxproj[m
[1mnew file mode 100644[m
[1mindex 0000000..9faf13d[m
[1m--- /dev/null[m
[1m+++ b/RubeusCore/ProjectManager.vcxproj[m
[36m@@ -0,0 +1,477 @@[m
[32m+[m[32mï»¿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">[m
[32m+[m[32m  <ItemGroup Label="ProjectConfigurations">[m
[32m+[m[32m    <ProjectConfiguration Include="Debug|Win32">[m
[32m+[m[32m      <Configuration>Debug</Configuration>[m
[32m+[m[32m      <Platform>Win32</Platform>[m
[32m+[m[32m    </ProjectConfiguration>[m
[32m+[m[32m    <ProjectConfiguration Include="Release|Win32">[m
[32m+[m[32m      <Configuration>Release</Configuration>[m
[32m+[m[32m      <Platform>Win32</Platform>[m
[32m+[m[32m    </ProjectConfiguration>[m
[32m+[m[32m    <ProjectConfiguration Include="MinSizeRel|Win32">[m
[32m+[m[32m      <Configuration>MinSizeRel</Configuration>[m
[32m+[m[32m      <Platform>Win32</Platform>[m
[32m+[m[32m    </ProjectConfiguration>[m
[32m+[m[32m    <ProjectConfiguration Include="RelWithDebInfo|Win32">[m
[32m+[m[32m      <Configuration>RelWithDebInfo</Configuration>[m
[32m+[m[32m      <Platform>Win32</Platform>[m
[32m+[m[32m    </ProjectConfiguration>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <PropertyGroup Label="Globals">[m
[32m+[m[32m    <ProjectGuid>{A1C2706D-5035-3FAB-AC13-FC3C97A467BE}</ProjectGuid>[m
[32m+[m[32m    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>[m
[32m+[m[32m    <Keyword>Win32Proj</Keyword>[m
[32m+[m[32m    <Platform>Win32</Platform>[m
[32m+[m[32m    <ProjectName>ProjectManager</ProjectName>[m
[32m+[m[32m    <VCProjectUpgraderObjectName>NoUpgrade</VCProjectUpgraderObjectName>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />[m
[32m+[m[32m  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">[m
[32m+[m[32m    <ConfigurationType>Application</ConfigurationType>[m
[32m+[m[32m    <CharacterSet>MultiByte</CharacterSet>[m
[32m+[m[32m    <PlatformToolset>v141</PlatformToolset>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">[m
[32m+[m[32m    <ConfigurationType>Application</ConfigurationType>[m
[32m+[m[32m    <CharacterSet>MultiByte</CharacterSet>[m
[32m+[m[32m    <PlatformToolset>v141</PlatformToolset>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'" Label="Configuration">[m
[32m+[m[32m    <ConfigurationType>Application</ConfigurationType>[m
[32m+[m[32m    <CharacterSet>MultiByte</CharacterSet>[m
[32m+[m[32m    <PlatformToolset>v141</PlatformToolset>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'" Label="Configuration">[m
[32m+[m[32m    <ConfigurationType>Application</ConfigurationType>[m
[32m+[m[32m    <CharacterSet>MultiByte</CharacterSet>[m
[32m+[m[32m    <PlatformToolset>v141</PlatformToolset>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />[m
[32m+[m[32m  <ImportGroup Label="ExtensionSettings">[m
[32m+[m[32m  </ImportGroup>[m
[32m+[m[32m  <ImportGroup Label="PropertySheets">[m
[32m+[m[32m    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />[m
[32m+[m[32m  </ImportGroup>[m
[32m+[m[32m  <PropertyGroup Label="UserMacros" />[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <_ProjectFileVersion>10.0.20506.1</_ProjectFileVersion>[m
[32m+[m[32m    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">D:\Rubeus\RubeusCore\Debug\</OutDir>[m
[32m+[m[32m    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">ProjectManager.dir\Debug\</IntDir>[m
[32m+[m[32m    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">ProjectManager</TargetName>[m
[32m+[m[32m    <TargetExt Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">.exe</TargetExt>[m
[32m+[m[32m    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>[m
[32m+[m[32m    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</GenerateManifest>[m
[32m+[m[32m    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">D:\Rubeus\RubeusCore\Release\</OutDir>[m
[32m+[m[32m    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">ProjectManager.dir\Release\</IntDir>[m
[32m+[m[32m    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">ProjectManager</TargetName>[m
[32m+[m[32m    <TargetExt Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">.exe</TargetExt>[m
[32m+[m[32m    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>[m
[32m+[m[32m    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</GenerateManifest>[m
[32m+[m[32m    <OutDir Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">D:\Rubeus\RubeusCore\MinSizeRel\</OutDir>[m
[32m+[m[32m    <IntDir Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">ProjectManager.dir\MinSizeRel\</IntDir>[m
[32m+[m[32m    <TargetName Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">ProjectManager</TargetName>[m
[32m+[m[32m    <TargetExt Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">.exe</TargetExt>[m
[32m+[m[32m    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">false</LinkIncremental>[m
[32m+[m[32m    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">true</GenerateManifest>[m
[32m+[m[32m    <OutDir Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">D:\Rubeus\RubeusCore\RelWithDebInfo\</OutDir>[m
[32m+[m[32m    <IntDir Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">ProjectManager.dir\RelWithDebInfo\</IntDir>[m
[32m+[m[32m    <TargetName Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">ProjectManager</TargetName>[m
[32m+[m[32m    <TargetExt Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">.exe</TargetExt>[m
[32m+[m[32m    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">true</LinkIncremental>[m
[32m+[m[32m    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">true</GenerateManifest>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">[m
[32m+[m[32m    <ClCompile>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;D:\Rubeus\RubeusCore\.\Game;D:\Rubeus\RubeusCore\.\Source\Architecture;D:\Rubeus\RubeusCore\.\Source\AudioComponents;D:\Rubeus\RubeusCore\.\Source\Awerere;D:\Rubeus\RubeusCore\.\Source\GraphicComponents;D:\Rubeus\RubeusCore\.\Source\InputManager;D:\Rubeus\RubeusCore\.\Source\MessageSystem;D:\Rubeus\RubeusCore\.\Source\RML;D:\Rubeus\RubeusCore\.\Source\UtilityComponents;D:\Rubeus\RubeusCore\.\Source\ProjectManager;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m      <AssemblerListingLocation>Debug/</AssemblerListingLocation>[m
[32m+[m[32m      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>[m
[32m+[m[32m      <CompileAs>CompileAsCpp</CompileAs>[m
[32m+[m[32m      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>[m
[32m+[m[32m      <ExceptionHandling>Sync</ExceptionHandling>[m
[32m+[m[32m      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>[m
[32m+[m[32m      <LanguageStandard>stdcpp17</LanguageStandard>[m
[32m+[m[32m      <Optimization>Disabled</Optimization>[m
[32m+[m[32m      <PrecompiledHeader>NotUsing</PrecompiledHeader>[m
[32m+[m[32m      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>[m
[32m+[m[32m      <RuntimeTypeInfo>true</RuntimeTypeInfo>[m
[32m+[m[32m      <WarningLevel>Level3</WarningLevel>[m
[32m+[m[32m      <PreprocessorDefinitions>WIN32;_WINDOWS;GLEW_STATIC;GLFW_DLL;IMGUI_IMPL_OPENGL_LOADER_GLEW;CMAKE_INTDIR="Debug";%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <ObjectFileName>$(IntDir)</ObjectFileName>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ResourceCompile>[m
[32m+[m[32m      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;GLEW_STATIC;GLFW_DLL;IMGUI_IMPL_OPENGL_LOADER_GLEW;CMAKE_INTDIR=\"Debug\";%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;D:\Rubeus\RubeusCore\.\Game;D:\Rubeus\RubeusCore\.\Source\Architecture;D:\Rubeus\RubeusCore\.\Source\AudioComponents;D:\Rubeus\RubeusCore\.\Source\Awerere;D:\Rubeus\RubeusCore\.\Source\GraphicComponents;D:\Rubeus\RubeusCore\.\Source\InputManager;D:\Rubeus\RubeusCore\.\Source\MessageSystem;D:\Rubeus\RubeusCore\.\Source\RML;D:\Rubeus\RubeusCore\.\Source\UtilityComponents;D:\Rubeus\RubeusCore\.\Source\ProjectManager;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m    </ResourceCompile>[m
[32m+[m[32m    <Midl>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;D:\Rubeus\RubeusCore\.\Game;D:\Rubeus\RubeusCore\.\Source\Architecture;D:\Rubeus\RubeusCore\.\Source\AudioComponents;D:\Rubeus\RubeusCore\.\Source\Awerere;D:\Rubeus\RubeusCore\.\Source\GraphicComponents;D:\Rubeus\RubeusCore\.\Source\InputManager;D:\Rubeus\RubeusCore\.\Source\MessageSystem;D:\Rubeus\RubeusCore\.\Source\RML;D:\Rubeus\RubeusCore\.\Source\UtilityComponents;D:\Rubeus\RubeusCore\.\Source\ProjectManager;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m      <OutputDirectory>$(ProjectDir)/$(IntDir)</OutputDirectory>[m
[32m+[m[32m      <HeaderFileName>%(Filename).h</HeaderFileName>[m
[32m+[m[32m      <TypeLibraryName>%(Filename).tlb</TypeLibraryName>[m
[32m+[m[32m      <InterfaceIdentifierFileName>%(Filename)_i.c</InterfaceIdentifierFileName>[m
[32m+[m[32m      <ProxyFileName>%(Filename)_p.c</ProxyFileName>[m
[32m+[m[32m    </Midl>[m
[32m+[m[32m    <Link>[m
[32m+[m[32m      <AdditionalDependencies>opengl32.lib;glu32.lib;..\vendor\libraries\Win\DevIL.lib;..\vendor\libraries\Win\ILU.lib;..\vendor\libraries\Win\ILUT.lib;..\vendor\libraries\Win\flac.lib;..\vendor\libraries\Win\glew32s.lib;..\vendor\libraries\Win\glfw3.lib;..\vendor\libraries\Win\glfw3dll.lib;..\vendor\libraries\Win\ogg.lib;..\vendor\libraries\Win\openal32.lib;..\vendor\libraries\Win\sfml-audio-d.lib;..\vendor\libraries\Win\sfml-audio-s-d.lib;..\vendor\libraries\Win\sfml-audio-s.lib;..\vendor\libraries\Win\sfml-audio.lib;..\vendor\libraries\Win\sfml-system-d.lib;..\vendor\libraries\Win\sfml-system-s-d.lib;..\vendor\libraries\Win\sfml-system-s.lib;..\vendor\libraries\Win\sfml-system.lib;..\vendor\libraries\Win\vorbis.lib;..\vendor\libraries\Win\vorbisenc.lib;..\vendor\libraries\Win\vorbisfile.lib;-lstdc++fs;Debug\imgui.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;comdlg32.lib;advapi32.lib</AdditionalDependencies>[m
[32m+[m[32m      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>[m
[32m+[m[32m      <AdditionalOptions>%(AdditionalOptions) /machine:X86</AdditionalOptions>[m
[32m+[m[32m      <GenerateDebugInformation>true</GenerateDebugInformation>[m
[32m+[m[32m      <IgnoreSpecificDefaultLibraries>%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>[m
[32m+[m[32m      <ImportLibrary>D:/Rubeus/RubeusCore/Debug/ProjectManager.lib</ImportLibrary>[m
[32m+[m[32m      <ProgramDataBaseFile>D:/Rubeus/RubeusCore/Debug/ProjectManager.pdb</ProgramDataBaseFile>[m
[32m+[m[32m      <SubSystem>Console</SubSystem>[m
[32m+[m[32m    </Link>[m
[32m+[m[32m    <ProjectReference>[m
[32m+[m[32m      <LinkLibraryDependencies>false</LinkLibraryDependencies>[m
[32m+[m[32m    </ProjectReference>[m
[32m+[m[32m  </ItemDefinitionGroup>[m
[32m+[m[32m  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">[m
[32m+[m[32m    <ClCompile>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;D:\Rubeus\RubeusCore\.\Game;D:\Rubeus\RubeusCore\.\Source\Architecture;D:\Rubeus\RubeusCore\.\Source\AudioComponents;D:\Rubeus\RubeusCore\.\Source\Awerere;D:\Rubeus\RubeusCore\.\Source\GraphicComponents;D:\Rubeus\RubeusCore\.\Source\InputManager;D:\Rubeus\RubeusCore\.\Source\MessageSystem;D:\Rubeus\RubeusCore\.\Source\RML;D:\Rubeus\RubeusCore\.\Source\UtilityComponents;D:\Rubeus\RubeusCore\.\Source\ProjectManager;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m      <AssemblerListingLocation>Release/</AssemblerListingLocation>[m
[32m+[m[32m      <CompileAs>CompileAsCpp</CompileAs>[m
[32m+[m[32m      <ExceptionHandling>Sync</ExceptionHandling>[m
[32m+[m[32m      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>[m
[32m+[m[32m      <LanguageStandard>stdcpp17</LanguageStandard>[m
[32m+[m[32m      <Optimization>MaxSpeed</Optimization>[m
[32m+[m[32m      <PrecompiledHeader>NotUsing</PrecompiledHeader>[m
[32m+[m[32m      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>[m
[32m+[m[32m      <RuntimeTypeInfo>true</RuntimeTypeInfo>[m
[32m+[m[32m      <WarningLevel>Level3</WarningLevel>[m
[32m+[m[32m      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;GLEW_STATIC;GLFW_DLL;IMGUI_IMPL_OPENGL_LOADER_GLEW;CMAKE_INTDIR="Release";%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <ObjectFileName>$(IntDir)</ObjectFileName>[m
[32m+[m[32m      <DebugInformationFormat>[m
[32m+[m[32m      </DebugInformationFormat>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ResourceCompile>[m
[32m+[m[32m      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;GLEW_STATIC;GLFW_DLL;IMGUI_IMPL_OPENGL_LOADER_GLEW;CMAKE_INTDIR=\"Release\";%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;D:\Rubeus\RubeusCore\.\Game;D:\Rubeus\RubeusCore\.\Source\Architecture;D:\Rubeus\RubeusCore\.\Source\AudioComponents;D:\Rubeus\RubeusCore\.\Source\Awerere;D:\Rubeus\RubeusCore\.\Source\GraphicComponents;D:\Rubeus\RubeusCore\.\Source\InputManager;D:\Rubeus\RubeusCore\.\Source\MessageSystem;D:\Rubeus\RubeusCore\.\Source\RML;D:\Rubeus\RubeusCore\.\Source\UtilityComponents;D:\Rubeus\RubeusCore\.\Source\ProjectManager;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m    </ResourceCompile>[m
[32m+[m[32m    <Midl>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;D:\Rubeus\RubeusCore\.\Game;D:\Rubeus\RubeusCore\.\Source\Architecture;D:\Rubeus\RubeusCore\.\Source\AudioComponents;D:\Rubeus\RubeusCore\.\Source\Awerere;D:\Rubeus\RubeusCore\.\Source\GraphicComponents;D:\Rubeus\RubeusCore\.\Source\InputManager;D:\Rubeus\RubeusCore\.\Source\MessageSystem;D:\Rubeus\RubeusCore\.\Source\RML;D:\Rubeus\RubeusCore\.\Source\UtilityComponents;D:\Rubeus\RubeusCore\.\Source\ProjectManager;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m      <OutputDirectory>$(ProjectDir)/$(IntDir)</OutputDirectory>[m
[32m+[m[32m      <HeaderFileName>%(Filename).h</HeaderFileName>[m
[32m+[m[32m      <TypeLibraryName>%(Filename).tlb</TypeLibraryName>[m
[32m+[m[32m      <InterfaceIdentifierFileName>%(Filename)_i.c</InterfaceIdentifierFileName>[m
[32m+[m[32m      <ProxyFileName>%(Filename)_p.c</ProxyFileName>[m
[32m+[m[32m    </Midl>[m
[32m+[m[32m    <Link>[m
[32m+[m[32m      <AdditionalDependencies>opengl32.lib;glu32.lib;..\vendor\libraries\Win\DevIL.lib;..\vendor\libraries\Win\ILU.lib;..\vendor\libraries\Win\ILUT.lib;..\vendor\libraries\Win\flac.lib;..\vendor\libraries\Win\glew32s.lib;..\vendor\libraries\Win\glfw3.lib;..\vendor\libraries\Win\glfw3dll.lib;..\vendor\libraries\Win\ogg.lib;..\vendor\libraries\Win\openal32.lib;..\vendor\libraries\Win\sfml-audio-d.lib;..\vendor\libraries\Win\sfml-audio-s-d.lib;..\vendor\libraries\Win\sfml-audio-s.lib;..\vendor\libraries\Win\sfml-audio.lib;..\vendor\libraries\Win\sfml-system-d.lib;..\vendor\libraries\Win\sfml-system-s-d.lib;..\vendor\libraries\Win\sfml-system-s.lib;..\vendor\libraries\Win\sfml-system.lib;..\vendor\libraries\Win\vorbis.lib;..\vendor\libraries\Win\vorbisenc.lib;..\vendor\libraries\Win\vorbisfile.lib;-lstdc++fs;Release\imgui.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;comdlg32.lib;advapi32.lib</AdditionalDependencies>[m
[32m+[m[32m      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>[m
[32m+[m[32m      <AdditionalOptions>%(AdditionalOptions) /machine:X86</AdditionalOptions>[m
[32m+[m[32m      <GenerateDebugInformation>false</GenerateDebugInformation>[m
[32m+[m[32m      <IgnoreSpecificDefaultLibraries>%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>[m
[32m+[m[32m      <ImportLibrary>D:/Rubeus/RubeusCore/Release/ProjectManager.lib</ImportLibrary>[m
[32m+[m[32m      <ProgramDataBaseFile>D:/Rubeus/RubeusCore/Release/ProjectManager.pdb</ProgramDataBaseFile>[m
[32m+[m[32m      <SubSystem>Console</SubSystem>[m
[32m+[m[32m    </Link>[m
[32m+[m[32m    <ProjectReference>[m
[32m+[m[32m      <LinkLibraryDependencies>false</LinkLibraryDependencies>[m
[32m+[m[32m    </ProjectReference>[m
[32m+[m[32m  </ItemDefinitionGroup>[m
[32m+[m[32m  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">[m
[32m+[m[32m    <ClCompile>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;D:\Rubeus\RubeusCore\.\Game;D:\Rubeus\RubeusCore\.\Source\Architecture;D:\Rubeus\RubeusCore\.\Source\AudioComponents;D:\Rubeus\RubeusCore\.\Source\Awerere;D:\Rubeus\RubeusCore\.\Source\GraphicComponents;D:\Rubeus\RubeusCore\.\Source\InputManager;D:\Rubeus\RubeusCore\.\Source\MessageSystem;D:\Rubeus\RubeusCore\.\Source\RML;D:\Rubeus\RubeusCore\.\Source\UtilityComponents;D:\Rubeus\RubeusCore\.\Source\ProjectManager;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m      <AssemblerListingLocation>MinSizeRel/</AssemblerListingLocation>[m
[32m+[m[32m      <CompileAs>CompileAsCpp</CompileAs>[m
[32m+[m[32m      <ExceptionHandling>Sync</ExceptionHandling>[m
[32m+[m[32m      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>[m
[32m+[m[32m      <LanguageStandard>stdcpp17</LanguageStandard>[m
[32m+[m[32m      <Optimization>MinSpace</Optimization>[m
[32m+[m[32m      <PrecompiledHeader>NotUsing</PrecompiledHeader>[m
[32m+[m[32m      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>[m
[32m+[m[32m      <RuntimeTypeInfo>true</RuntimeTypeInfo>[m
[32m+[m[32m      <WarningLevel>Level3</WarningLevel>[m
[32m+[m[32m      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;GLEW_STATIC;GLFW_DLL;IMGUI_IMPL_OPENGL_LOADER_GLEW;CMAKE_INTDIR="MinSizeRel";%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <ObjectFileName>$(IntDir)</ObjectFileName>[m
[32m+[m[32m      <DebugInformationFormat>[m
[32m+[m[32m      </DebugInformationFormat>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ResourceCompile>[m
[32m+[m[32m      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;GLEW_STATIC;GLFW_DLL;IMGUI_IMPL_OPENGL_LOADER_GLEW;CMAKE_INTDIR=\"MinSizeRel\";%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;D:\Rubeus\RubeusCore\.\Game;D:\Rubeus\RubeusCore\.\Source\Architecture;D:\Rubeus\RubeusCore\.\Source\AudioComponents;D:\Rubeus\RubeusCore\.\Source\Awerere;D:\Rubeus\RubeusCore\.\Source\GraphicComponents;D:\Rubeus\RubeusCore\.\Source\InputManager;D:\Rubeus\RubeusCore\.\Source\MessageSystem;D:\Rubeus\RubeusCore\.\Source\RML;D:\Rubeus\RubeusCore\.\Source\UtilityComponents;D:\Rubeus\RubeusCore\.\Source\ProjectManager;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m    </ResourceCompile>[m
[32m+[m[32m    <Midl>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;D:\Rubeus\RubeusCore\.\Game;D:\Rubeus\RubeusCore\.\Source\Architecture;D:\Rubeus\RubeusCore\.\Source\AudioComponents;D:\Rubeus\RubeusCore\.\Source\Awerere;D:\Rubeus\RubeusCore\.\Source\GraphicComponents;D:\Rubeus\RubeusCore\.\Source\InputManager;D:\Rubeus\RubeusCore\.\Source\MessageSystem;D:\Rubeus\RubeusCore\.\Source\RML;D:\Rubeus\RubeusCore\.\Source\UtilityComponents;D:\Rubeus\RubeusCore\.\Source\ProjectManager;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m      <OutputDirectory>$(ProjectDir)/$(IntDir)</OutputDirectory>[m
[32m+[m[32m      <HeaderFileName>%(Filename).h</HeaderFileName>[m
[32m+[m[32m      <TypeLibraryName>%(Filename).tlb</TypeLibraryName>[m
[32m+[m[32m      <InterfaceIdentifierFileName>%(Filename)_i.c</InterfaceIdentifierFileName>[m
[32m+[m[32m      <ProxyFileName>%(Filename)_p.c</ProxyFileName>[m
[32m+[m[32m    </Midl>[m
[32m+[m[32m    <Link>[m
[32m+[m[32m      <AdditionalDependencies>opengl32.lib;glu32.lib;..\vendor\libraries\Win\DevIL.lib;..\vendor\libraries\Win\ILU.lib;..\vendor\libraries\Win\ILUT.lib;..\vendor\libraries\Win\flac.lib;..\vendor\libraries\Win\glew32s.lib;..\vendor\libraries\Win\glfw3.lib;..\vendor\libraries\Win\glfw3dll.lib;..\vendor\libraries\Win\ogg.lib;..\vendor\libraries\Win\openal32.lib;..\vendor\libraries\Win\sfml-audio-d.lib;..\vendor\libraries\Win\sfml-audio-s-d.lib;..\vendor\libraries\Win\sfml-audio-s.lib;..\vendor\libraries\Win\sfml-audio.lib;..\vendor\libraries\Win\sfml-system-d.lib;..\vendor\libraries\Win\sfml-system-s-d.lib;..\vendor\libraries\Win\sfml-system-s.lib;..\vendor\libraries\Win\sfml-system.lib;..\vendor\libraries\Win\vorbis.lib;..\vendor\libraries\Win\vorbisenc.lib;..\vendor\libraries\Win\vorbisfile.lib;-lstdc++fs;MinSizeRel\imgui.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;comdlg32.lib;advapi32.lib</AdditionalDependencies>[m
[32m+[m[32m      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>[m
[32m+[m[32m      <AdditionalOptions>%(AdditionalOptions) /machine:X86</AdditionalOptions>[m
[32m+[m[32m      <GenerateDebugInformation>false</GenerateDebugInformation>[m
[32m+[m[32m      <IgnoreSpecificDefaultLibraries>%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>[m
[32m+[m[32m      <ImportLibrary>D:/Rubeus/RubeusCore/MinSizeRel/ProjectManager.lib</ImportLibrary>[m
[32m+[m[32m      <ProgramDataBaseFile>D:/Rubeus/RubeusCore/MinSizeRel/ProjectManager.pdb</ProgramDataBaseFile>[m
[32m+[m[32m      <SubSystem>Console</SubSystem>[m
[32m+[m[32m    </Link>[m
[32m+[m[32m    <ProjectReference>[m
[32m+[m[32m      <LinkLibraryDependencies>false</LinkLibraryDependencies>[m
[32m+[m[32m    </ProjectReference>[m
[32m+[m[32m  </ItemDefinitionGroup>[m
[32m+[m[32m  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">[m
[32m+[m[32m    <ClCompile>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;D:\Rubeus\RubeusCore\.\Game;D:\Rubeus\RubeusCore\.\Source\Architecture;D:\Rubeus\RubeusCore\.\Source\AudioComponents;D:\Rubeus\RubeusCore\.\Source\Awerere;D:\Rubeus\RubeusCore\.\Source\GraphicComponents;D:\Rubeus\RubeusCore\.\Source\InputManager;D:\Rubeus\RubeusCore\.\Source\MessageSystem;D:\Rubeus\RubeusCore\.\Source\RML;D:\Rubeus\RubeusCore\.\Source\UtilityComponents;D:\Rubeus\RubeusCore\.\Source\ProjectManager;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m      <AssemblerListingLocation>RelWithDebInfo/</AssemblerListingLocation>[m
[32m+[m[32m      <CompileAs>CompileAsCpp</CompileAs>[m
[32m+[m[32m      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>[m
[32m+[m[32m      <ExceptionHandling>Sync</ExceptionHandling>[m
[32m+[m[32m      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>[m
[32m+[m[32m      <LanguageStandard>stdcpp17</LanguageStandard>[m
[32m+[m[32m      <Optimization>MaxSpeed</Optimization>[m
[32m+[m[32m      <PrecompiledHeader>NotUsing</PrecompiledHeader>[m
[32m+[m[32m      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>[m
[32m+[m[32m      <RuntimeTypeInfo>true</RuntimeTypeInfo>[m
[32m+[m[32m      <WarningLevel>Level3</WarningLevel>[m
[32m+[m[32m      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;GLEW_STATIC;GLFW_DLL;IMGUI_IMPL_OPENGL_LOADER_GLEW;CMAKE_INTDIR="RelWithDebInfo";%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <ObjectFileName>$(IntDir)</ObjectFileName>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ResourceCompile>[m
[32m+[m[32m      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;GLEW_STATIC;GLFW_DLL;IMGUI_IMPL_OPENGL_LOADER_GLEW;CMAKE_INTDIR=\"RelWithDebInfo\";%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;D:\Rubeus\RubeusCore\.\Game;D:\Rubeus\RubeusCore\.\Source\Architecture;D:\Rubeus\RubeusCore\.\Source\AudioComponents;D:\Rubeus\RubeusCore\.\Source\Awerere;D:\Rubeus\RubeusCore\.\Source\GraphicComponents;D:\Rubeus\RubeusCore\.\Source\InputManager;D:\Rubeus\RubeusCore\.\Source\MessageSystem;D:\Rubeus\RubeusCore\.\Source\RML;D:\Rubeus\RubeusCore\.\Source\UtilityComponents;D:\Rubeus\RubeusCore\.\Source\ProjectManager;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m    </ResourceCompile>[m
[32m+[m[32m    <Midl>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;D:\Rubeus\RubeusCore\.\Game;D:\Rubeus\RubeusCore\.\Source\Architecture;D:\Rubeus\RubeusCore\.\Source\AudioComponents;D:\Rubeus\RubeusCore\.\Source\Awerere;D:\Rubeus\RubeusCore\.\Source\GraphicComponents;D:\Rubeus\RubeusCore\.\Source\InputManager;D:\Rubeus\RubeusCore\.\Source\MessageSystem;D:\Rubeus\RubeusCore\.\Source\RML;D:\Rubeus\RubeusCore\.\Source\UtilityComponents;D:\Rubeus\RubeusCore\.\Source\ProjectManager;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m      <OutputDirectory>$(ProjectDir)/$(IntDir)</OutputDirectory>[m
[32m+[m[32m      <HeaderFileName>%(Filename).h</HeaderFileName>[m
[32m+[m[32m      <TypeLibraryName>%(Filename).tlb</TypeLibraryName>[m
[32m+[m[32m      <InterfaceIdentifierFileName>%(Filename)_i.c</InterfaceIdentifierFileName>[m
[32m+[m[32m      <ProxyFileName>%(Filename)_p.c</ProxyFileName>[m
[32m+[m[32m    </Midl>[m
[32m+[m[32m    <Link>[m
[32m+[m[32m      <AdditionalDependencies>opengl32.lib;glu32.lib;..\vendor\libraries\Win\DevIL.lib;..\vendor\libraries\Win\ILU.lib;..\vendor\libraries\Win\ILUT.lib;..\vendor\libraries\Win\flac.lib;..\vendor\libraries\Win\glew32s.lib;..\vendor\libraries\Win\glfw3.lib;..\vendor\libraries\Win\glfw3dll.lib;..\vendor\libraries\Win\ogg.lib;..\vendor\libraries\Win\openal32.lib;..\vendor\libraries\Win\sfml-audio-d.lib;..\vendor\libraries\Win\sfml-audio-s-d.lib;..\vendor\libraries\Win\sfml-audio-s.lib;..\vendor\libraries\Win\sfml-audio.lib;..\vendor\libraries\Win\sfml-system-d.lib;..\vendor\libraries\Win\sfml-system-s-d.lib;..\vendor\libraries\Win\sfml-system-s.lib;..\vendor\libraries\Win\sfml-system.lib;..\vendor\libraries\Win\vorbis.lib;..\vendor\libraries\Win\vorbisenc.lib;..\vendor\libraries\Win\vorbisfile.lib;-lstdc++fs;RelWithDebInfo\imgui.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;comdlg32.lib;advapi32.lib</AdditionalDependencies>[m
[32m+[m[32m      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>[m
[32m+[m[32m      <AdditionalOptions>%(AdditionalOptions) /machine:X86</AdditionalOptions>[m
[32m+[m[32m      <GenerateDebugInformation>true</GenerateDebugInformation>[m
[32m+[m[32m      <IgnoreSpecificDefaultLibraries>%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>[m
[32m+[m[32m      <ImportLibrary>D:/Rubeus/RubeusCore/RelWithDebInfo/ProjectManager.lib</ImportLibrary>[m
[32m+[m[32m      <ProgramDataBaseFile>D:/Rubeus/RubeusCore/RelWithDebInfo/ProjectManager.pdb</ProgramDataBaseFile>[m
[32m+[m[32m      <SubSystem>Console</SubSystem>[m
[32m+[m[32m    </Link>[m
[32m+[m[32m    <ProjectReference>[m
[32m+[m[32m      <LinkLibraryDependencies>false</LinkLibraryDependencies>[m
[32m+[m[32m    </ProjectReference>[m
[32m+[m[32m  </ItemDefinitionGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <CustomBuild Include="D:\Rubeus\RubeusCore\CMakeLists.txt">[m
[32m+[m[32m      <Message Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Building Custom Rule D:/Rubeus/RubeusCore/CMakeLists.txt</Message>[m
[32m+[m[32m      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">setlocal[m
[32m+[m[32m"D:\Program Files\CMake\bin\cmake.exe" -HD:/Rubeus -BD:/Rubeus --check-stamp-file D:/Rubeus/RubeusCore/CMakeFiles/generate.stamp[m
[32m+[m[32mif %errorlevel% neq 0 goto :cmEnd[m
[32m+[m[32m:cmEnd[m
[32m+[m[32mendlocal &amp; call :cmErrorLevel %errorlevel% &amp; goto :cmDone[m
[32m+[m[32m:cmErrorLevel[m
[32m+[m[32mexit /b %1[m
[32m+[m[32m:cmDone[m
[32m+[m[32mif %errorlevel% neq 0 goto :VCEnd</Command>[m
[32m+[m[32m      <AdditionalInputs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">D:/Rubeus/RubeusCore/CMakeLists.txt;D:\Rubeus\RubeusCore\CMakeLists.txt;D:\Rubeus\RubeusCore\CMakeLists.txt;%(AdditionalInputs)</AdditionalInputs>[m
[32m+[m[32m      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">D:\Rubeus\RubeusCore\CMakeFiles\generate.stamp</Outputs>[m
[32m+[m[32m      <LinkObjects Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</LinkObjects>[m
[32m+[m[32m      <Message Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Building Custom Rule D:/Rubeus/RubeusCore/CMakeLists.txt</Message>[m
[32m+[m[32m      <Command Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">setlocal[m
[32m+[m[32m"D:\Program Files\CMake\bin\cmake.exe" -HD:/Rubeus -BD:/Rubeus --check-stamp-file D:/Rubeus/RubeusCore/CMakeFiles/generate.stamp[m
[32m+[m[32mif %errorlevel% neq 0 goto :cmEnd[m
[32m+[m[32m:cmEnd[m
[32m+[m[32mendlocal &amp; call :cmErrorLevel %errorlevel% &amp; goto :cmDone[m
[32m+[m[32m:cmErrorLevel[m
[32m+[m[32mexit /b %1[m
[32m+[m[32m:cmDone[m
[32m+[m[32mif %errorlevel% neq 0 goto :VCEnd</Command>[m
[32m+[m[32m      <AdditionalInputs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">D:/Rubeus/RubeusCore/CMakeLists.txt;D:\Rubeus\RubeusCore\CMakeLists.txt;D:\Rubeus\RubeusCore\CMakeLists.txt;%(AdditionalInputs)</AdditionalInputs>[m
[32m+[m[32m      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">D:\Rubeus\RubeusCore\CMakeFiles\generate.stamp</Outputs>[m
[32m+[m[32m      <LinkObjects Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkObjects>[m
[32m+[m[32m      <Message Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">Building Custom Rule D:/Rubeus/RubeusCore/CMakeLists.txt</Message>[m
[32m+[m[32m      <Command Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">setlocal[m
[32m+[m[32m"D:\Program Files\CMake\bin\cmake.exe" -HD:/Rubeus -BD:/Rubeus --check-stamp-file D:/Rubeus/RubeusCore/CMakeFiles/generate.stamp[m
[32m+[m[32mif %errorlevel% neq 0 goto :cmEnd[m
[32m+[m[32m:cmEnd[m
[32m+[m[32mendlocal &amp; call :cmErrorLevel %errorlevel% &amp; goto :cmDone[m
[32m+[m[32m:cmErrorLevel[m
[32m+[m[32mexit /b %1[m
[32m+[m[32m:cmDone[m
[32m+[m[32mif %errorlevel% neq 0 goto :VCEnd</Command>[m
[32m+[m[32m      <AdditionalInputs Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">D:/Rubeus/RubeusCore/CMakeLists.txt;D:\Rubeus\RubeusCore\CMakeLists.txt;D:\Rubeus\RubeusCore\CMakeLists.txt;%(AdditionalInputs)</AdditionalInputs>[m
[32m+[m[32m      <Outputs Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">D:\Rubeus\RubeusCore\CMakeFiles\generate.stamp</Outputs>[m
[32m+[m[32m      <LinkObjects Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">false</LinkObjects>[m
[32m+[m[32m      <Message Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">Building Custom Rule D:/Rubeus/RubeusCore/CMakeLists.txt</Message>[m
[32m+[m[32m      <Command Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">setlocal[m
[32m+[m[32m"D:\Program Files\CMake\bin\cmake.exe" -HD:/Rubeus -BD:/Rubeus --check-stamp-file D:/Rubeus/RubeusCore/CMakeFiles/generate.stamp[m
[32m+[m[32mif %errorlevel% neq 0 goto :cmEnd[m
[32m+[m[32m:cmEnd[m
[32m+[m[32mendlocal &amp; call :cmErrorLevel %errorlevel% &amp; goto :cmDone[m
[32m+[m[32m:cmErrorLevel[m
[32m+[m[32mexit /b %1[m
[32m+[m[32m:cmDone[m
[32m+[m[32mif %errorlevel% neq 0 goto :VCEnd</Command>[m
[32m+[m[32m      <AdditionalInputs Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">D:/Rubeus/RubeusCore/CMakeLists.txt;D:\Rubeus\RubeusCore\CMakeLists.txt;D:\Rubeus\RubeusCore\CMakeLists.txt;%(AdditionalInputs)</AdditionalInputs>[m
[32m+[m[32m      <Outputs Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">D:\Rubeus\RubeusCore\CMakeFiles\generate.stamp</Outputs>[m
[32m+[m[32m      <LinkObjects Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">false</LinkObjects>[m
[32m+[m[32m    </CustomBuild>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Architecture\engine.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Architecture\entity_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Architecture\game.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Architecture\game_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Architecture\level.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Architecture\master_component.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Architecture\world.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\AudioComponents\audio_manager_component.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_box_collider_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_collide_data_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_collider_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_collision_engine.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_collision_grid.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_flag.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_hit_event_list.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_physics_engine.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_physics_material.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_physics_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_plane_collider_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_sphere_collider_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\buffer_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\game_scene.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\guerrilla_renderer_component.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\image_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\index_buffer_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\main_layer.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\renderable_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\shader_component.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\simple_renderer_component.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\sprite_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\static_sprite_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\texture_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\vertex_array_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\window_component.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\InputManager\input_manager.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\MessageSystem\message_bus.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\MessageSystem\message_object.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\MessageSystem\message_system.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\ProjectManager\project_manager.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\RML\rubeus_maths_library.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\UtilityComponents\loader_component.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\UtilityComponents\logger_component.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\UtilityComponents\timer_component.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Game\ping_pong\engine_files\level.play_level.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Game\ping_pong\engine_files\object.ball.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Game\ping_pong\engine_files\object.paddle.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Game\user_init.cpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Architecture\engine.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Architecture\entity_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Architecture\game.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Architecture\game_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Architecture\level.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Architecture\master_component.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Architecture\world.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\AudioComponents\audio_manager_component.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_box_collider_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_collide_data_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_collider_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_collision_engine.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_collision_grid.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_flag.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_hit_event_list.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_physics_engine.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_physics_material.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_physics_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_plane_collider_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_sphere_collider_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\buffer_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\game_scene.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\guerrilla_renderer_component.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\image_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\index_buffer_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\layer_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\main_layer.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\nvidia_enable.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\renderable_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\renderer_component.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\shader_component.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\simple_renderer_component.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\sprite_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\static_sprite_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\texture_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\vertex_array_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\window_component.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\InputManager\input_manager.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\InputManager\keys.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\MessageSystem\message_bus.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\MessageSystem\message_codes.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\MessageSystem\message_object.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\MessageSystem\message_system.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\ProjectManager\project_manager.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\RML\rubeus_maths_library.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\UtilityComponents\loader_component.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\UtilityComponents\logger_component.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\UtilityComponents\timer_component.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\GL\eglew.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\GL\glew.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\GL\glxew.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\GL\wglew.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\GLFW\glfw3.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\GLFW\glfw3native.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\config.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\devil_internal_exports.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\il.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\il_wrap.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\ilu.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\ilu_region.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\ilut.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\ilut_config.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\devil_cpp_wrapper.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\AlResource.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\Export.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\InputSoundFile.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\Listener.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\Music.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\OutputSoundFile.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\Sound.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\SoundBuffer.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\SoundBufferRecorder.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\SoundFileFactory.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\SoundFileReader.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\SoundFileWriter.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\SoundRecorder.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\SoundSource.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\SoundStream.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Config.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Clock.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Err.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Export.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\FileInputStream.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\InputStream.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Lock.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\MemoryInputStream.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Mutex.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\NativeActivity.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\NonCopyable.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Sleep.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\String.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Thread.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\ThreadLocal.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\ThreadLocalPtr.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Time.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Utf.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Vector2.hpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Vector3.hpp" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <ProjectReference Include="D:\Rubeus\ZERO_CHECK.vcxproj">[m
[32m+[m[32m      <Project>{817CD231-EBDE-3BE3-A1A1-CD495ABC6585}</Project>[m
[32m+[m[32m      <Name>ZERO_CHECK</Name>[m
[32m+[m[32m    </ProjectReference>[m
[32m+[m[32m    <ProjectReference Include="D:\Rubeus\RubeusCore\imgui.vcxproj">[m
[32m+[m[32m      <Project>{68858766-958B-3CC9-BC60-CCCF38A29CD7}</Project>[m
[32m+[m[32m      <Name>imgui</Name>[m
[32m+[m[32m    </ProjectReference>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />[m
[32m+[m[32m  <ImportGroup Label="ExtensionTargets">[m
[32m+[m[32m  </ImportGroup>[m
[32m+[m[32m</Project>[m
\ No newline at end of file[m
[1mdiff --git a/RubeusCore/ProjectManager.vcxproj.filters b/RubeusCore/ProjectManager.vcxproj.filters[m
[1mnew file mode 100644[m
[1mindex 0000000..d33cf0b[m
[1m--- /dev/null[m
[1m+++ b/RubeusCore/ProjectManager.vcxproj.filters[m
[36m@@ -0,0 +1,459 @@[m
[32m+[m[32mï»¿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Architecture\engine.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Architecture\entity_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Architecture\game.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Architecture\game_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Architecture\level.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Architecture\master_component.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Architecture\world.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\AudioComponents\audio_manager_component.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_box_collider_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_collide_data_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_collider_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_collision_engine.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_collision_grid.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_flag.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_hit_event_list.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_physics_engine.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_physics_material.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_physics_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_plane_collider_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_sphere_collider_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\buffer_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\game_scene.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\guerrilla_renderer_component.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\image_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\index_buffer_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\main_layer.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\renderable_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\shader_component.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\simple_renderer_component.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\sprite_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\static_sprite_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\texture_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\vertex_array_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\window_component.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\InputManager\input_manager.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\MessageSystem\message_bus.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\MessageSystem\message_object.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\MessageSystem\message_system.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\ProjectManager\project_manager.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\RML\rubeus_maths_library.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\UtilityComponents\loader_component.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\UtilityComponents\logger_component.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Source\UtilityComponents\timer_component.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Game\ping_pong\engine_files\level.play_level.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Game\ping_pong\engine_files\object.ball.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Game\ping_pong\engine_files\object.paddle.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\RubeusCore\Game\user_init.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Architecture\engine.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Architecture\entity_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Architecture\game.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Architecture\game_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Architecture\level.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Architecture\master_component.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Architecture\world.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\AudioComponents\audio_manager_component.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_box_collider_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_collide_data_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_collider_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_collision_engine.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_collision_grid.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_flag.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_hit_event_list.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_physics_engine.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_physics_material.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_physics_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_plane_collider_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\Awerere\awerere_sphere_collider_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\buffer_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\game_scene.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\guerrilla_renderer_component.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\image_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\index_buffer_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\layer_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\main_layer.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\nvidia_enable.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\renderable_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\renderer_component.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\shader_component.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\simple_renderer_component.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\sprite_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\static_sprite_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\texture_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\vertex_array_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\GraphicComponents\window_component.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\InputManager\input_manager.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\InputManager\keys.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\MessageSystem\message_bus.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\MessageSystem\message_codes.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\MessageSystem\message_object.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\MessageSystem\message_system.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\ProjectManager\project_manager.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\RML\rubeus_maths_library.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\UtilityComponents\loader_component.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\UtilityComponents\logger_component.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\RubeusCore\Source\UtilityComponents\timer_component.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\GL\eglew.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\GL\glew.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\GL\glxew.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\GL\wglew.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\GLFW\glfw3.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\GLFW\glfw3native.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\config.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\devil_internal_exports.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\il.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\il_wrap.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\ilu.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\ilu_region.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\ilut.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\ilut_config.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\IL\devil_cpp_wrapper.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\AlResource.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\Export.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\InputSoundFile.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\Listener.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\Music.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\OutputSoundFile.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\Sound.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\SoundBuffer.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\SoundBufferRecorder.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\SoundFileFactory.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\SoundFileReader.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\SoundFileWriter.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\SoundRecorder.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\SoundSource.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Audio\SoundStream.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\Config.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Clock.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Err.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Export.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\FileInputStream.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\InputStream.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Lock.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\MemoryInputStream.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Mutex.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\NativeActivity.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\NonCopyable.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Sleep.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\String.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Thread.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\ThreadLocal.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\ThreadLocalPtr.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Time.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Utf.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Vector2.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\include\SFML\System\Vector3.hpp">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <CustomBuild Include="D:\Rubeus\RubeusCore\CMakeLists.txt" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Filter Include="Header Files">[m
[32m+[m[32m      <UniqueIdentifier>{2E1A23D5-F47A-3D2C-926C-7087F634B53E}</UniqueIdentifier>[m
[32m+[m[32m    </Filter>[m
[32m+[m[32m    <Filter Include="Source Files">[m
[32m+[m[32m      <UniqueIdentifier>{02633C0E-C854-33B0-8CD6-2EAB91B7EE29}</UniqueIdentifier>[m
[32m+[m[32m    </Filter>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m</Project>[m
[1mdiff --git a/RubeusCore/RubeusCore.cpp b/RubeusCore/RubeusCore.cpp[m
[1mindex d781d3f..532555f 100644[m
[1m--- a/RubeusCore/RubeusCore.cpp[m
[1m+++ b/RubeusCore/RubeusCore.cpp[m
[36m@@ -13,6 +13,12 @@[m [mint main()[m
 	using namespace RML;[m
 	using namespace Awerere;[m
 [m
[32m+[m
[32m+[m	[32mRLogger::CreateLogFile();[m
[32m+[m	[32mRLogger::Init();[m
[32m+[m	[32mRProjectManager m_ProjectManager;[m
[32m+[m	[32mm_ProjectManager.run();[m
[32m+[m
 	RGame * currentGame = RGame::getActiveGame();[m
 [m
 	// startupLevel : std::string contains the startup level name. Defined in user_init.cpp[m
[1mdiff --git a/RubeusCore/RubeusCore.h b/RubeusCore/RubeusCore.h[m
[1mindex 50386f2..dc87c55 100644[m
[1m--- a/RubeusCore/RubeusCore.h[m
[1m+++ b/RubeusCore/RubeusCore.h[m
[36m@@ -81,6 +81,7 @@[m [mvoid onEnd() override;											   \[m
 #include <game_object.h>[m
 #include <game.h>[m
 #include <world.h>[m
[32m+[m[32m#include <project_manager.h>[m
 [m
 // Awerere specific includes[m
 #include <awerere_collider_object.h>[m
[1mdiff --git a/RubeusCore/Source/Architecture/engine.cpp b/RubeusCore/Source/Architecture/engine.cpp[m
[1mindex 436c31c..df24705 100644[m
[1m--- a/RubeusCore/Source/Architecture/engine.cpp[m
[1m+++ b/RubeusCore/Source/Architecture/engine.cpp[m
[36m@@ -8,6 +8,9 @@[m
 [m
 #include <any>[m
 [m
[32m+[m[32m#include <ImGui/imgui.h>[m
[32m+[m[32m#include <ImGui/imgui_impl_glfw.h>[m
[32m+[m[32m#include <ImGui/imgui_impl_opengl3.h>[m
 namespace Rubeus[m
 {[m
 	std::unordered_map<int, bool> RInputManager::KeyMap;[m
[36m@@ -17,7 +20,6 @@[m [mnamespace Rubeus[m
 [m
 	REngine::REngine()[m
 	{[m
[31m-		UtilityComponents::RLogger::Init();[m
 		m_Window = new GraphicComponents::RWindowComponent([m
 			"Hello World",[m
 			1280,[m
[36m@@ -26,6 +28,16 @@[m [mnamespace Rubeus[m
 			GraphicComponents::EWindowParameters::NON_RESIZABLE_WINDOW,[m
 			1[m
 		);[m
[32m+[m
[32m+[m[32m// 		i_Window = new GraphicComponents::RWindowComponent([m
[32m+[m[32m// 			"ImGui",[m
[32m+[m[32m// 			1280,[m
[32m+[m[32m// 			720,[m
[32m+[m[32m// 			GraphicComponents::EWindowParameters::WINDOWED_MODE,[m
[32m+[m[32m// 			GraphicComponents::EWindowParameters::NON_RESIZABLE_WINDOW,[m
[32m+[m[32m// 			1[m
[32m+[m[32m// 		);[m
[32m+[m[41m		[m
 		m_GameScene = new GraphicComponents::RGameScene([m
 			"Shaders/basic.vert",[m
 			"Shaders/basic.frag"[m
[36m@@ -39,6 +51,7 @@[m [mnamespace Rubeus[m
 		delete m_PhysicsEngine;[m
 		delete m_GameScene;[m
 		delete m_Window;[m
[32m+[m[32m//		delete i_Window;[m
 		delete m_Timer;[m
 		delete m_Loader;[m
 	}[m
[36m@@ -111,6 +124,14 @@[m [mnamespace Rubeus[m
 [m
         float lastFrameEndTime = (float)glfwGetTime();[m
 [m
[32m+[m[32m// 		ImGui::CreateContext();[m
[32m+[m[32m// 		ImGui_ImplGlfw_InitForOpenGL(i_Window->m_Window, true);[m
[32m+[m[32m// 		ImGui_ImplOpenGL3_Init("#version 130");[m
[32m+[m[32m// 		ImGui::StyleColorsDark();[m
[32m+[m[32m// 		bool show_demo_window = true;[m
[32m+[m[32m// 		bool show_another_window = false;[m
[32m+[m[32m// 		ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);[m
[32m+[m
 		// Main game loop[m
 		while (m_Window->closed() == false)[m
 		{[m
[36m@@ -122,6 +143,11 @@[m [mnamespace Rubeus[m
 [m
 			// Clear window buffer[m
 			m_Window->clearWindow();[m
[32m+[m[32m//			i_Window->clearWindow();[m
[32m+[m
[32m+[m[32m// 			ImGui_ImplOpenGL3_NewFrame();[m
[32m+[m[32m// 			ImGui_ImplGlfw_NewFrame();[m
[32m+[m[32m// 			ImGui::NewFrame();[m
 [m
 			// Tick the entire world once[m
 			getWorld()->tick();[m
[36m@@ -132,8 +158,48 @@[m [mnamespace Rubeus[m
 			// Draw objects[m
 			m_GameScene->draw();[m
 [m
[32m+[m[32m// 			if (show_demo_window)[m
[32m+[m[32m// 				ImGui::ShowDemoWindow(&show_demo_window);[m
[32m+[m[32m//[m[41m [m
[32m+[m[32m// 			// 2. Show a simple window that we create ourselves. We use a Begin/End pair to created a named window.[m
[32m+[m[32m// 			{[m
[32m+[m[32m// 				static float f = 0.0f;[m
[32m+[m[32m// 				static int counter = 0;[m
[32m+[m[32m//[m[41m [m
[32m+[m[32m// 				ImGui::Begin("Hello, world!");                          // Create a window called "Hello, world!" and append into it.[m
[32m+[m[32m//[m[41m [m
[32m+[m[32m// 				ImGui::Text("This is some useful text.");               // Display some text (you can use a format strings too)[m
[32m+[m[32m// 				ImGui::Checkbox("Demo Window", &show_demo_window);      // Edit bools storing our window open/close state[m
[32m+[m[32m// 				ImGui::Checkbox("Another Window", &show_another_window);[m
[32m+[m[32m//[m[41m [m
[32m+[m[32m// 				ImGui::SliderFloat("float", &f, 0.0f, 1.0f);            // Edit 1 float using a slider from 0.0f to 1.0f[m
[32m+[m[32m// 				ImGui::ColorEdit3("clear color", (float*)&clear_color); // Edit 3 floats representing a color[m
[32m+[m[32m//[m[41m [m
[32m+[m[32m// 				if (ImGui::Button("Button"))                            // Buttons return true when clicked (most widgets return true when edited/activated)[m
[32m+[m[32m// 					counter++;[m
[32m+[m[32m// 				ImGui::SameLine();[m
[32m+[m[32m// 				ImGui::Text("counter = %d", counter);[m
[32m+[m[32m//[m[41m [m
[32m+[m[32m// 				ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);[m
[32m+[m[32m// 				ImGui::End();[m
[32m+[m[32m// 			}[m
[32m+[m[32m//[m[41m [m
[32m+[m[32m// 			// 3. Show another simple window.[m
[32m+[m[32m// 			if (show_another_window)[m
[32m+[m[32m// 			{[m
[32m+[m[32m// 				ImGui::Begin("Another Window", &show_another_window);   // Pass a pointer to our bool variable (the window will have a closing button that will clear the bool when clicked)[m
[32m+[m[32m// 				ImGui::Text("Hello from another window!");[m
[32m+[m[32m// 				if (ImGui::Button("Close Me"))[m
[32m+[m[32m// 					show_another_window = false;[m
[32m+[m[32m// 				ImGui::End();[m
[32m+[m[32m// 			}[m
[32m+[m[32m//[m[41m [m
[32m+[m[32m// 			ImGui::Render();[m
[32m+[m[32m// 			ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());[m
[32m+[m
 			// Switch windows draw and display buffers[m
 			m_Window->updateWindow();[m
[32m+[m[32m//			i_Window->updateWindow();[m
 [m
 			// Evaluate and display the frame times[m
 			m_Timer->evaluateFrames();[m
[36m@@ -151,6 +217,9 @@[m [mnamespace Rubeus[m
 				item->m_IsSubmitted = false;[m
 			}[m
 		}[m
[32m+[m		[32m//ImGui_ImplOpenGL3_Shutdown();[m
[32m+[m[32m// 		ImGui_ImplGlfw_Shutdown();[m
[32m+[m[32m// 		ImGui::DestroyContext();[m
 [m
 		m_StartupLevelName = "";[m
 	}[m
[1mdiff --git a/RubeusCore/Source/Architecture/engine.h b/RubeusCore/Source/Architecture/engine.h[m
[1mindex 1fda74c..de76847 100644[m
[1m--- a/RubeusCore/Source/Architecture/engine.h[m
[1m+++ b/RubeusCore/Source/Architecture/engine.h[m
[36m@@ -35,6 +35,8 @@[m [mnamespace Rubeus[m
 		/** @brief	The ref to Window in current use */[m
 		GraphicComponents::RWindowComponent * m_Window = NULL;[m
 [m
[32m+[m[32m//		GraphicComponents::RWindowComponent * i_Window = NULL;[m
[32m+[m
 		/** @brief	The ref to layers in use (for renderering) */[m
 		GraphicComponents::RGameScene * m_GameScene = NULL;[m
 [m
[1mdiff --git a/RubeusCore/Source/Architecture/game.cpp b/RubeusCore/Source/Architecture/game.cpp[m
[1mindex 65c66a0..fb38490 100644[m
[1m--- a/RubeusCore/Source/Architecture/game.cpp[m
[1m+++ b/RubeusCore/Source/Architecture/game.cpp[m
[36m@@ -1,6 +1,7 @@[m
 #include <game.h>[m
 [m
 #include <engine.h>[m
[32m+[m[32m#include <logger_component.h>[m
 [m
 namespace Rubeus[m
 {[m
[36m@@ -10,7 +11,7 @@[m [mnamespace Rubeus[m
 	RGame::RGame()[m
 		: m_StartupLevel("")[m
 	{[m
[31m-		Rubeus::UtilityComponents::RLogger::CreateLogFile();[m
[32m+[m		[32mUtilityComponents::RLogger::Init();[m
 		m_Engine = new Rubeus::REngine();[m
 		CurrentGame = this;[m
 	}[m
[1mdiff --git a/RubeusCore/Source/ProjectManager/project_manager.cpp b/RubeusCore/Source/ProjectManager/project_manager.cpp[m
[1mnew file mode 100644[m
[1mindex 0000000..795f0ab[m
[1m--- /dev/null[m
[1m+++ b/RubeusCore/Source/ProjectManager/project_manager.cpp[m
[36m@@ -0,0 +1,124 @@[m
[32m+[m[32m#include <project_manager.h>[m
[32m+[m
[32m+[m[32mnamespace Rubeus[m
[32m+[m[32m{[m
[32m+[m		[32mRProjectManager::RProjectManager()[m
[32m+[m		[32m{[m
[32m+[m			[32mUtilityComponents::RLogger::Init();[m
[32m+[m			[32mRubeus::UtilityComponents::RLogger::CreateLogFile();[m
[32m+[m			[32mm_Window = new GraphicComponents::RWindowComponent([m
[32m+[m				[32m"hehehehehe",[m
[32m+[m				[32m1280,[m
[32m+[m				[32m720,[m
[32m+[m				[32mGraphicComponents::EWindowParameters::WINDOWED_MODE,[m
[32m+[m				[32mGraphicComponents::EWindowParameters::NON_RESIZABLE_WINDOW,[m
[32m+[m				[32m1[m
[32m+[m			[32m);[m
[32m+[m			[32mm_Timer = new UtilityComponents::RTimer(10);[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mRProjectManager::~RProjectManager()[m
[32m+[m		[32m{[m
[32m+[m			[32mdelete m_Window;[m
[32m+[m			[32mdelete m_Timer;[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mvoid RProjectManager::run() {[m
[32m+[m			[32mSUCCESS("project window running");[m
[32m+[m			[32m//SUCCESS("Running level : " + m_CurrentLevel->m_Name);[m
[32m+[m
[32m+[m			[32mm_Timer->setFrameCounter();[m
[32m+[m
[32m+[m			[32mfloat lastFrameEndTime = (float)glfwGetTime();[m
[32m+[m
[32m+[m			[32mImGui::CreateContext();[m
[32m+[m			[32mImGui_ImplGlfw_InitForOpenGL(m_Window->m_GLFWWindow, true);[m
[32m+[m			[32mImGui_ImplOpenGL3_Init("#version 130");[m
[32m+[m			[32mImGui::StyleColorsDark();[m
[32m+[m			[32mbool show_demo_window = true;[m
[32m+[m			[32mbool show_another_window = false;[m
[32m+[m			[32mImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);[m
[32m+[m
[32m+[m			[32m// Main game loop[m
[32m+[m			[32mwhile (m_Window->closed() == false)[m
[32m+[m			[32m{[m
[32m+[m				[32mwhile (true)[m
[32m+[m				[32m{[m
[32m+[m					[32mif (glfwGetTime() - lastFrameEndTime >= 1.0f / 60.0f)[m
[32m+[m						[32mbreak;[m
[32m+[m				[32m}[m
[32m+[m
[32m+[m				[32m// Clear window buffer[m
[32m+[m				[32mm_Window->clearWindow();[m
[32m+[m
[32m+[m				[32mImGui_ImplOpenGL3_NewFrame();[m
[32m+[m				[32mImGui_ImplGlfw_NewFrame();[m
[32m+[m				[32mImGui::NewFrame();[m
[32m+[m
[32m+[m				[32mif (show_demo_window)[m
[32m+[m					[32mImGui::ShowDemoWindow(&show_demo_window);[m
[32m+[m
[32m+[m				[32m// 2. Show a simple window that we create ourselves. We use a Begin/End pair to created a named window.[m
[32m+[m				[32m{[m
[32m+[m					[32mstatic float f = 0.0f;[m
[32m+[m					[32mstatic int counter = 0;[m
[32m+[m
[32m+[m					[32mImGui::Begin("Hello, world!");                          // Create a window called "Hello, world!" and append into it.[m
[32m+[m
[32m+[m					[32mImGui::Text("This is some useful text.");               // Display some text (you can use a format strings too)[m
[32m+[m					[32mImGui::Checkbox("Demo Window", &show_demo_window);      // Edit bools storing our window open/close state[m
[32m+[m					[32mImGui::Checkbox("Another Window", &show_another_window);[m
[32m+[m
[32m+[m					[32mImGui::SliderFloat("float", &f, 0.0f, 1.0f);            // Edit 1 float using a slider from 0.0f to 1.0f[m
[32m+[m					[32mImGui::ColorEdit3("clear color", (float*)&clear_color); // Edit 3 floats representing a color[m
[32m+[m
[32m+[m					[32mif (ImGui::Button("Button"))                            // Buttons return true when clicked (most widgets return true when edited/activated)[m
[32m+[m						[32mcounter++;[m
[32m+[m					[32mImGui::SameLine();[m
[32m+[m					[32mImGui::Text("counter = %d", counter);[m
[32m+[m
[32m+[m					[32mImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);[m
[32m+[m					[32mImGui::End();[m
[32m+[m				[32m}[m
[32m+[m
[32m+[m				[32m// 3. Show another simple window.[m
[32m+[m				[32mif (show_another_window)[m
[32m+[m				[32m{[m
[32m+[m					[32mImGui::Begin("Another Window", &show_another_window);   // Pass a pointer to our bool variable (the window will have a closing button that will clear the bool when clicked)[m
[32m+[m					[32mImGui::Text("Hello from another window!");[m
[32m+[m					[32mif (ImGui::Button("Close Me"))[m
[32m+[m						[32mshow_another_window = false;[m
[32m+[m					[32mImGui::End();[m
[32m+[m				[32m}[m
[32m+[m
[32m+[m				[32mImGui::Render();[m
[32m+[m				[32mImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());[m
[32m+[m
[32m+[m				[32m// Switch windows draw and display buffers[m
[32m+[m				[32mm_Window->updateWindow();[m
[32m+[m
[32m+[m				[32m// Evaluate and display the frame times[m
[32m+[m				[32mm_Timer->evaluateFrames();[m
[32m+[m
[32m+[m				[32mlastFrameEndTime = (float)glfwGetTime();[m
[32m+[m
[32m+[m			[32m}[m
[32m+[m			[32mImGui_ImplOpenGL3_Shutdown();[m
[32m+[m			[32mImGui_ImplGlfw_Shutdown();[m
[32m+[m			[32mImGui::DestroyContext();[m
[32m+[m
[32m+[m		[32m}[m
[32m+[m[32m}[m
[32m+[m[32mint main() {[m
[32m+[m	[32musing namespace Rubeus;[m
[32m+[m	[32musing namespace GraphicComponents;[m
[32m+[m	[32musing namespace UtilityComponents;[m
[32m+[m	[32musing namespace RML;[m
[32m+[m	[32musing namespace Awerere;[m
[32m+[m
[32m+[m	[32mstd::cout << "lol";[m
[32m+[m	[32mRLogger::CreateLogFile();[m
[32m+[m	[32mRLogger::Init();[m
[32m+[m	[32mRProjectManager m_ProjectManager;[m
[32m+[m	[32mm_ProjectManager.run();[m
[32m+[m[32m}[m
[1mdiff --git a/RubeusCore/Source/ProjectManager/project_manager.h b/RubeusCore/Source/ProjectManager/project_manager.h[m
[1mnew file mode 100644[m
[1mindex 0000000..46386b4[m
[1m--- /dev/null[m
[1m+++ b/RubeusCore/Source/ProjectManager/project_manager.h[m
[36m@@ -0,0 +1,29 @@[m
[32m+[m
[32m+[m[32m#pragma once[m
[32m+[m
[32m+[m[32m#include <ImGui/imgui.h>[m
[32m+[m[32m#include <ImGui/imgui_impl_glfw.h>[m
[32m+[m[32m#include <ImGui/imgui_impl_opengl3.h>[m
[32m+[m
[32m+[m
[32m+[m[32m#include <window_component.h>[m
[32m+[m[32m#include <timer_component.h>[m
[32m+[m
[32m+[m[32mnamespace Rubeus[m
[32m+[m[32m{[m
[32m+[m	[32mclass RProjectManager[m
[32m+[m	[32m{[m
[32m+[m		[32m/** @brief	The ref to the timer in use */[m
[32m+[m		[32mUtilityComponents::RTimer * m_Timer = 0;[m
[32m+[m
[32m+[m		[32m/** @brief	The ref to Window in current use */[m
[32m+[m		[32mGraphicComponents::RWindowComponent *m_Window = 0;[m
[32m+[m
[32m+[m	[32mpublic:[m
[32m+[m		[32mRProjectManager();[m
[32m+[m
[32m+[m		[32m~RProjectManager();[m
[32m+[m
[32m+[m		[32mvoid run();[m
[32m+[m	[32m};[m
[32m+[m[32m}[m
[1mdiff --git a/RubeusCore/imgui.ini b/RubeusCore/imgui.ini[m
[1mnew file mode 100644[m
[1mindex 0000000..e29ddeb[m
[1m--- /dev/null[m
[1m+++ b/RubeusCore/imgui.ini[m
[36m@@ -0,0 +1,15 @@[m
[32m+[m[32m[Window][Debug##Default][m
[32m+[m[32mPos=60,60[m
[32m+[m[32mSize=400,400[m
[32m+[m[32mCollapsed=0[m
[32m+[m
[32m+[m[32m[Window][ImGui Demo][m
[32m+[m[32mPos=650,20[m
[32m+[m[32mSize=550,680[m
[32m+[m[32mCollapsed=0[m
[32m+[m
[32m+[m[32m[Window][Hello, world!][m
[32m+[m[32mPos=60,60[m
[32m+[m[32mSize=345,180[m
[32m+[m[32mCollapsed=0[m
[32m+[m
[1mdiff --git a/RubeusCore/imgui.vcxproj b/RubeusCore/imgui.vcxproj[m
[1mnew file mode 100644[m
[1mindex 0000000..6702e71[m
[1m--- /dev/null[m
[1m+++ b/RubeusCore/imgui.vcxproj[m
[36m@@ -0,0 +1,292 @@[m
[32m+[m[32mï»¿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">[m
[32m+[m[32m  <ItemGroup Label="ProjectConfigurations">[m
[32m+[m[32m    <ProjectConfiguration Include="Debug|Win32">[m
[32m+[m[32m      <Configuration>Debug</Configuration>[m
[32m+[m[32m      <Platform>Win32</Platform>[m
[32m+[m[32m    </ProjectConfiguration>[m
[32m+[m[32m    <ProjectConfiguration Include="Release|Win32">[m
[32m+[m[32m      <Configuration>Release</Configuration>[m
[32m+[m[32m      <Platform>Win32</Platform>[m
[32m+[m[32m    </ProjectConfiguration>[m
[32m+[m[32m    <ProjectConfiguration Include="MinSizeRel|Win32">[m
[32m+[m[32m      <Configuration>MinSizeRel</Configuration>[m
[32m+[m[32m      <Platform>Win32</Platform>[m
[32m+[m[32m    </ProjectConfiguration>[m
[32m+[m[32m    <ProjectConfiguration Include="RelWithDebInfo|Win32">[m
[32m+[m[32m      <Configuration>RelWithDebInfo</Configuration>[m
[32m+[m[32m      <Platform>Win32</Platform>[m
[32m+[m[32m    </ProjectConfiguration>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <PropertyGroup Label="Globals">[m
[32m+[m[32m    <ProjectGuid>{68858766-958B-3CC9-BC60-CCCF38A29CD7}</ProjectGuid>[m
[32m+[m[32m    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>[m
[32m+[m[32m    <Keyword>Win32Proj</Keyword>[m
[32m+[m[32m    <Platform>Win32</Platform>[m
[32m+[m[32m    <ProjectName>imgui</ProjectName>[m
[32m+[m[32m    <VCProjectUpgraderObjectName>NoUpgrade</VCProjectUpgraderObjectName>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />[m
[32m+[m[32m  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">[m
[32m+[m[32m    <ConfigurationType>StaticLibrary</ConfigurationType>[m
[32m+[m[32m    <CharacterSet>MultiByte</CharacterSet>[m
[32m+[m[32m    <PlatformToolset>v141</PlatformToolset>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">[m
[32m+[m[32m    <ConfigurationType>StaticLibrary</ConfigurationType>[m
[32m+[m[32m    <CharacterSet>MultiByte</CharacterSet>[m
[32m+[m[32m    <PlatformToolset>v141</PlatformToolset>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'" Label="Configuration">[m
[32m+[m[32m    <ConfigurationType>StaticLibrary</ConfigurationType>[m
[32m+[m[32m    <CharacterSet>MultiByte</CharacterSet>[m
[32m+[m[32m    <PlatformToolset>v141</PlatformToolset>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'" Label="Configuration">[m
[32m+[m[32m    <ConfigurationType>StaticLibrary</ConfigurationType>[m
[32m+[m[32m    <CharacterSet>MultiByte</CharacterSet>[m
[32m+[m[32m    <PlatformToolset>v141</PlatformToolset>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />[m
[32m+[m[32m  <ImportGroup Label="ExtensionSettings">[m
[32m+[m[32m  </ImportGroup>[m
[32m+[m[32m  <ImportGroup Label="PropertySheets">[m
[32m+[m[32m    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />[m
[32m+[m[32m  </ImportGroup>[m
[32m+[m[32m  <PropertyGroup Label="UserMacros" />[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <_ProjectFileVersion>10.0.20506.1</_ProjectFileVersion>[m
[32m+[m[32m    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">D:\Rubeus\RubeusCore\Debug\</OutDir>[m
[32m+[m[32m    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">imgui.dir\Debug\</IntDir>[m
[32m+[m[32m    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">imgui</TargetName>[m
[32m+[m[32m    <TargetExt Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">.lib</TargetExt>[m
[32m+[m[32m    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">D:\Rubeus\RubeusCore\Release\</OutDir>[m
[32m+[m[32m    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">imgui.dir\Release\</IntDir>[m
[32m+[m[32m    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">imgui</TargetName>[m
[32m+[m[32m    <TargetExt Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">.lib</TargetExt>[m
[32m+[m[32m    <OutDir Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">D:\Rubeus\RubeusCore\MinSizeRel\</OutDir>[m
[32m+[m[32m    <IntDir Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">imgui.dir\MinSizeRel\</IntDir>[m
[32m+[m[32m    <TargetName Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">imgui</TargetName>[m
[32m+[m[32m    <TargetExt Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">.lib</TargetExt>[m
[32m+[m[32m    <OutDir Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">D:\Rubeus\RubeusCore\RelWithDebInfo\</OutDir>[m
[32m+[m[32m    <IntDir Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">imgui.dir\RelWithDebInfo\</IntDir>[m
[32m+[m[32m    <TargetName Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">imgui</TargetName>[m
[32m+[m[32m    <TargetExt Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">.lib</TargetExt>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m[32m  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">[m
[32m+[m[32m    <ClCompile>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m      <AssemblerListingLocation>Debug/</AssemblerListingLocation>[m
[32m+[m[32m      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>[m
[32m+[m[32m      <CompileAs>CompileAsCpp</CompileAs>[m
[32m+[m[32m      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>[m
[32m+[m[32m      <ExceptionHandling>Sync</ExceptionHandling>[m
[32m+[m[32m      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>[m
[32m+[m[32m      <LanguageStandard>stdcpp17</LanguageStandard>[m
[32m+[m[32m      <Optimization>Disabled</Optimization>[m
[32m+[m[32m      <PrecompiledHeader>NotUsing</PrecompiledHeader>[m
[32m+[m[32m      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>[m
[32m+[m[32m      <RuntimeTypeInfo>true</RuntimeTypeInfo>[m
[32m+[m[32m      <WarningLevel>Level3</WarningLevel>[m
[32m+[m[32m      <PreprocessorDefinitions>WIN32;_WINDOWS;GLEW_STATIC;GLFW_DLL;IMGUI_IMPL_OPENGL_LOADER_GLEW;CMAKE_INTDIR="Debug";%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <ObjectFileName>$(IntDir)</ObjectFileName>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ResourceCompile>[m
[32m+[m[32m      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;GLEW_STATIC;GLFW_DLL;IMGUI_IMPL_OPENGL_LOADER_GLEW;CMAKE_INTDIR=\"Debug\";%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m    </ResourceCompile>[m
[32m+[m[32m    <Midl>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m      <OutputDirectory>$(ProjectDir)/$(IntDir)</OutputDirectory>[m
[32m+[m[32m      <HeaderFileName>%(Filename).h</HeaderFileName>[m
[32m+[m[32m      <TypeLibraryName>%(Filename).tlb</TypeLibraryName>[m
[32m+[m[32m      <InterfaceIdentifierFileName>%(Filename)_i.c</InterfaceIdentifierFileName>[m
[32m+[m[32m      <ProxyFileName>%(Filename)_p.c</ProxyFileName>[m
[32m+[m[32m    </Midl>[m
[32m+[m[32m    <Lib>[m
[32m+[m[32m      <AdditionalOptions>%(AdditionalOptions) /machine:X86</AdditionalOptions>[m
[32m+[m[32m    </Lib>[m
[32m+[m[32m  </ItemDefinitionGroup>[m
[32m+[m[32m  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">[m
[32m+[m[32m    <ClCompile>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m      <AssemblerListingLocation>Release/</AssemblerListingLocation>[m
[32m+[m[32m      <CompileAs>CompileAsCpp</CompileAs>[m
[32m+[m[32m      <ExceptionHandling>Sync</ExceptionHandling>[m
[32m+[m[32m      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>[m
[32m+[m[32m      <LanguageStandard>stdcpp17</LanguageStandard>[m
[32m+[m[32m      <Optimization>MaxSpeed</Optimization>[m
[32m+[m[32m      <PrecompiledHeader>NotUsing</PrecompiledHeader>[m
[32m+[m[32m      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>[m
[32m+[m[32m      <RuntimeTypeInfo>true</RuntimeTypeInfo>[m
[32m+[m[32m      <WarningLevel>Level3</WarningLevel>[m
[32m+[m[32m      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;GLEW_STATIC;GLFW_DLL;IMGUI_IMPL_OPENGL_LOADER_GLEW;CMAKE_INTDIR="Release";%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <ObjectFileName>$(IntDir)</ObjectFileName>[m
[32m+[m[32m      <DebugInformationFormat>[m
[32m+[m[32m      </DebugInformationFormat>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ResourceCompile>[m
[32m+[m[32m      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;GLEW_STATIC;GLFW_DLL;IMGUI_IMPL_OPENGL_LOADER_GLEW;CMAKE_INTDIR=\"Release\";%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m    </ResourceCompile>[m
[32m+[m[32m    <Midl>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m      <OutputDirectory>$(ProjectDir)/$(IntDir)</OutputDirectory>[m
[32m+[m[32m      <HeaderFileName>%(Filename).h</HeaderFileName>[m
[32m+[m[32m      <TypeLibraryName>%(Filename).tlb</TypeLibraryName>[m
[32m+[m[32m      <InterfaceIdentifierFileName>%(Filename)_i.c</InterfaceIdentifierFileName>[m
[32m+[m[32m      <ProxyFileName>%(Filename)_p.c</ProxyFileName>[m
[32m+[m[32m    </Midl>[m
[32m+[m[32m    <Lib>[m
[32m+[m[32m      <AdditionalOptions>%(AdditionalOptions) /machine:X86</AdditionalOptions>[m
[32m+[m[32m    </Lib>[m
[32m+[m[32m  </ItemDefinitionGroup>[m
[32m+[m[32m  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">[m
[32m+[m[32m    <ClCompile>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m      <AssemblerListingLocation>MinSizeRel/</AssemblerListingLocation>[m
[32m+[m[32m      <CompileAs>CompileAsCpp</CompileAs>[m
[32m+[m[32m      <ExceptionHandling>Sync</ExceptionHandling>[m
[32m+[m[32m      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>[m
[32m+[m[32m      <LanguageStandard>stdcpp17</LanguageStandard>[m
[32m+[m[32m      <Optimization>MinSpace</Optimization>[m
[32m+[m[32m      <PrecompiledHeader>NotUsing</PrecompiledHeader>[m
[32m+[m[32m      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>[m
[32m+[m[32m      <RuntimeTypeInfo>true</RuntimeTypeInfo>[m
[32m+[m[32m      <WarningLevel>Level3</WarningLevel>[m
[32m+[m[32m      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;GLEW_STATIC;GLFW_DLL;IMGUI_IMPL_OPENGL_LOADER_GLEW;CMAKE_INTDIR="MinSizeRel";%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <ObjectFileName>$(IntDir)</ObjectFileName>[m
[32m+[m[32m      <DebugInformationFormat>[m
[32m+[m[32m      </DebugInformationFormat>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ResourceCompile>[m
[32m+[m[32m      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;GLEW_STATIC;GLFW_DLL;IMGUI_IMPL_OPENGL_LOADER_GLEW;CMAKE_INTDIR=\"MinSizeRel\";%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m    </ResourceCompile>[m
[32m+[m[32m    <Midl>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m      <OutputDirectory>$(ProjectDir)/$(IntDir)</OutputDirectory>[m
[32m+[m[32m      <HeaderFileName>%(Filename).h</HeaderFileName>[m
[32m+[m[32m      <TypeLibraryName>%(Filename).tlb</TypeLibraryName>[m
[32m+[m[32m      <InterfaceIdentifierFileName>%(Filename)_i.c</InterfaceIdentifierFileName>[m
[32m+[m[32m      <ProxyFileName>%(Filename)_p.c</ProxyFileName>[m
[32m+[m[32m    </Midl>[m
[32m+[m[32m    <Lib>[m
[32m+[m[32m      <AdditionalOptions>%(AdditionalOptions) /machine:X86</AdditionalOptions>[m
[32m+[m[32m    </Lib>[m
[32m+[m[32m  </ItemDefinitionGroup>[m
[32m+[m[32m  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">[m
[32m+[m[32m    <ClCompile>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m      <AssemblerListingLocation>RelWithDebInfo/</AssemblerListingLocation>[m
[32m+[m[32m      <CompileAs>CompileAsCpp</CompileAs>[m
[32m+[m[32m      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>[m
[32m+[m[32m      <ExceptionHandling>Sync</ExceptionHandling>[m
[32m+[m[32m      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>[m
[32m+[m[32m      <LanguageStandard>stdcpp17</LanguageStandard>[m
[32m+[m[32m      <Optimization>MaxSpeed</Optimization>[m
[32m+[m[32m      <PrecompiledHeader>NotUsing</PrecompiledHeader>[m
[32m+[m[32m      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>[m
[32m+[m[32m      <RuntimeTypeInfo>true</RuntimeTypeInfo>[m
[32m+[m[32m      <WarningLevel>Level3</WarningLevel>[m
[32m+[m[32m      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;GLEW_STATIC;GLFW_DLL;IMGUI_IMPL_OPENGL_LOADER_GLEW;CMAKE_INTDIR="RelWithDebInfo";%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <ObjectFileName>$(IntDir)</ObjectFileName>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ResourceCompile>[m
[32m+[m[32m      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;GLEW_STATIC;GLFW_DLL;IMGUI_IMPL_OPENGL_LOADER_GLEW;CMAKE_INTDIR=\"RelWithDebInfo\";%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m    </ResourceCompile>[m
[32m+[m[32m    <Midl>[m
[32m+[m[32m      <AdditionalIncludeDirectories>D:\Rubeus\RubeusCore\PUBLIC;D:\Rubeus\RubeusCore\..\vendor\include;D:\Rubeus\RubeusCore\..\vendor\source;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
[32m+[m[32m      <OutputDirectory>$(ProjectDir)/$(IntDir)</OutputDirectory>[m
[32m+[m[32m      <HeaderFileName>%(Filename).h</HeaderFileName>[m
[32m+[m[32m      <TypeLibraryName>%(Filename).tlb</TypeLibraryName>[m
[32m+[m[32m      <InterfaceIdentifierFileName>%(Filename)_i.c</InterfaceIdentifierFileName>[m
[32m+[m[32m      <ProxyFileName>%(Filename)_p.c</ProxyFileName>[m
[32m+[m[32m    </Midl>[m
[32m+[m[32m    <Lib>[m
[32m+[m[32m      <AdditionalOptions>%(AdditionalOptions) /machine:X86</AdditionalOptions>[m
[32m+[m[32m    </Lib>[m
[32m+[m[32m  </ItemDefinitionGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <CustomBuild Include="D:\Rubeus\RubeusCore\CMakeLists.txt">[m
[32m+[m[32m      <Message Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Building Custom Rule D:/Rubeus/RubeusCore/CMakeLists.txt</Message>[m
[32m+[m[32m      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">setlocal[m
[32m+[m[32m"D:\Program Files\CMake\bin\cmake.exe" -HD:/Rubeus -BD:/Rubeus --check-stamp-file D:/Rubeus/RubeusCore/CMakeFiles/generate.stamp[m
[32m+[m[32mif %errorlevel% neq 0 goto :cmEnd[m
[32m+[m[32m:cmEnd[m
[32m+[m[32mendlocal &amp; call :cmErrorLevel %errorlevel% &amp; goto :cmDone[m
[32m+[m[32m:cmErrorLevel[m
[32m+[m[32mexit /b %1[m
[32m+[m[32m:cmDone[m
[32m+[m[32mif %errorlevel% neq 0 goto :VCEnd</Command>[m
[32m+[m[32m      <AdditionalInputs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">D:/Rubeus/RubeusCore/CMakeLists.txt;D:\Rubeus\RubeusCore\CMakeLists.txt;D:\Rubeus\RubeusCore\CMakeLists.txt;%(AdditionalInputs)</AdditionalInputs>[m
[32m+[m[32m      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">D:\Rubeus\RubeusCore\CMakeFiles\generate.stamp</Outputs>[m
[32m+[m[32m      <LinkObjects Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</LinkObjects>[m
[32m+[m[32m      <Message Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Building Custom Rule D:/Rubeus/RubeusCore/CMakeLists.txt</Message>[m
[32m+[m[32m      <Command Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">setlocal[m
[32m+[m[32m"D:\Program Files\CMake\bin\cmake.exe" -HD:/Rubeus -BD:/Rubeus --check-stamp-file D:/Rubeus/RubeusCore/CMakeFiles/generate.stamp[m
[32m+[m[32mif %errorlevel% neq 0 goto :cmEnd[m
[32m+[m[32m:cmEnd[m
[32m+[m[32mendlocal &amp; call :cmErrorLevel %errorlevel% &amp; goto :cmDone[m
[32m+[m[32m:cmErrorLevel[m
[32m+[m[32mexit /b %1[m
[32m+[m[32m:cmDone[m
[32m+[m[32mif %errorlevel% neq 0 goto :VCEnd</Command>[m
[32m+[m[32m      <AdditionalInputs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">D:/Rubeus/RubeusCore/CMakeLists.txt;D:\Rubeus\RubeusCore\CMakeLists.txt;D:\Rubeus\RubeusCore\CMakeLists.txt;%(AdditionalInputs)</AdditionalInputs>[m
[32m+[m[32m      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">D:\Rubeus\RubeusCore\CMakeFiles\generate.stamp</Outputs>[m
[32m+[m[32m      <LinkObjects Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkObjects>[m
[32m+[m[32m      <Message Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">Building Custom Rule D:/Rubeus/RubeusCore/CMakeLists.txt</Message>[m
[32m+[m[32m      <Command Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">setlocal[m
[32m+[m[32m"D:\Program Files\CMake\bin\cmake.exe" -HD:/Rubeus -BD:/Rubeus --check-stamp-file D:/Rubeus/RubeusCore/CMakeFiles/generate.stamp[m
[32m+[m[32mif %errorlevel% neq 0 goto :cmEnd[m
[32m+[m[32m:cmEnd[m
[32m+[m[32mendlocal &amp; call :cmErrorLevel %errorlevel% &amp; goto :cmDone[m
[32m+[m[32m:cmErrorLevel[m
[32m+[m[32mexit /b %1[m
[32m+[m[32m:cmDone[m
[32m+[m[32mif %errorlevel% neq 0 goto :VCEnd</Command>[m
[32m+[m[32m      <AdditionalInputs Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">D:/Rubeus/RubeusCore/CMakeLists.txt;D:\Rubeus\RubeusCore\CMakeLists.txt;D:\Rubeus\RubeusCore\CMakeLists.txt;%(AdditionalInputs)</AdditionalInputs>[m
[32m+[m[32m      <Outputs Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">D:\Rubeus\RubeusCore\CMakeFiles\generate.stamp</Outputs>[m
[32m+[m[32m      <LinkObjects Condition="'$(Configuration)|$(Platform)'=='MinSizeRel|Win32'">false</LinkObjects>[m
[32m+[m[32m      <Message Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">Building Custom Rule D:/Rubeus/RubeusCore/CMakeLists.txt</Message>[m
[32m+[m[32m      <Command Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">setlocal[m
[32m+[m[32m"D:\Program Files\CMake\bin\cmake.exe" -HD:/Rubeus -BD:/Rubeus --check-stamp-file D:/Rubeus/RubeusCore/CMakeFiles/generate.stamp[m
[32m+[m[32mif %errorlevel% neq 0 goto :cmEnd[m
[32m+[m[32m:cmEnd[m
[32m+[m[32mendlocal &amp; call :cmErrorLevel %errorlevel% &amp; goto :cmDone[m
[32m+[m[32m:cmErrorLevel[m
[32m+[m[32mexit /b %1[m
[32m+[m[32m:cmDone[m
[32m+[m[32mif %errorlevel% neq 0 goto :VCEnd</Command>[m
[32m+[m[32m      <AdditionalInputs Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">D:/Rubeus/RubeusCore/CMakeLists.txt;D:\Rubeus\RubeusCore\CMakeLists.txt;D:\Rubeus\RubeusCore\CMakeLists.txt;%(AdditionalInputs)</AdditionalInputs>[m
[32m+[m[32m      <Outputs Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">D:\Rubeus\RubeusCore\CMakeFiles\generate.stamp</Outputs>[m
[32m+[m[32m      <LinkObjects Condition="'$(Configuration)|$(Platform)'=='RelWithDebInfo|Win32'">false</LinkObjects>[m
[32m+[m[32m    </CustomBuild>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\source\ImGui\imgui.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\source\ImGui\imstb_rectpack.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\source\ImGui\imstb_textedit.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\source\ImGui\imstb_truetype.h" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\source\ImGui\imgui_internal.h" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\vendor\source\ImGui\imgui.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\vendor\source\ImGui\imgui_demo.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\vendor\source\ImGui\imgui_draw.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\vendor\source\ImGui\imgui_widgets.cpp" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\vendor\source\ImGui\imgui_impl_glfw.cpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\source\ImGui\imgui_impl_glfw.h" />[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\vendor\source\ImGui\imgui_impl_opengl3.cpp" />[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\source\ImGui\imgui_impl_opengl3.h" />[m
[32m+[m[32m    <None Include="D:\Rubeus\vendor" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <ProjectReference Include="D:\Rubeus\ZERO_CHECK.vcxproj">[m
[32m+[m[32m      <Project>{817CD231-EBDE-3BE3-A1A1-CD495ABC6585}</Project>[m
[32m+[m[32m      <Name>ZERO_CHECK</Name>[m
[32m+[m[32m    </ProjectReference>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />[m
[32m+[m[32m  <ImportGroup Label="ExtensionTargets">[m
[32m+[m[32m  </ImportGroup>[m
[32m+[m[32m</Project>[m
\ No newline at end of file[m
[1mdiff --git a/RubeusCore/imgui.vcxproj.filters b/RubeusCore/imgui.vcxproj.filters[m
[1mnew file mode 100644[m
[1mindex 0000000..4cca97e[m
[1m--- /dev/null[m
[1m+++ b/RubeusCore/imgui.vcxproj.filters[m
[36m@@ -0,0 +1,60 @@[m
[32m+[m[32mï»¿<?xml version="1.0" encoding="utf-8"?>[m
[32m+[m[32m<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\vendor\source\ImGui\imgui.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\vendor\source\ImGui\imgui_demo.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\vendor\source\ImGui\imgui_draw.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\vendor\source\ImGui\imgui_widgets.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\vendor\source\ImGui\imgui_impl_glfw.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m    <ClCompile Include="D:\Rubeus\vendor\source\ImGui\imgui_impl_opengl3.cpp">[m
[32m+[m[32m      <Filter>Source Files</Filter>[m
[32m+[m[32m    </ClCompile>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\source\ImGui\imgui.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\source\ImGui\imstb_rectpack.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\source\ImGui\imstb_textedit.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\source\ImGui\imstb_truetype.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\source\ImGui\imgui_internal.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\source\ImGui\imgui_impl_glfw.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m    <ClInclude Include="D:\Rubeus\vendor\source\ImGui\imgui_impl_opengl3.h">[m
[32m+[m[32m      <Filter>Header Files</Filter>[m
[32m+[m[32m    </ClInclude>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <CustomBuild Include="D:\Rubeus\RubeusCore\CMakeLists.txt" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <None Include="D:\Rubeus\vendor" />[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m  <ItemGroup>[m
[32m+[m[32m    <Filter Include="Header Files">[m
[32m+[m[32m      <UniqueIdentifier>{2E1A23D5-F47A-3D2C-926C-7087F634B53E}</UniqueIdentifier>[m
[32m+[m[32m    </Filter>[m
[32m+[m[32m    <Filter Include="Source Files">[m
[32m+[m[32m      <UniqueIdentifier>{02633C0E-C854-33B0-8CD6-2EAB91B7EE29}</UniqueIdentifier>[m
[32m+[m[32m    </Filter>[m
[32m+[m[32m  </ItemGroup>[m
[32m+[m[32m</Project>[m
[1mdiff --git a/vendor/source/ImGui/imconfig.h b/vendor/source/ImGui/imconfig.h[m
[1mnew file mode 100644[m
[1mindex 0000000..825505b[m
[1m--- /dev/null[m
[1m+++ b/vendor/source/ImGui/imconfig.h[m
[36m@@ -0,0 +1,73 @@[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// COMPILE-TIME OPTIONS FOR DEAR IMGUI[m
[32m+[m[32m// Runtime options (clipboard callbacks, enabling various features, etc.) can generally be set via the ImGuiIO structure.[m
[32m+[m[32m// You can use ImGui::SetAllocatorFunctions() before calling ImGui::CreateContext() to rewire memory allocation functions.[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// A) You may edit imconfig.h (and not overwrite it when updating imgui, or maintain a patch/branch with your modifications to imconfig.h)[m
[32m+[m[32m// B) or add configuration directives in your own file and compile with #define IMGUI_USER_CONFIG "myfilename.h"[m
[32m+[m[32m// If you do so you need to make sure that configuration settings are defined consistently _everywhere_ dear imgui is used, which include[m
[32m+[m[32m// the imgui*.cpp files but also _any_ of your code that uses imgui. This is because some compile-time options have an affect on data structures.[m
[32m+[m[32m// Defining those options in imconfig.h will ensure every compilation unit gets to see the same data structure layouts.[m
[32m+[m[32m// Call IMGUI_CHECKVERSION() from your .cpp files to verify that the data structures your files are using are matching the ones imgui.cpp is using.[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m#pragma once[m
[32m+[m
[32m+[m[32m//---- Define assertion handler. Defaults to calling assert().[m
[32m+[m[32m//#define IM_ASSERT(_EXPR)  MyAssert(_EXPR)[m
[32m+[m[32m//#define IM_ASSERT(_EXPR)  ((void)(_EXPR))     // Disable asserts[m
[32m+[m
[32m+[m[32m//---- Define attributes of all API symbols declarations, e.g. for DLL under Windows.[m
[32m+[m[32m//#define IMGUI_API __declspec( dllexport )[m
[32m+[m[32m//#define IMGUI_API __declspec( dllimport )[m
[32m+[m
[32m+[m[32m//---- Don't define obsolete functions/enums names. Consider enabling from time to time after updating to avoid using soon-to-be obsolete function/names.[m
[32m+[m[32m//#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m
[32m+[m[32m//---- Don't implement demo windows functionality (ShowDemoWindow()/ShowStyleEditor()/ShowUserGuide() methods will be empty)[m
[32m+[m[32m//---- It is very strongly recommended to NOT disable the demo windows during development. Please read the comments in imgui_demo.cpp.[m
[32m+[m[32m//#define IMGUI_DISABLE_DEMO_WINDOWS[m
[32m+[m
[32m+[m[32m//---- Don't implement some functions to reduce linkage requirements.[m
[32m+[m[32m//#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS   // [Win32] Don't implement default clipboard handler. Won't use and link with OpenClipboard/GetClipboardData/CloseClipboard etc.[m
[32m+[m[32m//#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS         // [Win32] Don't implement default IME handler. Won't use and link with ImmGetContext/ImmSetCompositionWindow.[m
[32m+[m[32m//#define IMGUI_DISABLE_WIN32_FUNCTIONS                     // [Win32] Won't use and link with any Win32 function.[m
[32m+[m[32m//#define IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS             // Don't implement ImFormatString/ImFormatStringV so you can implement them yourself if you don't want to link with vsnprintf.[m
[32m+[m[32m//#define IMGUI_DISABLE_MATH_FUNCTIONS                      // Don't implement ImFabs/ImSqrt/ImPow/ImFmod/ImCos/ImSin/ImAcos/ImAtan2 wrapper so you can implement them yourself. Declare your prototypes in imconfig.h.[m
[32m+[m[32m//#define IMGUI_DISABLE_DEFAULT_ALLOCATORS                  // Don't implement default allocators calling malloc()/free() to avoid linking with them. You will need to call ImGui::SetAllocatorFunctions().[m
[32m+[m
[32m+[m[32m//---- Include imgui_user.h at the end of imgui.h as a convenience[m
[32m+[m[32m//#define IMGUI_INCLUDE_IMGUI_USER_H[m
[32m+[m
[32m+[m[32m//---- Pack colors to BGRA8 instead of RGBA8 (to avoid converting from one to another)[m
[32m+[m[32m//#define IMGUI_USE_BGRA_PACKED_COLOR[m
[32m+[m
[32m+[m[32m//---- Avoid multiple STB libraries implementations, or redefine path/filenames to prioritize another version[m
[32m+[m[32m// By default the embedded implementations are declared static and not available outside of imgui cpp files.[m
[32m+[m[32m//#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"[m
[32m+[m[32m//#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"[m
[32m+[m[32m//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION[m
[32m+[m[32m//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION[m
[32m+[m
[32m+[m[32m//---- Define constructor and implicit cast operators to convert back<>forth between your math types and ImVec2/ImVec4.[m
[32m+[m[32m// This will be inlined as part of ImVec2 and ImVec4 class declarations.[m
[32m+[m[32m/*[m
[32m+[m[32m#define IM_VEC2_CLASS_EXTRA                                                 \[m
[32m+[m[32m        ImVec2(const MyVec2& f) { x = f.x; y = f.y; }                       \[m
[32m+[m[32m        operator MyVec2() const { return MyVec2(x,y); }[m
[32m+[m
[32m+[m[32m#define IM_VEC4_CLASS_EXTRA                                                 \[m
[32m+[m[32m        ImVec4(const MyVec4& f) { x = f.x; y = f.y; z = f.z; w = f.w; }     \[m
[32m+[m[32m        operator MyVec4() const { return MyVec4(x,y,z,w); }[m
[32m+[m[32m*/[m
[32m+[m
[32m+[m[32m//---- Use 32-bit vertex indices (default is 16-bit) to allow meshes with more than 64K vertices. Render function needs to support it.[m
[32m+[m[32m//#define ImDrawIdx unsigned int[m
[32m+[m
[32m+[m[32m//---- Tip: You can add extra functions within the ImGui:: namespace, here or in your own headers files.[m
[32m+[m[32m/*[m
[32m+[m[32mnamespace ImGui[m
[32m+[m[32m{[m
[32m+[m[32m    void MyFunction(const char* name, const MyMatrix44& v);[m
[32m+[m[32m}[m
[32m+[m[32m*/[m
[1mdiff --git a/vendor/source/ImGui/imgui.cpp b/vendor/source/ImGui/imgui.cpp[m
[1mnew file mode 100644[m
[1mindex 0000000..0bcaee5[m
[1m--- /dev/null[m
[1m+++ b/vendor/source/ImGui/imgui.cpp[m
[36m@@ -0,0 +1,9841 @@[m
[32m+[m[32m// dear imgui, v1.70[m
[32m+[m[32m// (main code and documentation)[m
[32m+[m
[32m+[m[32m// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.[m
[32m+[m[32m// Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.[m
[32m+[m[32m// Get latest version at https://github.com/ocornut/imgui[m
[32m+[m[32m// Releases change-log at https://github.com/ocornut/imgui/releases[m
[32m+[m[32m// Technical Support for Getting Started https://discourse.dearimgui.org/c/getting-started[m
[32m+[m[32m// Gallery (please post your screenshots/video there!): https://github.com/ocornut/imgui/issues/1269[m
[32m+[m
[32m+[m[32m// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.[m
[32m+[m[32m// See LICENSE.txt for copyright and licensing details (standard MIT License).[m
[32m+[m[32m// This library is free but I need your support to sustain development and maintenance.[m
[32m+[m[32m// Businesses: you can support continued maintenance and development via support contracts or sponsoring, see docs/README.[m
[32m+[m[32m// Individuals: you can support continued maintenance and development via donations or Patreon https://www.patreon.com/imgui.[m
[32m+[m
[32m+[m[32m// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.[m
[32m+[m[32m// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without[m
[32m+[m[32m// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't[m
[32m+[m[32m// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you[m
[32m+[m[32m// to a better solution or official support for them.[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m
[32m+[m[32mIndex of this file:[m
[32m+[m
[32m+[m[32mDOCUMENTATION[m
[32m+[m
[32m+[m[32m- MISSION STATEMENT[m
[32m+[m[32m- END-USER GUIDE[m
[32m+[m[32m- PROGRAMMER GUIDE (read me!)[m
[32m+[m[32m  - Read first.[m
[32m+[m[32m  - How to update to a newer version of Dear ImGui.[m
[32m+[m[32m  - Getting started with integrating Dear ImGui in your code/engine.[m
[32m+[m[32m  - This is how a simple application may look like (2 variations).[m
[32m+[m[32m  - This is how a simple rendering function may look like.[m
[32m+[m[32m  - Using gamepad/keyboard navigation controls.[m
[32m+[m[32m- API BREAKING CHANGES (read me when you update!)[m
[32m+[m[32m- FREQUENTLY ASKED QUESTIONS (FAQ), TIPS[m
[32m+[m[32m  - Where is the documentation?[m
[32m+[m[32m  - Which version should I get?[m
[32m+[m[32m  - Who uses Dear ImGui?[m
[32m+[m[32m  - Why the odd dual naming, "Dear ImGui" vs "ImGui"?[m
[32m+[m[32m  - How can I tell whether to dispatch mouse/keyboard to imgui or to my application?[m
[32m+[m[32m  - How can I display an image? What is ImTextureID, how does it works?[m
[32m+[m[32m  - Why are multiple widgets reacting when I interact with a single one? How can I have[m
[32m+[m[32m    multiple widgets with the same label or with an empty label? A primer on labels and the ID Stack...[m
[32m+[m[32m  - How can I use my own math types instead of ImVec2/ImVec4?[m
[32m+[m[32m  - How can I load a different font than the default?[m
[32m+[m[32m  - How can I easily use icons in my application?[m
[32m+[m[32m  - How can I load multiple fonts?[m
[32m+[m[32m  - How can I display and input non-latin characters such as Chinese, Japanese, Korean, Cyrillic?[m
[32m+[m[32m  - How can I interact with standard C++ types (such as std::string and std::vector)?[m
[32m+[m[32m  - How can I use the drawing facilities without an ImGui window? (using ImDrawList API)[m
[32m+[m[32m  - How can I use Dear ImGui on a platform that doesn't have a mouse or a keyboard? (input share, remoting, gamepad)[m
[32m+[m[32m  - I integrated Dear ImGui in my engine and the text or lines are blurry..[m
[32m+[m[32m  - I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..[m
[32m+[m[32m  - How can I help?[m
[32m+[m
[32m+[m[32mCODE[m
[32m+[m[32m(search for "[SECTION]" in the code to find them)[m
[32m+[m
[32m+[m[32m// [SECTION] FORWARD DECLARATIONS[m
[32m+[m[32m// [SECTION] CONTEXT AND MEMORY ALLOCATORS[m
[32m+[m[32m// [SECTION] MAIN USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)[m
[32m+[m[32m// [SECTION] MISC HELPERS/UTILITIES (Maths, String, Format, Hash, File functions)[m
[32m+[m[32m// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)[m
[32m+[m[32m// [SECTION] MISC HELPERS/UTILITIES (Color functions)[m
[32m+[m[32m// [SECTION] ImGuiStorage[m
[32m+[m[32m// [SECTION] ImGuiTextFilter[m
[32m+[m[32m// [SECTION] ImGuiTextBuffer[m
[32m+[m[32m// [SECTION] ImGuiListClipper[m
[32m+[m[32m// [SECTION] RENDER HELPERS[m
[32m+[m[32m// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)[m
[32m+[m[32m// [SECTION] TOOLTIPS[m
[32m+[m[32m// [SECTION] POPUPS[m
[32m+[m[32m// [SECTION] KEYBOARD/GAMEPAD NAVIGATION[m
[32m+[m[32m// [SECTION] COLUMNS[m
[32m+[m[32m// [SECTION] DRAG AND DROP[m
[32m+[m[32m// [SECTION] LOGGING/CAPTURING[m
[32m+[m[32m// [SECTION] SETTINGS[m
[32m+[m[32m// [SECTION] PLATFORM DEPENDENT HELPERS[m
[32m+[m[32m// [SECTION] METRICS/DEBUG WINDOW[m
[32m+[m
[32m+[m[32m*/[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// DOCUMENTATION[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m
[32m+[m[32m MISSION STATEMENT[m
[32m+[m[32m =================[m
[32m+[m
[32m+[m[32m - Easy to use to create code-driven and data-driven tools.[m
[32m+[m[32m - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.[m
[32m+[m[32m - Easy to hack and improve.[m
[32m+[m[32m - Minimize screen real-estate usage.[m
[32m+[m[32m - Minimize setup and maintenance.[m
[32m+[m[32m - Minimize state storage on user side.[m
[32m+[m[32m - Portable, minimize dependencies, run on target (consoles, phones, etc.).[m
[32m+[m[32m - Efficient runtime and memory consumption (NB- we do allocate when "growing" content e.g. creating a window,.[m
[32m+[m[32m   opening a tree node for the first time, etc. but a typical frame should not allocate anything).[m
[32m+[m
[32m+[m[32m Designed for developers and content-creators, not the typical end-user! Some of the weaknesses includes:[m
[32m+[m[32m - Doesn't look fancy, doesn't animate.[m
[32m+[m[32m - Limited layout features, intricate layouts are typically crafted in code.[m
[32m+[m
[32m+[m
[32m+[m[32m END-USER GUIDE[m
[32m+[m[32m ==============[m
[32m+[m
[32m+[m[32m - Double-click on title bar to collapse window.[m
[32m+[m[32m - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().[m
[32m+[m[32m - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).[m
[32m+[m[32m - Click and drag on any empty space to move window.[m
[32m+[m[32m - TAB/SHIFT+TAB to cycle through keyboard editable fields.[m
[32m+[m[32m - CTRL+Click on a slider or drag box to input value as text.[m
[32m+[m[32m - Use mouse wheel to scroll.[m
[32m+[m[32m - Text editor:[m
[32m+[m[32m   - Hold SHIFT or use mouse to select text.[m
[32m+[m[32m   - CTRL+Left/Right to word jump.[m
[32m+[m[32m   - CTRL+Shift+Left/Right to select words.[m
[32m+[m[32m   - CTRL+A our Double-Click to select all.[m
[32m+[m[32m   - CTRL+X,CTRL+C,CTRL+V to use OS clipboard/[m
[32m+[m[32m   - CTRL+Z,CTRL+Y to undo/redo.[m
[32m+[m[32m   - ESCAPE to revert text to its original value.[m
[32m+[m[32m   - You can apply arithmetic operators +,*,/ on numerical values. Use +- to subtract (because - would set a negative value!)[m
[32m+[m[32m   - Controls are automatically adjusted for OSX to match standard OSX text editing operations.[m
[32m+[m[32m - General Keyboard controls: enable with ImGuiConfigFlags_NavEnableKeyboard.[m
[32m+[m[32m - General Gamepad controls: enable with ImGuiConfigFlags_NavEnableGamepad. See suggested mappings in imgui.h ImGuiNavInput_ + download PNG/PSD at http://goo.gl/9LgVZW[m
[32m+[m
[32m+[m
[32m+[m[32m PROGRAMMER GUIDE[m
[32m+[m[32m ================[m
[32m+[m
[32m+[m[32m READ FIRST:[m
[32m+[m
[32m+[m[32m - Read the FAQ below this section![m
[32m+[m[32m - Your code creates the UI, if your code doesn't run the UI is gone! The UI can be highly dynamic, there are no construction[m
[32m+[m[32m   or destruction steps, less superfluous data retention on your side, less state duplication, less state synchronization, less bugs.[m
[32m+[m[32m - Call and read ImGui::ShowDemoWindow() for demo code demonstrating most features.[m
[32m+[m[32m - The library is designed to be built from sources. Avoid pre-compiled binaries and packaged versions. See imconfig.h to configure your build.[m
[32m+[m[32m - Dear ImGui is an implementation of the IMGUI paradigm (immediate-mode graphical user interface, a term coined by Casey Muratori).[m
[32m+[m[32m   You can learn about IMGUI principles at http://www.johno.se/book/imgui.html, http://mollyrocket.com/861 & more links docs/README.md.[m
[32m+[m[32m - Dear ImGui is a "single pass" rasterizing implementation of the IMGUI paradigm, aimed at ease of use and high-performances.[m
[32m+[m[32m   For every application frame your UI code will be called only once. This is in contrast to e.g. Unity's own implementation of an IMGUI,[m
[32m+[m[32m   where the UI code is called multiple times ("multiple passes") from a single entry point. There are pros and cons to both approaches.[m
[32m+[m[32m - Our origin are on the top-left. In axis aligned bounding boxes, Min = top-left, Max = bottom-right.[m
[32m+[m[32m - This codebase is also optimized to yield decent performances with typical "Debug" builds settings.[m
[32m+[m[32m - Please make sure you have asserts enabled (IM_ASSERT redirects to assert() by default, but can be redirected).[m
[32m+[m[32m   If you get an assert, read the messages and comments around the assert.[m
[32m+[m[32m - C++: this is a very C-ish codebase: we don't rely on C++11, we don't include any C++ headers, and ImGui:: is a namespace.[m
[32m+[m[32m - C++: ImVec2/ImVec4 do not expose math operators by default, because it is expected that you use your own math types.[m
[32m+[m[32m   See FAQ "How can I use my own math types instead of ImVec2/ImVec4?" for details about setting up imconfig.h for that.[m
[32m+[m[32m   However, imgui_internal.h can optionally export math operators for ImVec2/ImVec4, which we use in this codebase.[m
[32m+[m[32m - C++: pay attention that ImVector<> manipulates plain-old-data and does not honor construction/destruction (avoid using it in your code!).[m
[32m+[m
[32m+[m[32m HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI:[m
[32m+[m
[32m+[m[32m - Overwrite all the sources files except for imconfig.h (if you have made modification to your copy of imconfig.h)[m
[32m+[m[32m - Or maintain your own branch where you have imconfig.h modified.[m
[32m+[m[32m - Read the "API BREAKING CHANGES" section (below). This is where we list occasional API breaking changes.[m
[32m+[m[32m   If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed[m
[32m+[m[32m   from the public API. If you have a problem with a missing function/symbols, search for its name in the code, there will[m
[32m+[m[32m   likely be a comment about it. Please report any issue to the GitHub page![m
[32m+[m[32m - Try to keep your copy of dear imgui reasonably up to date.[m
[32m+[m
[32m+[m[32m GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE:[m
[32m+[m
[32m+[m[32m - Run and study the examples and demo in imgui_demo.cpp to get acquainted with the library.[m
[32m+[m[32m - Add the Dear ImGui source files to your projects or using your preferred build system.[m
[32m+[m[32m   It is recommended you build and statically link the .cpp files as part of your project and not as shared library (DLL).[m
[32m+[m[32m - You can later customize the imconfig.h file to tweak some compile-time behavior, such as integrating imgui types with your own maths types.[m
[32m+[m[32m - When using Dear ImGui, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.[m
[32m+[m[32m - Dear ImGui never touches or knows about your GPU state. The only function that knows about GPU is the draw function that you provide.[m
[32m+[m[32m   Effectively it means you can create widgets at any time in your code, regardless of considerations of being in "update" vs "render"[m
[32m+[m[32m   phases of your own application. All rendering informatioe are stored into command-lists that you will retrieve after calling ImGui::Render().[m
[32m+[m[32m - Refer to the bindings and demo applications in the examples/ folder for instruction on how to setup your code.[m
[32m+[m[32m - If you are running over a standard OS with a common graphics API, you should be able to use unmodified imgui_impl_*** files from the examples/ folder.[m
[32m+[m
[32m+[m[32m HOW A SIMPLE APPLICATION MAY LOOK LIKE:[m
[32m+[m[32m EXHIBIT 1: USING THE EXAMPLE BINDINGS (imgui_impl_XXX.cpp files from the examples/ folder).[m
[32m+[m
[32m+[m[32m     // Application init: create a dear imgui context, setup some options, load fonts[m
[32m+[m[32m     ImGui::CreateContext();[m
[32m+[m[32m     ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.[m
[32m+[m[32m     // TODO: Fill optional fields of the io structure later.[m
[32m+[m[32m     // TODO: Load TTF/OTF fonts if you don't want to use the default font.[m
[32m+[m
[32m+[m[32m     // Initialize helper Platform and Renderer bindings (here we are using imgui_impl_win32 and imgui_impl_dx11)[m
[32m+[m[32m     ImGui_ImplWin32_Init(hwnd);[m
[32m+[m[32m     ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);[m
[32m+[m
[32m+[m[32m     // Application main loop[m
[32m+[m[32m     while (true)[m
[32m+[m[32m     {[m
[32m+[m[32m         // Feed inputs to dear imgui, start new frame[m
[32m+[m[32m         ImGui_ImplDX11_NewFrame();[m
[32m+[m[32m         ImGui_ImplWin32_NewFrame();[m
[32m+[m[32m         ImGui::NewFrame();[m
[32m+[m
[32m+[m[32m         // Any application code here[m
[32m+[m[32m         ImGui::Text("Hello, world!");[m
[32m+[m
[32m+[m[32m         // Render dear imgui into screen[m
[32m+[m[32m         ImGui::Render();[m
[32m+[m[32m         ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());[m
[32m+[m[32m         g_pSwapChain->Present(1, 0);[m
[32m+[m[32m     }[m
[32m+[m
[32m+[m[32m     // Shutdown[m
[32m+[m[32m     ImGui_ImplDX11_Shutdown();[m
[32m+[m[32m     ImGui_ImplWin32_Shutdown();[m
[32m+[m[32m     ImGui::DestroyContext();[m
[32m+[m
[32m+[m[32m HOW A SIMPLE APPLICATION MAY LOOK LIKE:[m
[32m+[m[32m EXHIBIT 2: IMPLEMENTING CUSTOM BINDING / CUSTOM ENGINE.[m
[32m+[m
[32m+[m[32m     // Application init: create a dear imgui context, setup some options, load fonts[m
[32m+[m[32m     ImGui::CreateContext();[m
[32m+[m[32m     ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.[m
[32m+[m[32m     // TODO: Fill optional fields of the io structure later.[m
[32m+[m[32m     // TODO: Load TTF/OTF fonts if you don't want to use the default font.[m
[32m+[m
[32m+[m[32m     // Build and load the texture atlas into a texture[m
[32m+[m[32m     // (In the examples/ app this is usually done within the ImGui_ImplXXX_Init() function from one of the demo Renderer)[m
[32m+[m[32m     int width, height;[m
[32m+[m[32m     unsigned char* pixels = NULL;[m
[32m+[m[32m     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);[m
[32m+[m
[32m+[m[32m     // At this point you've got the texture data and you need to upload that your your graphic system:[m
[32m+[m[32m     // After we have created the texture, store its pointer/identifier (_in whichever format your engine uses_) in 'io.Fonts->TexID'.[m
[32m+[m[32m     // This will be passed back to your via the renderer. Basically ImTextureID == void*. Read FAQ below for details about ImTextureID.[m
[32m+[m[32m     MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA32)[m
[32m+[m[32m     io.Fonts->TexID = (void*)texture;[m
[32m+[m
[32m+[m[32m     // Application main loop[m
[32m+[m[32m     while (true)[m
[32m+[m[32m     {[m
[32m+[m[32m        // Setup low-level inputs, e.g. on Win32: calling GetKeyboardState(), or write to those fields from your Windows message handlers, etc.[m
[32m+[m[32m        // (In the examples/ app this is usually done within the ImGui_ImplXXX_NewFrame() function from one of the demo Platform bindings)[m
[32m+[m[32m        io.DeltaTime = 1.0f/60.0f;              // set the time elapsed since the previous frame (in seconds)[m
[32m+[m[32m        io.DisplaySize.x = 1920.0f;             // set the current display width[m
[32m+[m[32m        io.DisplaySize.y = 1280.0f;             // set the current display height here[m
[32m+[m[32m        io.MousePos = my_mouse_pos;             // set the mouse position[m
[32m+[m[32m        io.MouseDown[0] = my_mouse_buttons[0];  // set the mouse button states[m
[32m+[m[32m        io.MouseDown[1] = my_mouse_buttons[1];[m
[32m+[m
[32m+[m[32m        // Call NewFrame(), after this point you can use ImGui::* functions anytime[m
[32m+[m[32m        // (So you want to try calling NewFrame() as early as you can in your mainloop to be able to use imgui everywhere)[m
[32m+[m[32m        ImGui::NewFrame();[m
[32m+[m
[32m+[m[32m        // Most of your application code here[m
[32m+[m[32m        ImGui::Text("Hello, world!");[m
[32m+[m[32m        MyGameUpdate(); // may use any ImGui functions, e.g. ImGui::Begin("My window"); ImGui::Text("Hello, world!"); ImGui::End();[m
[32m+[m[32m        MyGameRender(); // may use any ImGui functions as well![m
[32m+[m
[32m+[m[32m        // Render imgui, swap buffers[m
[32m+[m[32m        // (You want to try calling EndFrame/Render as late as you can, to be able to use imgui in your own game rendering code)[m
[32m+[m[32m        ImGui::EndFrame();[m
[32m+[m[32m        ImGui::Render();[m
[32m+[m[32m        ImDrawData* draw_data = ImGui::GetDrawData();[m
[32m+[m[32m        MyImGuiRenderFunction(draw_data);[m
[32m+[m[32m        SwapBuffers();[m
[32m+[m[32m     }[m
[32m+[m
[32m+[m[32m     // Shutdown[m
[32m+[m[32m     ImGui::DestroyContext();[m
[32m+[m
[32m+[m[32m HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE:[m
[32m+[m
[32m+[m[32m    void void MyImGuiRenderFunction(ImDrawData* draw_data)[m
[32m+[m[32m    {[m
[32m+[m[32m       // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled[m
[32m+[m[32m       // TODO: Setup viewport covering draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize[m
[32m+[m[32m       // TODO: Setup orthographic projection matrix cover draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize[m
[32m+[m[32m       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.[m
[32m+[m[32m       for (int n = 0; n < draw_data->CmdListsCount; n++)[m
[32m+[m[32m       {[m
[32m+[m[32m          const ImDrawList* cmd_list = draw_data->CmdLists[n];[m
[32m+[m[32m          const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by ImGui[m
[32m+[m[32m          const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by ImGui[m
[32m+[m[32m          for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)[m
[32m+[m[32m          {[m
[32m+[m[32m             const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];[m
[32m+[m[32m             if (pcmd->UserCallback)[m
[32m+[m[32m             {[m
[32m+[m[32m                 pcmd->UserCallback(cmd_list, pcmd);[m
[32m+[m[32m             }[m
[32m+[m[32m             else[m
[32m+[m[32m             {[m
[32m+[m[32m                 // The texture for the draw call is specified by pcmd->TextureId.[m
[32m+[m[32m                 // The vast majority of draw calls will use the imgui texture atlas, which value you have set yourself during initialization.[m
[32m+[m[32m                 MyEngineBindTexture((MyTexture*)pcmd->TextureId);[m
[32m+[m
[32m+[m[32m                 // We are using scissoring to clip some objects. All low-level graphics API should supports it.[m
[32m+[m[32m                 // - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches[m
[32m+[m[32m                 //   (some elements visible outside their bounds) but you can fix that once everything else works![m
[32m+[m[32m                 // - Clipping coordinates are provided in imgui coordinates space (from draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize)[m
[32m+[m[32m                 //   In a single viewport application, draw_data->DisplayPos will always be (0,0) and draw_data->DisplaySize will always be == io.DisplaySize.[m
[32m+[m[32m                 //   However, in the interest of supporting multi-viewport applications in the future (see 'viewport' branch on github),[m
[32m+[m[32m                 //   always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.[m
[32m+[m[32m                 // - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)[m
[32m+[m[32m                 ImVec2 pos = draw_data->DisplayPos;[m
[32m+[m[32m                 MyEngineScissor((int)(pcmd->ClipRect.x - pos.x), (int)(pcmd->ClipRect.y - pos.y), (int)(pcmd->ClipRect.z - pos.x), (int)(pcmd->ClipRect.w - pos.y));[m
[32m+[m
[32m+[m[32m                 // Render 'pcmd->ElemCount/3' indexed triangles.[m
[32m+[m[32m                 // By default the indices ImDrawIdx are 16-bits, you can change them to 32-bits in imconfig.h if your engine doesn't support 16-bits indices.[m
[32m+[m[32m                 MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer, vtx_buffer);[m
[32m+[m[32m             }[m
[32m+[m[32m             idx_buffer += pcmd->ElemCount;[m
[32m+[m[32m          }[m
[32m+[m[32m       }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m - The examples/ folders contains many actual implementation of the pseudo-codes above.[m
[32m+[m[32m - When calling NewFrame(), the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags are updated.[m
[32m+[m[32m   They tell you if Dear ImGui intends to use your inputs. When a flag is set you want to hide the corresponding inputs[m
[32m+[m[32m   from the rest of your application. In every cases you need to pass on the inputs to imgui. Refer to the FAQ for more information.[m
[32m+[m[32m - Please read the FAQ below!. Amusingly, it is called a FAQ because people frequently run into the same issues![m
[32m+[m
[32m+[m[32m USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS[m
[32m+[m
[32m+[m[32m - The gamepad/keyboard navigation is fairly functional and keeps being improved.[m
[32m+[m[32m - Gamepad support is particularly useful to use dear imgui on a console system (e.g. PS4, Switch, XB1) without a mouse![m
[32m+[m[32m - You can ask questions and report issues at https://github.com/ocornut/imgui/issues/787[m
[32m+[m[32m - The initial focus was to support game controllers, but keyboard is becoming increasingly and decently usable.[m
[32m+[m[32m - Gamepad:[m
[32m+[m[32m    - Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable.[m
[32m+[m[32m    - Backend: Set io.BackendFlags |= ImGuiBackendFlags_HasGamepad + fill the io.NavInputs[] fields before calling NewFrame().[m
[32m+[m[32m      Note that io.NavInputs[] is cleared by EndFrame().[m
[32m+[m[32m    - See 'enum ImGuiNavInput_' in imgui.h for a description of inputs. For each entry of io.NavInputs[], set the following values:[m
[32m+[m[32m         0.0f= not held. 1.0f= fully held. Pass intermediate 0.0f..1.0f values for analog triggers/sticks.[m
[32m+[m[32m    - We uses a simple >0.0f test for activation testing, and won't attempt to test for a dead-zone.[m
[32m+[m[32m      Your code will probably need to transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range to 0.0..1.0 imgui range, etc.).[m
[32m+[m[32m    - You can download PNG/PSD files depicting the gamepad controls for common controllers at: http://goo.gl/9LgVZW.[m
[32m+[m[32m    - If you need to share inputs between your game and the imgui parts, the easiest approach is to go all-or-nothing, with a buttons combo[m
[32m+[m[32m      to toggle the target. Please reach out if you think the game vs navigation input sharing could be improved.[m
[32m+[m[32m - Keyboard:[m
[32m+[m[32m    - Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable.[m
[32m+[m[32m      NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.[m
[32m+[m[32m    - When keyboard navigation is active (io.NavActive + ImGuiConfigFlags_NavEnableKeyboard), the io.WantCaptureKeyboard flag[m
[32m+[m[32m      will be set. For more advanced uses, you may want to read from:[m
[32m+[m[32m       - io.NavActive: true when a window is focused and it doesn't have the ImGuiWindowFlags_NoNavInputs flag set.[m
[32m+[m[32m       - io.NavVisible: true when the navigation cursor is visible (and usually goes false when mouse is used).[m
[32m+[m[32m       - or query focus information with e.g. IsWindowFocused(ImGuiFocusedFlags_AnyWindow), IsItemFocused() etc. functions.[m
[32m+[m[32m      Please reach out if you think the game vs navigation input sharing could be improved.[m
[32m+[m[32m - Mouse:[m
[32m+[m[32m    - PS4 users: Consider emulating a mouse cursor with DualShock4 touch pad or a spare analog stick as a mouse-emulation fallback.[m
[32m+[m[32m    - Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your PC) + uSynergy.c (on your console/tablet/phone app) to share your PC mouse/keyboard.[m
[32m+[m[32m    - On a TV/console system where readability may be lower or mouse inputs may be awkward, you may want to set the ImGuiConfigFlags_NavEnableSetMousePos flag.[m
[32m+[m[32m      Enabling ImGuiConfigFlags_NavEnableSetMousePos + ImGuiBackendFlags_HasSetMousePos instructs dear imgui to move your mouse cursor along with navigation movements.[m
[32m+[m[32m      When enabled, the NewFrame() function may alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants the mouse cursor to be moved.[m
[32m+[m[32m      When that happens your back-end NEEDS to move the OS or underlying mouse cursor on the next frame. Some of the binding in examples/ do that.[m
[32m+[m[32m      (If you set the NavEnableSetMousePos flag but don't honor 'io.WantSetMousePos' properly, imgui will misbehave as it will see your mouse as moving back and forth!)[m
[32m+[m[32m      (In a setup when you may not have easy control over the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor, you may want[m
[32m+[m[32m       to set a boolean to ignore your other external mouse positions until the external source is moved again.)[m
[32m+[m
[32m+[m
[32m+[m[32m API BREAKING CHANGES[m
[32m+[m[32m ====================[m
[32m+[m
[32m+[m[32m Occasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.[m
[32m+[m[32m Below is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.[m
[32m+[m[32m When you are not sure about a old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all imgui files.[m
[32m+[m[32m You can read releases logs https://github.com/ocornut/imgui/releases for more details.[m
[32m+[m
[32m+[m[32m - 2019/04/29 (1.70) - improved ImDrawList thick strokes (>1.0f) preserving correct thickness up to 90 degrees angles (e.g. rectangles). If you have custom rendering using thick lines, they will appear thicker now.[m
[32m+[m[32m - 2019/04/29 (1.70) - removed GetContentRegionAvailWidth(), use GetContentRegionAvail().x instead. Kept inline redirection function (will obsolete).[m
[32m+[m[32m - 2019/03/04 (1.69) - renamed GetOverlayDrawList() to GetForegroundDrawList(). Kept redirection function (will obsolete).[m
[32m+[m[32m - 2019/02/26 (1.69) - renamed ImGuiColorEditFlags_RGB/ImGuiColorEditFlags_HSV/ImGuiColorEditFlags_HEX to ImGuiColorEditFlags_DisplayRGB/ImGuiColorEditFlags_DisplayHSV/ImGuiColorEditFlags_DisplayHex. Kept redirection enums (will obsolete).[m
[32m+[m[32m - 2019/02/14 (1.68) - made it illegal/assert when io.DisplayTime == 0.0f (with an exception for the first frame). If for some reason your time step calculation gives you a zero value, replace it with a dummy small value![m
[32m+[m[32m - 2019/02/01 (1.68) - removed io.DisplayVisibleMin/DisplayVisibleMax (which were marked obsolete and removed from viewport/docking branch already).[m
[32m+[m[32m - 2019/01/06 (1.67) - renamed io.InputCharacters[], marked internal as was always intended. Please don't access directly, and use AddInputCharacter() instead![m
[32m+[m[32m - 2019/01/06 (1.67) - renamed ImFontAtlas::GlyphRangesBuilder to ImFontGlyphRangesBuilder. Keep redirection typedef (will obsolete).[m
[32m+[m[32m - 2018/12/20 (1.67) - made it illegal to call Begin("") with an empty string. This somehow half-worked before but had various undesirable side-effects.[m
[32m+[m[32m - 2018/12/10 (1.67) - renamed io.ConfigResizeWindowsFromEdges to io.ConfigWindowsResizeFromEdges as we are doing a large pass on configuration flags.[m
[32m+[m[32m - 2018/10/12 (1.66) - renamed misc/stl/imgui_stl.* to misc/cpp/imgui_stdlib.* in prevision for other C++ helper files.[m
[32m+[m[32m - 2018/09/28 (1.66) - renamed SetScrollHere() to SetScrollHereY(). Kept redirection function (will obsolete).[m
[32m+[m[32m - 2018/09/06 (1.65) - renamed stb_truetype.h to imstb_truetype.h, stb_textedit.h to imstb_textedit.h, and stb_rect_pack.h to imstb_rectpack.h.[m
[32m+[m[32m                       If you were conveniently using the imgui copy of those STB headers in your project you will have to update your include paths.[m
[32m+[m[32m - 2018/09/05 (1.65) - renamed io.OptCursorBlink/io.ConfigCursorBlink to io.ConfigInputTextCursorBlink. (#1427)[m
[32m+[m[32m - 2018/08/31 (1.64) - added imgui_widgets.cpp file, extracted and moved widgets code out of imgui.cpp into imgui_widgets.cpp. Re-ordered some of the code remaining in imgui.cpp.[m
[32m+[m[32m                       NONE OF THE FUNCTIONS HAVE CHANGED. THE CODE IS SEMANTICALLY 100% IDENTICAL, BUT _EVERY_ FUNCTION HAS BEEN MOVED.[m
[32m+[m[32m                       Because of this, any local modifications to imgui.cpp will likely conflict when you update. Read docs/CHANGELOG.txt for suggestions.[m
[32m+[m[32m - 2018/08/22 (1.63) - renamed IsItemDeactivatedAfterChange() to IsItemDeactivatedAfterEdit() for consistency with new IsItemEdited() API. Kept redirection function (will obsolete soonish as IsItemDeactivatedAfterChange() is very recent).[m
[32m+[m[32m - 2018/08/21 (1.63) - renamed ImGuiTextEditCallback to ImGuiInputTextCallback, ImGuiTextEditCallbackData to ImGuiInputTextCallbackData for consistency. Kept redirection types (will obsolete).[m
[32m+[m[32m - 2018/08/21 (1.63) - removed ImGuiInputTextCallbackData::ReadOnly since it is a duplication of (ImGuiInputTextCallbackData::Flags & ImGuiInputTextFlags_ReadOnly).[m
[32m+[m[32m - 2018/08/01 (1.63) - removed per-window ImGuiWindowFlags_ResizeFromAnySide beta flag in favor of a global io.ConfigResizeWindowsFromEdges [update 1.67 renamed to ConfigWindowsResizeFromEdges] to enable the feature.[m
[32m+[m[32m - 2018/08/01 (1.63) - renamed io.OptCursorBlink to io.ConfigCursorBlink [-> io.ConfigInputTextCursorBlink in 1.65], io.OptMacOSXBehaviors to ConfigMacOSXBehaviors for consistency.[m
[32m+[m[32m - 2018/07/22 (1.63) - changed ImGui::GetTime() return value from float to double to avoid accumulating floating point imprecisions over time.[m
[32m+[m[32m - 2018/07/08 (1.63) - style: renamed ImGuiCol_ModalWindowDarkening to ImGuiCol_ModalWindowDimBg for consistency with other features. Kept redirection enum (will obsolete).[m
[32m+[m[32m - 2018/06/08 (1.62) - examples: the imgui_impl_xxx files have been split to separate platform (Win32, Glfw, SDL2, etc.) from renderer (DX11, OpenGL, Vulkan,  etc.).[m
[32m+[m[32m                       old bindings will still work as is, however prefer using the separated bindings as they will be updated to support multi-viewports.[m
[32m+[m[32m                       when adopting new bindings follow the main.cpp code of your preferred examples/ folder to know which functions to call.[m
[32m+[m[32m                       in particular, note that old bindings called ImGui::NewFrame() at the end of their ImGui_ImplXXXX_NewFrame() function.[m
[32m+[m[32m - 2018/06/06 (1.62) - renamed GetGlyphRangesChinese() to GetGlyphRangesChineseFull() to distinguish other variants and discourage using the full set.[m
[32m+[m[32m - 2018/06/06 (1.62) - TreeNodeEx()/TreeNodeBehavior(): the ImGuiTreeNodeFlags_CollapsingHeader helper now include the ImGuiTreeNodeFlags_NoTreePushOnOpen flag. See Changelog for details.[m
[32m+[m[32m - 2018/05/03 (1.61) - DragInt(): the default compile-time format string has been changed from "%.0f" to "%d", as we are not using integers internally any more.[m
[32m+[m[32m                       If you used DragInt() with custom format strings, make sure you change them to use %d or an integer-compatible format.[m
[32m+[m[32m                       To honor backward-compatibility, the DragInt() code will currently parse and modify format strings to replace %*f with %d, giving time to users to upgrade their code.[m
[32m+[m[32m                       If you have IMGUI_DISABLE_OBSOLETE_FUNCTIONS enabled, the code will instead assert! You may run a reg-exp search on your codebase for e.g. "DragInt.*%f" to help you find them.[m
[32m+[m[32m - 2018/04/28 (1.61) - obsoleted InputFloat() functions taking an optional "int decimal_precision" in favor of an equivalent and more flexible "const char* format",[m
[32m+[m[32m                       consistent with other functions. Kept redirection functions (will obsolete).[m
[32m+[m[32m - 2018/04/09 (1.61) - IM_DELETE() helper function added in 1.60 doesn't clear the input _pointer_ reference, more consistent with expectation and allows passing r-value.[m
[32m+[m[32m - 2018/03/20 (1.60) - renamed io.WantMoveMouse to io.WantSetMousePos for consistency and ease of understanding (was added in 1.52, _not_ used by core and only honored by some binding ahead of merging the Nav branch).[m
[32m+[m[32m - 2018/03/12 (1.60) - removed ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered as the closing cross uses regular button colors now.[m
[32m+[m[32m - 2018/03/08 (1.60) - changed ImFont::DisplayOffset.y to default to 0 instead of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were adding or subtracting to ImFont::DisplayOffset check if your fonts are correctly aligned vertically.[m
[32m+[m[32m - 2018/03/03 (1.60) - renamed ImGuiStyleVar_Count_ to ImGuiStyleVar_COUNT and ImGuiMouseCursor_Count_ to ImGuiMouseCursor_COUNT for consistency with other public enums.[m
[32m+[m[32m - 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional mouse_button=0 parameter because it is not really usable in many situations at the moment.[m
[32m+[m[32m - 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call your graphics engine render function after ImGui::Render(). Use ImGui::GetDrawData() to retrieve the ImDrawData* to display.[m
[32m+[m[32m - 2018/02/07 (1.60) - reorganized context handling to be more explicit,[m
[32m+[m[32m                       - YOU NOW NEED TO CALL ImGui::CreateContext() AT THE BEGINNING OF YOUR APP, AND CALL ImGui::DestroyContext() AT THE END.[m
[32m+[m[32m                       - removed Shutdown() function, as DestroyContext() serve this purpose.[m
[32m+[m[32m                       - you may pass a ImFontAtlas* pointer to CreateContext() to share a font atlas between contexts. Otherwise CreateContext() will create its own font atlas instance.[m
[32m+[m[32m                       - removed allocator parameters from CreateContext(), they are now setup with SetAllocatorFunctions(), and shared by all contexts.[m
[32m+[m[32m                       - removed the default global context and font atlas instance, which were confusing for users of DLL reloading and users of multiple contexts.[m
[32m+[m[32m - 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/. If you loaded files directly from the imgui repo you may need to update your paths.[m
[32m+[m[32m - 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of IsWindowHovered(ImGuiHoveredFlags_AnyWindow). Kept redirection function (will obsolete).[m
[32m+[m[32m - 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of IsWindowFocused(ImGuiFocusedFlags_AnyWindow). Kept redirection function (will obsolete).[m
[32m+[m[32m - 2018/01/03 (1.60) - renamed ImGuiSizeConstraintCallback to ImGuiSizeCallback, ImGuiSizeConstraintCallbackData to ImGuiSizeCallbackData.[m
[32m+[m[32m - 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and not really used by anyone except demo code. If you need it it's easy to replicate on your side.[m
[32m+[m[32m - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).[m
[32m+[m[32m - 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags[m
[32m+[m[32m - 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.[m
[32m+[m[32m - 2017/12/14 (1.53) - using the ImGuiWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set.[m
[32m+[m[32m - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).[m
[32m+[m[32m - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootWindow). Kept redirection function (will obsolete).[m
[32m+[m[32m                     - obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).[m
[32m+[m[32m - 2017/12/12 (1.53) - renamed ImGuiTreeNodeFlags_AllowOverlapMode to ImGuiTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).[m
[32m+[m[32m - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).[m
[32m+[m[32m - 2017/11/27 (1.53) - renamed ImGuiTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.[m
[32m+[m[32m - 2017/11/18 (1.53) - Style, Begin: removed ImGuiWindowFlags_ShowBorders window flag. Borders are now fully set up in the ImGuiStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use ImGui::ShowStyleEditor() to look them up.[m
[32m+[m[32m                       Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.[m
[32m+[m[32m - 2017/11/18 (1.53) - Style: removed ImGuiCol_ComboBg in favor of combo boxes using ImGuiCol_PopupBg for consistency.[m
[32m+[m[32m - 2017/11/18 (1.53) - Style: renamed ImGuiCol_ChildWindowBg to ImGuiCol_ChildBg.[m
[32m+[m[32m - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, ImGuiStyleVar_ChildWindowRounding to ImGuiStyleVar_ChildRounding.[m
[32m+[m[32m - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows);[m
[32m+[m[32m - 2017/10/24 (1.52) - renamed IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCS to IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.[m
[32m+[m[32m - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.[m
[32m+[m[32m - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for details.[m
[32m+[m[32m                       removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.[m
[32m+[m[32m - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead![m
[32m+[m[32m - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).[m
[32m+[m[32m - 2017/09/26 (1.52) - renamed ImFont::Glyph to ImFontGlyph. Keep redirection typedef (will obsolete).[m
[32m+[m[32m - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete).[m
[32m+[m[32m - 2017/08/25 (1.52) - io.MousePos needs to be set to ImVec2(-FLT_MAX,-FLT_MAX) when mouse is unavailable/missing. Previously ImVec2(-1,-1) was enough but we now accept negative mouse coordinates. In your binding if you need to support unavailable mouse, make sure to replace "io.MousePos = ImVec2(-1,-1)" with "io.MousePos = ImVec2(-FLT_MAX,-FLT_MAX)".[m
[32m+[m[32m - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(ImGuiHoveredFlags_RectOnly)![m
[32m+[m[32m                     - renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).[m
[32m+[m[32m                     - renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).[m
[32m+[m[32m - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.[m
[32m+[m[32m - 2017/08/20 (1.51) - added PushStyleColor(ImGuiCol idx, ImU32 col) overload, which _might_ cause an "ambiguous call" compilation error if you are using ImColor() with implicit cast. Cast to ImU32 or ImVec4 explicily to fix.[m
[32m+[m[32m - 2017/08/15 (1.51) - marked the weird IMGUI_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit ImGuiOnceUponAFrame.[m
[32m+[m[32m - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.[m
[32m+[m[32m - 2017/08/13 (1.51) - renamed ImGuiCol_Columns*** to ImGuiCol_Separator***. Kept redirection enums (will obsolete).[m
[32m+[m[32m - 2017/08/11 (1.51) - renamed ImGuiSetCond_*** types and flags to ImGuiCond_***. Kept redirection enums (will obsolete).[m
[32m+[m[32m - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().[m
[32m+[m[32m - 2017/08/08 (1.51) - removed ColorEditMode() and ImGuiColorEditMode in favor of ImGuiColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.[m
[32m+[m[32m                     - changed prototype of 'ColorEdit4(const char* label, float col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0)', where passing flags = 0x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under "Color/Picker Widgets", to understand the various new options.[m
[32m+[m[32m                     - changed prototype of rarely used 'ColorButton(ImVec4 col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, ImVec4 col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0))'[m
[32m+[m[32m - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(ImVec2), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse[m
[32m+[m[32m - 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.[m
[32m+[m[32m - 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.[m
[32m+[m[32m - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetId() and use it instead of passing string to BeginChild().[m
[32m+[m[32m - 2016/10/15 (1.50) - avoid 'void* user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.[m
[32m+[m[32m - 2016/09/25 (1.50) - style.WindowTitleAlign is now a ImVec2 (ImGuiAlign enum was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f) for upper-left, etc.[m
[32m+[m[32m - 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully breakage should be minimal.[m
[32m+[m[32m - 2016/05/12 (1.49) - title bar (using ImGuiCol_TitleBg/ImGuiCol_TitleBgActive colors) isn't rendered over a window background (ImGuiCol_WindowBg color) anymore.[m
[32m+[m[32m                       If your TitleBg/TitleBgActive alpha was 1.0f or you are using the default theme it will not affect you.[m
[32m+[m[32m                       If your TitleBg/TitleBgActive alpha was <1.0f you need to tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.[m
[32m+[m[32m                       This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color.[m
[32m+[m[32m                           ImVec4 ConvertTitleBgCol(const ImVec4& win_bg_col, const ImVec4& title_bg_col)[m
[32m+[m[32m                           {[m
[32m+[m[32m                               float new_a = 1.0f - ((1.0f - win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a;[m
[32m+[m[32m                               return ImVec4((win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a);[m
[32m+[m[32m                           }[m
[32m+[m[32m                       If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.[m
[32m+[m[32m - 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().[m
[32m+[m[32m - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.[m
[32m+[m[32m - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the "default_open = true" flag in new API with CollapsingHeader(label, ImGuiTreeNodeFlags_DefaultOpen).[m
[32m+[m[32m - 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(ImVec4 rect) to ImDrawList::PushClipRect(Imvec2 min,ImVec2 max,bool intersect_with_current_clip_rect=false). Note that higher-level ImGui::PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.[m
[32m+[m[32m - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[ImGuiCol_WindowBg] and all other Bg color values. (ref github issue #337).[m
[32m+[m[32m - 2016/04/03 (1.48) - renamed ImGuiCol_TooltipBg to ImGuiCol_PopupBg, used by popups/menus and tooltips. popups/menus were previously using ImGuiCol_WindowBg. (ref github issue #337)[m
[32m+[m[32m - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).[m
[32m+[m[32m - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.[m
[32m+[m[32m - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.[m
[32m+[m[32m - 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.[m
[32m+[m[32m - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.[m
[32m+[m[32m - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.[m
[32m+[m[32m                       GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0f) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.[m
[32m+[m[32m                       GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out![m
[32m+[m[32m - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize[m
[32m+[m[32m - 2015/08/05 (1.44) - split imgui.cpp into extra files: imgui_demo.cpp imgui_draw.cpp imgui_internal.h that you need to add to your project.[m
[32m+[m[32m - 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason[m
[32m+[m[32m - 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.[m
[32m+[m[32m                       you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.[m
[32m+[m[32m - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.[m
[32m+[m[32m                       this necessary change will break your rendering function! the fix should be very easy. sorry for that :([m
[32m+[m[32m                     - if you are using a vanilla copy of one of the imgui_impl_XXXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.[m
[32m+[m[32m                     - the signature of the io.RenderDrawListsFn handler has changed![m
[32m+[m[32m                       old: ImGui_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)[m
[32m+[m[32m                       new: ImGui_XXXX_RenderDrawLists(ImDrawData* draw_data).[m
[32m+[m[32m                         parameters: 'cmd_lists' becomes 'draw_data->CmdLists', 'cmd_lists_count' becomes 'draw_data->CmdListsCount'[m
[32m+[m[32m                         ImDrawList: 'commands' becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.[m
[32m+[m[32m                         ImDrawCmd:  'vtx_count' becomes 'ElemCount', 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback', 'texture_id' becomes 'TextureId'.[m
[32m+[m[32m                     - each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.[m
[32m+[m[32m                     - if you REALLY cannot render indexed primitives, you can call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering![m
[32m+[m[32m                     - refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade![m
[32m+[m[32m - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.[m
[32m+[m[32m - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).[m
[32m+[m[32m - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.[m
[32m+[m[32m - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence[m
[32m+[m[32m - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely be used. Sorry![m
[32m+[m[32m - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).[m
[32m+[m[32m - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).[m
[32m+[m[32m - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.[m
[32m+[m[32m - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. ImGui needs to manage the open/closed state of popups. Call OpenPopup() to actually set the "open" state of a popup. BeginPopup() returns true if the popup is opened.[m
[32m+[m[32m - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).[m
[32m+[m[32m - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.[m
[32m+[m[32m - 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API[m
[32m+[m[32m - 2015/04/03 (1.38) - removed ImGuiCol_CheckHovered, ImGuiCol_CheckActive, replaced with the more general ImGuiCol_FrameBgHovered, ImGuiCol_FrameBgActive.[m
[32m+[m[32m - 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.[m
[32m+[m[32m - 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.[m
[32m+[m[32m - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, ImGuiStyleVar_TreeNodeSpacing to ImGuiStyleVar_IndentSpacing[m
[32m+[m[32m - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.[m
[32m+[m[32m - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)[m
[32m+[m[32m - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, ImGuiSetCond). Kept inline redirection function until 1.50.[m
[32m+[m[32m - 2015/02/27 (1.34) - renamed ImGuiSetCondition_*** to ImGuiSetCond_***, and _FirstUseThisSession becomes _Once.[m
[32m+[m[32m - 2015/02/11 (1.32) - changed text input callback ImGuiTextEditCallback return type from void-->int. reserved for future use, return 0 for now.[m
[32m+[m[32m - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior[m
[32m+[m[32m - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()[m
[32m+[m[32m - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)[m
[32m+[m[32m - 2015/01/19 (1.30) - renamed ImGuiStorage::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage functions.[m
[32m+[m[32m - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.[m
[32m+[m[32m              (1.30) - removed GetDefaultFontData(). uses io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.[m
[32m+[m[32m                       font init:  { const void* png_data; unsigned int png_size; ImGui::GetDefaultFontData(NULL, NULL, &png_data, &png_size); <..Upload texture to GPU..>; }[m
[32m+[m[32m                       became:     { unsigned char* pixels; int width, height; io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); <..Upload texture to GPU>; io.Fonts->TexId = YourTextureIdentifier; }[m
[32m+[m[32m                       you now have more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs.[m
[32m+[m[32m                       it is now recommended that you sample the font texture with bilinear interpolation.[m
[32m+[m[32m              (1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to set io.Fonts->TexID.[m
[32m+[m[32m              (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)[m
[32m+[m[32m              (1.30) - removed ImGui::IsItemFocused() in favor of ImGui::IsItemActive() which handles all widgets[m
[32m+[m[32m - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, ImGuiSetCondition_FirstUseEver)[m
[32m+[m[32m - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)[m
[32m+[m[32m - 2014/11/26 (1.17) - reworked syntax of IMGUI_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility[m
[32m+[m[32m - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()[m
[32m+[m[32m - 2014/10/02 (1.14) - renamed IMGUI_INCLUDE_IMGUI_USER_CPP to IMGUI_INCLUDE_IMGUI_USER_INL and imgui_user.cpp to imgui_user.inl (more IDE friendly)[m
[32m+[m[32m - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)[m
[32m+[m[32m - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()[m
[32m+[m[32m - 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn[m
[32m+[m[32m - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)[m
[32m+[m[32m - 2014/08/30 (1.09) - moved IMGUI_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite[m
[32m+[m[32m - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes[m
[32m+[m
[32m+[m
[32m+[m[32m FREQUENTLY ASKED QUESTIONS (FAQ), TIPS[m
[32m+[m[32m ======================================[m
[32m+[m
[32m+[m[32m Q: Where is the documentation?[m
[32m+[m[32m A: This library is poorly documented at the moment and expects of the user to be acquainted with C/C++.[m
[32m+[m[32m    - Run the examples/ and explore them.[m
[32m+[m[32m    - See demo code in imgui_demo.cpp and particularly the ImGui::ShowDemoWindow() function.[m[41m [m
[32m+[m[32m    - The demo covers most features of Dear ImGui, so you can read the code and see its output.[m[41m [m
[32m+[m[32m    - See documentation and comments at the top of imgui.cpp + effectively imgui.h.[m
[32m+[m[32m    - Dozens of standalone example applications using e.g. OpenGL/DirectX are provided in the examples/[m[41m [m
[32m+[m[32m      folder to explain how to integrate Dear ImGui with your own engine/application.[m
[32m+[m[32m    - Your programming IDE is your friend, find the type or function declaration to find comments[m[41m [m
[32m+[m[32m      associated to it.[m
[32m+[m
[32m+[m[32m Q: Which version should I get?[m
[32m+[m[32m A: I occasionally tag Releases (https://github.com/ocornut/imgui/releases) but it is generally safe[m[41m [m
[32m+[m[32m    and recommended to sync to master/latest. The library is fairly stable and regressions tend to be[m[41m [m
[32m+[m[32m    fixed fast when reported. You may also peak at the 'docking' branch which includes:[m
[32m+[m[32m    - Docking/Merging features (https://github.com/ocornut/imgui/issues/2109)[m
[32m+[m[32m    - Multi-viewport features (https://github.com/ocornut/imgui/issues/1542)[m
[32m+[m[32m    Many projects are using this branch and it is kept in sync with master regularly.[m
[32m+[m
[32m+[m[32m Q: Who uses Dear ImGui?[m
[32m+[m[32m A: See "Quotes" (https://github.com/ocornut/imgui/wiki/Quotes) and[m
[32m+[m[32m    "Software using Dear ImGui" (https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui) Wiki pages[m
[32m+[m[32m    for a list of games/software which are publicly known to use dear imgui. Please add yours if you can![m
[32m+[m
[32m+[m[32m Q: Why the odd dual naming, "Dear ImGui" vs "ImGui"?[m
[32m+[m[32m A: The library started its life as "ImGui" due to the fact that I didn't give it a proper name when[m[41m [m
[32m+[m[32m    when I released 1.0, and had no particular expectation that it would take off. However, the term IMGUI[m[41m [m
[32m+[m[32m    (immediate-mode graphical user interface) was coined before and is being used in variety of other[m[41m [m
[32m+[m[32m    situations (e.g. Unity uses it own implementation of the IMGUI paradigm).[m[41m [m
[32m+[m[32m    To reduce the ambiguity without affecting existing code bases, I have decided on an alternate,[m[41m [m
[32m+[m[32m    longer name "Dear ImGui" that people can use to refer to this specific library.[m
[32m+[m[32m    Please try to refer to this library as "Dear ImGui".[m
[32m+[m
[32m+[m[32m Q: How can I tell whether to dispatch mouse/keyboard to imgui or to my application?[m
[32m+[m[32m A: You can read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags from the ImGuiIO structure (e.g. if (ImGui::GetIO().WantCaptureMouse) { ... } )[m
[32m+[m[32m    - When 'io.WantCaptureMouse' is set, imgui wants to use your mouse state, and you may want to discard/hide the inputs from the rest of your application.[m
[32m+[m[32m    - When 'io.WantCaptureKeyboard' is set, imgui wants to use your keyboard state, and you may want to discard/hide the inputs from the rest of your application.[m
[32m+[m[32m    - When 'io.WantTextInput' is set to may want to notify your OS to popup an on-screen keyboard, if available (e.g. on a mobile phone, or console OS).[m
[32m+[m[32m    Note: you should always pass your mouse/keyboard inputs to imgui, even when the io.WantCaptureXXX flag are set false.[m
[32m+[m[32m     This is because imgui needs to detect that you clicked in the void to unfocus its own windows.[m
[32m+[m[32m    Note: The 'io.WantCaptureMouse' is more accurate that any attempt to "check if the mouse is hovering a window" (don't do that!).[m
[32m+[m[32m     It handle mouse dragging correctly (both dragging that started over your application or over an imgui window) and handle e.g. modal windows blocking inputs.[m
[32m+[m[32m     Those flags are updated by ImGui::NewFrame(). Preferably read the flags after calling NewFrame() if you can afford it, but reading them before is also[m
[32m+[m[32m     perfectly fine, as the bool toggle fairly rarely. If you have on a touch device, you might find use for an early call to UpdateHoveredWindowAndCaptureFlags().[m
[32m+[m[32m    Note: Text input widget releases focus on "Return KeyDown", so the subsequent "Return KeyUp" event that your application receive will typically[m
[32m+[m[32m     have 'io.WantCaptureKeyboard=false'. Depending on your application logic it may or not be inconvenient. You might want to track which key-downs[m
[32m+[m[32m     were targeted for Dear ImGui, e.g. with an array of bool, and filter out the corresponding key-ups.)[m
[32m+[m
[32m+[m[32m Q: How can I display an image? What is ImTextureID, how does it works?[m
[32m+[m[32m A: Short explanation:[m
[32m+[m[32m    - You may use functions such as ImGui::Image(), ImGui::ImageButton() or lower-level ImDrawList::AddImage() to emit draw calls that will use your own textures.[m
[32m+[m[32m    - Actual textures are identified in a way that is up to the user/engine. Those identifiers are stored and passed as ImTextureID (void*) value.[m
[32m+[m[32m    - Loading image files from the disk and turning them into a texture is not within the scope of Dear ImGui (for a good reason).[m
[32m+[m[32m      Please read documentations or tutorials on your graphics API to understand how to display textures on the screen before moving onward.[m
[32m+[m
[32m+[m[32m    Long explanation:[m
[32m+[m[32m    - Dear ImGui's job is to create "meshes", defined in a renderer-agnostic format made of draw commands and vertices.[m
[32m+[m[32m      At the end of the frame those meshes (ImDrawList) will be displayed by your rendering function. They are made up of textured polygons and the code[m
[32m+[m[32m      to render them is generally fairly short (a few dozen lines). In the examples/ folder we provide functions for popular graphics API (OpenGL, DirectX, etc.).[m
[32m+[m[32m    - Each rendering function decides on a data type to represent "textures". The concept of what is a "texture" is entirely tied to your underlying engine/graphics API.[m
[32m+[m[32m      We carry the information to identify a "texture" in the ImTextureID type.[m
[32m+[m[32m      ImTextureID is nothing more that a void*, aka 4/8 bytes worth of data: just enough to store 1 pointer or 1 integer of your choice.[m
[32m+[m[32m      Dear ImGui doesn't know or understand what you are storing in ImTextureID, it merely pass ImTextureID values until they reach your rendering function.[m
[32m+[m[32m    - In the examples/ bindings, for each graphics API binding we decided on a type that is likely to be a good representation for specifying[m
[32m+[m[32m      an image from the end-user perspective. This is what the _examples_ rendering functions are using:[m
[32m+[m
[32m+[m[32m         OpenGL:     ImTextureID = GLuint                       (see ImGui_ImplGlfwGL3_RenderDrawData() function in imgui_impl_glfw_gl3.cpp)[m
[32m+[m[32m         DirectX9:   ImTextureID = LPDIRECT3DTEXTURE9           (see ImGui_ImplDX9_RenderDrawData()     function in imgui_impl_dx9.cpp)[m
[32m+[m[32m         DirectX11:  ImTextureID = ID3D11ShaderResourceView*    (see ImGui_ImplDX11_RenderDrawData()    function in imgui_impl_dx11.cpp)[m
[32m+[m[32m         DirectX12:  ImTextureID = D3D12_GPU_DESCRIPTOR_HANDLE  (see ImGui_ImplDX12_RenderDrawData()    function in imgui_impl_dx12.cpp)[m
[32m+[m
[32m+[m[32m      For example, in the OpenGL example binding we store raw OpenGL texture identifier (GLuint) inside ImTextureID.[m
[32m+[m[32m      Whereas in the DirectX11 example binding we store a pointer to ID3D11ShaderResourceView inside ImTextureID, which is a higher-level structure[m
[32m+[m[32m      tying together both the texture and information about its format and how to read it.[m
[32m+[m[32m    - If you have a custom engine built over e.g. OpenGL, instead of passing GLuint around you may decide to use a high-level data type to carry information about[m
[32m+[m[32m      the texture as well as how to display it (shaders, etc.). The decision of what to use as ImTextureID can always be made better knowing how your codebase[m
[32m+[m[32m      is designed. If your engine has high-level data types for "textures" and "material" then you may want to use them.[m
[32m+[m[32m      If you are starting with OpenGL or DirectX or Vulkan and haven't built much of a rendering engine over them, keeping the default ImTextureID[m
[32m+[m[32m      representation suggested by the example bindings is probably the best choice.[m
[32m+[m[32m      (Advanced users may also decide to keep a low-level type in ImTextureID, and use ImDrawList callback and pass information to their renderer)[m
[32m+[m
[32m+[m[32m    User code may do:[m
[32m+[m
[32m+[m[32m        // Cast our texture type to ImTextureID / void*[m
[32m+[m[32m        MyTexture* texture = g_CoffeeTableTexture;[m
[32m+[m[32m        ImGui::Image((void*)texture, ImVec2(texture->Width, texture->Height));[m
[32m+[m
[32m+[m[32m    The renderer function called after ImGui::Render() will receive that same value that the user code passed:[m
[32m+[m
[32m+[m[32m        // Cast ImTextureID / void* stored in the draw command as our texture type[m
[32m+[m[32m        MyTexture* texture = (MyTexture*)pcmd->TextureId;[m
[32m+[m[32m        MyEngineBindTexture2D(texture);[m
[32m+[m
[32m+[m[32m    Once you understand this design you will understand that loading image files and turning them into displayable textures is not within the scope of Dear ImGui.[m
[32m+[m[32m    This is by design and is actually a good thing, because it means your code has full control over your data types and how you display them.[m
[32m+[m[32m    If you want to display an image file (e.g. PNG file) into the screen, please refer to documentation and tutorials for the graphics API you are using.[m
[32m+[m
[32m+[m[32m    Here's a simplified OpenGL example using stb_image.h:[m
[32m+[m
[32m+[m[32m        // Use stb_image.h to load a PNG from disk and turn it into raw RGBA pixel data:[m
[32m+[m[32m        #define STB_IMAGE_IMPLEMENTATION[m
[32m+[m[32m        #include <stb_image.h>[m
[32m+[m[32m        [...][m
[32m+[m[32m        int my_image_width, my_image_height;[m
[32m+[m[32m        unsigned char* my_image_data = stbi_load("my_image.png", &my_image_width, &my_image_height, NULL, 4);[m
[32m+[m
[32m+[m[32m        // Turn the RGBA pixel data into an OpenGL texture:[m
[32m+[m[32m        GLuint my_opengl_texture;[m
[32m+[m[32m        glGenTextures(1, &my_opengl_texture);[m
[32m+[m[32m        glBindTexture(GL_TEXTURE_2D, my_opengl_texture);[m
[32m+[m[32m        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);[m
[32m+[m[32m        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);[m
[32m+[m[32m        glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);[m
[32m+[m[32m        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image_width, image_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image_data);[m
[32m+[m
[32m+[m[32m        // Now that we have an OpenGL texture, assuming our imgui rendering function (imgui_impl_xxx.cpp file) takes GLuint as ImTextureID, we can display it:[m
[32m+[m[32m        ImGui::Image((void*)(intptr_t)my_opengl_texture, ImVec2(my_image_width, my_image_height));[m
[32m+[m
[32m+[m[32m    C/C++ tip: a void* is pointer-sized storage. You may safely store any pointer or integer into it by casting your value to ImTextureID / void*, and vice-versa.[m
[32m+[m[32m    Because both end-points (user code and rendering function) are under your control, you know exactly what is stored inside the ImTextureID / void*.[m
[32m+[m[32m    Examples:[m
[32m+[m
[32m+[m[32m        GLuint my_tex = XXX;[m
[32m+[m[32m        void* my_void_ptr;[m
[32m+[m[32m        my_void_ptr = (void*)(intptr_t)my_tex;                  // cast a GLuint into a void* (we don't take its address! we literally store the value inside the pointer)[m
[32m+[m[32m        my_tex = (GLuint)(intptr_t)my_void_ptr;                 // cast a void* into a GLuint[m
[32m+[m
[32m+[m[32m        ID3D11ShaderResourceView* my_dx11_srv = XXX;[m
[32m+[m[32m        void* my_void_ptr;[m
[32m+[m[32m        my_void_ptr = (void*)my_dx11_srv;                       // cast a ID3D11ShaderResourceView* into an opaque void*[m
[32m+[m[32m        my_dx11_srv = (ID3D11ShaderResourceView*)my_void_ptr;   // cast a void* into a ID3D11ShaderResourceView*[m
[32m+[m
[32m+[m[32m    Finally, you may call ImGui::ShowMetricsWindow() to explore/visualize/understand how the ImDrawList are generated.[m
[32m+[m
[32m+[m[32m Q: Why are multiple widgets reacting when I interact with a single one?[m
[32m+[m[32m Q: How can I have multiple widgets with the same label or with an empty label?[m
[32m+[m[32m A: A primer on labels and the ID Stack...[m
[32m+[m
[32m+[m[32m    Dear ImGui internally need to uniquely identify UI elements.[m
[32m+[m[32m    Elements that are typically not clickable (such as calls to the Text functions) don't need an ID.[m
[32m+[m[32m    Interactive widgets (such as calls to Button buttons) need a unique ID.[m
[32m+[m[32m    Unique ID are used internally to track active widgets and occasionally associate state to widgets.[m
[32m+[m[32m    Unique ID are implicitly built from the hash of multiple elements that identify the "path" to the UI element.[m
[32m+[m
[32m+[m[32m   - Unique ID are often derived from a string label:[m
[32m+[m
[32m+[m[32m       Button("OK");          // Label = "OK",     ID = hash of (..., "OK")[m
[32m+[m[32m       Button("Cancel");      // Label = "Cancel", ID = hash of (..., "Cancel")[m
[32m+[m
[32m+[m[32m   - ID are uniquely scoped within windows, tree nodes, etc. which all pushes to the ID stack. Having[m
[32m+[m[32m     two buttons labeled "OK" in different windows or different tree locations is fine.[m
[32m+[m[32m     We used "..." above to signify whatever was already pushed to the ID stack previously:[m
[32m+[m
[32m+[m[32m       Begin("MyWindow");[m
[32m+[m[32m       Button("OK");          // Label = "OK",     ID = hash of ("MyWindow", "OK")[m
[32m+[m[32m       End();[m
[32m+[m[32m       Begin("MyOtherWindow");[m
[32m+[m[32m       Button("OK");          // Label = "OK",     ID = hash of ("MyOtherWindow", "OK")[m
[32m+[m[32m       End();[m
[32m+[m
[32m+[m[32m   - If you have a same ID twice in the same location, you'll have a conflict:[m
[32m+[m
[32m+[m[32m       Button("OK");[m
[32m+[m[32m       Button("OK");          // ID collision! Interacting with either button will trigger the first one.[m
[32m+[m
[32m+[m[32m     Fear not! this is easy to solve and there are many ways to solve it![m
[32m+[m
[32m+[m[32m   - Solving ID conflict in a simple/local context:[m
[32m+[m[32m     When passing a label you can optionally specify extra ID information within string itself.[m
[32m+[m[32m     Use "##" to pass a complement to the ID that won't be visible to the end-user.[m
[32m+[m[32m     This helps solving the simple collision cases when you know e.g. at compilation time which items[m
[32m+[m[32m     are going to be created:[m
[32m+[m
[32m+[m[32m       Begin("MyWindow");[m
[32m+[m[32m       Button("Play");        // Label = "Play",   ID = hash of ("MyWindow", "Play")[m
[32m+[m[32m       Button("Play##foo1");  // Label = "Play",   ID = hash of ("MyWindow", "Play##foo1")  // Different from above[m
[32m+[m[32m       Button("Play##foo2");  // Label = "Play",   ID = hash of ("MyWindow", "Play##foo2")  // Different from above[m
[32m+[m[32m       End();[m
[32m+[m
[32m+[m[32m   - If you want to completely hide the label, but still need an ID:[m
[32m+[m
[32m+[m[32m       Checkbox("##On", &b);  // Label = "",       ID = hash of (..., "##On")   // No visible label, just a checkbox![m
[32m+[m
[32m+[m[32m   - Occasionally/rarely you might want change a label while preserving a constant ID. This allows[m
[32m+[m[32m     you to animate labels. For example you may want to include varying information in a window title bar,[m
[32m+[m[32m     but windows are uniquely identified by their ID. Use "###" to pass a label that isn't part of ID:[m
[32m+[m
[32m+[m[32m       Button("Hello###ID");  // Label = "Hello",  ID = hash of (..., "###ID")[m
[32m+[m[32m       Button("World###ID");  // Label = "World",  ID = hash of (..., "###ID")  // Same as above, even though the label looks different[m
[32m+[m
[32m+[m[32m       sprintf(buf, "My game (%f FPS)###MyGame", fps);[m
[32m+[m[32m       Begin(buf);            // Variable title,   ID = hash of "MyGame"[m
[32m+[m
[32m+[m[32m   - Solving ID conflict in a more general manner:[m
[32m+[m[32m     Use PushID() / PopID() to create scopes and manipulate the ID stack, as to avoid ID conflicts[m
[32m+[m[32m     within the same window. This is the most convenient way of distinguishing ID when iterating and[m
[32m+[m[32m     creating many UI elements programmatically.[m
[32m+[m[32m     You can push a pointer, a string or an integer value into the ID stack.[m
[32m+[m[32m     Remember that ID are formed from the concatenation of _everything_ pushed into the ID stack.[m
[32m+[m[32m     At each level of the stack we store the seed used for items at this level of the ID stack.[m
[32m+[m
[32m+[m[32m     Begin("Window");[m
[32m+[m[32m       for (int i = 0; i < 100; i++)[m
[32m+[m[32m       {[m
[32m+[m[32m         PushID(i);           // Push i to the id tack[m
[32m+[m[32m         Button("Click");     // Label = "Click",  ID = hash of ("Window", i, "Click")[m
[32m+[m[32m         PopID();[m
[32m+[m[32m       }[m
[32m+[m[32m       for (int i = 0; i < 100; i++)[m
[32m+[m[32m       {[m
[32m+[m[32m         MyObject* obj = Objects[i];[m
[32m+[m[32m         PushID(obj);[m
[32m+[m[32m         Button("Click");     // Label = "Click",  ID = hash of ("Window", obj pointer, "Click")[m
[32m+[m[32m         PopID();[m
[32m+[m[32m       }[m
[32m+[m[32m       for (int i = 0; i < 100; i++)[m
[32m+[m[32m       {[m
[32m+[m[32m         MyObject* obj = Objects[i];[m
[32m+[m[32m         PushID(obj->Name);[m
[32m+[m[32m         Button("Click");     // Label = "Click",  ID = hash of ("Window", obj->Name, "Click")[m
[32m+[m[32m         PopID();[m
[32m+[m[32m       }[m
[32m+[m[32m       End();[m
[32m+[m
[32m+[m[32m   - You can stack multiple prefixes into the ID stack:[m
[32m+[m
[32m+[m[32m       Button("Click");       // Label = "Click",  ID = hash of (..., "Click")[m
[32m+[m[32m       PushID("node");[m
[32m+[m[32m       Button("Click");       // Label = "Click",  ID = hash of (..., "node", "Click")[m
[32m+[m[32m         PushID(my_ptr);[m
[32m+[m[32m           Button("Click");   // Label = "Click",  ID = hash of (..., "node", my_ptr, "Click")[m
[32m+[m[32m         PopID();[m
[32m+[m[32m       PopID();[m
[32m+[m
[32m+[m[32m   - Tree nodes implicitly creates a scope for you by calling PushID().[m
[32m+[m
[32m+[m[32m       Button("Click");       // Label = "Click",  ID = hash of (..., "Click")[m
[32m+[m[32m       if (TreeNode("node"))  // <-- this function call will do a PushID() for you (unless instructed not to, with a special flag)[m
[32m+[m[32m       {[m
[32m+[m[32m         Button("Click");     // Label = "Click",  ID = hash of (..., "node", "Click")[m
[32m+[m[32m         TreePop();[m
[32m+[m[32m       }[m
[32m+[m
[32m+[m[32m   - When working with trees, ID are used to preserve the open/close state of each tree node.[m
[32m+[m[32m     Depending on your use cases you may want to use strings, indices or pointers as ID.[m
[32m+[m[32m      e.g. when following a single pointer that may change over time, using a static string as ID[m
[32m+[m[32m       will preserve your node open/closed state when the targeted object change.[m
[32m+[m[32m      e.g. when displaying a list of objects, using indices or pointers as ID will preserve the[m
[32m+[m[32m       node open/closed state differently. See what makes more sense in your situation![m
[32m+[m
[32m+[m[32m Q: How can I use my own math types instead of ImVec2/ImVec4?[m
[32m+[m[32m A: You can edit imconfig.h and setup the IM_VEC2_CLASS_EXTRA/IM_VEC4_CLASS_EXTRA macros to add implicit type conversions.[m
[32m+[m[32m    This way you'll be able to use your own types everywhere, e.g. passing glm::vec2 to ImGui functions instead of ImVec2.[m
[32m+[m
[32m+[m[32m Q: How can I load a different font than the default?[m
[32m+[m[32m A: Use the font atlas to load the TTF/OTF file you want:[m
[32m+[m[32m      ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels);[m
[32m+[m[32m      io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()[m
[32m+[m[32m    Default is ProggyClean.ttf, monospace, rendered at size 13, embedded in dear imgui's source code.[m
[32m+[m[32m    (Tip: monospace fonts are convenient because they allow to facilitate horizontal alignment directly at the string level.)[m
[32m+[m[32m    (Read the 'misc/fonts/README.txt' file for more details about font loading.)[m
[32m+[m
[32m+[m[32m    New programmers: remember that in C/C++ and most programming languages if you want to use a[m
[32m+[m[32m    backslash \ within a string literal, you need to write it double backslash "\\":[m
[32m+[m[32m      io.Fonts->AddFontFromFileTTF("MyDataFolder\MyFontFile.ttf", size_in_pixels);   // WRONG (you are escape the M here!)[m
[32m+[m[32m      io.Fonts->AddFontFromFileTTF("MyDataFolder\\MyFontFile.ttf", size_in_pixels);  // CORRECT[m
[32m+[m[32m      io.Fonts->AddFontFromFileTTF("MyDataFolder/MyFontFile.ttf", size_in_pixels);   // ALSO CORRECT[m
[32m+[m
[32m+[m[32m Q: How can I easily use icons in my application?[m
[32m+[m[32m A: The most convenient and practical way is to merge an icon font such as FontAwesome inside you[m
[32m+[m[32m    main font. Then you can refer to icons within your strings.[m
[32m+[m[32m    You may want to see ImFontConfig::GlyphMinAdvanceX to make your icon look monospace to facilitate alignment.[m
[32m+[m[32m    (Read the 'misc/fonts/README.txt' file for more details about icons font loading.)[m
[32m+[m
[32m+[m[32m Q: How can I load multiple fonts?[m
[32m+[m[32m A: Use the font atlas to pack them into a single texture:[m
[32m+[m[32m    (Read the 'misc/fonts/README.txt' file and the code in ImFontAtlas for more details.)[m
[32m+[m
[32m+[m[32m      ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m      ImFont* font0 = io.Fonts->AddFontDefault();[m
[32m+[m[32m      ImFont* font1 = io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels);[m
[32m+[m[32m      ImFont* font2 = io.Fonts->AddFontFromFileTTF("myfontfile2.ttf", size_in_pixels);[m
[32m+[m[32m      io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()[m
[32m+[m[32m      // the first loaded font gets used by default[m
[32m+[m[32m      // use ImGui::PushFont()/ImGui::PopFont() to change the font at runtime[m
[32m+[m
[32m+[m[32m      // Options[m
[32m+[m[32m      ImFontConfig config;[m
[32m+[m[32m      config.OversampleH = 2;[m
[32m+[m[32m      config.OversampleV = 1;[m
[32m+[m[32m      config.GlyphOffset.y -= 1.0f;      // Move everything by 1 pixels up[m
[32m+[m[32m      config.GlyphExtraSpacing.x = 1.0f; // Increase spacing between characters[m
[32m+[m[32m      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_pixels, &config);[m
[32m+[m
[32m+[m[32m      // Combine multiple fonts into one (e.g. for icon fonts)[m
[32m+[m[32m      static ImWchar ranges[] = { 0xf000, 0xf3ff, 0 };[m
[32m+[m[32m      ImFontConfig config;[m
[32m+[m[32m      config.MergeMode = true;[m
[32m+[m[32m      io.Fonts->AddFontDefault();[m
[32m+[m[32m      io.Fonts->AddFontFromFileTTF("fontawesome-webfont.ttf", 16.0f, &config, ranges); // Merge icon font[m
[32m+[m[32m      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_pixels, NULL, &config, io.Fonts->GetGlyphRangesJapanese()); // Merge japanese glyphs[m
[32m+[m
[32m+[m[32m Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?[m
[32m+[m[32m A: When loading a font, pass custom Unicode ranges to specify the glyphs to load.[m
[32m+[m
[32m+[m[32m      // Add default Japanese ranges[m
[32m+[m[32m      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels, NULL, io.Fonts->GetGlyphRangesJapanese());[m
[32m+[m
[32m+[m[32m      // Or create your own custom ranges (e.g. for a game you can feed your entire game script and only build the characters the game need)[m
[32m+[m[32m      ImVector<ImWchar> ranges;[m
[32m+[m[32m      ImFontGlyphRangesBuilder builder;[m
[32m+[m[32m      builder.AddText("Hello world");                        // Add a string (here "Hello world" contains 7 unique characters)[m
[32m+[m[32m      builder.AddChar(0x7262);                               // Add a specific character[m
[32m+[m[32m      builder.AddRanges(io.Fonts->GetGlyphRangesJapanese()); // Add one of the default ranges[m
[32m+[m[32m      builder.BuildRanges(&ranges);                          // Build the final result (ordered ranges with all the unique characters submitted)[m
[32m+[m[32m      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels, NULL, ranges.Data);[m
[32m+[m
[32m+[m[32m    All your strings needs to use UTF-8 encoding. In C++11 you can encode a string literal in UTF-8[m
[32m+[m[32m    by using the u8"hello" syntax. Specifying literal in your source code using a local code page[m
[32m+[m[32m    (such as CP-923 for Japanese or CP-1251 for Cyrillic) will NOT work![m
[32m+[m[32m    Otherwise you can convert yourself to UTF-8 or load text data from file already saved as UTF-8.[m
[32m+[m
[32m+[m[32m    Text input: it is up to your application to pass the right character code by calling io.AddInputCharacter().[m
[32m+[m[32m    The applications in examples/ are doing that.[m
[32m+[m[32m    Windows: you can use the WM_CHAR or WM_UNICHAR or WM_IME_CHAR message (depending if your app is built using Unicode or MultiByte mode).[m
[32m+[m[32m    You may also use MultiByteToWideChar() or ToUnicode() to retrieve Unicode codepoints from MultiByte characters or keyboard state.[m
[32m+[m[32m    Windows: if your language is relying on an Input Method Editor (IME), you copy the HWND of your window to io.ImeWindowHandle in order for[m
[32m+[m[32m    the default implementation of io.ImeSetInputScreenPosFn() to set your Microsoft IME position correctly.[m
[32m+[m
[32m+[m[32m Q: How can I interact with standard C++ types (such as std::string and std::vector)?[m
[32m+[m[32m A: - Being highly portable (bindings for several languages, frameworks, programming style, obscure or older platforms/compilers),[m
[32m+[m[32m      and aiming for compatibility & performance suitable for every modern real-time game engines, dear imgui does not use[m
[32m+[m[32m      any of std C++ types. We use raw types (e.g. char* instead of std::string) because they adapt to more use cases.[m
[32m+[m[32m    - To use ImGui::InputText() with a std::string or any resizable string class, see misc/cpp/imgui_stdlib.h.[m
[32m+[m[32m    - To use combo boxes and list boxes with std::vector or any other data structure: the BeginCombo()/EndCombo() API[m
[32m+[m[32m      lets you iterate and submit items yourself, so does the ListBoxHeader()/ListBoxFooter() API.[m
[32m+[m[32m      Prefer using them over the old and awkward Combo()/ListBox() api.[m
[32m+[m[32m    - Generally for most high-level types you should be able to access the underlying data type.[m
[32m+[m[32m      You may write your own one-liner wrappers to facilitate user code (tip: add new functions in ImGui:: namespace from your code).[m
[32m+[m[32m    - Dear ImGui applications often need to make intensive use of strings. It is expected that many of the strings you will pass[m
[32m+[m[32m      to the API are raw literals (free in C/C++) or allocated in a manner that won't incur a large cost on your application.[m
[32m+[m[32m      Please bear in mind that using std::string on applications with large amount of UI may incur unsatisfactory performances.[m
[32m+[m[32m      Modern implementations of std::string often include small-string optimization (which is often a local buffer) but those[m
[32m+[m[32m      are not configurable and not the same across implementations.[m
[32m+[m[32m    - If you are finding your UI traversal cost to be too large, make sure your string usage is not leading to excessive amount[m
[32m+[m[32m      of heap allocations. Consider using literals, statically sized buffers and your own helper functions. A common pattern[m
[32m+[m[32m      is that you will need to build lots of strings on the fly, and their maximum length can be easily be scoped ahead.[m
[32m+[m[32m      One possible implementation of a helper to facilitate printf-style building of strings: https://github.com/ocornut/Str[m
[32m+[m[32m      This is a small helper where you can instance strings with configurable local buffers length. Many game engines will[m
[32m+[m[32m      provide similar or better string helpers.[m
[32m+[m
[32m+[m[32m Q: How can I use the drawing facilities without an ImGui window? (using ImDrawList API)[m
[32m+[m[32m A: - You can create a dummy window. Call Begin() with the NoBackground | NoDecoration | NoSavedSettings | NoInputs flags.[m
[32m+[m[32m      (The ImGuiWindowFlags_NoDecoration flag itself is a shortcut for NoTitleBar | NoResize | NoScrollbar | NoCollapse)[m
[32m+[m[32m      Then you can retrieve the ImDrawList* via GetWindowDrawList() and draw to it in any way you like.[m
[32m+[m[32m    - You can call ImGui::GetBackgroundDrawList() or ImGui::GetForegroundDrawList() and use those draw list to display[m
[32m+[m[32m      contents behind or over every other imgui windows (one bg/fg drawlist per viewport).[m
[32m+[m[32m    - You can create your own ImDrawList instance. You'll need to initialize them ImGui::GetDrawListSharedData(), or create[m
[32m+[m[32m      your own ImDrawListSharedData, and then call your rendered code with your own ImDrawList or ImDrawData data.[m
[32m+[m
[32m+[m[32m Q: How can I use this without a mouse, without a keyboard or without a screen? (gamepad, input share, remote display)[m
[32m+[m[32m A: - You can control Dear ImGui with a gamepad. Read about navigation in "Using gamepad/keyboard navigation controls".[m
[32m+[m[32m      (short version: map gamepad inputs into the io.NavInputs[] array + set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad)[m
[32m+[m[32m    - You can share your computer mouse seamlessly with your console/tablet/phone using Synergy (https://symless.com/synergy)[m
[32m+[m[32m      This is the preferred solution for developer productivity.[m
[32m+[m[32m      In particular, the "micro-synergy-client" repository (https://github.com/symless/micro-synergy-client) has simple[m
[32m+[m[32m      and portable source code (uSynergy.c/.h) for a small embeddable client that you can use on any platform to connect[m
[32m+[m[32m      to your host computer, based on the Synergy 1.x protocol. Make sure you download the Synergy 1 server on your computer.[m
[32m+[m[32m      Console SDK also sometimes provide equivalent tooling or wrapper for Synergy-like protocols.[m
[32m+[m[32m    - You may also use a third party solution such as Remote ImGui (https://github.com/JordiRos/remoteimgui) which sends[m
[32m+[m[32m      the vertices to render over the local network, allowing you to use Dear ImGui even on a screen-less machine.[m
[32m+[m[32m    - For touch inputs, you can increase the hit box of widgets (via the style.TouchPadding setting) to accommodate[m
[32m+[m[32m      for the lack of precision of touch inputs, but it is recommended you use a mouse or gamepad to allow optimizing[m
[32m+[m[32m      for screen real-estate and precision.[m
[32m+[m
[32m+[m[32m Q: I integrated Dear ImGui in my engine and the text or lines are blurry..[m
[32m+[m[32m A: In your Render function, try translating your projection matrix by (0.5f,0.5f) or (0.375f,0.375f).[m
[32m+[m[32m    Also make sure your orthographic projection matrix and io.DisplaySize matches your actual framebuffer dimension.[m
[32m+[m
[32m+[m[32m Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..[m
[32m+[m[32m A: You are probably mishandling the clipping rectangles in your render function.[m
[32m+[m[32m    Rectangles provided by ImGui are defined as (x1=left,y1=top,x2=right,y2=bottom) and NOT as (x1,y1,width,height).[m
[32m+[m
[32m+[m[32m Q: How can I help?[m
[32m+[m[32m A: - If you are experienced with Dear ImGui and C++, look at the github issues, look at the Wiki, read docs/TODO.txt[m
[32m+[m[32m      and see how you want to help and can help![m
[32m+[m[32m    - Businesses: convince your company to fund development via support contracts/sponsoring! This is among the most useful thing you can do for dear imgui.[m
[32m+[m[32m    - Individuals: you can also become a Patron (http://www.patreon.com/imgui) or donate on PayPal! See README.[m
[32m+[m[32m    - Disclose your usage of dear imgui via a dev blog post, a tweet, a screenshot, a mention somewhere etc.[m
[32m+[m[32m      You may post screenshot or links in the gallery threads (github.com/ocornut/imgui/issues/1902). Visuals are ideal as they inspire other programmers.[m
[32m+[m[32m      But even without visuals, disclosing your use of dear imgui help the library grow credibility, and help other teams and programmers with taking decisions.[m
[32m+[m[32m    - If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues (on github or privately).[m
[32m+[m
[32m+[m[32m - tip: you can call Begin() multiple times with the same name during the same frame, it will keep appending to the same window.[m
[32m+[m[32m        this is also useful to set yourself in the context of another window (to get/set other settings)[m
[32m+[m[32m - tip: you can create widgets without a Begin()/End() block, they will go in an implicit window called "Debug".[m
[32m+[m[32m - tip: the ImGuiOnceUponAFrame helper will allow run the block of code only once a frame. You can use it to quickly add custom UI in the middle[m
[32m+[m[32m        of a deep nested inner loop in your code.[m
[32m+[m[32m - tip: you can call Render() multiple times (e.g for VR renders).[m
[32m+[m[32m - tip: call and read the ShowDemoWindow() code in imgui_demo.cpp for more example of how to use ImGui![m
[32m+[m
[32m+[m[32m*/[m
[32m+[m
[32m+[m[32m#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)[m
[32m+[m[32m#define _CRT_SECURE_NO_WARNINGS[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#include "imgui.h"[m
[32m+[m[32m#ifndef IMGUI_DEFINE_MATH_OPERATORS[m
[32m+[m[32m#define IMGUI_DEFINE_MATH_OPERATORS[m
[32m+[m[32m#endif[m
[32m+[m[32m#include "imgui_internal.h"[m
[32m+[m
[32m+[m[32m#include <ctype.h>      // toupper[m
[32m+[m[32m#include <stdio.h>      // vsnprintf, sscanf, printf[m
[32m+[m[32m#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier[m
[32m+[m[32m#include <stddef.h>     // intptr_t[m
[32m+[m[32m#else[m
[32m+[m[32m#include <stdint.h>     // intptr_t[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Debug options[m
[32m+[m[32m#define IMGUI_DEBUG_NAV_SCORING     0   // Display navigation scoring preview when hovering items. Display last moving direction matches when holding CTRL[m
[32m+[m[32m#define IMGUI_DEBUG_NAV_RECTS       0   // Display the reference navigation rectangle for each window[m
[32m+[m
[32m+[m[32m// Visual Studio warnings[m
[32m+[m[32m#ifdef _MSC_VER[m
[32m+[m[32m#pragma warning (disable: 4127)     // condition expression is constant[m
[32m+[m[32m#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Clang/GCC warnings with -Weverything[m
[32m+[m[32m#ifdef __clang__[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wunknown-pragmas"        // warning : unknown warning group '-Wformat-pedantic *'        // not all warnings are known by all clang versions.. so ignoring warnings triggers new warnings on some configuration. great![m
[32m+[m[32m#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants (typically 0.0f) is ok.[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wformat-nonliteral"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wexit-time-destructors"  // warning : declaration requires an exit-time destructor       // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wglobal-constructors"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference is.[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wformat-pedantic"        // warning : format specifies type 'void *' but the argument has type 'xxxx *' // unreasonable, would lead to casting every %p arg to void*. probably enabled by -pedantic.[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"       // warning : cast to 'void *' from smaller integer type 'int'[m
[32m+[m[32m#if __has_warning("-Wzero-as-null-pointer-constant")[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning : zero as null pointer constant              // some standard header variations use #define NULL 0[m
[32m+[m[32m#endif[m
[32m+[m[32m#if __has_warning("-Wdouble-promotion")[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wdouble-promotion"       // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.[m
[32m+[m[32m#endif[m
[32m+[m[32m#elif defined(__GNUC__)[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"      // warning: cast to pointer from integer of different size[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wformat"                   // warning: format '%p' expects argument of type 'void*', but argument 6 has type 'ImGuiWindow*'[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wformat-nonliteral"        // warning: format not a string literal, format string not checked[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wstrict-overflow"          // warning: assuming signed overflow does not occur when assuming that (X - c) > X is always false[m
[32m+[m[32m#if __GNUC__ >= 8[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wclass-memaccess"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead[m
[32m+[m[32m#endif[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// When using CTRL+TAB (or Gamepad Square+L/R) we delay the visual a little in order to reduce visual noise doing a fast switch.[m
[32m+[m[32mstatic const float NAV_WINDOWING_HIGHLIGHT_DELAY            = 0.20f;    // Time before the highlight and screen dimming starts fading in[m
[32m+[m[32mstatic const float NAV_WINDOWING_LIST_APPEAR_DELAY          = 0.15f;    // Time before the window list starts to appear[m
[32m+[m
[32m+[m[32m// Window resizing from edges (when io.ConfigWindowsResizeFromEdges = true and ImGuiBackendFlags_HasMouseCursors is set in io.BackendFlags by back-end)[m
[32m+[m[32mstatic const float WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS = 4.0f;     // Extend outside and inside windows. Affect FindHoveredWindow().[m
[32m+[m[32mstatic const float WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER = 0.04f;    // Reduce visual noise by only highlighting the border after a certain time.[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] FORWARD DECLARATIONS[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mstatic void             SetCurrentWindow(ImGuiWindow* window);[m
[32m+[m[32mstatic void             FindHoveredWindow();[m
[32m+[m[32mstatic ImGuiWindow*     CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags);[m
[32m+[m[32mstatic void             CheckStacksSize(ImGuiWindow* window, bool write);[m
[32m+[m[32mstatic ImVec2           CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window, bool snap_on_edges);[m
[32m+[m
[32m+[m[32mstatic void             AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list);[m
[32m+[m[32mstatic void             AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window);[m
[32m+[m
[32m+[m[32mstatic ImRect           GetViewportRect();[m
[32m+[m
[32m+[m[32m// Settings[m
[32m+[m[32mstatic void*            SettingsHandlerWindow_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name);[m
[32m+[m[32mstatic void             SettingsHandlerWindow_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line);[m
[32m+[m[32mstatic void             SettingsHandlerWindow_WriteAll(ImGuiContext* imgui_ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf);[m
[32m+[m
[32m+[m[32m// Platform Dependents default implementation for IO functions[m
[32m+[m[32mstatic const char*      GetClipboardTextFn_DefaultImpl(void* user_data);[m
[32m+[m[32mstatic void             SetClipboardTextFn_DefaultImpl(void* user_data, const char* text);[m
[32m+[m[32mstatic void             ImeSetInputScreenPosFn_DefaultImpl(int x, int y);[m
[32m+[m
[32m+[m[32mnamespace ImGui[m
[32m+[m[32m{[m
[32m+[m[32mstatic bool             BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags);[m
[32m+[m
[32m+[m[32m// Navigation[m
[32m+[m[32mstatic void             NavUpdate();[m
[32m+[m[32mstatic void             NavUpdateWindowing();[m
[32m+[m[32mstatic void             NavUpdateWindowingList();[m
[32m+[m[32mstatic void             NavUpdateMoveResult();[m
[32m+[m[32mstatic float            NavUpdatePageUpPageDown(int allowed_dir_flags);[m
[32m+[m[32mstatic inline void      NavUpdateAnyRequestFlag();[m
[32m+[m[32mstatic void             NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, ImGuiID id);[m
[32m+[m[32mstatic ImVec2           NavCalcPreferredRefPos();[m
[32m+[m[32mstatic void             NavSaveLastChildNavWindowIntoParent(ImGuiWindow* nav_window);[m
[32m+[m[32mstatic ImGuiWindow*     NavRestoreLastChildNavWindow(ImGuiWindow* window);[m
[32m+[m[32mstatic int              FindWindowFocusIndex(ImGuiWindow* window);[m
[32m+[m
[32m+[m[32m// Misc[m
[32m+[m[32mstatic void             UpdateMouseInputs();[m
[32m+[m[32mstatic void             UpdateMouseWheel();[m
[32m+[m[32mstatic void             UpdateManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4]);[m
[32m+[m[32mstatic void             RenderOuterBorders(ImGuiWindow* window);[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] CONTEXT AND MEMORY ALLOCATORS[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Current context pointer. Implicitly used by all Dear ImGui functions. Always assumed to be != NULL.[m
[32m+[m[32m// ImGui::CreateContext() will automatically set this pointer if it is NULL. Change to a different context by calling ImGui::SetCurrentContext().[m
[32m+[m[32m// 1) Important: globals are not shared across DLL boundaries! If you use DLLs or any form of hot-reloading: you will need to call[m
[32m+[m[32m//    SetCurrentContext() (with the pointer you got from CreateContext) from each unique static/DLL boundary, and after each hot-reloading.[m
[32m+[m[32m//    In your debugger, add GImGui to your watch window and notice how its value changes depending on which location you are currently stepping into.[m
[32m+[m[32m// 2) Important: Dear ImGui functions are not thread-safe because of this pointer.[m
[32m+[m[32m//    If you want thread-safety to allow N threads to access N different contexts, you can:[m
[32m+[m[32m//    - Change this variable to use thread local storage so each thread can refer to a different context, in imconfig.h:[m
[32m+[m[32m//          struct ImGuiContext;[m
[32m+[m[32m//          extern thread_local ImGuiContext* MyImGuiTLS;[m
[32m+[m[32m//          #define GImGui MyImGuiTLS[m
[32m+[m[32m//      And then define MyImGuiTLS in one of your cpp file. Note that thread_local is a C++11 keyword, earlier C++ uses compiler-specific keyword.[m
[32m+[m[32m//    - Future development aim to make this context pointer explicit to all calls. Also read https://github.com/ocornut/imgui/issues/586[m
[32m+[m[32m//    - If you need a finite number of contexts, you may compile and use multiple instances of the ImGui code from different namespace.[m
[32m+[m[32m#ifndef GImGui[m
[32m+[m[32mImGuiContext*   GImGui = NULL;[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Memory Allocator functions. Use SetAllocatorFunctions() to change them.[m
[32m+[m[32m// If you use DLL hotreloading you might need to call SetAllocatorFunctions() after reloading code from this file.[m
[32m+[m[32m// Otherwise, you probably don't want to modify them mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.[m
[32m+[m[32m#ifndef IMGUI_DISABLE_DEFAULT_ALLOCATORS[m
[32m+[m[32mstatic void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }[m
[32m+[m[32mstatic void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }[m
[32m+[m[32m#else[m
[32m+[m[32mstatic void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); IM_UNUSED(size); IM_ASSERT(0); return NULL; }[m
[32m+[m[32mstatic void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); IM_UNUSED(ptr); IM_ASSERT(0); }[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32mstatic void*  (*GImAllocatorAllocFunc)(size_t size, void* user_data) = MallocWrapper;[m
[32m+[m[32mstatic void   (*GImAllocatorFreeFunc)(void* ptr, void* user_data) = FreeWrapper;[m
[32m+[m[32mstatic void*    GImAllocatorUserData = NULL;[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] MAIN USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mImGuiStyle::ImGuiStyle()[m
[32m+[m[32m{[m
[32m+[m[32m    Alpha                   = 1.0f;             // Global alpha applies to everything in ImGui[m
[32m+[m[32m    WindowPadding           = ImVec2(8,8);      // Padding within a window[m
[32m+[m[32m    WindowRounding          = 7.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows[m
[32m+[m[32m    WindowBorderSize        = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.[m
[32m+[m[32m    WindowMinSize           = ImVec2(32,32);    // Minimum window size[m
[32m+[m[32m    WindowTitleAlign        = ImVec2(0.0f,0.5f);// Alignment for title bar text[m
[32m+[m[32m    ChildRounding           = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows[m
[32m+[m[32m    ChildBorderSize         = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.[m
[32m+[m[32m    PopupRounding           = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows[m
[32m+[m[32m    PopupBorderSize         = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.[m
[32m+[m[32m    FramePadding            = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)[m
[32m+[m[32m    FrameRounding           = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).[m
[32m+[m[32m    FrameBorderSize         = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.[m
[32m+[m[32m    ItemSpacing             = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines[m
[32m+[m[32m    ItemInnerSpacing        = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)[m
[32m+[m[32m    TouchExtraPadding       = ImVec2(0,0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much![m
[32m+[m[32m    IndentSpacing           = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).[m
[32m+[m[32m    ColumnsMinSpacing       = 6.0f;             // Minimum horizontal spacing between two columns[m
[32m+[m[32m    ScrollbarSize           = 16.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar[m
[32m+[m[32m    ScrollbarRounding       = 9.0f;             // Radius of grab corners rounding for scrollbar[m
[32m+[m[32m    GrabMinSize             = 10.0f;            // Minimum width/height of a grab box for slider/scrollbar[m
[32m+[m[32m    GrabRounding            = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.[m
[32m+[m[32m    TabRounding             = 4.0f;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.[m
[32m+[m[32m    TabBorderSize           = 0.0f;             // Thickness of border around tabs.[m
[32m+[m[32m    ButtonTextAlign         = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.[m
[32m+[m[32m    SelectableTextAlign     = ImVec2(0.0f,0.0f);// Alignment of selectable text when button is larger than text.[m
[32m+[m[32m    DisplayWindowPadding    = ImVec2(19,19);    // Window position are clamped to be visible within the display area by at least this amount. Only applies to regular windows.[m
[32m+[m[32m    DisplaySafeAreaPadding  = ImVec2(3,3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.[m
[32m+[m[32m    MouseCursorScale        = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.[m
[32m+[m[32m    AntiAliasedLines        = true;             // Enable anti-aliasing on lines/borders. Disable if you are really short on CPU/GPU.[m
[32m+[m[32m    AntiAliasedFill         = true;             // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)[m
[32m+[m[32m    CurveTessellationTol    = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.[m
[32m+[m
[32m+[m[32m    // Default theme[m
[32m+[m[32m    ImGui::StyleColorsDark(this);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.[m
[32m+[m[32m// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.[m
[32m+[m[32mvoid ImGuiStyle::ScaleAllSizes(float scale_factor)[m
[32m+[m[32m{[m
[32m+[m[32m    WindowPadding = ImFloor(WindowPadding * scale_factor);[m
[32m+[m[32m    WindowRounding = ImFloor(WindowRounding * scale_factor);[m
[32m+[m[32m    WindowMinSize = ImFloor(WindowMinSize * scale_factor);[m
[32m+[m[32m    ChildRounding = ImFloor(ChildRounding * scale_factor);[m
[32m+[m[32m    PopupRounding = ImFloor(PopupRounding * scale_factor);[m
[32m+[m[32m    FramePadding = ImFloor(FramePadding * scale_factor);[m
[32m+[m[32m    FrameRounding = ImFloor(FrameRounding * scale_factor);[m
[32m+[m[32m    ItemSpacing = ImFloor(ItemSpacing * scale_factor);[m
[32m+[m[32m    ItemInnerSpacing = ImFloor(ItemInnerSpacing * scale_factor);[m
[32m+[m[32m    TouchExtraPadding = ImFloor(TouchExtraPadding * scale_factor);[m
[32m+[m[32m    IndentSpacing = ImFloor(IndentSpacing * scale_factor);[m
[32m+[m[32m    ColumnsMinSpacing = ImFloor(ColumnsMinSpacing * scale_factor);[m
[32m+[m[32m    ScrollbarSize = ImFloor(ScrollbarSize * scale_factor);[m
[32m+[m[32m    ScrollbarRounding = ImFloor(ScrollbarRounding * scale_factor);[m
[32m+[m[32m    GrabMinSize = ImFloor(GrabMinSize * scale_factor);[m
[32m+[m[32m    GrabRounding = ImFloor(GrabRounding * scale_factor);[m
[32m+[m[32m    TabRounding = ImFloor(TabRounding * scale_factor);[m
[32m+[m[32m    DisplayWindowPadding = ImFloor(DisplayWindowPadding * scale_factor);[m
[32m+[m[32m    DisplaySafeAreaPadding = ImFloor(DisplaySafeAreaPadding * scale_factor);[m
[32m+[m[32m    MouseCursorScale = ImFloor(MouseCursorScale * scale_factor);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiIO::ImGuiIO()[m
[32m+[m[32m{[m
[32m+[m[32m    // Most fields are initialized with zero[m
[32m+[m[32m    memset(this, 0, sizeof(*this));[m
[32m+[m
[32m+[m[32m    // Settings[m
[32m+[m[32m    ConfigFlags = ImGuiConfigFlags_None;[m
[32m+[m[32m    BackendFlags = ImGuiBackendFlags_None;[m
[32m+[m[32m    DisplaySize = ImVec2(-1.0f, -1.0f);[m
[32m+[m[32m    DeltaTime = 1.0f/60.0f;[m
[32m+[m[32m    IniSavingRate = 5.0f;[m
[32m+[m[32m    IniFilename = "imgui.ini";[m
[32m+[m[32m    LogFilename = "imgui_log.txt";[m
[32m+[m[32m    MouseDoubleClickTime = 0.30f;[m
[32m+[m[32m    MouseDoubleClickMaxDist = 6.0f;[m
[32m+[m[32m    for (int i = 0; i < ImGuiKey_COUNT; i++)[m
[32m+[m[32m        KeyMap[i] = -1;[m
[32m+[m[32m    KeyRepeatDelay = 0.250f;[m
[32m+[m[32m    KeyRepeatRate = 0.050f;[m
[32m+[m[32m    UserData = NULL;[m
[32m+[m
[32m+[m[32m    Fonts = NULL;[m
[32m+[m[32m    FontGlobalScale = 1.0f;[m
[32m+[m[32m    FontDefault = NULL;[m
[32m+[m[32m    FontAllowUserScaling = false;[m
[32m+[m[32m    DisplayFramebufferScale = ImVec2(1.0f, 1.0f);[m
[32m+[m
[32m+[m[32m    // Miscellaneous options[m
[32m+[m[32m    MouseDrawCursor = false;[m
[32m+[m[32m#ifdef __APPLE__[m
[32m+[m[32m    ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag[m
[32m+[m[32m#else[m
[32m+[m[32m    ConfigMacOSXBehaviors = false;[m
[32m+[m[32m#endif[m
[32m+[m[32m    ConfigInputTextCursorBlink = true;[m
[32m+[m[32m    ConfigWindowsResizeFromEdges = true;[m
[32m+[m[32m    ConfigWindowsMoveFromTitleBarOnly = false;[m
[32m+[m
[32m+[m[32m    // Platform Functions[m
[32m+[m[32m    BackendPlatformName = BackendRendererName = NULL;[m
[32m+[m[32m    BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = NULL;[m
[32m+[m[32m    GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;   // Platform dependent default implementations[m
[32m+[m[32m    SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;[m
[32m+[m[32m    ClipboardUserData = NULL;[m
[32m+[m[32m    ImeSetInputScreenPosFn = ImeSetInputScreenPosFn_DefaultImpl;[m
[32m+[m[32m    ImeWindowHandle = NULL;[m
[32m+[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32m    RenderDrawListsFn = NULL;[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m    // Input (NB: we already have memset zero the entire structure!)[m
[32m+[m[32m    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);[m
[32m+[m[32m    MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);[m
[32m+[m[32m    MouseDragThreshold = 6.0f;[m
[32m+[m[32m    for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;[m
[32m+[m[32m    for (int i = 0; i < IM_ARRAYSIZE(KeysDownDuration); i++) KeysDownDuration[i]  = KeysDownDurationPrev[i] = -1.0f;[m
[32m+[m[32m    for (int i = 0; i < IM_ARRAYSIZE(NavInputsDownDuration); i++) NavInputsDownDuration[i] = -1.0f;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Pass in translated ASCII characters for text input.[m
[32m+[m[32m// - with glfw you can get those from the callback set in glfwSetCharCallback()[m
[32m+[m[32m// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message[m
[32m+[m[32mvoid ImGuiIO::AddInputCharacter(ImWchar c)[m
[32m+[m[32m{[m
[32m+[m[32m    InputQueueCharacters.push_back(c);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)[m
[32m+[m[32m{[m
[32m+[m[32m    while (*utf8_chars != 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        unsigned int c = 0;[m
[32m+[m[32m        utf8_chars += ImTextCharFromUtf8(&c, utf8_chars, NULL);[m
[32m+[m[32m        if (c > 0 && c <= 0xFFFF)[m
[32m+[m[32m            InputQueueCharacters.push_back((ImWchar)c);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGuiIO::ClearInputCharacters()[m
[32m+[m[32m{[m
[32m+[m[32m    InputQueueCharacters.resize(0);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] MISC HELPERS/UTILITIES (Maths, String, Format, Hash, File functions)[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mImVec2 ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p)[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2 ap = p - a;[m
[32m+[m[32m    ImVec2 ab_dir = b - a;[m
[32m+[m[32m    float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;[m
[32m+[m[32m    if (dot < 0.0f)[m
[32m+[m[32m        return a;[m
[32m+[m[32m    float ab_len_sqr = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;[m
[32m+[m[32m    if (dot > ab_len_sqr)[m
[32m+[m[32m        return b;[m
[32m+[m[32m    return a + ab_dir * dot / ab_len_sqr;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)[m
[32m+[m[32m{[m
[32m+[m[32m    bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;[m
[32m+[m[32m    bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;[m
[32m+[m[32m    bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;[m
[32m+[m[32m    return ((b1 == b2) && (b2 == b3));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w)[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2 v0 = b - a;[m
[32m+[m[32m    ImVec2 v1 = c - a;[m
[32m+[m[32m    ImVec2 v2 = p - a;[m
[32m+[m[32m    const float denom = v0.x * v1.y - v1.x * v0.y;[m
[32m+[m[32m    out_v = (v2.x * v1.y - v1.x * v2.y) / denom;[m
[32m+[m[32m    out_w = (v0.x * v2.y - v2.x * v0.y) / denom;[m
[32m+[m[32m    out_u = 1.0f - out_v - out_w;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2 proj_ab = ImLineClosestPoint(a, b, p);[m
[32m+[m[32m    ImVec2 proj_bc = ImLineClosestPoint(b, c, p);[m
[32m+[m[32m    ImVec2 proj_ca = ImLineClosestPoint(c, a, p);[m
[32m+[m[32m    float dist2_ab = ImLengthSqr(p - proj_ab);[m
[32m+[m[32m    float dist2_bc = ImLengthSqr(p - proj_bc);[m
[32m+[m[32m    float dist2_ca = ImLengthSqr(p - proj_ca);[m
[32m+[m[32m    float m = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca));[m
[32m+[m[32m    if (m == dist2_ab)[m
[32m+[m[32m        return proj_ab;[m
[32m+[m[32m    if (m == dist2_bc)[m
[32m+[m[32m        return proj_bc;[m
[32m+[m[32m    return proj_ca;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Consider using _stricmp/_strnicmp under Windows or strcasecmp/strncasecmp. We don't actually use either ImStricmp/ImStrnicmp in the codebase any more.[m
[32m+[m[32mint ImStricmp(const char* str1, const char* str2)[m
[32m+[m[32m{[m
[32m+[m[32m    int d;[m
[32m+[m[32m    while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; }[m
[32m+[m[32m    return d;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImStrnicmp(const char* str1, const char* str2, size_t count)[m
[32m+[m[32m{[m
[32m+[m[32m    int d = 0;[m
[32m+[m[32m    while (count > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; count--; }[m
[32m+[m[32m    return d;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImStrncpy(char* dst, const char* src, size_t count)[m
[32m+[m[32m{[m
[32m+[m[32m    if (count < 1)[m
[32m+[m[32m        return;[m
[32m+[m[32m    if (count > 1)[m
[32m+[m[32m        strncpy(dst, src, count - 1);[m
[32m+[m[32m    dst[count - 1] = 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mchar* ImStrdup(const char* str)[m
[32m+[m[32m{[m
[32m+[m[32m    size_t len = strlen(str);[m
[32m+[m[32m    void* buf = IM_ALLOC(len + 1);[m
[32m+[m[32m    return (char*)memcpy(buf, (const void*)str, len + 1);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mchar* ImStrdupcpy(char* dst, size_t* p_dst_size, const char* src)[m
[32m+[m[32m{[m
[32m+[m[32m    size_t dst_buf_size = p_dst_size ? *p_dst_size : strlen(dst) + 1;[m
[32m+[m[32m    size_t src_size = strlen(src) + 1;[m
[32m+[m[32m    if (dst_buf_size < src_size)[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_FREE(dst);[m
[32m+[m[32m        dst = (char*)IM_ALLOC(src_size);[m
[32m+[m[32m        if (p_dst_size)[m
[32m+[m[32m            *p_dst_size = src_size;[m
[32m+[m[32m    }[m
[32m+[m[32m    return (char*)memcpy(dst, (const void*)src, src_size);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst char* ImStrchrRange(const char* str, const char* str_end, char c)[m
[32m+[m[32m{[m
[32m+[m[32m    const char* p = (const char*)memchr(str, (int)c, str_end - str);[m
[32m+[m[32m    return p;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImStrlenW(const ImWchar* str)[m
[32m+[m[32m{[m
[32m+[m[32m    //return (int)wcslen((const wchar_t*)str);  // FIXME-OPT: Could use this when wchar_t are 16-bits[m
[32m+[m[32m    int n = 0;[m
[32m+[m[32m    while (*str++) n++;[m
[32m+[m[32m    return n;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Find end-of-line. Return pointer will point to either first \n, either str_end.[m
[32m+[m[32mconst char* ImStreolRange(const char* str, const char* str_end)[m
[32m+[m[32m{[m
[32m+[m[32m    const char* p = (const char*)memchr(str, '\n', str_end - str);[m
[32m+[m[32m    return p ? p : str_end;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin) // find beginning-of-line[m
[32m+[m[32m{[m
[32m+[m[32m    while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')[m
[32m+[m[32m        buf_mid_line--;[m
[32m+[m[32m    return buf_mid_line;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)[m
[32m+[m[32m{[m
[32m+[m[32m    if (!needle_end)[m
[32m+[m[32m        needle_end = needle + strlen(needle);[m
[32m+[m
[32m+[m[32m    const char un0 = (char)toupper(*needle);[m
[32m+[m[32m    while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end))[m
[32m+[m[32m    {[m
[32m+[m[32m        if (toupper(*haystack) == un0)[m
[32m+[m[32m        {[m
[32m+[m[32m            const char* b = needle + 1;[m
[32m+[m[32m            for (const char* a = haystack + 1; b < needle_end; a++, b++)[m
[32m+[m[32m                if (toupper(*a) != toupper(*b))[m
[32m+[m[32m                    break;[m
[32m+[m[32m            if (b == needle_end)[m
[32m+[m[32m                return haystack;[m
[32m+[m[32m        }[m
[32m+[m[32m        haystack++;[m
[32m+[m[32m    }[m
[32m+[m[32m    return NULL;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Trim str by offsetting contents when there's leading data + writing a \0 at the trailing position. We use this in situation where the cost is negligible.[m
[32m+[m[32mvoid ImStrTrimBlanks(char* buf)[m
[32m+[m[32m{[m
[32m+[m[32m    char* p = buf;[m
[32m+[m[32m    while (p[0] == ' ' || p[0] == '\t')     // Leading blanks[m
[32m+[m[32m        p++;[m
[32m+[m[32m    char* p_start = p;[m
[32m+[m[32m    while (*p != 0)                         // Find end of string[m
[32m+[m[32m        p++;[m
[32m+[m[32m    while (p > p_start && (p[-1] == ' ' || p[-1] == '\t'))  // Trailing blanks[m
[32m+[m[32m        p--;[m
[32m+[m[32m    if (p_start != buf)                     // Copy memory if we had leading blanks[m
[32m+[m[32m        memmove(buf, p_start, p - p_start);[m
[32m+[m[32m    buf[p - p_start] = 0;                   // Zero terminate[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).[m
[32m+[m[32m// Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.[m
[32m+[m[32m// B) When buf==NULL vsnprintf() will return the output size.[m
[32m+[m[32m#ifndef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS[m
[32m+[m
[32m+[m[32m//#define IMGUI_USE_STB_SPRINTF[m
[32m+[m[32m#ifdef IMGUI_USE_STB_SPRINTF[m
[32m+[m[32m#define STB_SPRINTF_IMPLEMENTATION[m
[32m+[m[32m#include "imstb_sprintf.h"[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if defined(_MSC_VER) && !defined(vsnprintf)[m
[32m+[m[32m#define vsnprintf _vsnprintf[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32mint ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)[m
[32m+[m[32m{[m
[32m+[m[32m    va_list args;[m
[32m+[m[32m    va_start(args, fmt);[m
[32m+[m[32m#ifdef IMGUI_USE_STB_SPRINTF[m
[32m+[m[32m    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);[m
[32m+[m[32m#else[m
[32m+[m[32m    int w = vsnprintf(buf, buf_size, fmt, args);[m
[32m+[m[32m#endif[m
[32m+[m[32m    va_end(args);[m
[32m+[m[32m    if (buf == NULL)[m
[32m+[m[32m        return w;[m
[32m+[m[32m    if (w == -1 || w >= (int)buf_size)[m
[32m+[m[32m        w = (int)buf_size - 1;[m
[32m+[m[32m    buf[w] = 0;[m
[32m+[m[32m    return w;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)[m
[32m+[m[32m{[m
[32m+[m[32m#ifdef IMGUI_USE_STB_SPRINTF[m
[32m+[m[32m    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);[m
[32m+[m[32m#else[m
[32m+[m[32m    int w = vsnprintf(buf, buf_size, fmt, args);[m
[32m+[m[32m#endif[m
[32m+[m[32m    if (buf == NULL)[m
[32m+[m[32m        return w;[m
[32m+[m[32m    if (w == -1 || w >= (int)buf_size)[m
[32m+[m[32m        w = (int)buf_size - 1;[m
[32m+[m[32m    buf[w] = 0;[m
[32m+[m[32m    return w;[m
[32m+[m[32m}[m
[32m+[m[32m#endif // #ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS[m
[32m+[m
[32m+[m[32m// CRC32 needs a 1KB lookup table (not cache friendly)[m
[32m+[m[32m// Although the code to generate the table is simple and shorter than the table itself, using a const table allows us to easily:[m
[32m+[m[32m// - avoid an unnecessary branch/memory tap, - keep the ImHashXXX functions usable by static constructors, - make it thread-safe.[m
[32m+[m[32mstatic const ImU32 GCrc32LookupTable[256] =[m
[32m+[m[32m{[m
[32m+[m[32m    0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,0x9E6495A3,0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,[m
[32m+[m[32m    0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,[m
[32m+[m[32m    0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,0x35B5A8FA,0x42B2986C,0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,[m
[32m+[m[32m    0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,[m
[32m+[m[32m    0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,0x91646C97,0xE6635C01,[m
[32m+[m[32m    0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,0x65B0D9C6,0x12B7E950,0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,[m
[32m+[m[32m    0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,[m
[32m+[m[32m    0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,0xB7BD5C3B,0xC0BA6CAD,[m
[32m+[m[32m    0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,[m
[32m+[m[32m    0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,[m
[32m+[m[32m    0xD6D6A3E8,0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,0x4669BE79,[m
[32m+[m[32m    0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,[m
[32m+[m[32m    0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,[m
[32m+[m[32m    0x86D3D2D4,0xF1D4E242,0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,[m
[32m+[m[32m    0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,[m
[32m+[m[32m    0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,0x54DE5729,0x23D967BF,0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D,[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Known size hash[m
[32m+[m[32m// It is ok to call ImHashData on a string with known length but the ### operator won't be supported.[m
[32m+[m[32m// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.[m
[32m+[m[32mImU32 ImHashData(const void* data_p, size_t data_size, ImU32 seed)[m
[32m+[m[32m{[m
[32m+[m[32m    ImU32 crc = ~seed;[m
[32m+[m[32m    const unsigned char* data = (const unsigned char*)data_p;[m
[32m+[m[32m    const ImU32* crc32_lut = GCrc32LookupTable;[m
[32m+[m[32m    while (data_size-- != 0)[m
[32m+[m[32m        crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *data++];[m
[32m+[m[32m    return ~crc;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Zero-terminated string hash, with support for ### to reset back to seed value[m
[32m+[m[32m// We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.[m
[32m+[m[32m// Because this syntax is rarely used we are optimizing for the common case.[m
[32m+[m[32m// - If we reach ### in the string we discard the hash so far and reset to the seed.[m
[32m+[m[32m// - We don't do 'current += 2; continue;' after handling ### to keep the code smaller/faster (measured ~10% diff in Debug build)[m
[32m+[m[32m// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.[m
[32m+[m[32mImU32 ImHashStr(const char* data_p, size_t data_size, ImU32 seed)[m
[32m+[m[32m{[m
[32m+[m[32m    seed = ~seed;[m
[32m+[m[32m    ImU32 crc = seed;[m
[32m+[m[32m    const unsigned char* data = (const unsigned char*)data_p;[m
[32m+[m[32m    const ImU32* crc32_lut = GCrc32LookupTable;[m
[32m+[m[32m    if (data_size != 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        while (data_size-- != 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            unsigned char c = *data++;[m
[32m+[m[32m            if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')[m
[32m+[m[32m                crc = seed;[m
[32m+[m[32m            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        while (unsigned char c = *data++)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (c == '#' && data[0] == '#' && data[1] == '#')[m
[32m+[m[32m                crc = seed;[m
[32m+[m[32m            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    return ~crc;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mFILE* ImFileOpen(const char* filename, const char* mode)[m
[32m+[m[32m{[m
[32m+[m[32m#if defined(_WIN32) && !defined(__CYGWIN__) && !defined(__GNUC__)[m
[32m+[m[32m    // We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames. Converting both strings from UTF-8 to wchar format (using a single allocation, because we can)[m
[32m+[m[32m    const int filename_wsize = ImTextCountCharsFromUtf8(filename, NULL) + 1;[m
[32m+[m[32m    const int mode_wsize = ImTextCountCharsFromUtf8(mode, NULL) + 1;[m
[32m+[m[32m    ImVector<ImWchar> buf;[m
[32m+[m[32m    buf.resize(filename_wsize + mode_wsize);[m
[32m+[m[32m    ImTextStrFromUtf8(&buf[0], filename_wsize, filename, NULL);[m
[32m+[m[32m    ImTextStrFromUtf8(&buf[filename_wsize], mode_wsize, mode, NULL);[m
[32m+[m[32m    return _wfopen((wchar_t*)&buf[0], (wchar_t*)&buf[filename_wsize]);[m
[32m+[m[32m#else[m
[32m+[m[32m    return fopen(filename, mode);[m
[32m+[m[32m#endif[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Load file content into memory[m
[32m+[m[32m// Memory allocated with IM_ALLOC(), must be freed by user using IM_FREE() == ImGui::MemFree()[m
[32m+[m[32mvoid* ImFileLoadToMemory(const char* filename, const char* file_open_mode, size_t* out_file_size, int padding_bytes)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(filename && file_open_mode);[m
[32m+[m[32m    if (out_file_size)[m
[32m+[m[32m        *out_file_size = 0;[m
[32m+[m
[32m+[m[32m    FILE* f;[m
[32m+[m[32m    if ((f = ImFileOpen(filename, file_open_mode)) == NULL)[m
[32m+[m[32m        return NULL;[m
[32m+[m
[32m+[m[32m    long file_size_signed;[m
[32m+[m[32m    if (fseek(f, 0, SEEK_END) || (file_size_signed = ftell(f)) == -1 || fseek(f, 0, SEEK_SET))[m
[32m+[m[32m    {[m
[32m+[m[32m        fclose(f);[m
[32m+[m[32m        return NULL;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    size_t file_size = (size_t)file_size_signed;[m
[32m+[m[32m    void* file_data = IM_ALLOC(file_size + padding_bytes);[m
[32m+[m[32m    if (file_data == NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        fclose(f);[m
[32m+[m[32m        return NULL;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (fread(file_data, 1, file_size, f) != file_size)[m
[32m+[m[32m    {[m
[32m+[m[32m        fclose(f);[m
[32m+[m[32m        IM_FREE(file_data);[m
[32m+[m[32m        return NULL;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (padding_bytes > 0)[m
[32m+[m[32m        memset((void*)(((char*)file_data) + file_size), 0, (size_t)padding_bytes);[m
[32m+[m
[32m+[m[32m    fclose(f);[m
[32m+[m[32m    if (out_file_size)[m
[32m+[m[32m        *out_file_size = file_size;[m
[32m+[m
[32m+[m[32m    return file_data;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Convert UTF-8 to 32-bits character, process single character input.[m
[32m+[m[32m// Based on stb_from_utf8() from github.com/nothings/stb/[m
[32m+[m[32m// We handle UTF-8 decoding error by skipping forward.[m
[32m+[m[32mint ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)[m
[32m+[m[32m{[m
[32m+[m[32m    unsigned int c = (unsigned int)-1;[m
[32m+[m[32m    const unsigned char* str = (const unsigned char*)in_text;[m
[32m+[m[32m    if (!(*str & 0x80))[m
[32m+[m[32m    {[m
[32m+[m[32m        c = (unsigned int)(*str++);[m
[32m+[m[32m        *out_char = c;[m
[32m+[m[32m        return 1;[m
[32m+[m[32m    }[m
[32m+[m[32m    if ((*str & 0xe0) == 0xc0)[m
[32m+[m[32m    {[m
[32m+[m[32m        *out_char = 0xFFFD; // will be invalid but not end of string[m
[32m+[m[32m        if (in_text_end && in_text_end - (const char*)str < 2) return 1;[m
[32m+[m[32m        if (*str < 0xc2) return 2;[m
[32m+[m[32m        c = (unsigned int)((*str++ & 0x1f) << 6);[m
[32m+[m[32m        if ((*str & 0xc0) != 0x80) return 2;[m
[32m+[m[32m        c += (*str++ & 0x3f);[m
[32m+[m[32m        *out_char = c;[m
[32m+[m[32m        return 2;[m
[32m+[m[32m    }[m
[32m+[m[32m    if ((*str & 0xf0) == 0xe0)[m
[32m+[m[32m    {[m
[32m+[m[32m        *out_char = 0xFFFD; // will be invalid but not end of string[m
[32m+[m[32m        if (in_text_end && in_text_end - (const char*)str < 3) return 1;[m
[32m+[m[32m        if (*str == 0xe0 && (str[1] < 0xa0 || str[1] > 0xbf)) return 3;[m
[32m+[m[32m        if (*str == 0xed && str[1] > 0x9f) return 3; // str[1] < 0x80 is checked below[m
[32m+[m[32m        c = (unsigned int)((*str++ & 0x0f) << 12);[m
[32m+[m[32m        if ((*str & 0xc0) != 0x80) return 3;[m
[32m+[m[32m        c += (unsigned int)((*str++ & 0x3f) << 6);[m
[32m+[m[32m        if ((*str & 0xc0) != 0x80) return 3;[m
[32m+[m[32m        c += (*str++ & 0x3f);[m
[32m+[m[32m        *out_char = c;[m
[32m+[m[32m        return 3;[m
[32m+[m[32m    }[m
[32m+[m[32m    if ((*str & 0xf8) == 0xf0)[m
[32m+[m[32m    {[m
[32m+[m[32m        *out_char = 0xFFFD; // will be invalid but not end of string[m
[32m+[m[32m        if (in_text_end && in_text_end - (const char*)str < 4) return 1;[m
[32m+[m[32m        if (*str > 0xf4) return 4;[m
[32m+[m[32m        if (*str == 0xf0 && (str[1] < 0x90 || str[1] > 0xbf)) return 4;[m
[32m+[m[32m        if (*str == 0xf4 && str[1] > 0x8f) return 4; // str[1] < 0x80 is checked below[m
[32m+[m[32m        c = (unsigned int)((*str++ & 0x07) << 18);[m
[32m+[m[32m        if ((*str & 0xc0) != 0x80) return 4;[m
[32m+[m[32m        c += (unsigned int)((*str++ & 0x3f) << 12);[m
[32m+[m[32m        if ((*str & 0xc0) != 0x80) return 4;[m
[32m+[m[32m        c += (unsigned int)((*str++ & 0x3f) << 6);[m
[32m+[m[32m        if ((*str & 0xc0) != 0x80) return 4;[m
[32m+[m[32m        c += (*str++ & 0x3f);[m
[32m+[m[32m        // utf-8 encodings of values used in surrogate pairs are invalid[m
[32m+[m[32m        if ((c & 0xFFFFF800) == 0xD800) return 4;[m
[32m+[m[32m        *out_char = c;[m
[32m+[m[32m        return 4;[m
[32m+[m[32m    }[m
[32m+[m[32m    *out_char = 0;[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)[m
[32m+[m[32m{[m
[32m+[m[32m    ImWchar* buf_out = buf;[m
[32m+[m[32m    ImWchar* buf_end = buf + buf_size;[m
[32m+[m[32m    while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)[m
[32m+[m[32m    {[m
[32m+[m[32m        unsigned int c;[m
[32m+[m[32m        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);[m
[32m+[m[32m        if (c == 0)[m
[32m+[m[32m            break;[m
[32m+[m[32m        if (c < 0x10000)    // FIXME: Losing characters that don't fit in 2 bytes[m
[32m+[m[32m            *buf_out++ = (ImWchar)c;[m
[32m+[m[32m    }[m
[32m+[m[32m    *buf_out = 0;[m
[32m+[m[32m    if (in_text_remaining)[m
[32m+[m[32m        *in_text_remaining = in_text;[m
[32m+[m[32m    return (int)(buf_out - buf);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)[m
[32m+[m[32m{[m
[32m+[m[32m    int char_count = 0;[m
[32m+[m[32m    while ((!in_text_end || in_text < in_text_end) && *in_text)[m
[32m+[m[32m    {[m
[32m+[m[32m        unsigned int c;[m
[32m+[m[32m        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);[m
[32m+[m[32m        if (c == 0)[m
[32m+[m[32m            break;[m
[32m+[m[32m        if (c < 0x10000)[m
[32m+[m[32m            char_count++;[m
[32m+[m[32m    }[m
[32m+[m[32m    return char_count;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Based on stb_to_utf8() from github.com/nothings/stb/[m
[32m+[m[32mstatic inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)[m
[32m+[m[32m{[m
[32m+[m[32m    if (c < 0x80)[m
[32m+[m[32m    {[m
[32m+[m[32m        buf[0] = (char)c;[m
[32m+[m[32m        return 1;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (c < 0x800)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (buf_size < 2) return 0;[m
[32m+[m[32m        buf[0] = (char)(0xc0 + (c >> 6));[m
[32m+[m[32m        buf[1] = (char)(0x80 + (c & 0x3f));[m
[32m+[m[32m        return 2;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (c >= 0xdc00 && c < 0xe000)[m
[32m+[m[32m    {[m
[32m+[m[32m        return 0;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (c >= 0xd800 && c < 0xdc00)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (buf_size < 4) return 0;[m
[32m+[m[32m        buf[0] = (char)(0xf0 + (c >> 18));[m
[32m+[m[32m        buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));[m
[32m+[m[32m        buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));[m
[32m+[m[32m        buf[3] = (char)(0x80 + ((c ) & 0x3f));[m
[32m+[m[32m        return 4;[m
[32m+[m[32m    }[m
[32m+[m[32m    //else if (c < 0x10000)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (buf_size < 3) return 0;[m
[32m+[m[32m        buf[0] = (char)(0xe0 + (c >> 12));[m
[32m+[m[32m        buf[1] = (char)(0x80 + ((c>> 6) & 0x3f));[m
[32m+[m[32m        buf[2] = (char)(0x80 + ((c ) & 0x3f));[m
[32m+[m[32m        return 3;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Not optimal but we very rarely use this function.[m
[32m+[m[32mint ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end)[m
[32m+[m[32m{[m
[32m+[m[32m    unsigned int dummy = 0;[m
[32m+[m[32m    return ImTextCharFromUtf8(&dummy, in_text, in_text_end);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic inline int ImTextCountUtf8BytesFromChar(unsigned int c)[m
[32m+[m[32m{[m
[32m+[m[32m    if (c < 0x80) return 1;[m
[32m+[m[32m    if (c < 0x800) return 2;[m
[32m+[m[32m    if (c >= 0xdc00 && c < 0xe000) return 0;[m
[32m+[m[32m    if (c >= 0xd800 && c < 0xdc00) return 4;[m
[32m+[m[32m    return 3;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)[m
[32m+[m[32m{[m
[32m+[m[32m    char* buf_out = buf;[m
[32m+[m[32m    const char* buf_end = buf + buf_size;[m
[32m+[m[32m    while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)[m
[32m+[m[32m    {[m
[32m+[m[32m        unsigned int c = (unsigned int)(*in_text++);[m
[32m+[m[32m        if (c < 0x80)[m
[32m+[m[32m            *buf_out++ = (char)c;[m
[32m+[m[32m        else[m
[32m+[m[32m            buf_out += ImTextCharToUtf8(buf_out, (int)(buf_end-buf_out-1), c);[m
[32m+[m[32m    }[m
[32m+[m[32m    *buf_out = 0;[m
[32m+[m[32m    return (int)(buf_out - buf);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)[m
[32m+[m[32m{[m
[32m+[m[32m    int bytes_count = 0;[m
[32m+[m[32m    while ((!in_text_end || in_text < in_text_end) && *in_text)[m
[32m+[m[32m    {[m
[32m+[m[32m        unsigned int c = (unsigned int)(*in_text++);[m
[32m+[m[32m        if (c < 0x80)[m
[32m+[m[32m            bytes_count++;[m
[32m+[m[32m        else[m
[32m+[m[32m            bytes_count += ImTextCountUtf8BytesFromChar(c);[m
[32m+[m[32m    }[m
[32m+[m[32m    return bytes_count;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] MISC HELPERS/UTILTIES (Color functions)[m
[32m+[m[32m// Note: The Convert functions are early design which are not consistent with other API.[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)[m
[32m+[m[32m{[m
[32m+[m[32m    float s = 1.0f/255.0f;[m
[32m+[m[32m    return ImVec4([m
[32m+[m[32m        ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,[m
[32m+[m[32m        ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,[m
[32m+[m[32m        ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,[m
[32m+[m[32m        ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)[m
[32m+[m[32m{[m
[32m+[m[32m    ImU32 out;[m
[32m+[m[32m    out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;[m
[32m+[m[32m    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;[m
[32m+[m[32m    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;[m
[32m+[m[32m    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;[m
[32m+[m[32m    return out;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592[m
[32m+[m[32m// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv[m
[32m+[m[32mvoid ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)[m
[32m+[m[32m{[m
[32m+[m[32m    float K = 0.f;[m
[32m+[m[32m    if (g < b)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImSwap(g, b);[m
[32m+[m[32m        K = -1.f;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (r < g)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImSwap(r, g);[m
[32m+[m[32m        K = -2.f / 6.f - K;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    const float chroma = r - (g < b ? g : b);[m
[32m+[m[32m    out_h = ImFabs(K + (g - b) / (6.f * chroma + 1e-20f));[m
[32m+[m[32m    out_s = chroma / (r + 1e-20f);[m
[32m+[m[32m    out_v = r;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593[m
[32m+[m[32m// also http://en.wikipedia.org/wiki/HSL_and_HSV[m
[32m+[m[32mvoid ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)[m
[32m+[m[32m{[m
[32m+[m[32m    if (s == 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        // gray[m
[32m+[m[32m        out_r = out_g = out_b = v;[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    h = ImFmod(h, 1.0f) / (60.0f/360.0f);[m
[32m+[m[32m    int   i = (int)h;[m
[32m+[m[32m    float f = h - (float)i;[m
[32m+[m[32m    float p = v * (1.0f - s);[m
[32m+[m[32m    float q = v * (1.0f - s * f);[m
[32m+[m[32m    float t = v * (1.0f - s * (1.0f - f));[m
[32m+[m
[32m+[m[32m    switch (i)[m
[32m+[m[32m    {[m
[32m+[m[32m    case 0: out_r = v; out_g = t; out_b = p; break;[m
[32m+[m[32m    case 1: out_r = q; out_g = v; out_b = p; break;[m
[32m+[m[32m    case 2: out_r = p; out_g = v; out_b = t; break;[m
[32m+[m[32m    case 3: out_r = p; out_g = q; out_b = v; break;[m
[32m+[m[32m    case 4: out_r = t; out_g = p; out_b = v; break;[m
[32m+[m[32m    case 5: default: out_r = v; out_g = p; out_b = q; break;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStyle& style = GImGui->Style;[m
[32m+[m[32m    ImVec4 c = style.Colors[idx];[m
[32m+[m[32m    c.w *= style.Alpha * alpha_mul;[m
[32m+[m[32m    return ColorConvertFloat4ToU32(c);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImU32 ImGui::GetColorU32(const ImVec4& col)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStyle& style = GImGui->Style;[m
[32m+[m[32m    ImVec4 c = col;[m
[32m+[m[32m    c.w *= style.Alpha;[m
[32m+[m[32m    return ColorConvertFloat4ToU32(c);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst ImVec4& ImGui::GetStyleColorVec4(ImGuiCol idx)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStyle& style = GImGui->Style;[m
[32m+[m[32m    return style.Colors[idx];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImU32 ImGui::GetColorU32(ImU32 col)[m
[32m+[m[32m{[m
[32m+[m[32m    float style_alpha = GImGui->Style.Alpha;[m
[32m+[m[32m    if (style_alpha >= 1.0f)[m
[32m+[m[32m        return col;[m
[32m+[m[32m    ImU32 a = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;[m
[32m+[m[32m    a = (ImU32)(a * style_alpha); // We don't need to clamp 0..255 because Style.Alpha is in 0..1 range.[m
[32m+[m[32m    return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] ImGuiStorage[m
[32m+[m[32m// Helper: Key->value storage[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// std::lower_bound but without the bullshit[m
[32m+[m[32mstatic ImGuiStorage::Pair* LowerBound(ImVector<ImGuiStorage::Pair>& data, ImGuiID key)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStorage::Pair* first = data.Data;[m
[32m+[m[32m    ImGuiStorage::Pair* last = data.Data + data.Size;[m
[32m+[m[32m    size_t count = (size_t)(last - first);[m
[32m+[m[32m    while (count > 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        size_t count2 = count >> 1;[m
[32m+[m[32m        ImGuiStorage::Pair* mid = first + count2;[m
[32m+[m[32m        if (mid->key < key)[m
[32m+[m[32m        {[m
[32m+[m[32m            first = ++mid;[m
[32m+[m[32m            count -= count2 + 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            count = count2;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    return first;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.[m
[32m+[m[32mvoid ImGuiStorage::BuildSortByKey()[m
[32m+[m[32m{[m
[32m+[m[32m    struct StaticFunc[m
[32m+[m[32m    {[m
[32m+[m[32m        static int IMGUI_CDECL PairCompareByID(const void* lhs, const void* rhs)[m
[32m+[m[32m        {[m
[32m+[m[32m            // We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.[m
[32m+[m[32m            if (((const Pair*)lhs)->key > ((const Pair*)rhs)->key) return +1;[m
[32m+[m[32m            if (((const Pair*)lhs)->key < ((const Pair*)rhs)->key) return -1;[m
[32m+[m[32m            return 0;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m[32m    if (Data.Size > 1)[m
[32m+[m[32m        ImQsort(Data.Data, (size_t)Data.Size, sizeof(Pair), StaticFunc::PairCompareByID);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImGuiStorage::GetInt(ImGuiID key, int default_val) const[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStorage::Pair* it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);[m
[32m+[m[32m    if (it == Data.end() || it->key != key)[m
[32m+[m[32m        return default_val;[m
[32m+[m[32m    return it->val_i;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const[m
[32m+[m[32m{[m
[32m+[m[32m    return GetInt(key, default_val ? 1 : 0) != 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGuiStorage::GetFloat(ImGuiID key, float default_val) const[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStorage::Pair* it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);[m
[32m+[m[32m    if (it == Data.end() || it->key != key)[m
[32m+[m[32m        return default_val;[m
[32m+[m[32m    return it->val_f;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid* ImGuiStorage::GetVoidPtr(ImGuiID key) const[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStorage::Pair* it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);[m
[32m+[m[32m    if (it == Data.end() || it->key != key)[m
[32m+[m[32m        return NULL;[m
[32m+[m[32m    return it->val_p;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.[m
[32m+[m[32mint* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStorage::Pair* it = LowerBound(Data, key);[m
[32m+[m[32m    if (it == Data.end() || it->key != key)[m
[32m+[m[32m        it = Data.insert(it, Pair(key, default_val));[m
[32m+[m[32m    return &it->val_i;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)[m
[32m+[m[32m{[m
[32m+[m[32m    return (bool*)GetIntRef(key, default_val ? 1 : 0);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStorage::Pair* it = LowerBound(Data, key);[m
[32m+[m[32m    if (it == Data.end() || it->key != key)[m
[32m+[m[32m        it = Data.insert(it, Pair(key, default_val));[m
[32m+[m[32m    return &it->val_f;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStorage::Pair* it = LowerBound(Data, key);[m
[32m+[m[32m    if (it == Data.end() || it->key != key)[m
[32m+[m[32m        it = Data.insert(it, Pair(key, default_val));[m
[32m+[m[32m    return &it->val_p;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)[m
[32m+[m[32mvoid ImGuiStorage::SetInt(ImGuiID key, int val)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStorage::Pair* it = LowerBound(Data, key);[m
[32m+[m[32m    if (it == Data.end() || it->key != key)[m
[32m+[m[32m    {[m
[32m+[m[32m        Data.insert(it, Pair(key, val));[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    it->val_i = val;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGuiStorage::SetBool(ImGuiID key, bool val)[m
[32m+[m[32m{[m
[32m+[m[32m    SetInt(key, val ? 1 : 0);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGuiStorage::SetFloat(ImGuiID key, float val)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStorage::Pair* it = LowerBound(Data, key);[m
[32m+[m[32m    if (it == Data.end() || it->key != key)[m
[32m+[m[32m    {[m
[32m+[m[32m        Data.insert(it, Pair(key, val));[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    it->val_f = val;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStorage::Pair* it = LowerBound(Data, key);[m
[32m+[m[32m    if (it == Data.end() || it->key != key)[m
[32m+[m[32m    {[m
[32m+[m[32m        Data.insert(it, Pair(key, val));[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    it->val_p = val;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGuiStorage::SetAllInt(int v)[m
[32m+[m[32m{[m
[32m+[m[32m    for (int i = 0; i < Data.Size; i++)[m
[32m+[m[32m        Data[i].val_i = v;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] ImGuiTextFilter[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"[m
[32m+[m[32mImGuiTextFilter::ImGuiTextFilter(const char* default_filter)[m
[32m+[m[32m{[m
[32m+[m[32m    if (default_filter)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));[m
[32m+[m[32m        Build();[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        InputBuf[0] = 0;[m
[32m+[m[32m        CountGrep = 0;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGuiTextFilter::Draw(const char* label, float width)[m
[32m+[m[32m{[m
[32m+[m[32m    if (width != 0.0f)[m
[32m+[m[32m        ImGui::SetNextItemWidth(width);[m
[32m+[m[32m    bool value_changed = ImGui::InputText(label, InputBuf, IM_ARRAYSIZE(InputBuf));[m
[32m+[m[32m    if (value_changed)[m
[32m+[m[32m        Build();[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGuiTextFilter::TextRange::split(char separator, ImVector<TextRange>* out) const[m
[32m+[m[32m{[m
[32m+[m[32m    out->resize(0);[m
[32m+[m[32m    const char* wb = b;[m
[32m+[m[32m    const char* we = wb;[m
[32m+[m[32m    while (we < e)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (*we == separator)[m
[32m+[m[32m        {[m
[32m+[m[32m            out->push_back(TextRange(wb, we));[m
[32m+[m[32m            wb = we + 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        we++;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (wb != we)[m
[32m+[m[32m        out->push_back(TextRange(wb, we));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGuiTextFilter::Build()[m
[32m+[m[32m{[m
[32m+[m[32m    Filters.resize(0);[m
[32m+[m[32m    TextRange input_range(InputBuf, InputBuf+strlen(InputBuf));[m
[32m+[m[32m    input_range.split(',', &Filters);[m
[32m+[m
[32m+[m[32m    CountGrep = 0;[m
[32m+[m[32m    for (int i = 0; i != Filters.Size; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        TextRange& f = Filters[i];[m
[32m+[m[32m        while (f.b < f.e && ImCharIsBlankA(f.b[0]))[m
[32m+[m[32m            f.b++;[m
[32m+[m[32m        while (f.e > f.b && ImCharIsBlankA(f.e[-1]))[m
[32m+[m[32m            f.e--;[m
[32m+[m[32m        if (f.empty())[m
[32m+[m[32m            continue;[m
[32m+[m[32m        if (Filters[i].b[0] != '-')[m
[32m+[m[32m            CountGrep += 1;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const[m
[32m+[m[32m{[m
[32m+[m[32m    if (Filters.empty())[m
[32m+[m[32m        return true;[m
[32m+[m
[32m+[m[32m    if (text == NULL)[m
[32m+[m[32m        text = "";[m
[32m+[m
[32m+[m[32m    for (int i = 0; i != Filters.Size; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        const TextRange& f = Filters[i];[m
[32m+[m[32m        if (f.empty())[m
[32m+[m[32m            continue;[m
[32m+[m[32m        if (f.b[0] == '-')[m
[32m+[m[32m        {[m
[32m+[m[32m            // Subtract[m
[32m+[m[32m            if (ImStristr(text, text_end, f.begin()+1, f.end()) != NULL)[m
[32m+[m[32m                return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            // Grep[m
[32m+[m[32m            if (ImStristr(text, text_end, f.begin(), f.end()) != NULL)[m
[32m+[m[32m                return true;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Implicit * grep[m
[32m+[m[32m    if (CountGrep == 0)[m
[32m+[m[32m        return true;[m
[32m+[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] ImGuiTextBuffer[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// On some platform vsnprintf() takes va_list by reference and modifies it.[m
[32m+[m[32m// va_copy is the 'correct' way to copy a va_list but Visual Studio prior to 2013 doesn't have it.[m
[32m+[m[32m#ifndef va_copy[m
[32m+[m[32m#if defined(__GNUC__) || defined(__clang__)[m
[32m+[m[32m#define va_copy(dest, src) __builtin_va_copy(dest, src)[m
[32m+[m[32m#else[m
[32m+[m[32m#define va_copy(dest, src) (dest = src)[m
[32m+[m[32m#endif[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32mchar ImGuiTextBuffer::EmptyString[1] = { 0 };[m
[32m+[m
[32m+[m[32mvoid ImGuiTextBuffer::append(const char* str, const char* str_end)[m
[32m+[m[32m{[m
[32m+[m[32m    int len = str_end ? (int)(str_end - str) : (int)strlen(str);[m
[32m+[m
[32m+[m[32m    // Add zero-terminator the first time[m
[32m+[m[32m    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;[m
[32m+[m[32m    const int needed_sz = write_off + len;[m
[32m+[m[32m    if (write_off + len >= Buf.Capacity)[m
[32m+[m[32m    {[m
[32m+[m[32m        int new_capacity = Buf.Capacity * 2;[m
[32m+[m[32m        Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    Buf.resize(needed_sz);[m
[32m+[m[32m    memcpy(&Buf[write_off - 1], str, (size_t)len);[m
[32m+[m[32m    Buf[write_off - 1 + len] = 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGuiTextBuffer::appendf(const char* fmt, ...)[m
[32m+[m[32m{[m
[32m+[m[32m    va_list args;[m
[32m+[m[32m    va_start(args, fmt);[m
[32m+[m[32m    appendfv(fmt, args);[m
[32m+[m[32m    va_end(args);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Helper: Text buffer for logging/accumulating text[m
[32m+[m[32mvoid ImGuiTextBuffer::appendfv(const char* fmt, va_list args)[m
[32m+[m[32m{[m
[32m+[m[32m    va_list args_copy;[m
[32m+[m[32m    va_copy(args_copy, args);[m
[32m+[m
[32m+[m[32m    int len = ImFormatStringV(NULL, 0, fmt, args);         // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.[m
[32m+[m[32m    if (len <= 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        va_end(args_copy);[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Add zero-terminator the first time[m
[32m+[m[32m    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;[m
[32m+[m[32m    const int needed_sz = write_off + len;[m
[32m+[m[32m    if (write_off + len >= Buf.Capacity)[m
[32m+[m[32m    {[m
[32m+[m[32m        int new_capacity = Buf.Capacity * 2;[m
[32m+[m[32m        Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    Buf.resize(needed_sz);[m
[32m+[m[32m    ImFormatStringV(&Buf[write_off - 1], (size_t)len + 1, fmt, args_copy);[m
[32m+[m[32m    va_end(args_copy);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] ImGuiListClipper[m
[32m+[m[32m// This is currently not as flexible/powerful as it should be, needs some rework (see TODO)[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mstatic void SetCursorPosYAndSetupDummyPrevLine(float pos_y, float line_height)[m
[32m+[m[32m{[m
[32m+[m[32m    // Set cursor position and a few other things so that SetScrollHereY() and Columns() can work when seeking cursor.[m
[32m+[m[32m    // FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.[m
[32m+[m[32m    // The clipper should probably have a 4th step to display the last item in a regular manner.[m
[32m+[m[32m    ImGui::SetCursorPosY(pos_y);[m
[32m+[m[32m    ImGuiWindow* window = ImGui::GetCurrentWindow();[m
[32m+[m[32m    window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height;      // Setting those fields so that SetScrollHereY() can properly function after the end of our clipper usage.[m
[32m+[m[32m    window->DC.PrevLineSize.y = (line_height - GImGui->Style.ItemSpacing.y);    // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.[m
[32m+[m[32m    if (window->DC.CurrentColumns)[m
[32m+[m[32m        window->DC.CurrentColumns->LineMinY = window->DC.CursorPos.y;           // Setting this so that cell Y position are set properly[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Use case A: Begin() called from constructor with items_height<0, then called again from Sync() in StepNo 1[m
[32m+[m[32m// Use case B: Begin() called from constructor with items_height>0[m
[32m+[m[32m// FIXME-LEGACY: Ideally we should remove the Begin/End functions but they are part of the legacy API we still support. This is why some of the code in Step() calling Begin() and reassign some fields, spaghetti style.[m
[32m+[m[32mvoid ImGuiListClipper::Begin(int count, float items_height)[m
[32m+[m[32m{[m
[32m+[m[32m    StartPosY = ImGui::GetCursorPosY();[m
[32m+[m[32m    ItemsHeight = items_height;[m
[32m+[m[32m    ItemsCount = count;[m
[32m+[m[32m    StepNo = 0;[m
[32m+[m[32m    DisplayEnd = DisplayStart = -1;[m
[32m+[m[32m    if (ItemsHeight > 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::CalcListClipping(ItemsCount, ItemsHeight, &DisplayStart, &DisplayEnd); // calculate how many to clip/display[m
[32m+[m[32m        if (DisplayStart > 0)[m
[32m+[m[32m            SetCursorPosYAndSetupDummyPrevLine(StartPosY + DisplayStart * ItemsHeight, ItemsHeight); // advance cursor[m
[32m+[m[32m        StepNo = 2;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGuiListClipper::End()[m
[32m+[m[32m{[m
[32m+[m[32m    if (ItemsCount < 0)[m
[32m+[m[32m        return;[m
[32m+[m[32m    // In theory here we should assert that ImGui::GetCursorPosY() == StartPosY + DisplayEnd * ItemsHeight, but it feels saner to just seek at the end and not assert/crash the user.[m
[32m+[m[32m    if (ItemsCount < INT_MAX)[m
[32m+[m[32m        SetCursorPosYAndSetupDummyPrevLine(StartPosY + ItemsCount * ItemsHeight, ItemsHeight); // advance cursor[m
[32m+[m[32m    ItemsCount = -1;[m
[32m+[m[32m    StepNo = 3;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGuiListClipper::Step()[m
[32m+[m[32m{[m
[32m+[m[32m    if (ItemsCount == 0 || ImGui::GetCurrentWindowRead()->SkipItems)[m
[32m+[m[32m    {[m
[32m+[m[32m        ItemsCount = -1;[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (StepNo == 0) // Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height.[m
[32m+[m[32m    {[m
[32m+[m[32m        DisplayStart = 0;[m
[32m+[m[32m        DisplayEnd = 1;[m
[32m+[m[32m        StartPosY = ImGui::GetCursorPosY();[m
[32m+[m[32m        StepNo = 1;[m
[32m+[m[32m        return true;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (StepNo == 1) // Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.[m
[32m+[m[32m    {[m
[32m+[m[32m        if (ItemsCount == 1) { ItemsCount = -1; return false; }[m
[32m+[m[32m        float items_height = ImGui::GetCursorPosY() - StartPosY;[m
[32m+[m[32m        IM_ASSERT(items_height > 0.0f);   // If this triggers, it means Item 0 hasn't moved the cursor vertically[m
[32m+[m[32m        Begin(ItemsCount-1, items_height);[m
[32m+[m[32m        DisplayStart++;[m
[32m+[m[32m        DisplayEnd++;[m
[32m+[m[32m        StepNo = 3;[m
[32m+[m[32m        return true;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (StepNo == 2) // Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user still call Step(). Does nothing and switch to Step 3.[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(DisplayStart >= 0 && DisplayEnd >= 0);[m
[32m+[m[32m        StepNo = 3;[m
[32m+[m[32m        return true;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (StepNo == 3) // Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.[m
[32m+[m[32m        End();[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] RENDER HELPERS[m
[32m+[m[32m// Those (internal) functions are currently quite a legacy mess - their signature and behavior will change.[m
[32m+[m[32m// Also see imgui_draw.cpp for some more which have been reworked to not rely on ImGui:: state.[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mconst char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)[m
[32m+[m[32m{[m
[32m+[m[32m    const char* text_display_end = text;[m
[32m+[m[32m    if (!text_end)[m
[32m+[m[32m        text_end = (const char*)-1;[m
[32m+[m
[32m+[m[32m    while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))[m
[32m+[m[32m        text_display_end++;[m
[32m+[m[32m    return text_display_end;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Internal ImGui functions to render text[m
[32m+[m[32m// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()[m
[32m+[m[32mvoid ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m
[32m+[m[32m    // Hide anything after a '##' string[m
[32m+[m[32m    const char* text_display_end;[m
[32m+[m[32m    if (hide_text_after_hash)[m
[32m+[m[32m    {[m
[32m+[m[32m        text_display_end = FindRenderedTextEnd(text, text_end);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        if (!text_end)[m
[32m+[m[32m            text_end = text + strlen(text); // FIXME-OPT[m
[32m+[m[32m        text_display_end = text_end;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (text != text_display_end)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);[m
[32m+[m[32m        if (g.LogEnabled)[m
[32m+[m[32m            LogRenderedText(&pos, text, text_display_end);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m
[32m+[m[32m    if (!text_end)[m
[32m+[m[32m        text_end = text + strlen(text); // FIXME-OPT[m
[32m+[m
[32m+[m[32m    if (text != text_end)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_end, wrap_width);[m
[32m+[m[32m        if (g.LogEnabled)[m
[32m+[m[32m            LogRenderedText(&pos, text, text_end);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Default clip_rect uses (pos_min,pos_max)[m
[32m+[m[32m// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)[m
[32m+[m[32mvoid ImGui::RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_display_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)[m
[32m+[m[32m{[m
[32m+[m[32m    // Perform CPU side clipping for single clipped element to avoid using scissor state[m
[32m+[m[32m    ImVec2 pos = pos_min;[m
[32m+[m[32m    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);[m
[32m+[m
[32m+[m[32m    const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;[m
[32m+[m[32m    const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;[m
[32m+[m[32m    bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);[m
[32m+[m[32m    if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min[m
[32m+[m[32m        need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);[m
[32m+[m
[32m+[m[32m    // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.[m
[32m+[m[32m    if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);[m
[32m+[m[32m    if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);[m
[32m+[m
[32m+[m[32m    // Render[m
[32m+[m[32m    if (need_clipping)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);[m
[32m+[m[32m        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)[m
[32m+[m[32m{[m
[32m+[m[32m    // Hide anything after a '##' string[m
[32m+[m[32m    const char* text_display_end = FindRenderedTextEnd(text, text_end);[m
[32m+[m[32m    const int text_len = (int)(text_display_end - text);[m
[32m+[m[32m    if (text_len == 0)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);[m
[32m+[m[32m    if (g.LogEnabled)[m
[32m+[m[32m        LogRenderedText(&pos_min, text, text_display_end);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Render a rectangle shaped with optional rounding and borders[m
[32m+[m[32mvoid ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);[m
[32m+[m[32m    const float border_size = g.Style.FrameBorderSize;[m
[32m+[m[32m    if (border && border_size > 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->DrawList->AddRect(p_min+ImVec2(1,1), p_max+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);[m
[32m+[m[32m        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    const float border_size = g.Style.FrameBorderSize;[m
[32m+[m[32m    if (border_size > 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->DrawList->AddRect(p_min+ImVec2(1,1), p_max+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);[m
[32m+[m[32m        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Render an arrow aimed to be aligned with text (p_min is a position in the same space text would be positioned). To e.g. denote expanded/collapsed state[m
[32m+[m[32mvoid ImGui::RenderArrow(ImVec2 p_min, ImGuiDir dir, float scale)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    const float h = g.FontSize * 1.00f;[m
[32m+[m[32m    float r = h * 0.40f * scale;[m
[32m+[m[32m    ImVec2 center = p_min + ImVec2(h * 0.50f, h * 0.50f * scale);[m
[32m+[m
[32m+[m[32m    ImVec2 a, b, c;[m
[32m+[m[32m    switch (dir)[m
[32m+[m[32m    {[m
[32m+[m[32m    case ImGuiDir_Up:[m
[32m+[m[32m    case ImGuiDir_Down:[m
[32m+[m[32m        if (dir == ImGuiDir_Up) r = -r;[m
[32m+[m[32m        a = ImVec2(+0.000f,+0.750f) * r;[m
[32m+[m[32m        b = ImVec2(-0.866f,-0.750f) * r;[m
[32m+[m[32m        c = ImVec2(+0.866f,-0.750f) * r;[m
[32m+[m[32m        break;[m
[32m+[m[32m    case ImGuiDir_Left:[m
[32m+[m[32m    case ImGuiDir_Right:[m
[32m+[m[32m        if (dir == ImGuiDir_Left) r = -r;[m
[32m+[m[32m        a = ImVec2(+0.750f,+0.000f) * r;[m
[32m+[m[32m        b = ImVec2(-0.750f,+0.866f) * r;[m
[32m+[m[32m        c = ImVec2(-0.750f,-0.866f) * r;[m
[32m+[m[32m        break;[m
[32m+[m[32m    case ImGuiDir_None:[m
[32m+[m[32m    case ImGuiDir_COUNT:[m
[32m+[m[32m        IM_ASSERT(0);[m
[32m+[m[32m        break;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    g.CurrentWindow->DrawList->AddTriangleFilled(center + a, center + b, center + c, GetColorU32(ImGuiCol_Text));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::RenderBullet(ImVec2 pos)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    window->DrawList->AddCircleFilled(pos, g.FontSize*0.20f, GetColorU32(ImGuiCol_Text), 8);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::RenderCheckMark(ImVec2 pos, ImU32 col, float sz)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m
[32m+[m[32m    float thickness = ImMax(sz / 5.0f, 1.0f);[m
[32m+[m[32m    sz -= thickness*0.5f;[m
[32m+[m[32m    pos += ImVec2(thickness*0.25f, thickness*0.25f);[m
[32m+[m
[32m+[m[32m    float third = sz / 3.0f;[m
[32m+[m[32m    float bx = pos.x + third;[m
[32m+[m[32m    float by = pos.y + sz - third*0.5f;[m
[32m+[m[32m    window->DrawList->PathLineTo(ImVec2(bx - third, by - third));[m
[32m+[m[32m    window->DrawList->PathLineTo(ImVec2(bx, by));[m
[32m+[m[32m    window->DrawList->PathLineTo(ImVec2(bx + third*2, by - third*2));[m
[32m+[m[32m    window->DrawList->PathStroke(col, false, thickness);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (id != g.NavId)[m
[32m+[m[32m        return;[m
[32m+[m[32m    if (g.NavDisableHighlight && !(flags & ImGuiNavHighlightFlags_AlwaysDraw))[m
[32m+[m[32m        return;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (window->DC.NavHideHighlightOneFrame)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    float rounding = (flags & ImGuiNavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;[m
[32m+[m[32m    ImRect display_rect = bb;[m
[32m+[m[32m    display_rect.ClipWith(window->ClipRect);[m
[32m+[m[32m    if (flags & ImGuiNavHighlightFlags_TypeDefault)[m
[32m+[m[32m    {[m
[32m+[m[32m        const float THICKNESS = 2.0f;[m
[32m+[m[32m        const float DISTANCE = 3.0f + THICKNESS * 0.5f;[m
[32m+[m[32m        display_rect.Expand(ImVec2(DISTANCE,DISTANCE));[m
[32m+[m[32m        bool fully_visible = window->ClipRect.Contains(display_rect);[m
[32m+[m[32m        if (!fully_visible)[m
[32m+[m[32m            window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);[m
[32m+[m[32m        window->DrawList->AddRect(display_rect.Min + ImVec2(THICKNESS*0.5f,THICKNESS*0.5f), display_rect.Max - ImVec2(THICKNESS*0.5f,THICKNESS*0.5f), GetColorU32(ImGuiCol_NavHighlight), rounding, ImDrawCornerFlags_All, THICKNESS);[m
[32m+[m[32m        if (!fully_visible)[m
[32m+[m[32m            window->DrawList->PopClipRect();[m
[32m+[m[32m    }[m
[32m+[m[32m    if (flags & ImGuiNavHighlightFlags_TypeThin)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, ~0, 1.0f);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// ImGuiWindow is mostly a dumb struct. It merely has a constructor and a few helper methods[m
[32m+[m[32mImGuiWindow::ImGuiWindow(ImGuiContext* context, const char* name)[m
[32m+[m[32m    : DrawListInst(&context->DrawListSharedData)[m
[32m+[m[32m{[m
[32m+[m[32m    Name = ImStrdup(name);[m
[32m+[m[32m    ID = ImHashStr(name);[m
[32m+[m[32m    IDStack.push_back(ID);[m
[32m+[m[32m    Flags = ImGuiWindowFlags_None;[m
[32m+[m[32m    Pos = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    Size = SizeFull = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    SizeContents = SizeContentsExplicit = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    WindowPadding = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    WindowRounding = 0.0f;[m
[32m+[m[32m    WindowBorderSize = 0.0f;[m
[32m+[m[32m    NameBufLen = (int)strlen(name) + 1;[m
[32m+[m[32m    MoveId = GetID("#MOVE");[m
[32m+[m[32m    ChildId = 0;[m
[32m+[m[32m    Scroll = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);[m
[32m+[m[32m    ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);[m
[32m+[m[32m    ScrollbarSizes = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    ScrollbarX = ScrollbarY = false;[m
[32m+[m[32m    Active = WasActive = false;[m
[32m+[m[32m    WriteAccessed = false;[m
[32m+[m[32m    Collapsed = false;[m
[32m+[m[32m    WantCollapseToggle = false;[m
[32m+[m[32m    SkipItems = false;[m
[32m+[m[32m    Appearing = false;[m
[32m+[m[32m    Hidden = false;[m
[32m+[m[32m    HasCloseButton = false;[m
[32m+[m[32m    ResizeBorderHeld = -1;[m
[32m+[m[32m    BeginCount = 0;[m
[32m+[m[32m    BeginOrderWithinParent = -1;[m
[32m+[m[32m    BeginOrderWithinContext = -1;[m
[32m+[m[32m    PopupId = 0;[m
[32m+[m[32m    AutoFitFramesX = AutoFitFramesY = -1;[m
[32m+[m[32m    AutoFitOnlyGrows = false;[m
[32m+[m[32m    AutoFitChildAxises = 0x00;[m
[32m+[m[32m    AutoPosLastDirection = ImGuiDir_None;[m
[32m+[m[32m    HiddenFramesCanSkipItems = HiddenFramesCannotSkipItems = 0;[m
[32m+[m[32m    SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;[m
[32m+[m[32m    SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);[m
[32m+[m
[32m+[m[32m    LastFrameActive = -1;[m
[32m+[m[32m    ItemWidthDefault = 0.0f;[m
[32m+[m[32m    FontWindowScale = 1.0f;[m
[32m+[m[32m    SettingsIdx = -1;[m
[32m+[m
[32m+[m[32m    DrawList = &DrawListInst;[m
[32m+[m[32m    DrawList->_OwnerName = Name;[m
[32m+[m[32m    ParentWindow = NULL;[m
[32m+[m[32m    RootWindow = NULL;[m
[32m+[m[32m    RootWindowForTitleBarHighlight = NULL;[m
[32m+[m[32m    RootWindowForNav = NULL;[m
[32m+[m
[32m+[m[32m    NavLastIds[0] = NavLastIds[1] = 0;[m
[32m+[m[32m    NavRectRel[0] = NavRectRel[1] = ImRect();[m
[32m+[m[32m    NavLastChildNavWindow = NULL;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiWindow::~ImGuiWindow()[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(DrawList == &DrawListInst);[m
[32m+[m[32m    IM_DELETE(Name);[m
[32m+[m[32m    for (int i = 0; i != ColumnsStorage.Size; i++)[m
[32m+[m[32m        ColumnsStorage[i].~ImGuiColumns();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiID seed = IDStack.back();[m
[32m+[m[32m    ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);[m
[32m+[m[32m    ImGui::KeepAliveID(id);[m
[32m+[m[32m    return id;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiID ImGuiWindow::GetID(const void* ptr)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiID seed = IDStack.back();[m
[32m+[m[32m    ImGuiID id = ImHashData(&ptr, sizeof(void*), seed);[m
[32m+[m[32m    ImGui::KeepAliveID(id);[m
[32m+[m[32m    return id;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiID ImGuiWindow::GetIDNoKeepAlive(const char* str, const char* str_end)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiID seed = IDStack.back();[m
[32m+[m[32m    return ImHashStr(str, str_end ? (str_end - str) : 0, seed);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiID ImGuiWindow::GetIDNoKeepAlive(const void* ptr)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiID seed = IDStack.back();[m
[32m+[m[32m    return ImHashData(&ptr, sizeof(void*), seed);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// This is only used in rare/specific situations to manufacture an ID out of nowhere.[m
[32m+[m[32mImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect& r_abs)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiID seed = IDStack.back();[m
[32m+[m[32m    const int r_rel[4] = { (int)(r_abs.Min.x - Pos.x), (int)(r_abs.Min.y - Pos.y), (int)(r_abs.Max.x - Pos.x), (int)(r_abs.Max.y - Pos.y) };[m
[32m+[m[32m    ImGuiID id = ImHashData(&r_rel, sizeof(r_rel), seed);[m
[32m+[m[32m    ImGui::KeepAliveID(id);[m
[32m+[m[32m    return id;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void SetCurrentWindow(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.CurrentWindow = window;[m
[32m+[m[32m    if (window)[m
[32m+[m[32m        g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetNavID(ImGuiID id, int nav_layer)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(g.NavWindow);[m
[32m+[m[32m    IM_ASSERT(nav_layer == 0 || nav_layer == 1);[m
[32m+[m[32m    g.NavId = id;[m
[32m+[m[32m    g.NavWindow->NavLastIds[nav_layer] = id;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetNavIDWithRectRel(ImGuiID id, int nav_layer, const ImRect& rect_rel)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    SetNavID(id, nav_layer);[m
[32m+[m[32m    g.NavWindow->NavRectRel[nav_layer] = rect_rel;[m
[32m+[m[32m    g.NavMousePosDirty = true;[m
[32m+[m[32m    g.NavDisableHighlight = false;[m
[32m+[m[32m    g.NavDisableMouseHover = true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.ActiveIdIsJustActivated = (g.ActiveId != id);[m
[32m+[m[32m    if (g.ActiveIdIsJustActivated)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.ActiveIdTimer = 0.0f;[m
[32m+[m[32m        g.ActiveIdHasBeenPressed = false;[m
[32m+[m[32m        g.ActiveIdHasBeenEdited = false;[m
[32m+[m[32m        if (id != 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            g.LastActiveId = id;[m
[32m+[m[32m            g.LastActiveIdTimer = 0.0f;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    g.ActiveId = id;[m
[32m+[m[32m    g.ActiveIdAllowNavDirFlags = 0;[m
[32m+[m[32m    g.ActiveIdBlockNavInputFlags = 0;[m
[32m+[m[32m    g.ActiveIdAllowOverlap = false;[m
[32m+[m[32m    g.ActiveIdWindow = window;[m
[32m+[m[32m    if (id)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.ActiveIdIsAlive = id;[m
[32m+[m[32m        g.ActiveIdSource = (g.NavActivateId == id || g.NavInputId == id || g.NavJustTabbedId == id || g.NavJustMovedToId == id) ? ImGuiInputSource_Nav : ImGuiInputSource_Mouse;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// FIXME-NAV: The existence of SetNavID/SetNavIDWithRectRel/SetFocusID is incredibly messy and confusing and needs some explanation or refactoring.[m
[32m+[m[32mvoid ImGui::SetFocusID(ImGuiID id, ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(id != 0);[m
[32m+[m
[32m+[m[32m    // Assume that SetFocusID() is called in the context where its NavLayer is the current layer, which is the case everywhere we call it.[m
[32m+[m[32m    const ImGuiNavLayer nav_layer = window->DC.NavLayerCurrent;[m
[32m+[m[32m    if (g.NavWindow != window)[m
[32m+[m[32m        g.NavInitRequest = false;[m
[32m+[m[32m    g.NavId = id;[m
[32m+[m[32m    g.NavWindow = window;[m
[32m+[m[32m    g.NavLayer = nav_layer;[m
[32m+[m[32m    window->NavLastIds[nav_layer] = id;[m
[32m+[m[32m    if (window->DC.LastItemId == id)[m
[32m+[m[32m        window->NavRectRel[nav_layer] = ImRect(window->DC.LastItemRect.Min - window->Pos, window->DC.LastItemRect.Max - window->Pos);[m
[32m+[m
[32m+[m[32m    if (g.ActiveIdSource == ImGuiInputSource_Nav)[m
[32m+[m[32m        g.NavDisableMouseHover = true;[m
[32m+[m[32m    else[m
[32m+[m[32m        g.NavDisableHighlight = true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::ClearActiveID()[m
[32m+[m[32m{[m
[32m+[m[32m    SetActiveID(0, NULL);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetHoveredID(ImGuiID id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.HoveredId = id;[m
[32m+[m[32m    g.HoveredIdAllowOverlap = false;[m
[32m+[m[32m    if (id != 0 && g.HoveredIdPreviousFrame != id)[m
[32m+[m[32m        g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiID ImGui::GetHoveredID()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::KeepAliveID(ImGuiID id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.ActiveId == id)[m
[32m+[m[32m        g.ActiveIdIsAlive = id;[m
[32m+[m[32m    if (g.ActiveIdPreviousFrame == id)[m
[32m+[m[32m        g.ActiveIdPreviousFrameIsAlive = true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::MarkItemEdited(ImGuiID id)[m
[32m+[m[32m{[m
[32m+[m[32m    // This marking is solely to be able to provide info for IsItemDeactivatedAfterEdit().[m
[32m+[m[32m    // ActiveId might have been released by the time we call this (as in the typical press/release button behavior) but still need need to fill the data.[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(g.ActiveId == id || g.ActiveId == 0 || g.DragDropActive);[m
[32m+[m[32m    IM_UNUSED(id); // Avoid unused variable warnings when asserts are compiled out.[m
[32m+[m[32m    //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);[m
[32m+[m[32m    g.ActiveIdHasBeenEdited = true;[m
[32m+[m[32m    g.CurrentWindow->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_Edited;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic inline bool IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    // An active popup disable hovering on other windows (apart from its own children)[m
[32m+[m[32m    // FIXME-OPT: This could be cached/stored within the window.[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.NavWindow)[m
[32m+[m[32m        if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindow)[m
[32m+[m[32m            if (focused_root_window->WasActive && focused_root_window != window->RootWindow)[m
[32m+[m[32m            {[m
[32m+[m[32m                // For the purpose of those flags we differentiate "standard popup" from "modal popup"[m
[32m+[m[32m                // NB: The order of those two tests is important because Modal windows are also Popups.[m
[32m+[m[32m                if (focused_root_window->Flags & ImGuiWindowFlags_Modal)[m
[32m+[m[32m                    return false;[m
[32m+[m[32m                if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))[m
[32m+[m[32m                    return false;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Advance cursor given item size for layout.[m
[32m+[m[32mvoid ImGui::ItemSize(const ImVec2& size, float text_offset_y)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // Always align ourselves on pixel boundaries[m
[32m+[m[32m    const float line_height = ImMax(window->DC.CurrentLineSize.y, size.y);[m
[32m+[m[32m    const float text_base_offset = ImMax(window->DC.CurrentLineTextBaseOffset, text_offset_y);[m
[32m+[m[32m    //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG][m
[32m+[m[32m    window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x + size.x, window->DC.CursorPos.y);[m
[32m+[m[32m    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);[m
[32m+[m[32m    window->DC.CursorPos.y = (float)(int)(window->DC.CursorPos.y + line_height + g.Style.ItemSpacing.y);[m
[32m+[m[32m    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);[m
[32m+[m[32m    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);[m
[32m+[m[32m    //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG][m
[32m+[m
[32m+[m[32m    window->DC.PrevLineSize.y = line_height;[m
[32m+[m[32m    window->DC.PrevLineTextBaseOffset = text_base_offset;[m
[32m+[m[32m    window->DC.CurrentLineSize.y = window->DC.CurrentLineTextBaseOffset = 0.0f;[m
[32m+[m
[32m+[m[32m    // Horizontal layout mode[m
[32m+[m[32m    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)[m
[32m+[m[32m        SameLine();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::ItemSize(const ImRect& bb, float text_offset_y)[m
[32m+[m[32m{[m
[32m+[m[32m    ItemSize(bb.GetSize(), text_offset_y);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Declare item bounding box for clipping and interaction.[m
[32m+[m[32m// Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface[m
[32m+[m[32m// declare their minimum size requirement to ItemSize() and then use a larger region for drawing/interaction, which is passed to ItemAdd().[m
[32m+[m[32mbool ImGui::ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb_arg)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m
[32m+[m[32m    if (id != 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Navigation processing runs prior to clipping early-out[m
[32m+[m[32m        //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget[m
[32m+[m[32m        //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests unfortunately, but it is still limited to one window.[m
[32m+[m[32m        //      it may not scale very well for windows with ten of thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.[m
[32m+[m[32m        //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick)[m
[32m+[m[32m        window->DC.NavLayerActiveMaskNext |= window->DC.NavLayerCurrentMask;[m
[32m+[m[32m        if (g.NavId == id || g.NavAnyRequest)[m
[32m+[m[32m            if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)[m
[32m+[m[32m                if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))[m
[32m+[m[32m                    NavProcessItem(window, nav_bb_arg ? *nav_bb_arg : bb, id);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    window->DC.LastItemId = id;[m
[32m+[m[32m    window->DC.LastItemRect = bb;[m
[32m+[m[32m    window->DC.LastItemStatusFlags = ImGuiItemStatusFlags_None;[m
[32m+[m
[32m+[m[32m#ifdef IMGUI_ENABLE_TEST_ENGINE[m
[32m+[m[32m    if (id != 0)[m
[32m+[m[32m        IMGUI_TEST_ENGINE_ITEM_ADD(nav_bb_arg ? *nav_bb_arg : bb, id);[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m    // Clipping test[m
[32m+[m[32m    const bool is_clipped = IsClippedEx(bb, id, false);[m
[32m+[m[32m    if (is_clipped)[m
[32m+[m[32m        return false;[m
[32m+[m[32m    //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG][m
[32m+[m
[32m+[m[32m    // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)[m
[32m+[m[32m    if (IsMouseHoveringRect(bb.Min, bb.Max))[m
[32m+[m[32m        window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HoveredRect;[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// This is roughly matching the behavior of internal-facing ItemHoverable()[m
[32m+[m[32m// - we allow hovering to be true when ActiveId==window->MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()[m
[32m+[m[32m// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId[m
[32m+[m[32mbool ImGui::IsItemHovered(ImGuiHoveredFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (g.NavDisableMouseHover && !g.NavDisableHighlight)[m
[32m+[m[32m        return IsItemFocused();[m
[32m+[m
[32m+[m[32m    // Test for bounding box overlap, as updated as ItemAdd()[m
[32m+[m[32m    if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))[m
[32m+[m[32m        return false;[m
[32m+[m[32m    IM_ASSERT((flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows)) == 0);   // Flags not supported by this function[m
[32m+[m
[32m+[m[32m    // Test if we are hovering the right window (our window could be behind another window)[m
[32m+[m[32m    // [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable to use IsItemHovered() after EndChild() itself.[m
[32m+[m[32m    // Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was the test that has been running for a long while.[m
[32m+[m[32m    //if (g.HoveredWindow != window)[m
[32m+[m[32m    //    return false;[m
[32m+[m[32m    if (g.HoveredRootWindow != window->RootWindow && !(flags & ImGuiHoveredFlags_AllowWhenOverlapped))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    // Test if another item is active (e.g. being dragged)[m
[32m+[m[32m    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))[m
[32m+[m[32m        if (g.ActiveId != 0 && g.ActiveId != window->DC.LastItemId && !g.ActiveIdAllowOverlap && g.ActiveId != window->MoveId)[m
[32m+[m[32m            return false;[m
[32m+[m
[32m+[m[32m    // Test if interactions on this window are blocked by an active popup or modal.[m
[32m+[m[32m    // The ImGuiHoveredFlags_AllowWhenBlockedByPopup flag will be tested here.[m
[32m+[m[32m    if (!IsWindowContentHoverable(window, flags))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    // Test if the item is disabled[m
[32m+[m[32m    if ((window->DC.ItemFlags & ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_AllowWhenDisabled))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    // Special handling for the dummy item after Begin() which represent the title bar or tab.[m
[32m+[m[32m    // When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect the case.[m
[32m+[m[32m    if (window->DC.LastItemId == window->MoveId && window->WriteAccessed)[m
[32m+[m[32m        return false;[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().[m
[32m+[m[32mbool ImGui::ItemHoverable(const ImRect& bb, ImGuiID id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (g.HoveredWindow != window)[m
[32m+[m[32m        return false;[m
[32m+[m[32m    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)[m
[32m+[m[32m        return false;[m
[32m+[m[32m    if (!IsMouseHoveringRect(bb.Min, bb.Max))[m
[32m+[m[32m        return false;[m
[32m+[m[32m    if (g.NavDisableMouseHover || !IsWindowContentHoverable(window, ImGuiHoveredFlags_None))[m
[32m+[m[32m        return false;[m
[32m+[m[32m    if (window->DC.ItemFlags & ImGuiItemFlags_Disabled)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    SetHoveredID(id);[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (!bb.Overlaps(window->ClipRect))[m
[32m+[m[32m        if (id == 0 || id != g.ActiveId)[m
[32m+[m[32m            if (clip_even_when_logged || !g.LogEnabled)[m
[32m+[m[32m                return true;[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Process TAB/Shift+TAB. Be mindful that this function may _clear_ the ActiveID when tabbing out.[m
[32m+[m[32mbool ImGui::FocusableItemRegister(ImGuiWindow* window, ImGuiID id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    // Increment counters[m
[32m+[m[32m    const bool is_tab_stop = (window->DC.ItemFlags & (ImGuiItemFlags_NoTabStop | ImGuiItemFlags_Disabled)) == 0;[m
[32m+[m[32m    window->DC.FocusCounterAll++;[m
[32m+[m[32m    if (is_tab_stop)[m
[32m+[m[32m        window->DC.FocusCounterTab++;[m
[32m+[m
[32m+[m[32m    // Process TAB/Shift-TAB to tab *OUT* of the currently focused item.[m
[32m+[m[32m    // (Note that we can always TAB out of a widget that doesn't allow tabbing in)[m
[32m+[m[32m    if (g.ActiveId == id && g.FocusTabPressed && !(g.ActiveIdBlockNavInputFlags & (1 << ImGuiNavInput_KeyTab_)) && g.FocusRequestNextWindow == NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.FocusRequestNextWindow = window;[m
[32m+[m[32m        g.FocusRequestNextCounterTab = window->DC.FocusCounterTab + (g.IO.KeyShift ? (is_tab_stop ? -1 : 0) : +1); // Modulo on index will be applied at the end of frame once we've got the total counter of items.[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Handle focus requests[m
[32m+[m[32m    if (g.FocusRequestCurrWindow == window)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (window->DC.FocusCounterAll == g.FocusRequestCurrCounterAll)[m
[32m+[m[32m            return true;[m
[32m+[m[32m        if (is_tab_stop && window->DC.FocusCounterTab == g.FocusRequestCurrCounterTab)[m
[32m+[m[32m        {[m
[32m+[m[32m            g.NavJustTabbedId = id;[m
[32m+[m[32m            return true;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // If another item is about to be focused, we clear our own active id[m
[32m+[m[32m        if (g.ActiveId == id)[m
[32m+[m[32m            ClearActiveID();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::FocusableItemUnregister(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    window->DC.FocusCounterAll--;[m
[32m+[m[32m    window->DC.FocusCounterTab--;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)[m
[32m+[m[32m{[m
[32m+[m[32m    if (wrap_pos_x < 0.0f)[m
[32m+[m[32m        return 0.0f;[m
[32m+[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    if (wrap_pos_x == 0.0f)[m
[32m+[m[32m        wrap_pos_x = GetWorkRectMax().x;[m
[32m+[m[32m    else if (wrap_pos_x > 0.0f)[m
[32m+[m[32m        wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space[m
[32m+[m
[32m+[m[32m    return ImMax(wrap_pos_x - pos.x, 1.0f);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// IM_ALLOC() == ImGui::MemAlloc()[m
[32m+[m[32mvoid* ImGui::MemAlloc(size_t size)[m
[32m+[m[32m{[m
[32m+[m[32m    if (ImGuiContext* ctx = GImGui)[m
[32m+[m[32m        ctx->IO.MetricsActiveAllocations++;[m
[32m+[m[32m    return GImAllocatorAllocFunc(size, GImAllocatorUserData);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// IM_FREE() == ImGui::MemFree()[m
[32m+[m[32mvoid ImGui::MemFree(void* ptr)[m
[32m+[m[32m{[m
[32m+[m[32m    if (ptr)[m
[32m+[m[32m        if (ImGuiContext* ctx = GImGui)[m
[32m+[m[32m            ctx->IO.MetricsActiveAllocations--;[m
[32m+[m[32m    return GImAllocatorFreeFunc(ptr, GImAllocatorUserData);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst char* ImGui::GetClipboardText()[m
[32m+[m[32m{[m
[32m+[m[32m    return GImGui->IO.GetClipboardTextFn ? GImGui->IO.GetClipboardTextFn(GImGui->IO.ClipboardUserData) : "";[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetClipboardText(const char* text)[m
[32m+[m[32m{[m
[32m+[m[32m    if (GImGui->IO.SetClipboardTextFn)[m
[32m+[m[32m        GImGui->IO.SetClipboardTextFn(GImGui->IO.ClipboardUserData, text);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst char* ImGui::GetVersion()[m
[32m+[m[32m{[m
[32m+[m[32m    return IMGUI_VERSION;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Internal state access - if you want to share ImGui state between modules (e.g. DLL) or allocate it yourself[m
[32m+[m[32m// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module[m
[32m+[m[32mImGuiContext* ImGui::GetCurrentContext()[m
[32m+[m[32m{[m
[32m+[m[32m    return GImGui;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetCurrentContext(ImGuiContext* ctx)[m
[32m+[m[32m{[m
[32m+[m[32m#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC[m
[32m+[m[32m    IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.[m
[32m+[m[32m#else[m
[32m+[m[32m    GImGui = ctx;[m
[32m+[m[32m#endif[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Helper function to verify ABI compatibility between caller code and compiled version of Dear ImGui.[m
[32m+[m[32m// Verify that the type sizes are matching between the calling file's compilation unit and imgui.cpp's compilation unit[m
[32m+[m[32m// If the user has inconsistent compilation settings, imgui configuration #define, packing pragma, etc. your user code[m
[32m+[m[32m// may see different structures thanwhat imgui.cpp sees, which is problematic.[m
[32m+[m[32m// We usually require settings to be in imconfig.h to make sure that they are accessible to all compilation units involved with Dear ImGui.[m
[32m+[m[32mbool ImGui::DebugCheckVersionAndDataLayout(const char* version, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_vert, size_t sz_idx)[m
[32m+[m[32m{[m
[32m+[m[32m    bool error = false;[m
[32m+[m[32m    if (strcmp(version, IMGUI_VERSION)!=0) { error = true; IM_ASSERT(strcmp(version,IMGUI_VERSION)==0 && "Mismatched version string!");  }[m
[32m+[m[32m    if (sz_io    != sizeof(ImGuiIO))       { error = true; IM_ASSERT(sz_io    == sizeof(ImGuiIO)      && "Mismatched struct layout!"); }[m
[32m+[m[32m    if (sz_style != sizeof(ImGuiStyle))    { error = true; IM_ASSERT(sz_style == sizeof(ImGuiStyle)   && "Mismatched struct layout!"); }[m
[32m+[m[32m    if (sz_vec2  != sizeof(ImVec2))        { error = true; IM_ASSERT(sz_vec2  == sizeof(ImVec2)       && "Mismatched struct layout!"); }[m
[32m+[m[32m    if (sz_vec4  != sizeof(ImVec4))        { error = true; IM_ASSERT(sz_vec4  == sizeof(ImVec4)       && "Mismatched struct layout!"); }[m
[32m+[m[32m    if (sz_vert  != sizeof(ImDrawVert))    { error = true; IM_ASSERT(sz_vert  == sizeof(ImDrawVert)   && "Mismatched struct layout!"); }[m
[32m+[m[32m    if (sz_idx   != sizeof(ImDrawIdx))     { error = true; IM_ASSERT(sz_idx   == sizeof(ImDrawIdx)    && "Mismatched struct layout!"); }[m
[32m+[m[32m    return !error;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void (*free_func)(void* ptr, void* user_data), void* user_data)[m
[32m+[m[32m{[m
[32m+[m[32m    GImAllocatorAllocFunc = alloc_func;[m
[32m+[m[32m    GImAllocatorFreeFunc = free_func;[m
[32m+[m[32m    GImAllocatorUserData = user_data;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiContext* ImGui::CreateContext(ImFontAtlas* shared_font_atlas)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);[m
[32m+[m[32m    if (GImGui == NULL)[m
[32m+[m[32m        SetCurrentContext(ctx);[m
[32m+[m[32m    Initialize(ctx);[m
[32m+[m[32m    return ctx;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::DestroyContext(ImGuiContext* ctx)[m
[32m+[m[32m{[m
[32m+[m[32m    if (ctx == NULL)[m
[32m+[m[32m        ctx = GImGui;[m
[32m+[m[32m    Shutdown(ctx);[m
[32m+[m[32m    if (GImGui == ctx)[m
[32m+[m[32m        SetCurrentContext(NULL);[m
[32m+[m[32m    IM_DELETE(ctx);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiIO& ImGui::GetIO()[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");[m
[32m+[m[32m    return GImGui->IO;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiStyle& ImGui::GetStyle()[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");[m
[32m+[m[32m    return GImGui->Style;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Same value as passed to the old io.RenderDrawListsFn function. Valid after Render() and until the next call to NewFrame()[m
[32m+[m[32mImDrawData* ImGui::GetDrawData()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.DrawData.Valid ? &g.DrawData : NULL;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mdouble ImGui::GetTime()[m
[32m+[m[32m{[m
[32m+[m[32m    return GImGui->Time;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImGui::GetFrameCount()[m
[32m+[m[32m{[m
[32m+[m[32m    return GImGui->FrameCount;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImDrawList* ImGui::GetBackgroundDrawList()[m
[32m+[m[32m{[m
[32m+[m[32m    return &GImGui->BackgroundDrawList;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic ImDrawList* GetForegroundDrawList(ImGuiWindow*)[m
[32m+[m[32m{[m
[32m+[m[32m    // This seemingly unnecessary wrapper simplifies compatibility between the 'master' and 'docking' branches.[m
[32m+[m[32m    return &GImGui->ForegroundDrawList;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImDrawList* ImGui::GetForegroundDrawList()[m
[32m+[m[32m{[m
[32m+[m[32m    return &GImGui->ForegroundDrawList;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImDrawListSharedData* ImGui::GetDrawListSharedData()[m
[32m+[m[32m{[m
[32m+[m[32m    return &GImGui->DrawListSharedData;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::StartMouseMovingWindow(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.[m
[32m+[m[32m    // We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.[m
[32m+[m[32m    // This is because we want ActiveId to be set even when the window is not permitted to move.[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    FocusWindow(window);[m
[32m+[m[32m    SetActiveID(window->MoveId, window);[m
[32m+[m[32m    g.NavDisableHighlight = true;[m
[32m+[m[32m    g.ActiveIdClickOffset = g.IO.MousePos - window->RootWindow->Pos;[m
[32m+[m
[32m+[m[32m    bool can_move_window = true;[m
[32m+[m[32m    if ((window->Flags & ImGuiWindowFlags_NoMove) || (window->RootWindow->Flags & ImGuiWindowFlags_NoMove))[m
[32m+[m[32m        can_move_window = false;[m
[32m+[m[32m    if (can_move_window)[m
[32m+[m[32m        g.MovingWindow = window;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Handle mouse moving window[m
[32m+[m[32m// Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()[m
[32m+[m[32mvoid ImGui::UpdateMouseMovingWindowNewFrame()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.MovingWindow != NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).[m
[32m+[m[32m        // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.[m
[32m+[m[32m        KeepAliveID(g.ActiveId);[m
[32m+[m[32m        IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindow);[m
[32m+[m[32m        ImGuiWindow* moving_window = g.MovingWindow->RootWindow;[m
[32m+[m[32m        if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;[m
[32m+[m[32m            if (moving_window->Pos.x != pos.x || moving_window->Pos.y != pos.y)[m
[32m+[m[32m            {[m
[32m+[m[32m                MarkIniSettingsDirty(moving_window);[m
[32m+[m[32m                SetWindowPos(moving_window, pos, ImGuiCond_Always);[m
[32m+[m[32m            }[m
[32m+[m[32m            FocusWindow(g.MovingWindow);[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            ClearActiveID();[m
[32m+[m[32m            g.MovingWindow = NULL;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.[m
[32m+[m[32m        if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)[m
[32m+[m[32m        {[m
[32m+[m[32m            KeepAliveID(g.ActiveId);[m
[32m+[m[32m            if (!g.IO.MouseDown[0])[m
[32m+[m[32m                ClearActiveID();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Initiate moving window, handle left-click and right-click focus[m
[32m+[m[32mvoid ImGui::UpdateMouseMovingWindowEndFrame()[m
[32m+[m[32m{[m
[32m+[m[32m    // Initiate moving window[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.ActiveId != 0 || g.HoveredId != 0)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // Unless we just made a window/popup appear[m
[32m+[m[32m    if (g.NavWindow && g.NavWindow->Appearing)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // Click to focus window and start moving (after we're done with all our widgets)[m
[32m+[m[32m    if (g.IO.MouseClicked[0])[m
[32m+[m[32m    {[m
[32m+[m[32m        if (g.HoveredRootWindow != NULL)[m
[32m+[m[32m        {[m
[32m+[m[32m            StartMouseMovingWindow(g.HoveredWindow);[m
[32m+[m[32m            if (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(g.HoveredRootWindow->Flags & ImGuiWindowFlags_NoTitleBar))[m
[32m+[m[32m                if (!g.HoveredRootWindow->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))[m
[32m+[m[32m                    g.MovingWindow = NULL;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (g.NavWindow != NULL && GetFrontMostPopupModal() == NULL)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Clicking on void disable focus[m
[32m+[m[32m            FocusWindow(NULL);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // With right mouse button we close popups without changing focus based on where the mouse is aimed[m
[32m+[m[32m    // Instead, focus will be restored to the window under the bottom-most closed popup.[m
[32m+[m[32m    // (The left mouse button path calls FocusWindow on the hovered window, which will lead NewFrame->ClosePopupsOverWindow to trigger)[m
[32m+[m[32m    if (g.IO.MouseClicked[1])[m
[32m+[m[32m    {[m
[32m+[m[32m        // Find the top-most window between HoveredWindow and the front most Modal Window.[m
[32m+[m[32m        // This is where we can trim the popup stack.[m
[32m+[m[32m        ImGuiWindow* modal = GetFrontMostPopupModal();[m
[32m+[m[32m        bool hovered_window_above_modal = false;[m
[32m+[m[32m        if (modal == NULL)[m
[32m+[m[32m            hovered_window_above_modal = true;[m
[32m+[m[32m        for (int i = g.Windows.Size - 1; i >= 0 && hovered_window_above_modal == false; i--)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGuiWindow* window = g.Windows[i];[m
[32m+[m[32m            if (window == modal)[m
[32m+[m[32m                break;[m
[32m+[m[32m            if (window == g.HoveredWindow)[m
[32m+[m[32m                hovered_window_above_modal = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal, true);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic bool IsWindowActiveAndVisible(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    return (window->Active) && (!window->Hidden);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void ImGui::UpdateMouseInputs()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    // Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)[m
[32m+[m[32m    if (IsMousePosValid(&g.IO.MousePos))[m
[32m+[m[32m        g.IO.MousePos = g.LastValidMousePos = ImFloor(g.IO.MousePos);[m
[32m+[m
[32m+[m[32m    // If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta[m
[32m+[m[32m    if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MousePosPrev))[m
[32m+[m[32m        g.IO.MouseDelta = g.IO.MousePos - g.IO.MousePosPrev;[m
[32m+[m[32m    else[m
[32m+[m[32m        g.IO.MouseDelta = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    if (g.IO.MouseDelta.x != 0.0f || g.IO.MouseDelta.y != 0.0f)[m
[32m+[m[32m        g.NavDisableMouseHover = false;[m
[32m+[m
[32m+[m[32m    g.IO.MousePosPrev = g.IO.MousePos;[m
[32m+[m[32m    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.IO.MouseClicked[i] = g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] < 0.0f;[m
[32m+[m[32m        g.IO.MouseReleased[i] = !g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] >= 0.0f;[m
[32m+[m[32m        g.IO.MouseDownDurationPrev[i] = g.IO.MouseDownDuration[i];[m
[32m+[m[32m        g.IO.MouseDownDuration[i] = g.IO.MouseDown[i] ? (g.IO.MouseDownDuration[i] < 0.0f ? 0.0f : g.IO.MouseDownDuration[i] + g.IO.DeltaTime) : -1.0f;[m
[32m+[m[32m        g.IO.MouseDoubleClicked[i] = false;[m
[32m+[m[32m        if (g.IO.MouseClicked[i])[m
[32m+[m[32m        {[m
[32m+[m[32m            if ((float)(g.Time - g.IO.MouseClickedTime[i]) < g.IO.MouseDoubleClickTime)[m
[32m+[m[32m            {[m
[32m+[m[32m                ImVec2 delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);[m
[32m+[m[32m                if (ImLengthSqr(delta_from_click_pos) < g.IO.MouseDoubleClickMaxDist * g.IO.MouseDoubleClickMaxDist)[m
[32m+[m[32m                    g.IO.MouseDoubleClicked[i] = true;[m
[32m+[m[32m                g.IO.MouseClickedTime[i] = -FLT_MAX;    // so the third click isn't turned into a double-click[m
[32m+[m[32m            }[m
[32m+[m[32m            else[m
[32m+[m[32m            {[m
[32m+[m[32m                g.IO.MouseClickedTime[i] = g.Time;[m
[32m+[m[32m            }[m
[32m+[m[32m            g.IO.MouseClickedPos[i] = g.IO.MousePos;[m
[32m+[m[32m            g.IO.MouseDownWasDoubleClick[i] = g.IO.MouseDoubleClicked[i];[m
[32m+[m[32m            g.IO.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m            g.IO.MouseDragMaxDistanceSqr[i] = 0.0f;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (g.IO.MouseDown[i])[m
[32m+[m[32m        {[m
[32m+[m[32m            // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold[m
[32m+[m[32m            ImVec2 delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);[m
[32m+[m[32m            g.IO.MouseDragMaxDistanceSqr[i] = ImMax(g.IO.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));[m
[32m+[m[32m            g.IO.MouseDragMaxDistanceAbs[i].x = ImMax(g.IO.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x);[m
[32m+[m[32m            g.IO.MouseDragMaxDistanceAbs[i].y = ImMax(g.IO.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!g.IO.MouseDown[i] && !g.IO.MouseReleased[i])[m
[32m+[m[32m            g.IO.MouseDownWasDoubleClick[i] = false;[m
[32m+[m[32m        if (g.IO.MouseClicked[i]) // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation[m
[32m+[m[32m            g.NavDisableMouseHover = false;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::UpdateMouseWheel()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (!g.HoveredWindow || g.HoveredWindow->Collapsed)[m
[32m+[m[32m        return;[m
[32m+[m[32m    if (g.IO.MouseWheel == 0.0f && g.IO.MouseWheelH == 0.0f)[m
[32m+[m[32m        return;[m
[32m+[m[32m    ImGuiWindow* window = g.HoveredWindow;[m
[32m+[m
[32m+[m[32m    // Zoom / Scale window[m
[32m+[m[32m    // FIXME-OBSOLETE: This is an old feature, it still works but pretty much nobody is using it and may be best redesigned.[m
[32m+[m[32m    if (g.IO.MouseWheel != 0.0f && g.IO.KeyCtrl && g.IO.FontAllowUserScaling)[m
[32m+[m[32m    {[m
[32m+[m[32m        const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);[m
[32m+[m[32m        const float scale = new_font_scale / window->FontWindowScale;[m
[32m+[m[32m        window->FontWindowScale = new_font_scale;[m
[32m+[m[32m        if (!(window->Flags & ImGuiWindowFlags_ChildWindow))[m
[32m+[m[32m        {[m
[32m+[m[32m            const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;[m
[32m+[m[32m            window->Pos = ImFloor(window->Pos + offset);[m
[32m+[m[32m            window->Size = ImFloor(window->Size * scale);[m
[32m+[m[32m            window->SizeFull = ImFloor(window->SizeFull * scale);[m
[32m+[m[32m        }[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Mouse wheel scrolling[m
[32m+[m[32m    // If a child window has the ImGuiWindowFlags_NoScrollWithMouse flag, we give a chance to scroll its parent (unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set).[m
[32m+[m[32m    while ((window->Flags & ImGuiWindowFlags_ChildWindow) && (window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs) && window->ParentWindow)[m
[32m+[m[32m        window = window->ParentWindow;[m
[32m+[m[32m    const bool scroll_allowed = !(window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs);[m
[32m+[m[32m    if (scroll_allowed && (g.IO.MouseWheel != 0.0f || g.IO.MouseWheelH != 0.0f) && !g.IO.KeyCtrl)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImVec2 max_step = (window->ContentsRegionRect.GetSize() + window->WindowPadding * 2.0f) * 0.67f;[m
[32m+[m
[32m+[m[32m        // Vertical Mouse Wheel Scrolling (hold Shift to scroll horizontally)[m
[32m+[m[32m        if (g.IO.MouseWheel != 0.0f && !g.IO.KeyShift)[m
[32m+[m[32m        {[m
[32m+[m[32m            float scroll_step = ImFloor(ImMin(5 * window->CalcFontSize(), max_step.y));[m
[32m+[m[32m            SetWindowScrollY(window, window->Scroll.y - g.IO.MouseWheel * scroll_step);[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (g.IO.MouseWheel != 0.0f && g.IO.KeyShift)[m
[32m+[m[32m        {[m
[32m+[m[32m            float scroll_step = ImFloor(ImMin(2 * window->CalcFontSize(), max_step.x));[m
[32m+[m[32m            SetWindowScrollX(window, window->Scroll.x - g.IO.MouseWheel * scroll_step);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Horizontal Mouse Wheel Scrolling (for hardware that supports it)[m
[32m+[m[32m        if (g.IO.MouseWheelH != 0.0f && !g.IO.KeyShift)[m
[32m+[m[32m        {[m
[32m+[m[32m            float scroll_step = ImFloor(ImMin(2 * window->CalcFontSize(), max_step.x));[m
[32m+[m[32m            SetWindowScrollX(window, window->Scroll.x - g.IO.MouseWheelH * scroll_step);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)[m
[32m+[m[32mvoid ImGui::UpdateHoveredWindowAndCaptureFlags()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    // Find the window hovered by mouse:[m
[32m+[m[32m    // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.[m
[32m+[m[32m    // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.[m
[32m+[m[32m    // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.[m
[32m+[m[32m    FindHoveredWindow();[m
[32m+[m
[32m+[m[32m    // Modal windows prevents cursor from hovering behind them.[m
[32m+[m[32m    ImGuiWindow* modal_window = GetFrontMostPopupModal();[m
[32m+[m[32m    if (modal_window)[m
[32m+[m[32m        if (g.HoveredRootWindow && !IsWindowChildOf(g.HoveredRootWindow, modal_window))[m
[32m+[m[32m            g.HoveredRootWindow = g.HoveredWindow = NULL;[m
[32m+[m
[32m+[m[32m    // Disabled mouse?[m
[32m+[m[32m    if (g.IO.ConfigFlags & ImGuiConfigFlags_NoMouse)[m
[32m+[m[32m        g.HoveredWindow = g.HoveredRootWindow = NULL;[m
[32m+[m
[32m+[m[32m    // We track click ownership. When clicked outside of a window the click is owned by the application and won't report hovering nor request capture even while dragging over our windows afterward.[m
[32m+[m[32m    int mouse_earliest_button_down = -1;[m
[32m+[m[32m    bool mouse_any_down = false;[m
[32m+[m[32m    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (g.IO.MouseClicked[i])[m
[32m+[m[32m            g.IO.MouseDownOwned[i] = (g.HoveredWindow != NULL) || (!g.OpenPopupStack.empty());[m
[32m+[m[32m        mouse_any_down |= g.IO.MouseDown[i];[m
[32m+[m[32m        if (g.IO.MouseDown[i])[m
[32m+[m[32m            if (mouse_earliest_button_down == -1 || g.IO.MouseClickedTime[i] < g.IO.MouseClickedTime[mouse_earliest_button_down])[m
[32m+[m[32m                mouse_earliest_button_down = i;[m
[32m+[m[32m    }[m
[32m+[m[32m    const bool mouse_avail_to_imgui = (mouse_earliest_button_down == -1) || g.IO.MouseDownOwned[mouse_earliest_button_down];[m
[32m+[m
[32m+[m[32m    // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.[m
[32m+[m[32m    // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)[m
[32m+[m[32m    const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;[m
[32m+[m[32m    if (!mouse_avail_to_imgui && !mouse_dragging_extern_payload)[m
[32m+[m[32m        g.HoveredWindow = g.HoveredRootWindow = NULL;[m
[32m+[m
[32m+[m[32m    // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to imgui, false = dispatch mouse info to imgui + app)[m
[32m+[m[32m    if (g.WantCaptureMouseNextFrame != -1)[m
[32m+[m[32m        g.IO.WantCaptureMouse = (g.WantCaptureMouseNextFrame != 0);[m
[32m+[m[32m    else[m
[32m+[m[32m        g.IO.WantCaptureMouse = (mouse_avail_to_imgui && (g.HoveredWindow != NULL || mouse_any_down)) || (!g.OpenPopupStack.empty());[m
[32m+[m
[32m+[m[32m    // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to imgui, false = dispatch keyboard info to imgui + app)[m
[32m+[m[32m    if (g.WantCaptureKeyboardNextFrame != -1)[m
[32m+[m[32m        g.IO.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);[m
[32m+[m[32m    else[m
[32m+[m[32m        g.IO.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);[m
[32m+[m[32m    if (g.IO.NavActive && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))[m
[32m+[m[32m        g.IO.WantCaptureKeyboard = true;[m
[32m+[m
[32m+[m[32m    // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible[m
[32m+[m[32m    g.IO.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::NewFrame()[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m#ifdef IMGUI_ENABLE_TEST_ENGINE[m
[32m+[m[32m    ImGuiTestEngineHook_PreNewFrame(&g);[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m    // Check user data[m
[32m+[m[32m    // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)[m
[32m+[m[32m    IM_ASSERT(g.Initialized);[m
[32m+[m[32m    IM_ASSERT((g.IO.DeltaTime > 0.0f || g.FrameCount == 0)              && "Need a positive DeltaTime!");[m
[32m+[m[32m    IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount)  && "Forgot to call Render() or EndFrame() at the end of the previous frame?");[m
[32m+[m[32m    IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f  && "Invalid DisplaySize value!");[m
[32m+[m[32m    IM_ASSERT(g.IO.Fonts->Fonts.Size > 0                                && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?");[m
[32m+[m[32m    IM_ASSERT(g.IO.Fonts->Fonts[0]->IsLoaded()                          && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?");[m
[32m+[m[32m    IM_ASSERT(g.Style.CurveTessellationTol > 0.0f                       && "Invalid style setting!");[m
[32m+[m[32m    IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f            && "Invalid style setting. Alpha cannot be negative (allows us to avoid a few clamps in color computations)!");[m
[32m+[m[32m    IM_ASSERT(g.Style.WindowMinSize.x >= 1.0f && g.Style.WindowMinSize.y >= 1.0f && "Invalid style setting.");[m
[32m+[m[32m    for (int n = 0; n < ImGuiKey_COUNT; n++)[m
[32m+[m[32m        IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < IM_ARRAYSIZE(g.IO.KeysDown) && "io.KeyMap[] contains an out of bound value (need to be 0..512, or -1 for unmapped key)");[m
[32m+[m
[32m+[m[32m    // Perform simple check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only recently added in 1.60 WIP)[m
[32m+[m[32m    if (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard)[m
[32m+[m[32m        IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation.");[m
[32m+[m
[32m+[m[32m    // Perform simple check: the beta io.ConfigWindowsResizeFromEdges option requires back-end to honor mouse cursor changes and set the ImGuiBackendFlags_HasMouseCursors flag accordingly.[m
[32m+[m[32m    if (g.IO.ConfigWindowsResizeFromEdges && !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseCursors))[m
[32m+[m[32m        g.IO.ConfigWindowsResizeFromEdges = false;[m
[32m+[m
[32m+[m[32m    // Load settings on first frame (if not explicitly loaded manually before)[m
[32m+[m[32m    if (!g.SettingsLoaded)[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(g.SettingsWindows.empty());[m
[32m+[m[32m        if (g.IO.IniFilename)[m
[32m+[m[32m            LoadIniSettingsFromDisk(g.IO.IniFilename);[m
[32m+[m[32m        g.SettingsLoaded = true;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Save settings (with a delay after the last modification, so we don't spam disk too much)[m
[32m+[m[32m    if (g.SettingsDirtyTimer > 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.SettingsDirtyTimer -= g.IO.DeltaTime;[m
[32m+[m[32m        if (g.SettingsDirtyTimer <= 0.0f)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (g.IO.IniFilename != NULL)[m
[32m+[m[32m                SaveIniSettingsToDisk(g.IO.IniFilename);[m
[32m+[m[32m            else[m
[32m+[m[32m                g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.[m
[32m+[m[32m            g.SettingsDirtyTimer = 0.0f;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    g.Time += g.IO.DeltaTime;[m
[32m+[m[32m    g.FrameScopeActive = true;[m
[32m+[m[32m    g.FrameCount += 1;[m
[32m+[m[32m    g.TooltipOverrideCount = 0;[m
[32m+[m[32m    g.WindowsActiveCount = 0;[m
[32m+[m
[32m+[m[32m    // Setup current font and draw list shared data[m
[32m+[m[32m    g.IO.Fonts->Locked = true;[m
[32m+[m[32m    SetCurrentFont(GetDefaultFont());[m
[32m+[m[32m    IM_ASSERT(g.Font->IsLoaded());[m
[32m+[m[32m    g.DrawListSharedData.ClipRectFullscreen = ImVec4(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);[m
[32m+[m[32m    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;[m
[32m+[m
[32m+[m[32m    g.BackgroundDrawList.Clear();[m
[32m+[m[32m    g.BackgroundDrawList.PushTextureID(g.IO.Fonts->TexID);[m
[32m+[m[32m    g.BackgroundDrawList.PushClipRectFullScreen();[m
[32m+[m[32m    g.BackgroundDrawList.Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);[m
[32m+[m
[32m+[m[32m    g.ForegroundDrawList.Clear();[m
[32m+[m[32m    g.ForegroundDrawList.PushTextureID(g.IO.Fonts->TexID);[m
[32m+[m[32m    g.ForegroundDrawList.PushClipRectFullScreen();[m
[32m+[m[32m    g.ForegroundDrawList.Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);[m
[32m+[m
[32m+[m[32m    // Mark rendering data as invalid to prevent user who may have a handle on it to use it.[m
[32m+[m[32m    g.DrawData.Clear();[m
[32m+[m
[32m+[m[32m    // Drag and drop keep the source ID alive so even if the source disappear our state is consistent[m
[32m+[m[32m    if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)[m
[32m+[m[32m        KeepAliveID(g.DragDropPayload.SourceId);[m
[32m+[m
[32m+[m[32m    // Clear reference to active widget if the widget isn't alive anymore[m
[32m+[m[32m    if (!g.HoveredIdPreviousFrame)[m
[32m+[m[32m        g.HoveredIdTimer = 0.0f;[m
[32m+[m[32m    if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))[m
[32m+[m[32m        g.HoveredIdNotActiveTimer = 0.0f;[m
[32m+[m[32m    if (g.HoveredId)[m
[32m+[m[32m        g.HoveredIdTimer += g.IO.DeltaTime;[m
[32m+[m[32m    if (g.HoveredId && g.ActiveId != g.HoveredId)[m
[32m+[m[32m        g.HoveredIdNotActiveTimer += g.IO.DeltaTime;[m
[32m+[m[32m    g.HoveredIdPreviousFrame = g.HoveredId;[m
[32m+[m[32m    g.HoveredId = 0;[m
[32m+[m[32m    g.HoveredIdAllowOverlap = false;[m
[32m+[m[32m    if (g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId && g.ActiveId != 0)[m
[32m+[m[32m        ClearActiveID();[m
[32m+[m[32m    if (g.ActiveId)[m
[32m+[m[32m        g.ActiveIdTimer += g.IO.DeltaTime;[m
[32m+[m[32m    g.LastActiveIdTimer += g.IO.DeltaTime;[m
[32m+[m[32m    g.ActiveIdPreviousFrame = g.ActiveId;[m
[32m+[m[32m    g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;[m
[32m+[m[32m    g.ActiveIdPreviousFrameHasBeenEdited = g.ActiveIdHasBeenEdited;[m
[32m+[m[32m    g.ActiveIdIsAlive = 0;[m
[32m+[m[32m    g.ActiveIdPreviousFrameIsAlive = false;[m
[32m+[m[32m    g.ActiveIdIsJustActivated = false;[m
[32m+[m[32m    if (g.TempInputTextId != 0 && g.ActiveId != g.TempInputTextId)[m
[32m+[m[32m        g.TempInputTextId = 0;[m
[32m+[m
[32m+[m[32m    // Drag and drop[m
[32m+[m[32m    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;[m
[32m+[m[32m    g.DragDropAcceptIdCurr = 0;[m
[32m+[m[32m    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;[m
[32m+[m[32m    g.DragDropWithinSourceOrTarget = false;[m
[32m+[m
[32m+[m[32m    // Update keyboard input state[m
[32m+[m[32m    memcpy(g.IO.KeysDownDurationPrev, g.IO.KeysDownDuration, sizeof(g.IO.KeysDownDuration));[m
[32m+[m[32m    for (int i = 0; i < IM_ARRAYSIZE(g.IO.KeysDown); i++)[m
[32m+[m[32m        g.IO.KeysDownDuration[i] = g.IO.KeysDown[i] ? (g.IO.KeysDownDuration[i] < 0.0f ? 0.0f : g.IO.KeysDownDuration[i] + g.IO.DeltaTime) : -1.0f;[m
[32m+[m
[32m+[m[32m    // Update gamepad/keyboard directional navigation[m
[32m+[m[32m    NavUpdate();[m
[32m+[m
[32m+[m[32m    // Update mouse input state[m
[32m+[m[32m    UpdateMouseInputs();[m
[32m+[m
[32m+[m[32m    // Calculate frame-rate for the user, as a purely luxurious feature[m
[32m+[m[32m    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];[m
[32m+[m[32m    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;[m
[32m+[m[32m    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);[m
[32m+[m[32m    g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)IM_ARRAYSIZE(g.FramerateSecPerFrame))) : FLT_MAX;[m
[32m+[m
[32m+[m[32m    // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)[m
[32m+[m[32m    UpdateMouseMovingWindowNewFrame();[m
[32m+[m[32m    UpdateHoveredWindowAndCaptureFlags();[m
[32m+[m
[32m+[m[32m    // Background darkening/whitening[m
[32m+[m[32m    if (GetFrontMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))[m
[32m+[m[32m        g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);[m
[32m+[m[32m    else[m
[32m+[m[32m        g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);[m
[32m+[m
[32m+[m[32m    g.MouseCursor = ImGuiMouseCursor_Arrow;[m
[32m+[m[32m    g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;[m
[32m+[m[32m    g.PlatformImePos = ImVec2(1.0f, 1.0f); // OS Input Method Editor showing on top-left of our window by default[m
[32m+[m
[32m+[m[32m    // Mouse wheel scrolling, scale[m
[32m+[m[32m    UpdateMouseWheel();[m
[32m+[m
[32m+[m[32m    // Pressing TAB activate widget focus[m
[32m+[m[32m    g.FocusTabPressed = (g.NavWindow && g.NavWindow->Active && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab));[m
[32m+[m[32m    if (g.ActiveId == 0 && g.FocusTabPressed)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Note that SetKeyboardFocusHere() sets the Next fields mid-frame. To be consistent we also[m
[32m+[m[32m        // manipulate the Next fields even, even though they will be turned into Curr fields by the code below.[m
[32m+[m[32m        g.FocusRequestNextWindow = g.NavWindow;[m
[32m+[m[32m        g.FocusRequestNextCounterAll = INT_MAX;[m
[32m+[m[32m        if (g.NavId != 0 && g.NavIdTabCounter != INT_MAX)[m
[32m+[m[32m            g.FocusRequestNextCounterTab = g.NavIdTabCounter + 1 + (g.IO.KeyShift ? -1 : 1);[m
[32m+[m[32m        else[m
[32m+[m[32m            g.FocusRequestNextCounterTab = g.IO.KeyShift ? -1 : 0;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Turn queued focus request into current one[m
[32m+[m[32m    g.FocusRequestCurrWindow = NULL;[m
[32m+[m[32m    g.FocusRequestCurrCounterAll = g.FocusRequestCurrCounterTab = INT_MAX;[m
[32m+[m[32m    if (g.FocusRequestNextWindow != NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiWindow* window = g.FocusRequestNextWindow;[m
[32m+[m[32m        g.FocusRequestCurrWindow = window;[m
[32m+[m[32m        if (g.FocusRequestNextCounterAll != INT_MAX && window->DC.FocusCounterAll != -1)[m
[32m+[m[32m            g.FocusRequestCurrCounterAll = ImModPositive(g.FocusRequestNextCounterAll, window->DC.FocusCounterAll + 1);[m
[32m+[m[32m        if (g.FocusRequestNextCounterTab != INT_MAX && window->DC.FocusCounterTab != -1)[m
[32m+[m[32m            g.FocusRequestCurrCounterTab = ImModPositive(g.FocusRequestNextCounterTab, window->DC.FocusCounterTab + 1);[m
[32m+[m[32m        g.FocusRequestNextWindow = NULL;[m
[32m+[m[32m        g.FocusRequestNextCounterAll = g.FocusRequestNextCounterTab = INT_MAX;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    g.NavIdTabCounter = INT_MAX;[m
[32m+[m
[32m+[m[32m    // Mark all windows as not visible[m
[32m+[m[32m    IM_ASSERT(g.WindowsFocusOrder.Size == g.Windows.Size);[m
[32m+[m[32m    for (int i = 0; i != g.Windows.Size; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiWindow* window = g.Windows[i];[m
[32m+[m[32m        window->WasActive = window->Active;[m
[32m+[m[32m        window->BeginCount = 0;[m
[32m+[m[32m        window->Active = false;[m
[32m+[m[32m        window->WriteAccessed = false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Closing the focused window restore focus to the first active root window in descending z-order[m
[32m+[m[32m    if (g.NavWindow && !g.NavWindow->WasActive)[m
[32m+[m[32m        FocusTopMostWindowUnderOne(NULL, NULL);[m
[32m+[m
[32m+[m[32m    // No window should be open at the beginning of the frame.[m
[32m+[m[32m    // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.[m
[32m+[m[32m    g.CurrentWindowStack.resize(0);[m
[32m+[m[32m    g.BeginPopupStack.resize(0);[m
[32m+[m[32m    ClosePopupsOverWindow(g.NavWindow, false);[m
[32m+[m
[32m+[m[32m    // Create implicit/fallback window - which we will only render it if the user has added something to it.[m
[32m+[m[32m    // We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.[m
[32m+[m[32m    // This fallback is particularly important as it avoid ImGui:: calls from crashing.[m
[32m+[m[32m    SetNextWindowSize(ImVec2(400,400), ImGuiCond_FirstUseEver);[m
[32m+[m[32m    Begin("Debug##Default");[m
[32m+[m[32m    g.FrameScopePushedImplicitWindow = true;[m
[32m+[m
[32m+[m[32m#ifdef IMGUI_ENABLE_TEST_ENGINE[m
[32m+[m[32m    ImGuiTestEngineHook_PostNewFrame(&g);[m
[32m+[m[32m#endif[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::Initialize(ImGuiContext* context)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *context;[m
[32m+[m[32m    IM_ASSERT(!g.Initialized && !g.SettingsLoaded);[m
[32m+[m
[32m+[m[32m    // Add .ini handle for ImGuiWindow type[m
[32m+[m[32m    ImGuiSettingsHandler ini_handler;[m
[32m+[m[32m    ini_handler.TypeName = "Window";[m
[32m+[m[32m    ini_handler.TypeHash = ImHashStr("Window");[m
[32m+[m[32m    ini_handler.ReadOpenFn = SettingsHandlerWindow_ReadOpen;[m
[32m+[m[32m    ini_handler.ReadLineFn = SettingsHandlerWindow_ReadLine;[m
[32m+[m[32m    ini_handler.WriteAllFn = SettingsHandlerWindow_WriteAll;[m
[32m+[m[32m    g.SettingsHandlers.push_back(ini_handler);[m
[32m+[m
[32m+[m[32m    g.Initialized = true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// This function is merely here to free heap allocations.[m
[32m+[m[32mvoid ImGui::Shutdown(ImGuiContext* context)[m
[32m+[m[32m{[m
[32m+[m[32m    // The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)[m
[32m+[m[32m    ImGuiContext& g = *context;[m
[32m+[m[32m    if (g.IO.Fonts && g.FontAtlasOwnedByContext)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.IO.Fonts->Locked = false;[m
[32m+[m[32m        IM_DELETE(g.IO.Fonts);[m
[32m+[m[32m    }[m
[32m+[m[32m    g.IO.Fonts = NULL;[m
[32m+[m
[32m+[m[32m    // Cleanup of other data are conditional on actually having initialized ImGui.[m
[32m+[m[32m    if (!g.Initialized)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // Save settings (unless we haven't attempted to load them: CreateContext/DestroyContext without a call to NewFrame shouldn't save an empty file)[m
[32m+[m[32m    if (g.SettingsLoaded && g.IO.IniFilename != NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiContext* backup_context = GImGui;[m
[32m+[m[32m        SetCurrentContext(context);[m
[32m+[m[32m        SaveIniSettingsToDisk(g.IO.IniFilename);[m
[32m+[m[32m        SetCurrentContext(backup_context);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Clear everything else[m
[32m+[m[32m    for (int i = 0; i < g.Windows.Size; i++)[m
[32m+[m[32m        IM_DELETE(g.Windows[i]);[m
[32m+[m[32m    g.Windows.clear();[m
[32m+[m[32m    g.WindowsFocusOrder.clear();[m
[32m+[m[32m    g.WindowsSortBuffer.clear();[m
[32m+[m[32m    g.CurrentWindow = NULL;[m
[32m+[m[32m    g.CurrentWindowStack.clear();[m
[32m+[m[32m    g.WindowsById.Clear();[m
[32m+[m[32m    g.NavWindow = NULL;[m
[32m+[m[32m    g.HoveredWindow = g.HoveredRootWindow = NULL;[m
[32m+[m[32m    g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow = NULL;[m
[32m+[m[32m    g.MovingWindow = NULL;[m
[32m+[m[32m    g.ColorModifiers.clear();[m
[32m+[m[32m    g.StyleModifiers.clear();[m
[32m+[m[32m    g.FontStack.clear();[m
[32m+[m[32m    g.OpenPopupStack.clear();[m
[32m+[m[32m    g.BeginPopupStack.clear();[m
[32m+[m[32m    g.DrawDataBuilder.ClearFreeMemory();[m
[32m+[m[32m    g.BackgroundDrawList.ClearFreeMemory();[m
[32m+[m[32m    g.ForegroundDrawList.ClearFreeMemory();[m
[32m+[m[32m    g.PrivateClipboard.clear();[m
[32m+[m[32m    g.InputTextState.ClearFreeMemory();[m
[32m+[m
[32m+[m[32m    for (int i = 0; i < g.SettingsWindows.Size; i++)[m
[32m+[m[32m        IM_DELETE(g.SettingsWindows[i].Name);[m
[32m+[m[32m    g.SettingsWindows.clear();[m
[32m+[m[32m    g.SettingsHandlers.clear();[m
[32m+[m
[32m+[m[32m    if (g.LogFile && g.LogFile != stdout)[m
[32m+[m[32m    {[m
[32m+[m[32m        fclose(g.LogFile);[m
[32m+[m[32m        g.LogFile = NULL;[m
[32m+[m[32m    }[m
[32m+[m[32m    g.LogBuffer.clear();[m
[32m+[m
[32m+[m[32m    g.Initialized = false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// FIXME: Add a more explicit sort order in the window structure.[m
[32m+[m[32mstatic int IMGUI_CDECL ChildWindowComparer(const void* lhs, const void* rhs)[m
[32m+[m[32m{[m
[32m+[m[32m    const ImGuiWindow* const a = *(const ImGuiWindow* const *)lhs;[m
[32m+[m[32m    const ImGuiWindow* const b = *(const ImGuiWindow* const *)rhs;[m
[32m+[m[32m    if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))[m
[32m+[m[32m        return d;[m
[32m+[m[32m    if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))[m
[32m+[m[32m        return d;[m
[32m+[m[32m    return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    out_sorted_windows->push_back(window);[m
[32m+[m[32m    if (window->Active)[m
[32m+[m[32m    {[m
[32m+[m[32m        int count = window->DC.ChildWindows.Size;[m
[32m+[m[32m        if (count > 1)[m
[32m+[m[32m            ImQsort(window->DC.ChildWindows.begin(), (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);[m
[32m+[m[32m        for (int i = 0; i < count; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGuiWindow* child = window->DC.ChildWindows[i];[m
[32m+[m[32m            if (child->Active)[m
[32m+[m[32m                AddWindowToSortBuffer(out_sorted_windows, child);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list)[m
[32m+[m[32m{[m
[32m+[m[32m    if (draw_list->CmdBuffer.empty())[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // Remove trailing command if unused[m
[32m+[m[32m    ImDrawCmd& last_cmd = draw_list->CmdBuffer.back();[m
[32m+[m[32m    if (last_cmd.ElemCount == 0 && last_cmd.UserCallback == NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        draw_list->CmdBuffer.pop_back();[m
[32m+[m[32m        if (draw_list->CmdBuffer.empty())[m
[32m+[m[32m            return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc. May trigger for you if you are using PrimXXX functions incorrectly.[m
[32m+[m[32m    IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);[m
[32m+[m[32m    IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);[m
[32m+[m[32m    IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);[m
[32m+[m
[32m+[m[32m    // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)[m
[32m+[m[32m    // If this assert triggers because you are drawing lots of stuff manually:[m
[32m+[m[32m    // A) Make sure you are coarse clipping, because ImDrawList let all your vertices pass. You can use the Metrics window to inspect draw list contents.[m
[32m+[m[32m    // B) If you need/want meshes with more than 64K vertices, uncomment the '#define ImDrawIdx unsigned int' line in imconfig.h to set the index size to 4 bytes.[m
[32m+[m[32m    //    You'll need to handle the 4-bytes indices to your renderer. For example, the OpenGL example code detect index size at compile-time by doing:[m
[32m+[m[32m    //      glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);[m
[32m+[m[32m    //    Your own engine or render API may use different parameters or function calls to specify index sizes. 2 and 4 bytes indices are generally supported by most API.[m
[32m+[m[32m    // C) If for some reason you cannot use 4 bytes indices or don't want to, a workaround is to call BeginChild()/EndChild() before reaching the 64K limit to split your draw commands in multiple draw lists.[m
[32m+[m[32m    if (sizeof(ImDrawIdx) == 2)[m
[32m+[m[32m        IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");[m
[32m+[m
[32m+[m[32m    out_list->push_back(draw_list);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void AddWindowToDrawData(ImVector<ImDrawList*>* out_render_list, ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.IO.MetricsRenderWindows++;[m
[32m+[m[32m    AddDrawListToDrawData(out_render_list, window->DrawList);[m
[32m+[m[32m    for (int i = 0; i < window->DC.ChildWindows.Size; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiWindow* child = window->DC.ChildWindows[i];[m
[32m+[m[32m        if (IsWindowActiveAndVisible(child)) // clipped children may have been marked not active[m
[32m+[m[32m            AddWindowToDrawData(out_render_list, child);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Layer is locked for the root window, however child windows may use a different viewport (e.g. extruding menu)[m
[32m+[m[32mstatic void AddRootWindowToDrawData(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (window->Flags & ImGuiWindowFlags_Tooltip)[m
[32m+[m[32m        AddWindowToDrawData(&g.DrawDataBuilder.Layers[1], window);[m
[32m+[m[32m    else[m
[32m+[m[32m        AddWindowToDrawData(&g.DrawDataBuilder.Layers[0], window);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawDataBuilder::FlattenIntoSingleLayer()[m
[32m+[m[32m{[m
[32m+[m[32m    int n = Layers[0].Size;[m
[32m+[m[32m    int size = n;[m
[32m+[m[32m    for (int i = 1; i < IM_ARRAYSIZE(Layers); i++)[m
[32m+[m[32m        size += Layers[i].Size;[m
[32m+[m[32m    Layers[0].resize(size);[m
[32m+[m[32m    for (int layer_n = 1; layer_n < IM_ARRAYSIZE(Layers); layer_n++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImVector<ImDrawList*>& layer = Layers[layer_n];[m
[32m+[m[32m        if (layer.empty())[m
[32m+[m[32m            continue;[m
[32m+[m[32m        memcpy(&Layers[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));[m
[32m+[m[32m        n += layer.Size;[m
[32m+[m[32m        layer.resize(0);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void SetupDrawData(ImVector<ImDrawList*>* draw_lists, ImDrawData* draw_data)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m    draw_data->Valid = true;[m
[32m+[m[32m    draw_data->CmdLists = (draw_lists->Size > 0) ? draw_lists->Data : NULL;[m
[32m+[m[32m    draw_data->CmdListsCount = draw_lists->Size;[m
[32m+[m[32m    draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;[m
[32m+[m[32m    draw_data->DisplayPos = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    draw_data->DisplaySize = io.DisplaySize;[m
[32m+[m[32m    draw_data->FramebufferScale = io.DisplayFramebufferScale;[m
[32m+[m[32m    for (int n = 0; n < draw_lists->Size; n++)[m
[32m+[m[32m    {[m
[32m+[m[32m        draw_data->TotalVtxCount += draw_lists->Data[n]->VtxBuffer.Size;[m
[32m+[m[32m        draw_data->TotalIdxCount += draw_lists->Data[n]->IdxBuffer.Size;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// When using this function it is sane to ensure that float are perfectly rounded to integer values, to that e.g. (int)(max.x-min.x) in user's render produce correct result.[m
[32m+[m[32mvoid ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);[m
[32m+[m[32m    window->ClipRect = window->DrawList->_ClipRectStack.back();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PopClipRect()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->DrawList->PopClipRect();[m
[32m+[m[32m    window->ClipRect = window->DrawList->_ClipRectStack.back();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.[m
[32m+[m[32mvoid ImGui::EndFrame()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(g.Initialized);[m
[32m+[m[32m    if (g.FrameCountEnded == g.FrameCount)          // Don't process EndFrame() multiple times.[m
[32m+[m[32m        return;[m
[32m+[m[32m    IM_ASSERT(g.FrameScopeActive && "Forgot to call ImGui::NewFrame()?");[m
[32m+[m
[32m+[m[32m    // Notify OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)[m
[32m+[m[32m    if (g.IO.ImeSetInputScreenPosFn && (g.PlatformImeLastPos.x == FLT_MAX || ImLengthSqr(g.PlatformImeLastPos - g.PlatformImePos) > 0.0001f))[m
[32m+[m[32m    {[m
[32m+[m[32m        g.IO.ImeSetInputScreenPosFn((int)g.PlatformImePos.x, (int)g.PlatformImePos.y);[m
[32m+[m[32m        g.PlatformImeLastPos = g.PlatformImePos;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Report when there is a mismatch of Begin/BeginChild vs End/EndChild calls. Important: Remember that the Begin/BeginChild API requires you[m
[32m+[m[32m    // to always call End/EndChild even if Begin/BeginChild returns false! (this is unfortunately inconsistent with most other Begin* API).[m
[32m+[m[32m    if (g.CurrentWindowStack.Size != 1)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (g.CurrentWindowStack.Size > 1)[m
[32m+[m[32m        {[m
[32m+[m[32m            IM_ASSERT(g.CurrentWindowStack.Size == 1 && "Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?");[m
[32m+[m[32m            while (g.CurrentWindowStack.Size > 1) // FIXME-ERRORHANDLING[m
[32m+[m[32m                End();[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            IM_ASSERT(g.CurrentWindowStack.Size == 1 && "Mismatched Begin/BeginChild vs End/EndChild calls: did you call End/EndChild too much?");[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Hide implicit/fallback "Debug" window if it hasn't been used[m
[32m+[m[32m    g.FrameScopePushedImplicitWindow = false;[m
[32m+[m[32m    if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)[m
[32m+[m[32m        g.CurrentWindow->Active = false;[m
[32m+[m[32m    End();[m
[32m+[m
[32m+[m[32m    // Show CTRL+TAB list window[m
[32m+[m[32m    if (g.NavWindowingTarget)[m
[32m+[m[32m        NavUpdateWindowingList();[m
[32m+[m
[32m+[m[32m    // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)[m
[32m+[m[32m    if (g.DragDropActive)[m
[32m+[m[32m    {[m
[32m+[m[32m        bool is_delivered = g.DragDropPayload.Delivery;[m
[32m+[m[32m        bool is_elapsed = (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceAutoExpirePayload) || !IsMouseDown(g.DragDropMouseButton));[m
[32m+[m[32m        if (is_delivered || is_elapsed)[m
[32m+[m[32m            ClearDragDrop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Drag and Drop: Fallback for source tooltip. This is not ideal but better than nothing.[m
[32m+[m[32m    if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.DragDropWithinSourceOrTarget = true;[m
[32m+[m[32m        SetTooltip("...");[m
[32m+[m[32m        g.DragDropWithinSourceOrTarget = false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // End frame[m
[32m+[m[32m    g.FrameScopeActive = false;[m
[32m+[m[32m    g.FrameCountEnded = g.FrameCount;[m
[32m+[m
[32m+[m[32m    // Initiate moving window + handle left-click and right-click focus[m
[32m+[m[32m    UpdateMouseMovingWindowEndFrame();[m
[32m+[m
[32m+[m[32m    // Sort the window list so that all child windows are after their parent[m
[32m+[m[32m    // We cannot do that on FocusWindow() because childs may not exist yet[m
[32m+[m[32m    g.WindowsSortBuffer.resize(0);[m
[32m+[m[32m    g.WindowsSortBuffer.reserve(g.Windows.Size);[m
[32m+[m[32m    for (int i = 0; i != g.Windows.Size; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiWindow* window = g.Windows[i];[m
[32m+[m[32m        if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it[m
[32m+[m[32m            continue;[m
[32m+[m[32m        AddWindowToSortBuffer(&g.WindowsSortBuffer, window);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.[m
[32m+[m[32m    IM_ASSERT(g.Windows.Size == g.WindowsSortBuffer.Size);[m
[32m+[m[32m    g.Windows.swap(g.WindowsSortBuffer);[m
[32m+[m[32m    g.IO.MetricsActiveWindows = g.WindowsActiveCount;[m
[32m+[m
[32m+[m[32m    // Unlock font atlas[m
[32m+[m[32m    g.IO.Fonts->Locked = false;[m
[32m+[m
[32m+[m[32m    // Clear Input data for next frame[m
[32m+[m[32m    g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;[m
[32m+[m[32m    g.IO.InputQueueCharacters.resize(0);[m
[32m+[m[32m    memset(g.IO.NavInputs, 0, sizeof(g.IO.NavInputs));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::Render()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(g.Initialized);[m
[32m+[m
[32m+[m[32m    if (g.FrameCountEnded != g.FrameCount)[m
[32m+[m[32m        EndFrame();[m
[32m+[m[32m    g.FrameCountRendered = g.FrameCount;[m
[32m+[m
[32m+[m[32m    // Gather ImDrawList to render (for each active window)[m
[32m+[m[32m    g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = g.IO.MetricsRenderWindows = 0;[m
[32m+[m[32m    g.DrawDataBuilder.Clear();[m
[32m+[m[32m    if (!g.BackgroundDrawList.VtxBuffer.empty())[m
[32m+[m[32m        AddDrawListToDrawData(&g.DrawDataBuilder.Layers[0], &g.BackgroundDrawList);[m
[32m+[m
[32m+[m[32m    ImGuiWindow* windows_to_render_front_most[2];[m
[32m+[m[32m    windows_to_render_front_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindow : NULL;[m
[32m+[m[32m    windows_to_render_front_most[1] = g.NavWindowingTarget ? g.NavWindowingList : NULL;[m
[32m+[m[32m    for (int n = 0; n != g.Windows.Size; n++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiWindow* window = g.Windows[n];[m
[32m+[m[32m        if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_front_most[0] && window != windows_to_render_front_most[1])[m
[32m+[m[32m            AddRootWindowToDrawData(window);[m
[32m+[m[32m    }[m
[32m+[m[32m    for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_front_most); n++)[m
[32m+[m[32m        if (windows_to_render_front_most[n] && IsWindowActiveAndVisible(windows_to_render_front_most[n])) // NavWindowingTarget is always temporarily displayed as the front-most window[m
[32m+[m[32m            AddRootWindowToDrawData(windows_to_render_front_most[n]);[m
[32m+[m[32m    g.DrawDataBuilder.FlattenIntoSingleLayer();[m
[32m+[m
[32m+[m[32m    // Draw software mouse cursor if requested[m
[32m+[m[32m    if (g.IO.MouseDrawCursor)[m
[32m+[m[32m        RenderMouseCursor(&g.ForegroundDrawList, g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor);[m
[32m+[m
[32m+[m[32m    if (!g.ForegroundDrawList.VtxBuffer.empty())[m
[32m+[m[32m        AddDrawListToDrawData(&g.DrawDataBuilder.Layers[0], &g.ForegroundDrawList);[m
[32m+[m
[32m+[m[32m    // Setup ImDrawData structure for end-user[m
[32m+[m[32m    SetupDrawData(&g.DrawDataBuilder.Layers[0], &g.DrawData);[m
[32m+[m[32m    g.IO.MetricsRenderVertices = g.DrawData.TotalVtxCount;[m
[32m+[m[32m    g.IO.MetricsRenderIndices = g.DrawData.TotalIdxCount;[m
[32m+[m
[32m+[m[32m    // (Legacy) Call the Render callback function. The current prefer way is to let the user retrieve GetDrawData() and call the render function themselves.[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32m    if (g.DrawData.CmdListsCount > 0 && g.IO.RenderDrawListsFn != NULL)[m
[32m+[m[32m        g.IO.RenderDrawListsFn(&g.DrawData);[m
[32m+[m[32m#endif[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.[m
[32m+[m[32m// CalcTextSize("") should return ImVec2(0.0f, GImGui->FontSize)[m
[32m+[m[32mImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    const char* text_display_end;[m
[32m+[m[32m    if (hide_text_after_double_hash)[m
[32m+[m[32m        text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string[m
[32m+[m[32m    else[m
[32m+[m[32m        text_display_end = text_end;[m
[32m+[m
[32m+[m[32m    ImFont* font = g.Font;[m
[32m+[m[32m    const float font_size = g.FontSize;[m
[32m+[m[32m    if (text == text_display_end)[m
[32m+[m[32m        return ImVec2(0.0f, font_size);[m
[32m+[m[32m    ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);[m
[32m+[m
[32m+[m[32m    // Round[m
[32m+[m[32m    text_size.x = (float)(int)(text_size.x + 0.95f);[m
[32m+[m
[32m+[m[32m    return text_size;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Helper to calculate coarse clipping of large list of evenly sized items.[m
[32m+[m[32m// NB: Prefer using the ImGuiListClipper higher-level helper if you can! Read comments and instructions there on how those use this sort of pattern.[m
[32m+[m[32m// NB: 'items_count' is only used to clamp the result, if you don't know your count you can use INT_MAX[m
[32m+[m[32mvoid ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (g.LogEnabled)[m
[32m+[m[32m    {[m
[32m+[m[32m        // If logging is active, do not perform any clipping[m
[32m+[m[32m        *out_items_display_start = 0;[m
[32m+[m[32m        *out_items_display_end = items_count;[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m    {[m
[32m+[m[32m        *out_items_display_start = *out_items_display_end = 0;[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // We create the union of the ClipRect and the NavScoringRect which at worst should be 1 page away from ClipRect[m
[32m+[m[32m    ImRect unclipped_rect = window->ClipRect;[m
[32m+[m[32m    if (g.NavMoveRequest)[m
[32m+[m[32m        unclipped_rect.Add(g.NavScoringRectScreen);[m
[32m+[m
[32m+[m[32m    const ImVec2 pos = window->DC.CursorPos;[m
[32m+[m[32m    int start = (int)((unclipped_rect.Min.y - pos.y) / items_height);[m
[32m+[m[32m    int end = (int)((unclipped_rect.Max.y - pos.y) / items_height);[m
[32m+[m
[32m+[m[32m    // When performing a navigation request, ensure we have one item extra in the direction we are moving to[m
[32m+[m[32m    if (g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Up)[m
[32m+[m[32m        start--;[m
[32m+[m[32m    if (g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Down)[m
[32m+[m[32m        end++;[m
[32m+[m
[32m+[m[32m    start = ImClamp(start, 0, items_count);[m
[32m+[m[32m    end = ImClamp(end + 1, start, items_count);[m
[32m+[m[32m    *out_items_display_start = start;[m
[32m+[m[32m    *out_items_display_end = end;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Find window given position, search front-to-back[m
[32m+[m[32m// FIXME: Note that we have an inconsequential lag here: OuterRectClipped is updated in Begin(), so windows moved programatically[m
[32m+[m[32m// with SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is[m
[32m+[m[32m// called, aka before the next Begin(). Moving window isn't affected.[m
[32m+[m[32mstatic void FindHoveredWindow()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    ImGuiWindow* hovered_window = NULL;[m
[32m+[m[32m    if (g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))[m
[32m+[m[32m        hovered_window = g.MovingWindow;[m
[32m+[m
[32m+[m[32m    ImVec2 padding_regular = g.Style.TouchExtraPadding;[m
[32m+[m[32m    ImVec2 padding_for_resize_from_edges = g.IO.ConfigWindowsResizeFromEdges ? ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS, WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS)) : padding_regular;[m
[32m+[m[32m    for (int i = g.Windows.Size - 1; i >= 0; i--)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiWindow* window = g.Windows[i];[m
[32m+[m[32m        if (!window->Active || window->Hidden)[m
[32m+[m[32m            continue;[m
[32m+[m[32m        if (window->Flags & ImGuiWindowFlags_NoMouseInputs)[m
[32m+[m[32m            continue;[m
[32m+[m
[32m+[m[32m        // Using the clipped AABB, a child window will typically be clipped by its parent (not always)[m
[32m+[m[32m        ImRect bb(window->OuterRectClipped);[m
[32m+[m[32m        if (window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize))[m
[32m+[m[32m            bb.Expand(padding_regular);[m
[32m+[m[32m        else[m
[32m+[m[32m            bb.Expand(padding_for_resize_from_edges);[m
[32m+[m[32m        if (!bb.Contains(g.IO.MousePos))[m
[32m+[m[32m            continue;[m
[32m+[m
[32m+[m[32m        // Those seemingly unnecessary extra tests are because the code here is a little different in viewport/docking branches.[m
[32m+[m[32m        if (hovered_window == NULL)[m
[32m+[m[32m            hovered_window = window;[m
[32m+[m[32m        if (hovered_window)[m
[32m+[m[32m            break;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    g.HoveredWindow = hovered_window;[m
[32m+[m[32m    g.HoveredRootWindow = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Test if mouse cursor is hovering given rectangle[m
[32m+[m[32m// NB- Rectangle is clipped by our current clip setting[m
[32m+[m[32m// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)[m
[32m+[m[32mbool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    // Clip[m
[32m+[m[32m    ImRect rect_clipped(r_min, r_max);[m
[32m+[m[32m    if (clip)[m
[32m+[m[32m        rect_clipped.ClipWith(g.CurrentWindow->ClipRect);[m
[32m+[m
[32m+[m[32m    // Expand for touch input[m
[32m+[m[32m    const ImRect rect_for_touch(rect_clipped.Min - g.Style.TouchExtraPadding, rect_clipped.Max + g.Style.TouchExtraPadding);[m
[32m+[m[32m    if (!rect_for_touch.Contains(g.IO.MousePos))[m
[32m+[m[32m        return false;[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImGui::GetKeyIndex(ImGuiKey imgui_key)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(imgui_key >= 0 && imgui_key < ImGuiKey_COUNT);[m
[32m+[m[32m    return GImGui->IO.KeyMap[imgui_key];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Note that imgui doesn't know the semantic of each entry of io.KeysDown[]. Use your own indices/enums according to how your back-end/engine stored them into io.KeysDown[]![m
[32m+[m[32mbool ImGui::IsKeyDown(int user_key_index)[m
[32m+[m[32m{[m
[32m+[m[32m    if (user_key_index < 0) return false;[m
[32m+[m[32m    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(GImGui->IO.KeysDown));[m
[32m+[m[32m    return GImGui->IO.KeysDown[user_key_index];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImGui::CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate)[m
[32m+[m[32m{[m
[32m+[m[32m    if (t == 0.0f)[m
[32m+[m[32m        return 1;[m
[32m+[m[32m    if (t <= repeat_delay || repeat_rate <= 0.0f)[m
[32m+[m[32m        return 0;[m
[32m+[m[32m    const int count = (int)((t - repeat_delay) / repeat_rate) - (int)((t_prev - repeat_delay) / repeat_rate);[m
[32m+[m[32m    return (count > 0) ? count : 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImGui::GetKeyPressedAmount(int key_index, float repeat_delay, float repeat_rate)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (key_index < 0)[m
[32m+[m[32m        return 0;[m
[32m+[m[32m    IM_ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(g.IO.KeysDown));[m
[32m+[m[32m    const float t = g.IO.KeysDownDuration[key_index];[m
[32m+[m[32m    return CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, repeat_delay, repeat_rate);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsKeyPressed(int user_key_index, bool repeat)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (user_key_index < 0)[m
[32m+[m[32m        return false;[m
[32m+[m[32m    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));[m
[32m+[m[32m    const float t = g.IO.KeysDownDuration[user_key_index];[m
[32m+[m[32m    if (t == 0.0f)[m
[32m+[m[32m        return true;[m
[32m+[m[32m    if (repeat && t > g.IO.KeyRepeatDelay)[m
[32m+[m[32m        return GetKeyPressedAmount(user_key_index, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsKeyReleased(int user_key_index)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (user_key_index < 0) return false;[m
[32m+[m[32m    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));[m
[32m+[m[32m    return g.IO.KeysDownDurationPrev[user_key_index] >= 0.0f && !g.IO.KeysDown[user_key_index];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsMouseDown(int button)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));[m
[32m+[m[32m    return g.IO.MouseDown[button];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsAnyMouseDown()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    for (int n = 0; n < IM_ARRAYSIZE(g.IO.MouseDown); n++)[m
[32m+[m[32m        if (g.IO.MouseDown[n])[m
[32m+[m[32m            return true;[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsMouseClicked(int button, bool repeat)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));[m
[32m+[m[32m    const float t = g.IO.MouseDownDuration[button];[m
[32m+[m[32m    if (t == 0.0f)[m
[32m+[m[32m        return true;[m
[32m+[m
[32m+[m[32m    if (repeat && t > g.IO.KeyRepeatDelay)[m
[32m+[m[32m    {[m
[32m+[m[32m        // FIXME: 2019/05/03: Our old repeat code was wrong here and led to doubling the repeat rate, which made it an ok rate for repeat on mouse hold.[m
[32m+[m[32m        int amount = CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate * 0.5f);[m
[32m+[m[32m        if (amount > 0)[m
[32m+[m[32m            return true;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsMouseReleased(int button)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));[m
[32m+[m[32m    return g.IO.MouseReleased[button];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsMouseDoubleClicked(int button)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));[m
[32m+[m[32m    return g.IO.MouseDoubleClicked[button];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsMouseDragging(int button, float lock_threshold)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));[m
[32m+[m[32m    if (!g.IO.MouseDown[button])[m
[32m+[m[32m        return false;[m
[32m+[m[32m    if (lock_threshold < 0.0f)[m
[32m+[m[32m        lock_threshold = g.IO.MouseDragThreshold;[m
[32m+[m[32m    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImGui::GetMousePos()[m
[32m+[m[32m{[m
[32m+[m[32m    return GImGui->IO.MousePos;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed![m
[32m+[m[32mImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.BeginPopupStack.Size > 0)[m
[32m+[m[32m        return g.OpenPopupStack[g.BeginPopupStack.Size-1].OpenMousePos;[m
[32m+[m[32m    return g.IO.MousePos;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position.[m
[32m+[m[32mbool ImGui::IsMousePosValid(const ImVec2* mouse_pos)[m
[32m+[m[32m{[m
[32m+[m[32m    // The assert is only to silence a false-positive in XCode Static Analysis.[m
[32m+[m[32m    // Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).[m
[32m+[m[32m    IM_ASSERT(GImGui != NULL);[m
[32m+[m[32m    const float MOUSE_INVALID = -256000.0f;[m
[32m+[m[32m    ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;[m
[32m+[m[32m    return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Return the delta from the initial clicking position while the mouse button is clicked or was just released.[m
[32m+[m[32m// This is locked and return 0.0f until the mouse moves past a distance threshold at least once.[m
[32m+[m[32m// NB: This is only valid if IsMousePosValid(). Back-ends in theory should always keep mouse position valid when dragging even outside the client window.[m
[32m+[m[32mImVec2 ImGui::GetMouseDragDelta(int button, float lock_threshold)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));[m
[32m+[m[32m    if (lock_threshold < 0.0f)[m
[32m+[m[32m        lock_threshold = g.IO.MouseDragThreshold;[m
[32m+[m[32m    if (g.IO.MouseDown[button] || g.IO.MouseReleased[button])[m
[32m+[m[32m        if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)[m
[32m+[m[32m            if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MouseClickedPos[button]))[m
[32m+[m[32m                return g.IO.MousePos - g.IO.MouseClickedPos[button];[m
[32m+[m[32m    return ImVec2(0.0f, 0.0f);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::ResetMouseDragDelta(int button)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));[m
[32m+[m[32m    // NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr[m
[32m+[m[32m    g.IO.MouseClickedPos[button] = g.IO.MousePos;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiMouseCursor ImGui::GetMouseCursor()[m
[32m+[m[32m{[m
[32m+[m[32m    return GImGui->MouseCursor;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)[m
[32m+[m[32m{[m
[32m+[m[32m    GImGui->MouseCursor = cursor_type;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::CaptureKeyboardFromApp(bool capture)[m
[32m+[m[32m{[m
[32m+[m[32m    GImGui->WantCaptureKeyboardNextFrame = capture ? 1 : 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::CaptureMouseFromApp(bool capture)[m
[32m+[m[32m{[m
[32m+[m[32m    GImGui->WantCaptureMouseNextFrame = capture ? 1 : 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsItemActive()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.ActiveId)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m        return g.ActiveId == window->DC.LastItemId;[m
[32m+[m[32m    }[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsItemActivated()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.ActiveId)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m        if (g.ActiveId == window->DC.LastItemId && g.ActiveIdPreviousFrame != window->DC.LastItemId)[m
[32m+[m[32m            return true;[m
[32m+[m[32m    }[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsItemDeactivated()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    return (g.ActiveIdPreviousFrame == window->DC.LastItemId && g.ActiveIdPreviousFrame != 0 && g.ActiveId != window->DC.LastItemId);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsItemDeactivatedAfterEdit()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return IsItemDeactivated() && (g.ActiveIdPreviousFrameHasBeenEdited || (g.ActiveId == 0 && g.ActiveIdHasBeenEdited));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsItemFocused()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m
[32m+[m[32m    if (g.NavId == 0 || g.NavDisableHighlight || g.NavId != window->DC.LastItemId)[m
[32m+[m[32m        return false;[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsItemClicked(int mouse_button)[m
[32m+[m[32m{[m
[32m+[m[32m    return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_None);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsItemToggledSelection()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return (g.CurrentWindow->DC.LastItemStatusFlags & ImGuiItemStatusFlags_ToggledSelection) ? true : false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsAnyItemHovered()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsAnyItemActive()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.ActiveId != 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsAnyItemFocused()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.NavId != 0 && !g.NavDisableHighlight;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsItemVisible()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->ClipRect.Overlaps(window->DC.LastItemRect);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsItemEdited()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_Edited) != 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Allow last item to be overlapped by a subsequent item. Both may be activated during the same frame before the later one takes priority.[m
[32m+[m[32mvoid ImGui::SetItemAllowOverlap()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.HoveredId == g.CurrentWindow->DC.LastItemId)[m
[32m+[m[32m        g.HoveredIdAllowOverlap = true;[m
[32m+[m[32m    if (g.ActiveId == g.CurrentWindow->DC.LastItemId)[m
[32m+[m[32m        g.ActiveIdAllowOverlap = true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImGui::GetItemRectMin()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->DC.LastItemRect.Min;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImGui::GetItemRectMax()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->DC.LastItemRect.Max;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImGui::GetItemRectSize()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->DC.LastItemRect.GetSize();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic ImRect GetViewportRect()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return ImRect(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic bool ImGui::BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* parent_window = g.CurrentWindow;[m
[32m+[m
[32m+[m[32m    flags |= ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_ChildWindow;[m
[32m+[m[32m    flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove);  // Inherit the NoMove flag[m
[32m+[m
[32m+[m[32m    // Size[m
[32m+[m[32m    const ImVec2 content_avail = GetContentRegionAvail();[m
[32m+[m[32m    ImVec2 size = ImFloor(size_arg);[m
[32m+[m[32m    const int auto_fit_axises = ((size.x == 0.0f) ? (1 << ImGuiAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << ImGuiAxis_Y) : 0x00);[m
[32m+[m[32m    if (size.x <= 0.0f)[m
[32m+[m[32m        size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)[m
[32m+[m[32m    if (size.y <= 0.0f)[m
[32m+[m[32m        size.y = ImMax(content_avail.y + size.y, 4.0f);[m
[32m+[m[32m    SetNextWindowSize(size);[m
[32m+[m
[32m+[m[32m    // Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.[m
[32m+[m[32m    char title[256];[m
[32m+[m[32m    if (name)[m
[32m+[m[32m        ImFormatString(title, IM_ARRAYSIZE(title), "%s/%s_%08X", parent_window->Name, name, id);[m
[32m+[m[32m    else[m
[32m+[m[32m        ImFormatString(title, IM_ARRAYSIZE(title), "%s/%08X", parent_window->Name, id);[m
[32m+[m
[32m+[m[32m    const float backup_border_size = g.Style.ChildBorderSize;[m
[32m+[m[32m    if (!border)[m
[32m+[m[32m        g.Style.ChildBorderSize = 0.0f;[m
[32m+[m[32m    bool ret = Begin(title, NULL, flags);[m
[32m+[m[32m    g.Style.ChildBorderSize = backup_border_size;[m
[32m+[m
[32m+[m[32m    ImGuiWindow* child_window = g.CurrentWindow;[m
[32m+[m[32m    child_window->ChildId = id;[m
[32m+[m[32m    child_window->AutoFitChildAxises = auto_fit_axises;[m
[32m+[m
[32m+[m[32m    // Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.[m
[32m+[m[32m    // While this is not really documented/defined, it seems that the expected thing to do.[m
[32m+[m[32m    if (child_window->BeginCount == 1)[m
[32m+[m[32m        parent_window->DC.CursorPos = child_window->Pos;[m
[32m+[m
[32m+[m[32m    // Process navigation-in immediately so NavInit can run on first frame[m
[32m+[m[32m    if (g.NavActivateId == id && !(flags & ImGuiWindowFlags_NavFlattened) && (child_window->DC.NavLayerActiveMask != 0 || child_window->DC.NavHasScroll))[m
[32m+[m[32m    {[m
[32m+[m[32m        FocusWindow(child_window);[m
[32m+[m[32m        NavInitWindow(child_window, false);[m
[32m+[m[32m        SetActiveID(id+1, child_window); // Steal ActiveId with a dummy id so that key-press won't activate child item[m
[32m+[m[32m        g.ActiveIdSource = ImGuiInputSource_Nav;[m
[32m+[m[32m    }[m
[32m+[m[32m    return ret;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(id != 0);[m
[32m+[m[32m    return BeginChildEx(NULL, id, size_arg, border, extra_flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::EndChild()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m
[32m+[m[32m    IM_ASSERT(window->Flags & ImGuiWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() callss[m
[32m+[m[32m    if (window->BeginCount > 1)[m
[32m+[m[32m    {[m
[32m+[m[32m        End();[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        ImVec2 sz = window->Size;[m
[32m+[m[32m        if (window->AutoFitChildAxises & (1 << ImGuiAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f[m
[32m+[m[32m            sz.x = ImMax(4.0f, sz.x);[m
[32m+[m[32m        if (window->AutoFitChildAxises & (1 << ImGuiAxis_Y))[m
[32m+[m[32m            sz.y = ImMax(4.0f, sz.y);[m
[32m+[m[32m        End();[m
[32m+[m
[32m+[m[32m        ImGuiWindow* parent_window = g.CurrentWindow;[m
[32m+[m[32m        ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);[m
[32m+[m[32m        ItemSize(sz);[m
[32m+[m[32m        if ((window->DC.NavLayerActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & ImGuiWindowFlags_NavFlattened))[m
[32m+[m[32m        {[m
[32m+[m[32m            ItemAdd(bb, window->ChildId);[m
[32m+[m[32m            RenderNavHighlight(bb, window->ChildId);[m
[32m+[m
[32m+[m[32m            // When browsing a window that has no activable items (scroll only) we keep a highlight on the child[m
[32m+[m[32m            if (window->DC.NavLayerActiveMask == 0 && window == g.NavWindow)[m
[32m+[m[32m                RenderNavHighlight(ImRect(bb.Min - ImVec2(2,2), bb.Max + ImVec2(2,2)), g.NavId, ImGuiNavHighlightFlags_TypeThin);[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            // Not navigable into[m
[32m+[m[32m            ItemAdd(bb, 0);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Helper to create a child window / scrolling region that looks like a normal widget frame.[m
[32m+[m[32mbool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    PushStyleColor(ImGuiCol_ChildBg, style.Colors[ImGuiCol_FrameBg]);[m
[32m+[m[32m    PushStyleVar(ImGuiStyleVar_ChildRounding, style.FrameRounding);[m
[32m+[m[32m    PushStyleVar(ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize);[m
[32m+[m[32m    PushStyleVar(ImGuiStyleVar_WindowPadding, style.FramePadding);[m
[32m+[m[32m    bool ret = BeginChild(id, size, true, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysUseWindowPadding | extra_flags);[m
[32m+[m[32m    PopStyleVar(3);[m
[32m+[m[32m    PopStyleColor();[m
[32m+[m[32m    return ret;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::EndChildFrame()[m
[32m+[m[32m{[m
[32m+[m[32m    EndChild();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Save and compare stack sizes on Begin()/End() to detect usage errors[m
[32m+[m[32mstatic void CheckStacksSize(ImGuiWindow* window, bool write)[m
[32m+[m[32m{[m
[32m+[m[32m    // NOT checking: DC.ItemWidth, DC.AllowKeyboardFocus, DC.ButtonRepeat, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    short* p_backup = &window->DC.StackSizesBackup[0];[m
[32m+[m[32m    { int current = window->IDStack.Size;       if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup == current && "PushID/PopID or TreeNode/TreePop Mismatch!");   p_backup++; }    // Too few or too many PopID()/TreePop()[m
[32m+[m[32m    { int current = window->DC.GroupStack.Size; if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup == current && "BeginGroup/EndGroup Mismatch!");                p_backup++; }    // Too few or too many EndGroup()[m
[32m+[m[32m    { int current = g.BeginPopupStack.Size;     if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup == current && "BeginMenu/EndMenu or BeginPopup/EndPopup Mismatch"); p_backup++;}// Too few or too many EndMenu()/EndPopup()[m
[32m+[m[32m    // For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.[m
[32m+[m[32m    { int current = g.ColorModifiers.Size;      if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushStyleColor/PopStyleColor Mismatch!");       p_backup++; }    // Too few or too many PopStyleColor()[m
[32m+[m[32m    { int current = g.StyleModifiers.Size;      if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushStyleVar/PopStyleVar Mismatch!");           p_backup++; }    // Too few or too many PopStyleVar()[m
[32m+[m[32m    { int current = g.FontStack.Size;           if (write) *p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushFont/PopFont Mismatch!");                   p_backup++; }    // Too few or too many PopFont()[m
[32m+[m[32m    IM_ASSERT(p_backup == window->DC.StackSizesBackup + IM_ARRAYSIZE(window->DC.StackSizesBackup));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void SetWindowConditionAllowFlags(ImGuiWindow* window, ImGuiCond flags, bool enabled)[m
[32m+[m[32m{[m
[32m+[m[32m    window->SetWindowPosAllowFlags       = enabled ? (window->SetWindowPosAllowFlags       | flags) : (window->SetWindowPosAllowFlags       & ~flags);[m
[32m+[m[32m    window->SetWindowSizeAllowFlags      = enabled ? (window->SetWindowSizeAllowFlags      | flags) : (window->SetWindowSizeAllowFlags      & ~flags);[m
[32m+[m[32m    window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiWindow* ImGui::FindWindowByID(ImGuiID id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiWindow* ImGui::FindWindowByName(const char* name)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiID id = ImHashStr(name);[m
[32m+[m[32m    return FindWindowByID(id);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic ImGuiWindow* CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    // Create window the first time[m
[32m+[m[32m    ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);[m
[32m+[m[32m    window->Flags = flags;[m
[32m+[m[32m    g.WindowsById.SetVoidPtr(window->ID, window);[m
[32m+[m
[32m+[m[32m    // Default/arbitrary window position. Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.[m
[32m+[m[32m    window->Pos = ImVec2(60, 60);[m
[32m+[m
[32m+[m[32m    // User can disable loading and saving of settings. Tooltip and child windows also don't store settings.[m
[32m+[m[32m    if (!(flags & ImGuiWindowFlags_NoSavedSettings))[m
[32m+[m[32m        if (ImGuiWindowSettings* settings = ImGui::FindWindowSettings(window->ID))[m
[32m+[m[32m        {[m
[32m+[m[32m            // Retrieve settings from .ini file[m
[32m+[m[32m            window->SettingsIdx = g.SettingsWindows.index_from_ptr(settings);[m
[32m+[m[32m            SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);[m
[32m+[m[32m            window->Pos = ImFloor(settings->Pos);[m
[32m+[m[32m            window->Collapsed = settings->Collapsed;[m
[32m+[m[32m            if (ImLengthSqr(settings->Size) > 0.00001f)[m
[32m+[m[32m                size = ImFloor(settings->Size);[m
[32m+[m[32m        }[m
[32m+[m[32m    window->Size = window->SizeFull = window->SizeFullAtLastBegin = ImFloor(size);[m
[32m+[m[32m    window->DC.CursorMaxPos = window->Pos; // So first call to CalcSizeContents() doesn't return crazy values[m
[32m+[m
[32m+[m[32m    if ((flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->AutoFitFramesX = window->AutoFitFramesY = 2;[m
[32m+[m[32m        window->AutoFitOnlyGrows = false;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        if (window->Size.x <= 0.0f)[m
[32m+[m[32m            window->AutoFitFramesX = 2;[m
[32m+[m[32m        if (window->Size.y <= 0.0f)[m
[32m+[m[32m            window->AutoFitFramesY = 2;[m
[32m+[m[32m        window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    g.WindowsFocusOrder.push_back(window);[m
[32m+[m[32m    if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)[m
[32m+[m[32m        g.Windows.push_front(window); // Quite slow but rare and only once[m
[32m+[m[32m    else[m
[32m+[m[32m        g.Windows.push_back(window);[m
[32m+[m[32m    return window;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic ImVec2 CalcSizeAfterConstraint(ImGuiWindow* window, ImVec2 new_size)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.NextWindowData.SizeConstraintCond != 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Using -1,-1 on either X/Y axis to preserve the current size.[m
[32m+[m[32m        ImRect cr = g.NextWindowData.SizeConstraintRect;[m
[32m+[m[32m        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;[m
[32m+[m[32m        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;[m
[32m+[m[32m        if (g.NextWindowData.SizeCallback)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGuiSizeCallbackData data;[m
[32m+[m[32m            data.UserData = g.NextWindowData.SizeCallbackUserData;[m
[32m+[m[32m            data.Pos = window->Pos;[m
[32m+[m[32m            data.CurrentSize = window->SizeFull;[m
[32m+[m[32m            data.DesiredSize = new_size;[m
[32m+[m[32m            g.NextWindowData.SizeCallback(&data);[m
[32m+[m[32m            new_size = data.DesiredSize;[m
[32m+[m[32m        }[m
[32m+[m[32m        new_size.x = ImFloor(new_size.x);[m
[32m+[m[32m        new_size.y = ImFloor(new_size.y);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Minimum size[m
[32m+[m[32m    if (!(window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysAutoResize)))[m
[32m+[m[32m    {[m
[32m+[m[32m        new_size = ImMax(new_size, g.Style.WindowMinSize);[m
[32m+[m[32m        new_size.y = ImMax(new_size.y, window->TitleBarHeight() + window->MenuBarHeight() + ImMax(0.0f, g.Style.WindowRounding - 1.0f)); // Reduce artifacts with very small windows[m
[32m+[m[32m    }[m
[32m+[m[32m    return new_size;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic ImVec2 CalcSizeContents(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    if (window->Collapsed)[m
[32m+[m[32m        if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)[m
[32m+[m[32m            return window->SizeContents;[m
[32m+[m[32m    if (window->Hidden && window->HiddenFramesCannotSkipItems == 0 && window->HiddenFramesCanSkipItems > 0)[m
[32m+[m[32m        return window->SizeContents;[m
[32m+[m
[32m+[m[32m    ImVec2 sz;[m
[32m+[m[32m    sz.x = (float)(int)((window->SizeContentsExplicit.x != 0.0f) ? window->SizeContentsExplicit.x : (window->DC.CursorMaxPos.x - window->Pos.x + window->Scroll.x));[m
[32m+[m[32m    sz.y = (float)(int)((window->SizeContentsExplicit.y != 0.0f) ? window->SizeContentsExplicit.y : (window->DC.CursorMaxPos.y - window->Pos.y + window->Scroll.y));[m
[32m+[m[32m    return sz + window->WindowPadding;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic ImVec2 CalcSizeAutoFit(ImGuiWindow* window, const ImVec2& size_contents)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiStyle& style = g.Style;[m
[32m+[m[32m    if (window->Flags & ImGuiWindowFlags_Tooltip)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Tooltip always resize[m
[32m+[m[32m        return size_contents;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // Maximum window size is determined by the display size[m
[32m+[m[32m        const bool is_popup = (window->Flags & ImGuiWindowFlags_Popup) != 0;[m
[32m+[m[32m        const bool is_menu = (window->Flags & ImGuiWindowFlags_ChildMenu) != 0;[m
[32m+[m[32m        ImVec2 size_min = style.WindowMinSize;[m
[32m+[m[32m        if (is_popup || is_menu) // Popups and menus bypass style.WindowMinSize by default, but we give then a non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)[m
[32m+[m[32m            size_min = ImMin(size_min, ImVec2(4.0f, 4.0f));[m
[32m+[m[32m        ImVec2 size_auto_fit = ImClamp(size_contents, size_min, ImMax(size_min, g.IO.DisplaySize - style.DisplaySafeAreaPadding * 2.0f));[m
[32m+[m
[32m+[m[32m        // When the window cannot fit all contents (either because of constraints, either because screen is too small),[m
[32m+[m[32m        // we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.[m
[32m+[m[32m        ImVec2 size_auto_fit_after_constraint = CalcSizeAfterConstraint(window, size_auto_fit);[m
[32m+[m[32m        if (size_auto_fit_after_constraint.x < size_contents.x && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar))[m
[32m+[m[32m            size_auto_fit.y += style.ScrollbarSize;[m
[32m+[m[32m        if (size_auto_fit_after_constraint.y < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar))[m
[32m+[m[32m            size_auto_fit.x += style.ScrollbarSize;[m
[32m+[m[32m        return size_auto_fit;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImGui::CalcWindowExpectedSize(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2 size_contents = CalcSizeContents(window);[m
[32m+[m[32m    return CalcSizeAfterConstraint(window, CalcSizeAutoFit(window, size_contents));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetWindowScrollMaxX(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    return ImMax(0.0f, window->SizeContents.x - (window->SizeFull.x - window->ScrollbarSizes.x));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetWindowScrollMaxY(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    return ImMax(0.0f, window->SizeContents.y - (window->SizeFull.y - window->ScrollbarSizes.y));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window, bool snap_on_edges)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImVec2 scroll = window->Scroll;[m
[32m+[m[32m    if (window->ScrollTarget.x < FLT_MAX)[m
[32m+[m[32m    {[m
[32m+[m[32m        float cr_x = window->ScrollTargetCenterRatio.x;[m
[32m+[m[32m        scroll.x = window->ScrollTarget.x - cr_x * (window->SizeFull.x - window->ScrollbarSizes.x);[m
[32m+[m[32m    }[m
[32m+[m[32m    if (window->ScrollTarget.y < FLT_MAX)[m
[32m+[m[32m    {[m
[32m+[m[32m        // 'snap_on_edges' allows for a discontinuity at the edge of scrolling limits to take account of WindowPadding so that scrolling to make the last item visible scroll far enough to see the padding.[m
[32m+[m[32m        float cr_y = window->ScrollTargetCenterRatio.y;[m
[32m+[m[32m        float target_y = window->ScrollTarget.y;[m
[32m+[m[32m        if (snap_on_edges && cr_y <= 0.0f && target_y <= window->WindowPadding.y)[m
[32m+[m[32m            target_y = 0.0f;[m
[32m+[m[32m        if (snap_on_edges && cr_y >= 1.0f && target_y >= window->SizeContents.y - window->WindowPadding.y + g.Style.ItemSpacing.y)[m
[32m+[m[32m            target_y = window->SizeContents.y;[m
[32m+[m[32m        scroll.y = target_y - (1.0f - cr_y) * (window->TitleBarHeight() + window->MenuBarHeight()) - cr_y * (window->SizeFull.y - window->ScrollbarSizes.y);[m
[32m+[m[32m    }[m
[32m+[m[32m    scroll = ImMax(scroll, ImVec2(0.0f, 0.0f));[m
[32m+[m[32m    if (!window->Collapsed && !window->SkipItems)[m
[32m+[m[32m    {[m
[32m+[m[32m        scroll.x = ImMin(scroll.x, ImGui::GetWindowScrollMaxX(window));[m
[32m+[m[32m        scroll.y = ImMin(scroll.y, ImGui::GetWindowScrollMaxY(window));[m
[32m+[m[32m    }[m
[32m+[m[32m    return scroll;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic ImGuiCol GetWindowBgColorIdxFromFlags(ImGuiWindowFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))[m
[32m+[m[32m        return ImGuiCol_PopupBg;[m
[32m+[m[32m    if (flags & ImGuiWindowFlags_ChildWindow)[m
[32m+[m[32m        return ImGuiCol_ChildBg;[m
[32m+[m[32m    return ImGuiCol_WindowBg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void CalcResizePosSizeFromAnyCorner(ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size)[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm);                // Expected window upper-left[m
[32m+[m[32m    ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right[m
[32m+[m[32m    ImVec2 size_expected = pos_max - pos_min;[m
[32m+[m[32m    ImVec2 size_constrained = CalcSizeAfterConstraint(window, size_expected);[m
[32m+[m[32m    *out_pos = pos_min;[m
[32m+[m[32m    if (corner_norm.x == 0.0f)[m
[32m+[m[32m        out_pos->x -= (size_constrained.x - size_expected.x);[m
[32m+[m[32m    if (corner_norm.y == 0.0f)[m
[32m+[m[32m        out_pos->y -= (size_constrained.y - size_expected.y);[m
[32m+[m[32m    *out_size = size_constrained;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstruct ImGuiResizeGripDef[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2  CornerPosN;[m
[32m+[m[32m    ImVec2  InnerDir;[m
[32m+[m[32m    int     AngleMin12, AngleMax12;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstatic const ImGuiResizeGripDef resize_grip_def[4] =[m
[32m+[m[32m{[m
[32m+[m[32m    { ImVec2(1,1), ImVec2(-1,-1), 0, 3 }, // Lower right[m
[32m+[m[32m    { ImVec2(0,1), ImVec2(+1,-1), 3, 6 }, // Lower left[m
[32m+[m[32m    { ImVec2(0,0), ImVec2(+1,+1), 6, 9 }, // Upper left[m
[32m+[m[32m    { ImVec2(1,0), ImVec2(-1,+1), 9,12 }, // Upper right[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstatic ImRect GetResizeBorderRect(ImGuiWindow* window, int border_n, float perp_padding, float thickness)[m
[32m+[m[32m{[m
[32m+[m[32m    ImRect rect = window->Rect();[m
[32m+[m[32m    if (thickness == 0.0f) rect.Max -= ImVec2(1,1);[m
[32m+[m[32m    if (border_n == 0) return ImRect(rect.Min.x + perp_padding, rect.Min.y - thickness,    rect.Max.x - perp_padding, rect.Min.y + thickness);      // Top[m
[32m+[m[32m    if (border_n == 1) return ImRect(rect.Max.x - thickness,    rect.Min.y + perp_padding, rect.Max.x + thickness,    rect.Max.y - perp_padding);   // Right[m
[32m+[m[32m    if (border_n == 2) return ImRect(rect.Min.x + perp_padding, rect.Max.y - thickness,    rect.Max.x - perp_padding, rect.Max.y + thickness);      // Bottom[m
[32m+[m[32m    if (border_n == 3) return ImRect(rect.Min.x - thickness,    rect.Min.y + perp_padding, rect.Min.x + thickness,    rect.Max.y - perp_padding);   // Left[m
[32m+[m[32m    IM_ASSERT(0);[m
[32m+[m[32m    return ImRect();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Handle resize for: Resize Grips, Borders, Gamepad[m
[32m+[m[32mstatic void ImGui::UpdateManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4])[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindowFlags flags = window->Flags;[m
[32m+[m[32m    if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)[m
[32m+[m[32m        return;[m
[32m+[m[32m    if (window->WasActive == false) // Early out to avoid running this code for e.g. an hidden implicit/fallback Debug window.[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    const int resize_border_count = g.IO.ConfigWindowsResizeFromEdges ? 4 : 0;[m
[32m+[m[32m    const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f);[m
[32m+[m[32m    const float grip_hover_inner_size = (float)(int)(grip_draw_size * 0.75f);[m
[32m+[m[32m    const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS : 0.0f;[m
[32m+[m
[32m+[m[32m    ImVec2 pos_target(FLT_MAX, FLT_MAX);[m
[32m+[m[32m    ImVec2 size_target(FLT_MAX, FLT_MAX);[m
[32m+[m
[32m+[m[32m    // Resize grips and borders are on layer 1[m
[32m+[m[32m    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;[m
[32m+[m[32m    window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Menu);[m
[32m+[m
[32m+[m[32m    // Manual resize grips[m
[32m+[m[32m    PushID("#RESIZE");[m
[32m+[m[32m    for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)[m
[32m+[m[32m    {[m
[32m+[m[32m        const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];[m
[32m+[m[32m        const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);[m
[32m+[m
[32m+[m[32m        // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window[m
[32m+[m[32m        ImRect resize_rect(corner - grip.InnerDir * grip_hover_outer_size, corner + grip.InnerDir * grip_hover_inner_size);[m
[32m+[m[32m        if (resize_rect.Min.x > resize_rect.Max.x) ImSwap(resize_rect.Min.x, resize_rect.Max.x);[m
[32m+[m[32m        if (resize_rect.Min.y > resize_rect.Max.y) ImSwap(resize_rect.Min.y, resize_rect.Max.y);[m
[32m+[m[32m        bool hovered, held;[m
[32m+[m[32m        ButtonBehavior(resize_rect, window->GetID((void*)(intptr_t)resize_grip_n), &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);[m
[32m+[m[32m        //GetForegroundDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));[m
[32m+[m[32m        if (hovered || held)[m
[32m+[m[32m            g.MouseCursor = (resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;[m
[32m+[m
[32m+[m[32m        if (held && g.IO.MouseDoubleClicked[0] && resize_grip_n == 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Manual auto-fit when double-clicking[m
[32m+[m[32m            size_target = CalcSizeAfterConstraint(window, size_auto_fit);[m
[32m+[m[32m            ClearActiveID();[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (held)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Resize from any of the four corners[m
[32m+[m[32m            // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position[m
[32m+[m[32m            ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(grip.InnerDir * grip_hover_outer_size, grip.InnerDir * -grip_hover_inner_size, grip.CornerPosN); // Corner of the window corresponding to our corner grip[m
[32m+[m[32m            CalcResizePosSizeFromAnyCorner(window, corner_target, grip.CornerPosN, &pos_target, &size_target);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (resize_grip_n == 0 || held || hovered)[m
[32m+[m[32m            resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);[m
[32m+[m[32m    }[m
[32m+[m[32m    for (int border_n = 0; border_n < resize_border_count; border_n++)[m
[32m+[m[32m    {[m
[32m+[m[32m        bool hovered, held;[m
[32m+[m[32m        ImRect border_rect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS);[m
[32m+[m[32m        ButtonBehavior(border_rect, window->GetID((void*)(intptr_t)(border_n + 4)), &hovered, &held, ImGuiButtonFlags_FlattenChildren);[m
[32m+[m[32m        //GetForegroundDrawLists(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));[m
[32m+[m[32m        if ((hovered && g.HoveredIdTimer > WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER) || held)[m
[32m+[m[32m        {[m
[32m+[m[32m            g.MouseCursor = (border_n & 1) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;[m
[32m+[m[32m            if (held)[m
[32m+[m[32m                *border_held = border_n;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (held)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImVec2 border_target = window->Pos;[m
[32m+[m[32m            ImVec2 border_posn;[m
[32m+[m[32m            if (border_n == 0) { border_posn = ImVec2(0, 0); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Top[m
[32m+[m[32m            if (border_n == 1) { border_posn = ImVec2(1, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Right[m
[32m+[m[32m            if (border_n == 2) { border_posn = ImVec2(0, 1); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Bottom[m
[32m+[m[32m            if (border_n == 3) { border_posn = ImVec2(0, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Left[m
[32m+[m[32m            CalcResizePosSizeFromAnyCorner(window, border_target, border_posn, &pos_target, &size_target);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    PopID();[m
[32m+[m
[32m+[m[32m    // Navigation resize (keyboard/gamepad)[m
[32m+[m[32m    if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindow == window)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImVec2 nav_resize_delta;[m
[32m+[m[32m        if (g.NavInputSource == ImGuiInputSource_NavKeyboard && g.IO.KeyShift)[m
[32m+[m[32m            nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);[m
[32m+[m[32m        if (g.NavInputSource == ImGuiInputSource_NavGamepad)[m
[32m+[m[32m            nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_Down);[m
[32m+[m[32m        if (nav_resize_delta.x != 0.0f || nav_resize_delta.y != 0.0f)[m
[32m+[m[32m        {[m
[32m+[m[32m            const float NAV_RESIZE_SPEED = 600.0f;[m
[32m+[m[32m            nav_resize_delta *= ImFloor(NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y));[m
[32m+[m[32m            g.NavWindowingToggleLayer = false;[m
[32m+[m[32m            g.NavDisableMouseHover = true;[m
[32m+[m[32m            resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);[m
[32m+[m[32m            // FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.[m
[32m+[m[32m            size_target = CalcSizeAfterConstraint(window, window->SizeFull + nav_resize_delta);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Apply back modified position/size to window[m
[32m+[m[32m    if (size_target.x != FLT_MAX)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->SizeFull = size_target;[m
[32m+[m[32m        MarkIniSettingsDirty(window);[m
[32m+[m[32m    }[m
[32m+[m[32m    if (pos_target.x != FLT_MAX)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->Pos = ImFloor(pos_target);[m
[32m+[m[32m        MarkIniSettingsDirty(window);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Resize nav layer[m
[32m+[m[32m    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;[m
[32m+[m[32m    window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);[m
[32m+[m
[32m+[m[32m    window->Size = window->SizeFull;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic inline void ClampWindowRect(ImGuiWindow* window, const ImRect& rect, const ImVec2& padding)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImVec2 size_for_clamping = (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window->Flags & ImGuiWindowFlags_NoTitleBar)) ? ImVec2(window->Size.x, window->TitleBarHeight()) : window->Size;[m
[32m+[m[32m    window->Pos = ImMin(rect.Max - padding, ImMax(window->Pos + size_for_clamping, rect.Min + padding) - size_for_clamping);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void ImGui::RenderOuterBorders(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    float rounding = window->WindowRounding;[m
[32m+[m[32m    float border_size = window->WindowBorderSize;[m
[32m+[m[32m    if (border_size > 0.0f && !(window->Flags & ImGuiWindowFlags_NoBackground))[m
[32m+[m[32m        window->DrawList->AddRect(window->Pos, window->Pos + window->Size, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);[m
[32m+[m
[32m+[m[32m    int border_held = window->ResizeBorderHeld;[m
[32m+[m[32m    if (border_held != -1)[m
[32m+[m[32m    {[m
[32m+[m[32m        struct ImGuiResizeBorderDef[m
[32m+[m[32m        {[m
[32m+[m[32m            ImVec2 InnerDir;[m
[32m+[m[32m            ImVec2 CornerPosN1, CornerPosN2;[m
[32m+[m[32m            float  OuterAngle;[m
[32m+[m[32m        };[m
[32m+[m[32m        static const ImGuiResizeBorderDef resize_border_def[4] =[m
[32m+[m[32m        {[m
[32m+[m[32m            { ImVec2(0,+1), ImVec2(0,0), ImVec2(1,0), IM_PI*1.50f }, // Top[m
[32m+[m[32m            { ImVec2(-1,0), ImVec2(1,0), ImVec2(1,1), IM_PI*0.00f }, // Right[m
[32m+[m[32m            { ImVec2(0,-1), ImVec2(1,1), ImVec2(0,1), IM_PI*0.50f }, // Bottom[m
[32m+[m[32m            { ImVec2(+1,0), ImVec2(0,1), ImVec2(0,0), IM_PI*1.00f }  // Left[m
[32m+[m[32m        };[m
[32m+[m[32m        const ImGuiResizeBorderDef& def = resize_border_def[border_held];[m
[32m+[m[32m        ImRect border_r = GetResizeBorderRect(window, border_held, rounding, 0.0f);[m
[32m+[m[32m        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.CornerPosN1) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI*0.25f, def.OuterAngle);[m
[32m+[m[32m        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.CornerPosN2) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI*0.25f);[m
[32m+[m[32m        window->DrawList->PathStroke(GetColorU32(ImGuiCol_SeparatorActive), false, ImMax(2.0f, border_size)); // Thicker than usual[m
[32m+[m[32m    }[m
[32m+[m[32m    if (g.Style.FrameBorderSize > 0 && !(window->Flags & ImGuiWindowFlags_NoTitleBar))[m
[32m+[m[32m    {[m
[32m+[m[32m        float y = window->Pos.y + window->TitleBarHeight() - 1;[m
[32m+[m[32m        window->DrawList->AddLine(ImVec2(window->Pos.x + border_size, y), ImVec2(window->Pos.x + window->Size.x - border_size, y), GetColorU32(ImGuiCol_Border), g.Style.FrameBorderSize);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window)[m
[32m+[m[32m{[m
[32m+[m[32m    window->ParentWindow = parent_window;[m
[32m+[m[32m    window->RootWindow = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;[m
[32m+[m[32m    if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))[m
[32m+[m[32m        window->RootWindow = parent_window->RootWindow;[m
[32m+[m[32m    if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)))[m
[32m+[m[32m        window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;[m
[32m+[m[32m    while (window->RootWindowForNav->Flags & ImGuiWindowFlags_NavFlattened)[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(window->RootWindowForNav->ParentWindow != NULL);[m
[32m+[m[32m        window->RootWindowForNav = window->RootWindowForNav->ParentWindow;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Push a new ImGui window to add widgets to.[m
[32m+[m[32m// - A default window called "Debug" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.[m
[32m+[m[32m// - Begin/End can be called multiple times during the frame with the same window name to append content.[m
[32m+[m[32m// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).[m
[32m+[m[32m//   You can use the "##" or "###" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.[m
[32m+[m[32m// - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.[m
[32m+[m[32m// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.[m
[32m+[m[32mbool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required[m
[32m+[m[32m    IM_ASSERT(g.FrameScopeActive);                  // Forgot to call ImGui::NewFrame()[m
[32m+[m[32m    IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet[m
[32m+[m
[32m+[m[32m    // Find or create[m
[32m+[m[32m    ImGuiWindow* window = FindWindowByName(name);[m
[32m+[m[32m    const bool window_just_created = (window == NULL);[m
[32m+[m[32m    if (window_just_created)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImVec2 size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : ImVec2(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.[m
[32m+[m[32m        window = CreateNewWindow(name, size_on_first_use, flags);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Automatically disable manual moving/resizing when NoInputs is set[m
[32m+[m[32m    if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)[m
[32m+[m[32m        flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;[m
[32m+[m
[32m+[m[32m    if (flags & ImGuiWindowFlags_NavFlattened)[m
[32m+[m[32m        IM_ASSERT(flags & ImGuiWindowFlags_ChildWindow);[m
[32m+[m
[32m+[m[32m    const int current_frame = g.FrameCount;[m
[32m+[m[32m    const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);[m
[32m+[m
[32m+[m[32m    // Update the Appearing flag[m
[32m+[m[32m    bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on[m
[32m+[m[32m    const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);[m
[32m+[m[32m    if (flags & ImGuiWindowFlags_Popup)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];[m
[32m+[m[32m        window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed[m
[32m+[m[32m        window_just_activated_by_user |= (window != popup_ref.Window);[m
[32m+[m[32m    }[m
[32m+[m[32m    window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);[m
[32m+[m[32m    if (window->Appearing)[m
[32m+[m[32m        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);[m
[32m+[m
[32m+[m[32m    // Update Flags, LastFrameActive, BeginOrderXXX fields[m
[32m+[m[32m    if (first_begin_of_the_frame)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->Flags = (ImGuiWindowFlags)flags;[m
[32m+[m[32m        window->LastFrameActive = current_frame;[m
[32m+[m[32m        window->BeginOrderWithinParent = 0;[m
[32m+[m[32m        window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        flags = window->Flags;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack[m
[32m+[m[32m    ImGuiWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();[m
[32m+[m[32m    ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;[m
[32m+[m[32m    IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));[m
[32m+[m
[32m+[m[32m    // Add to stack[m
[32m+[m[32m    // We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()[m
[32m+[m[32m    g.CurrentWindowStack.push_back(window);[m
[32m+[m[32m    g.CurrentWindow = NULL;[m
[32m+[m[32m    CheckStacksSize(window, true);[m
[32m+[m[32m    if (flags & ImGuiWindowFlags_Popup)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];[m
[32m+[m[32m        popup_ref.Window = window;[m
[32m+[m[32m        g.BeginPopupStack.push_back(popup_ref);[m
[32m+[m[32m        window->PopupId = popup_ref.PopupId;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (window_just_appearing_after_hidden_for_resize && !(flags & ImGuiWindowFlags_ChildWindow))[m
[32m+[m[32m        window->NavLastIds[0] = 0;[m
[32m+[m
[32m+[m[32m    // Process SetNextWindow***() calls[m
[32m+[m[32m    bool window_pos_set_by_api = false;[m
[32m+[m[32m    bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;[m
[32m+[m[32m    if (g.NextWindowData.PosCond)[m
[32m+[m[32m    {[m
[32m+[m[32m        window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;[m
[32m+[m[32m        if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)[m
[32m+[m[32m        {[m
[32m+[m[32m            // May be processed on the next frame if this is our first frame and we are measuring size[m
[32m+[m[32m            // FIXME: Look into removing the branch so everything can go through this same code path for consistency.[m
[32m+[m[32m            window->SetWindowPosVal = g.NextWindowData.PosVal;[m
[32m+[m[32m            window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;[m
[32m+[m[32m            window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    if (g.NextWindowData.SizeCond)[m
[32m+[m[32m    {[m
[32m+[m[32m        window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);[m
[32m+[m[32m        window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);[m
[32m+[m[32m        SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);[m
[32m+[m[32m    }[m
[32m+[m[32m    if (g.NextWindowData.ContentSizeCond)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Adjust passed "client size" to become a "window size"[m
[32m+[m[32m        window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;[m
[32m+[m[32m        if (window->SizeContentsExplicit.y != 0.0f)[m
[32m+[m[32m            window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (first_begin_of_the_frame)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->SizeContentsExplicit = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    }[m
[32m+[m[32m    if (g.NextWindowData.CollapsedCond)[m
[32m+[m[32m        SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);[m
[32m+[m[32m    if (g.NextWindowData.FocusCond)[m
[32m+[m[32m        FocusWindow(window);[m
[32m+[m[32m    if (window->Appearing)[m
[32m+[m[32m        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);[m
[32m+[m
[32m+[m[32m    // When reusing window again multiple times a frame, just append content (don't need to setup again)[m
[32m+[m[32m    if (first_begin_of_the_frame)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Initialize[m
[32m+[m[32m        const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)[m
[32m+[m[32m        UpdateWindowParentAndRootLinks(window, flags, parent_window);[m
[32m+[m
[32m+[m[32m        window->Active = true;[m
[32m+[m[32m        window->HasCloseButton = (p_open != NULL);[m
[32m+[m[32m        window->ClipRect = ImVec4(-FLT_MAX,-FLT_MAX,+FLT_MAX,+FLT_MAX);[m
[32m+[m[32m        window->IDStack.resize(1);[m
[32m+[m
[32m+[m[32m        // Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).[m
[32m+[m[32m        // The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.[m
[32m+[m[32m        bool window_title_visible_elsewhere = false;[m
[32m+[m[32m        if (g.NavWindowingList != NULL && (window->Flags & ImGuiWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB[m
[32m+[m[32m            window_title_visible_elsewhere = true;[m
[32m+[m[32m        if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            size_t buf_len = (size_t)window->NameBufLen;[m
[32m+[m[32m            window->Name = ImStrdupcpy(window->Name, &buf_len, name);[m
[32m+[m[32m            window->NameBufLen = (int)buf_len;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS[m
[32m+[m
[32m+[m[32m        // Update contents size from last frame for auto-fitting (or use explicit size)[m
[32m+[m[32m        window->SizeContents = CalcSizeContents(window);[m
[32m+[m[32m        if (window->HiddenFramesCanSkipItems > 0)[m
[32m+[m[32m            window->HiddenFramesCanSkipItems--;[m
[32m+[m[32m        if (window->HiddenFramesCannotSkipItems > 0)[m
[32m+[m[32m            window->HiddenFramesCannotSkipItems--;[m
[32m+[m
[32m+[m[32m        // Hide new windows for one frame until they calculate their size[m
[32m+[m[32m        if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))[m
[32m+[m[32m            window->HiddenFramesCannotSkipItems = 1;[m
[32m+[m
[32m+[m[32m        // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)[m
[32m+[m[32m        // We reset Size/SizeContents for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.[m
[32m+[m[32m        if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            window->HiddenFramesCannotSkipItems = 1;[m
[32m+[m[32m            if (flags & ImGuiWindowFlags_AlwaysAutoResize)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (!window_size_x_set_by_api)[m
[32m+[m[32m                    window->Size.x = window->SizeFull.x = 0.f;[m
[32m+[m[32m                if (!window_size_y_set_by_api)[m
[32m+[m[32m                    window->Size.y = window->SizeFull.y = 0.f;[m
[32m+[m[32m                window->SizeContents = ImVec2(0.f, 0.f);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        SetCurrentWindow(window);[m
[32m+[m
[32m+[m[32m        // Lock border size and padding for the frame (so that altering them doesn't cause inconsistencies)[m
[32m+[m[32m        if (flags & ImGuiWindowFlags_ChildWindow)[m
[32m+[m[32m            window->WindowBorderSize = style.ChildBorderSize;[m
[32m+[m[32m        else[m
[32m+[m[32m            window->WindowBorderSize = ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;[m
[32m+[m[32m        window->WindowPadding = style.WindowPadding;[m
[32m+[m[32m        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)[m
[32m+[m[32m            window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);[m
[32m+[m[32m        window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);[m
[32m+[m[32m        window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;[m
[32m+[m
[32m+[m[32m        // Collapse window by double-clicking on title bar[m
[32m+[m[32m        // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing[m
[32m+[m[32m        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse))[m
[32m+[m[32m        {[m
[32m+[m[32m            // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.[m
[32m+[m[32m            ImRect title_bar_rect = window->TitleBarRect();[m
[32m+[m[32m            if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])[m
[32m+[m[32m                window->WantCollapseToggle = true;[m
[32m+[m[32m            if (window->WantCollapseToggle)[m
[32m+[m[32m            {[m
[32m+[m[32m                window->Collapsed = !window->Collapsed;[m
[32m+[m[32m                MarkIniSettingsDirty(window);[m
[32m+[m[32m                FocusWindow(window);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            window->Collapsed = false;[m
[32m+[m[32m        }[m
[32m+[m[32m        window->WantCollapseToggle = false;[m
[32m+[m
[32m+[m[32m        // SIZE[m
[32m+[m
[32m+[m[32m        // Calculate auto-fit size, handle automatic resize[m
[32m+[m[32m        const ImVec2 size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);[m
[32m+[m[32m        ImVec2 size_full_modified(FLT_MAX, FLT_MAX);[m
[32m+[m[32m        if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.[m
[32m+[m[32m            if (!window_size_x_set_by_api)[m
[32m+[m[32m                window->SizeFull.x = size_full_modified.x = size_auto_fit.x;[m
[32m+[m[32m            if (!window_size_y_set_by_api)[m
[32m+[m[32m                window->SizeFull.y = size_full_modified.y = size_auto_fit.y;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Auto-fit may only grow window during the first few frames[m
[32m+[m[32m            // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.[m
[32m+[m[32m            if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)[m
[32m+[m[32m                window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;[m
[32m+[m[32m            if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)[m
[32m+[m[32m                window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;[m
[32m+[m[32m            if (!window->Collapsed)[m
[32m+[m[32m                MarkIniSettingsDirty(window);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Apply minimum/maximum window size constraints and final size[m
[32m+[m[32m        window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);[m
[32m+[m[32m        window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;[m
[32m+[m
[32m+[m[32m        // SCROLLBAR STATUS[m
[32m+[m
[32m+[m[32m        // Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).[m
[32m+[m[32m        if (!window->Collapsed)[m
[32m+[m[32m        {[m
[32m+[m[32m            // When reading the current size we need to read it after size constraints have been applied[m
[32m+[m[32m            float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;[m
[32m+[m[32m            float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;[m
[32m+[m[32m            window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));[m
[32m+[m[32m            window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));[m
[32m+[m[32m            if (window->ScrollbarX && !window->ScrollbarY)[m
[32m+[m[32m                window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & ImGuiWindowFlags_NoScrollbar);[m
[32m+[m[32m            window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // POSITION[m
[32m+[m
[32m+[m[32m        // Popup latch its initial position, will position itself when it appears next frame[m
[32m+[m[32m        if (window_just_activated_by_user)[m
[32m+[m[32m        {[m
[32m+[m[32m            window->AutoPosLastDirection = ImGuiDir_None;[m
[32m+[m[32m            if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api)[m
[32m+[m[32m                window->Pos = g.BeginPopupStack.back().OpenPopupPos;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Position child window[m
[32m+[m[32m        if (flags & ImGuiWindowFlags_ChildWindow)[m
[32m+[m[32m        {[m
[32m+[m[32m            IM_ASSERT(parent_window && parent_window->Active);[m
[32m+[m[32m            window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;[m
[32m+[m[32m            parent_window->DC.ChildWindows.push_back(window);[m
[32m+[m[32m            if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)[m
[32m+[m[32m                window->Pos = parent_window->DC.CursorPos;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);[m
[32m+[m[32m        if (window_pos_with_pivot)[m
[32m+[m[32m            SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0); // Position given a pivot (e.g. for centering)[m
[32m+[m[32m        else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)[m
[32m+[m[32m            window->Pos = FindBestWindowPosForPopup(window);[m
[32m+[m[32m        else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)[m
[32m+[m[32m            window->Pos = FindBestWindowPosForPopup(window);[m
[32m+[m[32m        else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)[m
[32m+[m[32m            window->Pos = FindBestWindowPosForPopup(window);[m
[32m+[m
[32m+[m[32m        // Clamp position so it stays visible[m
[32m+[m[32m        // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.[m
[32m+[m[32m        ImRect viewport_rect(GetViewportRect());[m
[32m+[m[32m        if (!window_pos_set_by_api && !(flags & ImGuiWindowFlags_ChildWindow) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.[m
[32m+[m[32m            {[m
[32m+[m[32m                ImVec2 clamp_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);[m
[32m+[m[32m                ClampWindowRect(window, viewport_rect, clamp_padding);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        window->Pos = ImFloor(window->Pos);[m
[32m+[m
[32m+[m[32m        // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)[m
[32m+[m[32m        window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;[m
[32m+[m
[32m+[m[32m        // Apply scrolling[m
[32m+[m[32m        window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window, true);[m
[32m+[m[32m        window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);[m
[32m+[m
[32m+[m[32m        // Apply window focus (new and reactivated windows are moved to front)[m
[32m+[m[32m        bool want_focus = false;[m
[32m+[m[32m        if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))[m
[32m+[m[32m        {[m
[32m+[m[32m            if (flags & ImGuiWindowFlags_Popup)[m
[32m+[m[32m                want_focus = true;[m
[32m+[m[32m            else if ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Tooltip)) == 0)[m
[32m+[m[32m                want_focus = true;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Handle manual resize: Resize Grips, Borders, Gamepad[m
[32m+[m[32m        int border_held = -1;[m
[32m+[m[32m        ImU32 resize_grip_col[4] = { 0 };[m
[32m+[m[32m        const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // 4[m
[32m+[m[32m        const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f);[m
[32m+[m[32m        if (!window->Collapsed)[m
[32m+[m[32m            UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);[m
[32m+[m[32m        window->ResizeBorderHeld = (signed char)border_held;[m
[32m+[m
[32m+[m[32m        // Default item width. Make it proportional to window size if window manually resizes[m
[32m+[m[32m        if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))[m
[32m+[m[32m            window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);[m
[32m+[m[32m        else[m
[32m+[m[32m            window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);[m
[32m+[m
[32m+[m[32m        // DRAWING[m
[32m+[m
[32m+[m[32m        // Setup draw list and outer clipping rectangle[m
[32m+[m[32m        window->DrawList->Clear();[m
[32m+[m[32m        window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);[m
[32m+[m[32m        window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);[m
[32m+[m[32m        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)[m
[32m+[m[32m            PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);[m
[32m+[m[32m        else[m
[32m+[m[32m            PushClipRect(viewport_rect.Min, viewport_rect.Max, true);[m
[32m+[m
[32m+[m[32m        // Draw modal window background (darkens what is behind them, all viewports)[m
[32m+[m[32m        const bool dim_bg_for_modal = (flags & ImGuiWindowFlags_Modal) && window == GetFrontMostPopupModal() && window->HiddenFramesCannotSkipItems <= 0;[m
[32m+[m[32m        const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && (window == g.NavWindowingTargetAnim->RootWindow);[m
[32m+[m[32m        if (dim_bg_for_modal || dim_bg_for_window_list)[m
[32m+[m[32m        {[m
[32m+[m[32m            const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio);[m
[32m+[m[32m            window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Draw navigation selection/windowing rectangle background[m
[32m+[m[32m        if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImRect bb = window->Rect();[m
[32m+[m[32m            bb.Expand(g.FontSize);[m
[32m+[m[32m            if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway[m
[32m+[m[32m                window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Draw window + handle manual resize[m
[32m+[m[32m        // As we highlight the title bar when want_focus is set, multiple reappearing windows will have have their title bar highlighted on their reappearing frame.[m
[32m+[m[32m        const float window_rounding = window->WindowRounding;[m
[32m+[m[32m        const float window_border_size = window->WindowBorderSize;[m
[32m+[m[32m        const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;[m
[32m+[m[32m        const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);[m
[32m+[m[32m        const ImRect title_bar_rect = window->TitleBarRect();[m
[32m+[m[32m        if (window->Collapsed)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Title bar only[m
[32m+[m[32m            float backup_border_size = style.FrameBorderSize;[m
[32m+[m[32m            g.Style.FrameBorderSize = window->WindowBorderSize;[m
[32m+[m[32m            ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);[m
[32m+[m[32m            RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);[m
[32m+[m[32m            g.Style.FrameBorderSize = backup_border_size;[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            // Window background[m
[32m+[m[32m            if (!(flags & ImGuiWindowFlags_NoBackground))[m
[32m+[m[32m            {[m
[32m+[m[32m                ImU32 bg_col = GetColorU32(GetWindowBgColorIdxFromFlags(flags));[m
[32m+[m[32m                float alpha = 1.0f;[m
[32m+[m[32m                if (g.NextWindowData.BgAlphaCond != 0)[m
[32m+[m[32m                    alpha = g.NextWindowData.BgAlphaVal;[m
[32m+[m[32m                if (alpha != 1.0f)[m
[32m+[m[32m                    bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);[m
[32m+[m[32m                window->DrawList->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight()), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Bot);[m
[32m+[m[32m            }[m
[32m+[m[32m            g.NextWindowData.BgAlphaCond = 0;[m
[32m+[m
[32m+[m[32m            // Title bar[m
[32m+[m[32m            if (!(flags & ImGuiWindowFlags_NoTitleBar))[m
[32m+[m[32m            {[m
[32m+[m[32m                ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);[m
[32m+[m[32m                window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Menu bar[m
[32m+[m[32m            if (flags & ImGuiWindowFlags_MenuBar)[m
[32m+[m[32m            {[m
[32m+[m[32m                ImRect menu_bar_rect = window->MenuBarRect();[m
[32m+[m[32m                menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.[m
[32m+[m[32m                window->DrawList->AddRectFilled(menu_bar_rect.Min+ImVec2(window_border_size,0), menu_bar_rect.Max-ImVec2(window_border_size,0), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);[m
[32m+[m[32m                if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)[m
[32m+[m[32m                    window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Scrollbars[m
[32m+[m[32m            if (window->ScrollbarX)[m
[32m+[m[32m                Scrollbar(ImGuiAxis_X);[m
[32m+[m[32m            if (window->ScrollbarY)[m
[32m+[m[32m                Scrollbar(ImGuiAxis_Y);[m
[32m+[m
[32m+[m[32m            // Render resize grips (after their input handling so we don't have a frame of latency)[m
[32m+[m[32m            if (!(flags & ImGuiWindowFlags_NoResize))[m
[32m+[m[32m            {[m
[32m+[m[32m                for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)[m
[32m+[m[32m                {[m
[32m+[m[32m                    const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];[m
[32m+[m[32m                    const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);[m
[32m+[m[32m                    window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, grip_draw_size) : ImVec2(grip_draw_size, window_border_size)));[m
[32m+[m[32m                    window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(grip_draw_size, window_border_size) : ImVec2(window_border_size, grip_draw_size)));[m
[32m+[m[32m                    window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);[m
[32m+[m[32m                    window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Borders[m
[32m+[m[32m            RenderOuterBorders(window);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Draw navigation selection/windowing rectangle border[m
[32m+[m[32m        if (g.NavWindowingTargetAnim == window)[m
[32m+[m[32m        {[m
[32m+[m[32m            float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);[m
[32m+[m[32m            ImRect bb = window->Rect();[m
[32m+[m[32m            bb.Expand(g.FontSize);[m
[32m+[m[32m            if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward[m
[32m+[m[32m            {[m
[32m+[m[32m                bb.Expand(-g.FontSize - 1.0f);[m
[32m+[m[32m                rounding = window->WindowRounding;[m
[32m+[m[32m            }[m
[32m+[m[32m            window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.[m
[32m+[m[32m        window->SizeFullAtLastBegin = window->SizeFull;[m
[32m+[m
[32m+[m[32m        // Update various regions. Variables they depends on are set above in this function.[m
[32m+[m[32m        // FIXME: window->ContentsRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.[m
[32m+[m[32m        // NB: WindowBorderSize is included in WindowPadding _and_ ScrollbarSizes so we need to cancel one out.[m
[32m+[m[32m        window->ContentsRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;[m
[32m+[m[32m        window->ContentsRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();[m
[32m+[m[32m        window->ContentsRegionRect.Max.x = window->Pos.x - window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x + ImMin(window->ScrollbarSizes.x, window->WindowBorderSize)));[m
[32m+[m[32m        window->ContentsRegionRect.Max.y = window->Pos.y - window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y + ImMin(window->ScrollbarSizes.y, window->WindowBorderSize)));[m
[32m+[m
[32m+[m[32m        // Save clipped aabb so we can access it in constant-time in FindHoveredWindow()[m
[32m+[m[32m        window->OuterRectClipped = window->Rect();[m
[32m+[m[32m        window->OuterRectClipped.ClipWith(window->ClipRect);[m
[32m+[m
[32m+[m[32m        // Inner rectangle[m
[32m+[m[32m        // We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame[m
[32m+[m[32m        // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.[m
[32m+[m[32m        window->InnerMainRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;[m
[32m+[m[32m        window->InnerMainRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);[m
[32m+[m[32m        window->InnerMainRect.Max.x = window->Pos.x + window->Size.x - ImMax(window->ScrollbarSizes.x, window->WindowBorderSize);[m
[32m+[m[32m        window->InnerMainRect.Max.y = window->Pos.y + window->Size.y - ImMax(window->ScrollbarSizes.y, window->WindowBorderSize);[m
[32m+[m
[32m+[m[32m        // Inner clipping rectangle[m
[32m+[m[32m        // Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.[m
[32m+[m[32m        window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerMainRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));[m
[32m+[m[32m        window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerMainRect.Min.y);[m
[32m+[m[32m        window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerMainRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));[m
[32m+[m[32m        window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerMainRect.Max.y);[m
[32m+[m[32m        // Setup drawing context[m
[32m+[m[32m        // (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)[m
[32m+[m[32m        window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;[m
[32m+[m[32m        window->DC.GroupOffset.x = 0.0f;[m
[32m+[m[32m        window->DC.ColumnsOffset.x = 0.0f;[m
[32m+[m[32m        window->DC.CursorStartPos = window->Pos + ImVec2(window->DC.Indent.x + window->DC.ColumnsOffset.x, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);[m
[32m+[m[32m        window->DC.CursorPos = window->DC.CursorStartPos;[m
[32m+[m[32m        window->DC.CursorPosPrevLine = window->DC.CursorPos;[m
[32m+[m[32m        window->DC.CursorMaxPos = window->DC.CursorStartPos;[m
[32m+[m[32m        window->DC.CurrentLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m        window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;[m
[32m+[m[32m        window->DC.NavHideHighlightOneFrame = false;[m
[32m+[m[32m        window->DC.NavHasScroll = (GetWindowScrollMaxY(window) > 0.0f);[m
[32m+[m[32m        window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;[m
[32m+[m[32m        window->DC.NavLayerActiveMaskNext = 0x00;[m
[32m+[m[32m        window->DC.MenuBarAppending = false;[m
[32m+[m[32m        window->DC.ChildWindows.resize(0);[m
[32m+[m[32m        window->DC.LayoutType = ImGuiLayoutType_Vertical;[m
[32m+[m[32m        window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;[m
[32m+[m[32m        window->DC.FocusCounterAll = window->DC.FocusCounterTab = -1;[m
[32m+[m[32m        window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : ImGuiItemFlags_Default_;[m
[32m+[m[32m        window->DC.ItemWidth = window->ItemWidthDefault;[m
[32m+[m[32m        window->DC.TextWrapPos = -1.0f; // disabled[m
[32m+[m[32m        window->DC.ItemFlagsStack.resize(0);[m
[32m+[m[32m        window->DC.ItemWidthStack.resize(0);[m
[32m+[m[32m        window->DC.TextWrapPosStack.resize(0);[m
[32m+[m[32m        window->DC.CurrentColumns = NULL;[m
[32m+[m[32m        window->DC.TreeDepth = 0;[m
[32m+[m[32m        window->DC.TreeStoreMayJumpToParentOnPop = 0x00;[m
[32m+[m[32m        window->DC.StateStorage = &window->StateStorage;[m
[32m+[m[32m        window->DC.GroupStack.resize(0);[m
[32m+[m[32m        window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);[m
[32m+[m
[32m+[m[32m        if ((flags & ImGuiWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))[m
[32m+[m[32m        {[m
[32m+[m[32m            window->DC.ItemFlags = parent_window->DC.ItemFlags;[m
[32m+[m[32m            window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (window->AutoFitFramesX > 0)[m
[32m+[m[32m            window->AutoFitFramesX--;[m
[32m+[m[32m        if (window->AutoFitFramesY > 0)[m
[32m+[m[32m            window->AutoFitFramesY--;[m
[32m+[m
[32m+[m[32m        // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)[m
[32m+[m[32m        if (want_focus)[m
[32m+[m[32m        {[m
[32m+[m[32m            FocusWindow(window);[m
[32m+[m[32m            NavInitWindow(window, false);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Title bar[m
[32m+[m[32m        if (!(flags & ImGuiWindowFlags_NoTitleBar))[m
[32m+[m[32m        {[m
[32m+[m[32m            // Close & collapse button are on layer 1 (same as menus) and don't default focus[m
[32m+[m[32m            const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;[m
[32m+[m[32m            window->DC.ItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;[m
[32m+[m[32m            window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;[m
[32m+[m[32m            window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Menu);[m
[32m+[m
[32m+[m[32m            // Collapse button[m
[32m+[m[32m            if (!(flags & ImGuiWindowFlags_NoCollapse))[m
[32m+[m[32m                if (CollapseButton(window->GetID("#COLLAPSE"), window->Pos))[m
[32m+[m[32m                    window->WantCollapseToggle = true; // Defer collapsing to next frame as we are too far in the Begin() function[m
[32m+[m
[32m+[m[32m            // Close button[m
[32m+[m[32m            if (p_open != NULL)[m
[32m+[m[32m            {[m
[32m+[m[32m                const float rad = g.FontSize * 0.5f;[m
[32m+[m[32m                if (CloseButton(window->GetID("#CLOSE"), ImVec2(window->Pos.x + window->Size.x - style.FramePadding.x - rad, window->Pos.y + style.FramePadding.y + rad), rad + 1))[m
[32m+[m[32m                    *p_open = false;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            window->DC.NavLayerCurrent = ImGuiNavLayer_Main;[m
[32m+[m[32m            window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);[m
[32m+[m[32m            window->DC.ItemFlags = item_flags_backup;[m
[32m+[m
[32m+[m[32m            // Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)[m
[32m+[m[32m            // FIXME: Refactor text alignment facilities along with RenderText helpers, this is too much code..[m
[32m+[m[32m            const char* UNSAVED_DOCUMENT_MARKER = "*";[m
[32m+[m[32m            float marker_size_x = (flags & ImGuiWindowFlags_UnsavedDocument) ? CalcTextSize(UNSAVED_DOCUMENT_MARKER, NULL, false).x : 0.0f;[m
[32m+[m[32m            ImVec2 text_size = CalcTextSize(name, NULL, true) + ImVec2(marker_size_x, 0.0f);[m
[32m+[m[32m            ImRect text_r = title_bar_rect;[m
[32m+[m[32m            float pad_left = (flags & ImGuiWindowFlags_NoCollapse) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);[m
[32m+[m[32m            float pad_right = (p_open == NULL)                     ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);[m
[32m+[m[32m            if (style.WindowTitleAlign.x > 0.0f)[m
[32m+[m[32m                pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);[m
[32m+[m[32m            text_r.Min.x += pad_left;[m
[32m+[m[32m            text_r.Max.x -= pad_right;[m
[32m+[m[32m            ImRect clip_rect = text_r;[m
[32m+[m[32m            clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()[m
[32m+[m[32m            RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);[m
[32m+[m[32m            if (flags & ImGuiWindowFlags_UnsavedDocument)[m
[32m+[m[32m            {[m
[32m+[m[32m                ImVec2 marker_pos = ImVec2(ImMax(text_r.Min.x, text_r.Min.x + (text_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x) + text_size.x, text_r.Min.y) + ImVec2(2 - marker_size_x, 0.0f);[m
[32m+[m[32m                ImVec2 off = ImVec2(0.0f, (float)(int)(-g.FontSize * 0.25f));[m
[32m+[m[32m                RenderTextClipped(marker_pos + off, text_r.Max + off, UNSAVED_DOCUMENT_MARKER, NULL, NULL, ImVec2(0, style.WindowTitleAlign.y), &clip_rect);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Pressing CTRL+C while holding on a window copy its content to the clipboard[m
[32m+[m[32m        // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.[m
[32m+[m[32m        // Maybe we can support CTRL+C on every element?[m
[32m+[m[32m        /*[m
[32m+[m[32m        if (g.ActiveId == move_id)[m
[32m+[m[32m            if (g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_C))[m
[32m+[m[32m                LogToClipboard();[m
[32m+[m[32m        */[m
[32m+[m
[32m+[m[32m        // We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().[m
[32m+[m[32m        // This is useful to allow creating context menus on title bar only, etc.[m
[32m+[m[32m        window->DC.LastItemId = window->MoveId;[m
[32m+[m[32m        window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0;[m
[32m+[m[32m        window->DC.LastItemRect = title_bar_rect;[m
[32m+[m[32m#ifdef IMGUI_ENABLE_TEST_ENGINE[m
[32m+[m[32m        if (!(window->Flags & ImGuiWindowFlags_NoTitleBar))[m
[32m+[m[32m            IMGUI_TEST_ENGINE_ITEM_ADD(window->DC.LastItemRect, window->DC.LastItemId);[m
[32m+[m[32m#endif[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // Append[m
[32m+[m[32m        SetCurrentWindow(window);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);[m
[32m+[m
[32m+[m[32m    // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)[m
[32m+[m[32m    if (first_begin_of_the_frame)[m
[32m+[m[32m        window->WriteAccessed = false;[m
[32m+[m
[32m+[m[32m    window->BeginCount++;[m
[32m+[m[32m    g.NextWindowData.Clear();[m
[32m+[m
[32m+[m[32m    if (flags & ImGuiWindowFlags_ChildWindow)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Child window can be out of sight and have "negative" clip windows.[m
[32m+[m[32m        // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).[m
[32m+[m[32m        IM_ASSERT((flags & ImGuiWindowFlags_NoTitleBar) != 0);[m
[32m+[m[32m        if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)[m
[32m+[m[32m            if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)[m
[32m+[m[32m                window->HiddenFramesCanSkipItems = 1;[m
[32m+[m
[32m+[m[32m        // Completely hide along with parent or if parent is collapsed[m
[32m+[m[32m        if (parent_window && (parent_window->Collapsed || parent_window->Hidden))[m
[32m+[m[32m            window->HiddenFramesCanSkipItems = 1;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)[m
[32m+[m[32m    if (style.Alpha <= 0.0f)[m
[32m+[m[32m        window->HiddenFramesCanSkipItems = 1;[m
[32m+[m
[32m+[m[32m    // Update the Hidden flag[m
[32m+[m[32m    window->Hidden = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);[m
[32m+[m
[32m+[m[32m    // Update the SkipItems flag, used to early out of all items functions (no layout required)[m
[32m+[m[32m    bool skip_items = false;[m
[32m+[m[32m    if (window->Collapsed || !window->Active || window->Hidden)[m
[32m+[m[32m        if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)[m
[32m+[m[32m            skip_items = true;[m
[32m+[m[32m    window->SkipItems = skip_items;[m
[32m+[m
[32m+[m[32m    return !skip_items;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Old Begin() API with 5 parameters, avoid calling this version directly! Use SetNextWindowSize()/SetNextWindowBgAlpha() + Begin() instead.[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32mbool ImGui::Begin(const char* name, bool* p_open, const ImVec2& size_first_use, float bg_alpha_override, ImGuiWindowFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    // Old API feature: we could pass the initial window size as a parameter. This was misleading because it only had an effect if the window didn't have data in the .ini file.[m
[32m+[m[32m    if (size_first_use.x != 0.0f || size_first_use.y != 0.0f)[m
[32m+[m[32m        SetNextWindowSize(size_first_use, ImGuiCond_FirstUseEver);[m
[32m+[m
[32m+[m[32m    // Old API feature: override the window background alpha with a parameter.[m
[32m+[m[32m    if (bg_alpha_override >= 0.0f)[m
[32m+[m[32m        SetNextWindowBgAlpha(bg_alpha_override);[m
[32m+[m
[32m+[m[32m    return Begin(name, p_open, flags);[m
[32m+[m[32m}[m
[32m+[m[32m#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m
[32m+[m[32mvoid ImGui::End()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    if (g.CurrentWindowStack.Size <= 1 && g.FrameScopePushedImplicitWindow)[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(g.CurrentWindowStack.Size > 1 && "Calling End() too many times!");[m
[32m+[m[32m        return; // FIXME-ERRORHANDLING[m
[32m+[m[32m    }[m
[32m+[m[32m    IM_ASSERT(g.CurrentWindowStack.Size > 0);[m
[32m+[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m
[32m+[m[32m    if (window->DC.CurrentColumns != NULL)[m
[32m+[m[32m        EndColumns();[m
[32m+[m[32m    PopClipRect();   // Inner window clip rectangle[m
[32m+[m
[32m+[m[32m    // Stop logging[m
[32m+[m[32m    if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging[m
[32m+[m[32m        LogFinish();[m
[32m+[m
[32m+[m[32m    // Pop from window stack[m
[32m+[m[32m    g.CurrentWindowStack.pop_back();[m
[32m+[m[32m    if (window->Flags & ImGuiWindowFlags_Popup)[m
[32m+[m[32m        g.BeginPopupStack.pop_back();[m
[32m+[m[32m    CheckStacksSize(window, false);[m
[32m+[m[32m    SetCurrentWindow(g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back());[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::BringWindowToFocusFront(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.WindowsFocusOrder.back() == window)[m
[32m+[m[32m        return;[m
[32m+[m[32m    for (int i = g.WindowsFocusOrder.Size - 2; i >= 0; i--) // We can ignore the front most window[m
[32m+[m[32m        if (g.WindowsFocusOrder[i] == window)[m
[32m+[m[32m        {[m
[32m+[m[32m            memmove(&g.WindowsFocusOrder[i], &g.WindowsFocusOrder[i + 1], (size_t)(g.WindowsFocusOrder.Size - i - 1) * sizeof(ImGuiWindow*));[m
[32m+[m[32m            g.WindowsFocusOrder[g.WindowsFocusOrder.Size - 1] = window;[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::BringWindowToDisplayFront(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* current_front_window = g.Windows.back();[m
[32m+[m[32m    if (current_front_window == window || current_front_window->RootWindow == window)[m
[32m+[m[32m        return;[m
[32m+[m[32m    for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the front most window[m
[32m+[m[32m        if (g.Windows[i] == window)[m
[32m+[m[32m        {[m
[32m+[m[32m            memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(ImGuiWindow*));[m
[32m+[m[32m            g.Windows[g.Windows.Size - 1] = window;[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::BringWindowToDisplayBack(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.Windows[0] == window)[m
[32m+[m[32m        return;[m
[32m+[m[32m    for (int i = 0; i < g.Windows.Size; i++)[m
[32m+[m[32m        if (g.Windows[i] == window)[m
[32m+[m[32m        {[m
[32m+[m[32m            memmove(&g.Windows[1], &g.Windows[0], (size_t)i * sizeof(ImGuiWindow*));[m
[32m+[m[32m            g.Windows[0] = window;[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Moving window to front of display and set focus (which happens to be back of our sorted list)[m
[32m+[m[32mvoid ImGui::FocusWindow(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    if (g.NavWindow != window)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.NavWindow = window;[m
[32m+[m[32m        if (window && g.NavDisableMouseHover)[m
[32m+[m[32m            g.NavMousePosDirty = true;[m
[32m+[m[32m        g.NavInitRequest = false;[m
[32m+[m[32m        g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId[m
[32m+[m[32m        g.NavIdIsAlive = false;[m
[32m+[m[32m        g.NavLayer = ImGuiNavLayer_Main;[m
[32m+[m[32m        //IMGUI_DEBUG_LOG("FocusWindow(\"%s\")\n", window ? window->Name : NULL);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Close popups if any[m
[32m+[m[32m    ClosePopupsOverWindow(window, false);[m
[32m+[m
[32m+[m[32m    // Passing NULL allow to disable keyboard focus[m
[32m+[m[32m    if (!window)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // Move the root window to the top of the pile[m
[32m+[m[32m    if (window->RootWindow)[m
[32m+[m[32m        window = window->RootWindow;[m
[32m+[m
[32m+[m[32m    // Steal focus on active widgets[m
[32m+[m[32m    if (window->Flags & ImGuiWindowFlags_Popup) // FIXME: This statement should be unnecessary. Need further testing before removing it..[m
[32m+[m[32m        if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != window)[m
[32m+[m[32m            ClearActiveID();[m
[32m+[m
[32m+[m[32m    // Bring to front[m
[32m+[m[32m    BringWindowToFocusFront(window);[m
[32m+[m[32m    if (!(window->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus))[m
[32m+[m[32m        BringWindowToDisplayFront(window);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    int start_idx = g.WindowsFocusOrder.Size - 1;[m
[32m+[m[32m    if (under_this_window != NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        int under_this_window_idx = FindWindowFocusIndex(under_this_window);[m
[32m+[m[32m        if (under_this_window_idx != -1)[m
[32m+[m[32m            start_idx = under_this_window_idx - 1;[m
[32m+[m[32m    }[m
[32m+[m[32m    for (int i = start_idx; i >= 0; i--)[m
[32m+[m[32m    {[m
[32m+[m[32m        // We may later decide to test for different NoXXXInputs based on the active navigation input (mouse vs nav) but that may feel more confusing to the user.[m
[32m+[m[32m        ImGuiWindow* window = g.WindowsFocusOrder[i];[m
[32m+[m[32m        if (window != ignore_window && window->WasActive && !(window->Flags & ImGuiWindowFlags_ChildWindow))[m
[32m+[m[32m            if ((window->Flags & (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs)) != (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs))[m
[32m+[m[32m            {[m
[32m+[m[32m                ImGuiWindow* focus_window = NavRestoreLastChildNavWindow(window);[m
[32m+[m[32m                FocusWindow(focus_window);[m
[32m+[m[32m                return;[m
[32m+[m[32m            }[m
[32m+[m[32m    }[m
[32m+[m[32m    FocusWindow(NULL);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetNextItemWidth(float item_width)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->DC.NextItemWidth = item_width;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PushItemWidth(float item_width)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);[m
[32m+[m[32m    window->DC.ItemWidthStack.push_back(window->DC.ItemWidth);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PushMultiItemsWidths(int components, float w_full)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    const ImGuiStyle& style = GImGui->Style;[m
[32m+[m[32m    const float w_item_one  = ImMax(1.0f, (float)(int)((w_full - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));[m
[32m+[m[32m    const float w_item_last = ImMax(1.0f, (float)(int)(w_full - (w_item_one + style.ItemInnerSpacing.x) * (components-1)));[m
[32m+[m[32m    window->DC.ItemWidthStack.push_back(w_item_last);[m
[32m+[m[32m    for (int i = 0; i < components-1; i++)[m
[32m+[m[32m        window->DC.ItemWidthStack.push_back(w_item_one);[m
[32m+[m[32m    window->DC.ItemWidth = window->DC.ItemWidthStack.back();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PopItemWidth()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->DC.ItemWidthStack.pop_back();[m
[32m+[m[32m    window->DC.ItemWidth = window->DC.ItemWidthStack.empty() ? window->ItemWidthDefault : window->DC.ItemWidthStack.back();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Calculate default item width given value passed to PushItemWidth() or SetNextItemWidth(),[m
[32m+[m[32m// Then consume the[m[41m [m
[32m+[m[32mfloat ImGui::GetNextItemWidth()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    float w;[m
[32m+[m[32m    if (window->DC.NextItemWidth != FLT_MAX)[m
[32m+[m[32m    {[m
[32m+[m[32m        w = window->DC.NextItemWidth;[m
[32m+[m[32m        window->DC.NextItemWidth = FLT_MAX;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        w = window->DC.ItemWidth;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (w < 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        float region_max_x = GetWorkRectMax().x;[m
[32m+[m[32m        w = ImMax(1.0f, region_max_x - window->DC.CursorPos.x + w);[m
[32m+[m[32m    }[m
[32m+[m[32m    w = (float)(int)w;[m
[32m+[m[32m    return w;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Calculate item width *without* popping/consuming NextItemWidth if it was set.[m
[32m+[m[32m// (rarely used, which is why we avoid calling this from GetNextItemWidth() and instead do a backup/restore here)[m
[32m+[m[32mfloat ImGui::CalcItemWidth()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    float backup_next_item_width = window->DC.NextItemWidth;[m
[32m+[m[32m    float w = GetNextItemWidth();[m
[32m+[m[32m    window->DC.NextItemWidth = backup_next_item_width;[m
[32m+[m[32m    return w;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// [Internal] Calculate full item size given user provided 'size' parameter and default width/height. Default width is often == GetNextItemWidth().[m
[32m+[m[32m// Those two functions CalcItemWidth vs CalcItemSize are awkwardly named because they are not fully symmetrical.[m
[32m+[m[32m// Note that only CalcItemWidth() is publicly exposed.[m
[32m+[m[32m// The 4.0f here may be changed to match GetNextItemWidth() and/or BeginChild() (right now we have a mismatch which is harmless but undesirable)[m
[32m+[m[32mImVec2 ImGui::CalcItemSize(ImVec2 size, float default_w, float default_h)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m
[32m+[m[32m    ImVec2 region_max;[m
[32m+[m[32m    if (size.x < 0.0f || size.y < 0.0f)[m
[32m+[m[32m        region_max = GetWorkRectMax();[m
[32m+[m
[32m+[m[32m    if (size.x == 0.0f)[m
[32m+[m[32m        size.x = default_w;[m
[32m+[m[32m    else if (size.x < 0.0f)[m
[32m+[m[32m        size.x = ImMax(4.0f, region_max.x - window->DC.CursorPos.x + size.x);[m
[32m+[m
[32m+[m[32m    if (size.y == 0.0f)[m
[32m+[m[32m        size.y = default_h;[m
[32m+[m[32m    else if (size.y < 0.0f)[m
[32m+[m[32m        size.y = ImMax(4.0f, region_max.y - window->DC.CursorPos.y + size.y);[m
[32m+[m
[32m+[m[32m    return size;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetCurrentFont(ImFont* font)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?[m
[32m+[m[32m    IM_ASSERT(font->Scale > 0.0f);[m
[32m+[m[32m    g.Font = font;[m
[32m+[m[32m    g.FontBaseSize = ImMax(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);[m
[32m+[m[32m    g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;[m
[32m+[m
[32m+[m[32m    ImFontAtlas* atlas = g.Font->ContainerAtlas;[m
[32m+[m[32m    g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;[m
[32m+[m[32m    g.DrawListSharedData.Font = g.Font;[m
[32m+[m[32m    g.DrawListSharedData.FontSize = g.FontSize;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PushFont(ImFont* font)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (!font)[m
[32m+[m[32m        font = GetDefaultFont();[m
[32m+[m[32m    SetCurrentFont(font);[m
[32m+[m[32m    g.FontStack.push_back(font);[m
[32m+[m[32m    g.CurrentWindow->DrawList->PushTextureID(font->ContainerAtlas->TexID);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid  ImGui::PopFont()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.CurrentWindow->DrawList->PopTextureID();[m
[32m+[m[32m    g.FontStack.pop_back();[m
[32m+[m[32m    SetCurrentFont(g.FontStack.empty() ? GetDefaultFont() : g.FontStack.back());[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PushItemFlag(ImGuiItemFlags option, bool enabled)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (enabled)[m
[32m+[m[32m        window->DC.ItemFlags |= option;[m
[32m+[m[32m    else[m
[32m+[m[32m        window->DC.ItemFlags &= ~option;[m
[32m+[m[32m    window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PopItemFlag()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->DC.ItemFlagsStack.pop_back();[m
[32m+[m[32m    window->DC.ItemFlags = window->DC.ItemFlagsStack.empty() ? ImGuiItemFlags_Default_ : window->DC.ItemFlagsStack.back();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// FIXME: Look into renaming this once we have settled the new Focus/Activation/TabStop system.[m
[32m+[m[32mvoid ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)[m
[32m+[m[32m{[m
[32m+[m[32m    PushItemFlag(ImGuiItemFlags_NoTabStop, !allow_keyboard_focus);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PopAllowKeyboardFocus()[m
[32m+[m[32m{[m
[32m+[m[32m    PopItemFlag();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PushButtonRepeat(bool repeat)[m
[32m+[m[32m{[m
[32m+[m[32m    PushItemFlag(ImGuiItemFlags_ButtonRepeat, repeat);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PopButtonRepeat()[m
[32m+[m[32m{[m
[32m+[m[32m    PopItemFlag();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PushTextWrapPos(float wrap_pos_x)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->DC.TextWrapPos = wrap_pos_x;[m
[32m+[m[32m    window->DC.TextWrapPosStack.push_back(wrap_pos_x);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PopTextWrapPos()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->DC.TextWrapPosStack.pop_back();[m
[32m+[m[32m    window->DC.TextWrapPos = window->DC.TextWrapPosStack.empty() ? -1.0f : window->DC.TextWrapPosStack.back();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32[m
[32m+[m[32mvoid ImGui::PushStyleColor(ImGuiCol idx, ImU32 col)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiColorMod backup;[m
[32m+[m[32m    backup.Col = idx;[m
[32m+[m[32m    backup.BackupValue = g.Style.Colors[idx];[m
[32m+[m[32m    g.ColorModifiers.push_back(backup);[m
[32m+[m[32m    g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiColorMod backup;[m
[32m+[m[32m    backup.Col = idx;[m
[32m+[m[32m    backup.BackupValue = g.Style.Colors[idx];[m
[32m+[m[32m    g.ColorModifiers.push_back(backup);[m
[32m+[m[32m    g.Style.Colors[idx] = col;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PopStyleColor(int count)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    while (count > 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiColorMod& backup = g.ColorModifiers.back();[m
[32m+[m[32m        g.Style.Colors[backup.Col] = backup.BackupValue;[m
[32m+[m[32m        g.ColorModifiers.pop_back();[m
[32m+[m[32m        count--;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstruct ImGuiStyleVarInfo[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiDataType   Type;[m
[32m+[m[32m    ImU32           Count;[m
[32m+[m[32m    ImU32           Offset;[m
[32m+[m[32m    void*           GetVarPtr(ImGuiStyle* style) const { return (void*)((unsigned char*)style + Offset); }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstatic const ImGuiStyleVarInfo GStyleVarInfo[] =[m
[32m+[m[32m{[m
[32m+[m[32m    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, Alpha) },               // ImGuiStyleVar_Alpha[m
[32m+[m[32m    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowPadding) },       // ImGuiStyleVar_WindowPadding[m
[32m+[m[32m    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowRounding) },      // ImGuiStyleVar_WindowRounding[m
[32m+[m[32m    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowBorderSize) },    // ImGuiStyleVar_WindowBorderSize[m
[32m+[m[32m    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowMinSize) },       // ImGuiStyleVar_WindowMinSize[m
[32m+[m[32m    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowTitleAlign) },    // ImGuiStyleVar_WindowTitleAlign[m
[32m+[m[32m    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ChildRounding) },       // ImGuiStyleVar_ChildRounding[m
[32m+[m[32m    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ChildBorderSize) },     // ImGuiStyleVar_ChildBorderSize[m
[32m+[m[32m    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, PopupRounding) },       // ImGuiStyleVar_PopupRounding[m
[32m+[m[32m    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, PopupBorderSize) },     // ImGuiStyleVar_PopupBorderSize[m
[32m+[m[32m    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, FramePadding) },        // ImGuiStyleVar_FramePadding[m
[32m+[m[32m    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, FrameRounding) },       // ImGuiStyleVar_FrameRounding[m
[32m+[m[32m    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, FrameBorderSize) },     // ImGuiStyleVar_FrameBorderSize[m
[32m+[m[32m    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemSpacing) },         // ImGuiStyleVar_ItemSpacing[m
[32m+[m[32m    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemInnerSpacing) },    // ImGuiStyleVar_ItemInnerSpacing[m
[32m+[m[32m    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, IndentSpacing) },       // ImGuiStyleVar_IndentSpacing[m
[32m+[m[32m    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ScrollbarSize) },       // ImGuiStyleVar_ScrollbarSize[m
[32m+[m[32m    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ScrollbarRounding) },   // ImGuiStyleVar_ScrollbarRounding[m
[32m+[m[32m    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, GrabMinSize) },         // ImGuiStyleVar_GrabMinSize[m
[32m+[m[32m    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, GrabRounding) },        // ImGuiStyleVar_GrabRounding[m
[32m+[m[32m    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, TabRounding) },         // ImGuiStyleVar_TabRounding[m
[32m+[m[32m    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ButtonTextAlign) },     // ImGuiStyleVar_ButtonTextAlign[m
[32m+[m[32m    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, SelectableTextAlign) }, // ImGuiStyleVar_SelectableTextAlign[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstatic const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar idx)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);[m
[32m+[m[32m    IM_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);[m
[32m+[m[32m    return &GStyleVarInfo[idx];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PushStyleVar(ImGuiStyleVar idx, float val)[m
[32m+[m[32m{[m
[32m+[m[32m    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);[m
[32m+[m[32m    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiContext& g = *GImGui;[m
[32m+[m[32m        float* pvar = (float*)var_info->GetVarPtr(&g.Style);[m
[32m+[m[32m        g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));[m
[32m+[m[32m        *pvar = val;[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    IM_ASSERT(0 && "Called PushStyleVar() float variant but variable is not a float!");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)[m
[32m+[m[32m{[m
[32m+[m[32m    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);[m
[32m+[m[32m    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiContext& g = *GImGui;[m
[32m+[m[32m        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);[m
[32m+[m[32m        g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));[m
[32m+[m[32m        *pvar = val;[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    IM_ASSERT(0 && "Called PushStyleVar() ImVec2 variant but variable is not a ImVec2!");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PopStyleVar(int count)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    while (count > 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.[m
[32m+[m[32m        ImGuiStyleMod& backup = g.StyleModifiers.back();[m
[32m+[m[32m        const ImGuiStyleVarInfo* info = GetStyleVarInfo(backup.VarIdx);[m
[32m+[m[32m        void* data = info->GetVarPtr(&g.Style);[m
[32m+[m[32m        if (info->Type == ImGuiDataType_Float && info->Count == 1)      { ((float*)data)[0] = backup.BackupFloat[0]; }[m
[32m+[m[32m        else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }[m
[32m+[m[32m        g.StyleModifiers.pop_back();[m
[32m+[m[32m        count--;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst char* ImGui::GetStyleColorName(ImGuiCol idx)[m
[32m+[m[32m{[m
[32m+[m[32m    // Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\1: return "\1";[m
[32m+[m[32m    switch (idx)[m
[32m+[m[32m    {[m
[32m+[m[32m    case ImGuiCol_Text: return "Text";[m
[32m+[m[32m    case ImGuiCol_TextDisabled: return "TextDisabled";[m
[32m+[m[32m    case ImGuiCol_WindowBg: return "WindowBg";[m
[32m+[m[32m    case ImGuiCol_ChildBg: return "ChildBg";[m
[32m+[m[32m    case ImGuiCol_PopupBg: return "PopupBg";[m
[32m+[m[32m    case ImGuiCol_Border: return "Border";[m
[32m+[m[32m    case ImGuiCol_BorderShadow: return "BorderShadow";[m
[32m+[m[32m    case ImGuiCol_FrameBg: return "FrameBg";[m
[32m+[m[32m    case ImGuiCol_FrameBgHovered: return "FrameBgHovered";[m
[32m+[m[32m    case ImGuiCol_FrameBgActive: return "FrameBgActive";[m
[32m+[m[32m    case ImGuiCol_TitleBg: return "TitleBg";[m
[32m+[m[32m    case ImGuiCol_TitleBgActive: return "TitleBgActive";[m
[32m+[m[32m    case ImGuiCol_TitleBgCollapsed: return "TitleBgCollapsed";[m
[32m+[m[32m    case ImGuiCol_MenuBarBg: return "MenuBarBg";[m
[32m+[m[32m    case ImGuiCol_ScrollbarBg: return "ScrollbarBg";[m
[32m+[m[32m    case ImGuiCol_ScrollbarGrab: return "ScrollbarGrab";[m
[32m+[m[32m    case ImGuiCol_ScrollbarGrabHovered: return "ScrollbarGrabHovered";[m
[32m+[m[32m    case ImGuiCol_ScrollbarGrabActive: return "ScrollbarGrabActive";[m
[32m+[m[32m    case ImGuiCol_CheckMark: return "CheckMark";[m
[32m+[m[32m    case ImGuiCol_SliderGrab: return "SliderGrab";[m
[32m+[m[32m    case ImGuiCol_SliderGrabActive: return "SliderGrabActive";[m
[32m+[m[32m    case ImGuiCol_Button: return "Button";[m
[32m+[m[32m    case ImGuiCol_ButtonHovered: return "ButtonHovered";[m
[32m+[m[32m    case ImGuiCol_ButtonActive: return "ButtonActive";[m
[32m+[m[32m    case ImGuiCol_Header: return "Header";[m
[32m+[m[32m    case ImGuiCol_HeaderHovered: return "HeaderHovered";[m
[32m+[m[32m    case ImGuiCol_HeaderActive: return "HeaderActive";[m
[32m+[m[32m    case ImGuiCol_Separator: return "Separator";[m
[32m+[m[32m    case ImGuiCol_SeparatorHovered: return "SeparatorHovered";[m
[32m+[m[32m    case ImGuiCol_SeparatorActive: return "SeparatorActive";[m
[32m+[m[32m    case ImGuiCol_ResizeGrip: return "ResizeGrip";[m
[32m+[m[32m    case ImGuiCol_ResizeGripHovered: return "ResizeGripHovered";[m
[32m+[m[32m    case ImGuiCol_ResizeGripActive: return "ResizeGripActive";[m
[32m+[m[32m    case ImGuiCol_Tab: return "Tab";[m
[32m+[m[32m    case ImGuiCol_TabHovered: return "TabHovered";[m
[32m+[m[32m    case ImGuiCol_TabActive: return "TabActive";[m
[32m+[m[32m    case ImGuiCol_TabUnfocused: return "TabUnfocused";[m
[32m+[m[32m    case ImGuiCol_TabUnfocusedActive: return "TabUnfocusedActive";[m
[32m+[m[32m    case ImGuiCol_PlotLines: return "PlotLines";[m
[32m+[m[32m    case ImGuiCol_PlotLinesHovered: return "PlotLinesHovered";[m
[32m+[m[32m    case ImGuiCol_PlotHistogram: return "PlotHistogram";[m
[32m+[m[32m    case ImGuiCol_PlotHistogramHovered: return "PlotHistogramHovered";[m
[32m+[m[32m    case ImGuiCol_TextSelectedBg: return "TextSelectedBg";[m
[32m+[m[32m    case ImGuiCol_DragDropTarget: return "DragDropTarget";[m
[32m+[m[32m    case ImGuiCol_NavHighlight: return "NavHighlight";[m
[32m+[m[32m    case ImGuiCol_NavWindowingHighlight: return "NavWindowingHighlight";[m
[32m+[m[32m    case ImGuiCol_NavWindowingDimBg: return "NavWindowingDimBg";[m
[32m+[m[32m    case ImGuiCol_ModalWindowDimBg: return "ModalWindowDimBg";[m
[32m+[m[32m    }[m
[32m+[m[32m    IM_ASSERT(0);[m
[32m+[m[32m    return "Unknown";[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent)[m
[32m+[m[32m{[m
[32m+[m[32m    if (window->RootWindow == potential_parent)[m
[32m+[m[32m        return true;[m
[32m+[m[32m    while (window != NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (window == potential_parent)[m
[32m+[m[32m            return true;[m
[32m+[m[32m        window = window->ParentWindow;[m
[32m+[m[32m    }[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsWindowHovered(ImGuiHoveredFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT((flags & ImGuiHoveredFlags_AllowWhenOverlapped) == 0);   // Flags not supported by this function[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    if (flags & ImGuiHoveredFlags_AnyWindow)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (g.HoveredWindow == NULL)[m
[32m+[m[32m            return false;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        switch (flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows))[m
[32m+[m[32m        {[m
[32m+[m[32m        case ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows:[m
[32m+[m[32m            if (g.HoveredRootWindow != g.CurrentWindow->RootWindow)[m
[32m+[m[32m                return false;[m
[32m+[m[32m            break;[m
[32m+[m[32m        case ImGuiHoveredFlags_RootWindow:[m
[32m+[m[32m            if (g.HoveredWindow != g.CurrentWindow->RootWindow)[m
[32m+[m[32m                return false;[m
[32m+[m[32m            break;[m
[32m+[m[32m        case ImGuiHoveredFlags_ChildWindows:[m
[32m+[m[32m            if (g.HoveredWindow == NULL || !IsWindowChildOf(g.HoveredWindow, g.CurrentWindow))[m
[32m+[m[32m                return false;[m
[32m+[m[32m            break;[m
[32m+[m[32m        default:[m
[32m+[m[32m            if (g.HoveredWindow != g.CurrentWindow)[m
[32m+[m[32m                return false;[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (!IsWindowContentHoverable(g.HoveredWindow, flags))[m
[32m+[m[32m        return false;[m
[32m+[m[32m    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))[m
[32m+[m[32m        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != g.HoveredWindow->MoveId)[m
[32m+[m[32m            return false;[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsWindowFocused(ImGuiFocusedFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    if (flags & ImGuiFocusedFlags_AnyWindow)[m
[32m+[m[32m        return g.NavWindow != NULL;[m
[32m+[m
[32m+[m[32m    IM_ASSERT(g.CurrentWindow);     // Not inside a Begin()/End()[m
[32m+[m[32m    switch (flags & (ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows))[m
[32m+[m[32m    {[m
[32m+[m[32m    case ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows:[m
[32m+[m[32m        return g.NavWindow && g.NavWindow->RootWindow == g.CurrentWindow->RootWindow;[m
[32m+[m[32m    case ImGuiFocusedFlags_RootWindow:[m
[32m+[m[32m        return g.NavWindow == g.CurrentWindow->RootWindow;[m
[32m+[m[32m    case ImGuiFocusedFlags_ChildWindows:[m
[32m+[m[32m        return g.NavWindow && IsWindowChildOf(g.NavWindow, g.CurrentWindow);[m
[32m+[m[32m    default:[m
[32m+[m[32m        return g.NavWindow == g.CurrentWindow;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Can we focus this window with CTRL+TAB (or PadMenu + PadFocusPrev/PadFocusNext)[m
[32m+[m[32m// Note that NoNavFocus makes the window not reachable with CTRL+TAB but it can still be focused with mouse or programmaticaly.[m
[32m+[m[32m// If you want a window to never be focused, you may use the e.g. NoInputs flag.[m
[32m+[m[32mbool ImGui::IsWindowNavFocusable(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    return window->Active && window == window->RootWindow && !(window->Flags & ImGuiWindowFlags_NoNavFocus);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetWindowWidth()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    return window->Size.x;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetWindowHeight()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    return window->Size.y;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImGui::GetWindowPos()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    return window->Pos;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetWindowScrollX(ImGuiWindow* window, float new_scroll_x)[m
[32m+[m[32m{[m
[32m+[m[32m    window->DC.CursorMaxPos.x += window->Scroll.x; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.[m
[32m+[m[32m    window->Scroll.x = new_scroll_x;[m
[32m+[m[32m    window->DC.CursorMaxPos.x -= window->Scroll.x;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetWindowScrollY(ImGuiWindow* window, float new_scroll_y)[m
[32m+[m[32m{[m
[32m+[m[32m    window->DC.CursorMaxPos.y += window->Scroll.y; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.[m
[32m+[m[32m    window->Scroll.y = new_scroll_y;[m
[32m+[m[32m    window->DC.CursorMaxPos.y -= window->Scroll.y;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond)[m
[32m+[m[32m{[m
[32m+[m[32m    // Test condition (NB: bit 0 is always true) and clear flags for next time[m
[32m+[m[32m    if (cond && (window->SetWindowPosAllowFlags & cond) == 0)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.[m
[32m+[m[32m    window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);[m
[32m+[m[32m    window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);[m
[32m+[m
[32m+[m[32m    // Set[m
[32m+[m[32m    const ImVec2 old_pos = window->Pos;[m
[32m+[m[32m    window->Pos = ImFloor(pos);[m
[32m+[m[32m    window->DC.CursorPos += (window->Pos - old_pos);    // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor[m
[32m+[m[32m    window->DC.CursorMaxPos += (window->Pos - old_pos); // And more importantly we need to adjust this so size calculation doesn't get affected.[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetWindowPos(const ImVec2& pos, ImGuiCond cond)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    SetWindowPos(window, pos, cond);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond)[m
[32m+[m[32m{[m
[32m+[m[32m    if (ImGuiWindow* window = FindWindowByName(name))[m
[32m+[m[32m        SetWindowPos(window, pos, cond);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImGui::GetWindowSize()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->Size;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond)[m
[32m+[m[32m{[m
[32m+[m[32m    // Test condition (NB: bit 0 is always true) and clear flags for next time[m
[32m+[m[32m    if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.[m
[32m+[m[32m    window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);[m
[32m+[m
[32m+[m[32m    // Set[m
[32m+[m[32m    if (size.x > 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->AutoFitFramesX = 0;[m
[32m+[m[32m        window->SizeFull.x = ImFloor(size.x);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        window->AutoFitFramesX = 2;[m
[32m+[m[32m        window->AutoFitOnlyGrows = false;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (size.y > 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->AutoFitFramesY = 0;[m
[32m+[m[32m        window->SizeFull.y = ImFloor(size.y);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        window->AutoFitFramesY = 2;[m
[32m+[m[32m        window->AutoFitOnlyGrows = false;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetWindowSize(const ImVec2& size, ImGuiCond cond)[m
[32m+[m[32m{[m
[32m+[m[32m    SetWindowSize(GImGui->CurrentWindow, size, cond);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond)[m
[32m+[m[32m{[m
[32m+[m[32m    if (ImGuiWindow* window = FindWindowByName(name))[m
[32m+[m[32m        SetWindowSize(window, size, cond);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond)[m
[32m+[m[32m{[m
[32m+[m[32m    // Test condition (NB: bit 0 is always true) and clear flags for next time[m
[32m+[m[32m    if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)[m
[32m+[m[32m        return;[m
[32m+[m[32m    window->SetWindowCollapsedAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);[m
[32m+[m
[32m+[m[32m    // Set[m
[32m+[m[32m    window->Collapsed = collapsed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetWindowCollapsed(bool collapsed, ImGuiCond cond)[m
[32m+[m[32m{[m
[32m+[m[32m    SetWindowCollapsed(GImGui->CurrentWindow, collapsed, cond);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsWindowCollapsed()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->Collapsed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsWindowAppearing()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->Appearing;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond)[m
[32m+[m[32m{[m
[32m+[m[32m    if (ImGuiWindow* window = FindWindowByName(name))[m
[32m+[m[32m        SetWindowCollapsed(window, collapsed, cond);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetWindowFocus()[m
[32m+[m[32m{[m
[32m+[m[32m    FocusWindow(GImGui->CurrentWindow);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetWindowFocus(const char* name)[m
[32m+[m[32m{[m
[32m+[m[32m    if (name)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (ImGuiWindow* window = FindWindowByName(name))[m
[32m+[m[32m            FocusWindow(window);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        FocusWindow(NULL);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.[m
[32m+[m[32m    g.NextWindowData.PosVal = pos;[m
[32m+[m[32m    g.NextWindowData.PosPivotVal = pivot;[m
[32m+[m[32m    g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetNextWindowSize(const ImVec2& size, ImGuiCond cond)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.[m
[32m+[m[32m    g.NextWindowData.SizeVal = size;[m
[32m+[m[32m    g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback, void* custom_callback_user_data)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.NextWindowData.SizeConstraintCond = ImGuiCond_Always;[m
[32m+[m[32m    g.NextWindowData.SizeConstraintRect = ImRect(size_min, size_max);[m
[32m+[m[32m    g.NextWindowData.SizeCallback = custom_callback;[m
[32m+[m[32m    g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetNextWindowContentSize(const ImVec2& size)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.NextWindowData.ContentSizeVal = size;  // In Begin() we will add the size of window decorations (title bar, menu etc.) to that to form a SizeContents value.[m
[32m+[m[32m    g.NextWindowData.ContentSizeCond = ImGuiCond_Always;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.[m
[32m+[m[32m    g.NextWindowData.CollapsedVal = collapsed;[m
[32m+[m[32m    g.NextWindowData.CollapsedCond = cond ? cond : ImGuiCond_Always;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetNextWindowFocus()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.NextWindowData.FocusCond = ImGuiCond_Always;   // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetNextWindowBgAlpha(float alpha)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.NextWindowData.BgAlphaVal = alpha;[m
[32m+[m[32m    g.NextWindowData.BgAlphaCond = ImGuiCond_Always; // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// FIXME: This is in window space (not screen space!). We should try to obsolete all those functions.[m
[32m+[m[32mImVec2 ImGui::GetContentRegionMax()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    ImVec2 mx = window->ContentsRegionRect.Max - window->Pos;[m
[32m+[m[32m    if (window->DC.CurrentColumns)[m
[32m+[m[32m        mx.x = GetColumnOffset(window->DC.CurrentColumns->Current + 1) - window->WindowPadding.x;[m
[32m+[m[32m    return mx;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// [Internal] Absolute coordinate. Saner. This is not exposed until we finishing refactoring work rect features.[m
[32m+[m[32mImVec2 ImGui::GetWorkRectMax()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    ImVec2 mx = window->ContentsRegionRect.Max;[m
[32m+[m[32m    if (window->DC.CurrentColumns)[m
[32m+[m[32m        mx.x = window->Pos.x + GetColumnOffset(window->DC.CurrentColumns->Current + 1) - window->WindowPadding.x;[m
[32m+[m[32m    return mx;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImGui::GetContentRegionAvail()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    return GetWorkRectMax() - window->DC.CursorPos;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// In window space (not screen space!)[m
[32m+[m[32mImVec2 ImGui::GetWindowContentRegionMin()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->ContentsRegionRect.Min - window->Pos;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImGui::GetWindowContentRegionMax()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->ContentsRegionRect.Max - window->Pos;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetWindowContentRegionWidth()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->ContentsRegionRect.GetWidth();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetTextLineHeight()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.FontSize;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetTextLineHeightWithSpacing()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.FontSize + g.Style.ItemSpacing.y;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetFrameHeight()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.FontSize + g.Style.FramePadding.y * 2.0f;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetFrameHeightWithSpacing()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImDrawList* ImGui::GetWindowDrawList()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    return window->DrawList;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImFont* ImGui::GetFont()[m
[32m+[m[32m{[m
[32m+[m[32m    return GImGui->Font;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetFontSize()[m
[32m+[m[32m{[m
[32m+[m[32m    return GImGui->FontSize;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImGui::GetFontTexUvWhitePixel()[m
[32m+[m[32m{[m
[32m+[m[32m    return GImGui->DrawListSharedData.TexUvWhitePixel;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetWindowFontScale(float scale)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->FontWindowScale = scale;[m
[32m+[m[32m    g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// User generally sees positions in window coordinates. Internally we store CursorPos in absolute screen coordinates because it is more convenient.[m
[32m+[m[32m// Conversion happens as we pass the value to user, but it makes our naming convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.[m
[32m+[m[32mImVec2 ImGui::GetCursorPos()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->DC.CursorPos - window->Pos + window->Scroll;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetCursorPosX()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetCursorPosY()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetCursorPos(const ImVec2& local_pos)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->DC.CursorPos = window->Pos - window->Scroll + local_pos;[m
[32m+[m[32m    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetCursorPosX(float x)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;[m
[32m+[m[32m    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetCursorPosY(float y)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;[m
[32m+[m[32m    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImGui::GetCursorStartPos()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->DC.CursorStartPos - window->Pos;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImGui::GetCursorScreenPos()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->DC.CursorPos;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetCursorScreenPos(const ImVec2& pos)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->DC.CursorPos = pos;[m
[32m+[m[32m    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetScrollX()[m
[32m+[m[32m{[m
[32m+[m[32m    return GImGui->CurrentWindow->Scroll.x;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetScrollY()[m
[32m+[m[32m{[m
[32m+[m[32m    return GImGui->CurrentWindow->Scroll.y;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetScrollMaxX()[m
[32m+[m[32m{[m
[32m+[m[32m    return GetWindowScrollMaxX(GImGui->CurrentWindow);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetScrollMaxY()[m
[32m+[m[32m{[m
[32m+[m[32m    return GetWindowScrollMaxY(GImGui->CurrentWindow);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetScrollX(float scroll_x)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->ScrollTarget.x = scroll_x;[m
[32m+[m[32m    window->ScrollTargetCenterRatio.x = 0.0f;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetScrollY(float scroll_y)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->ScrollTarget.y = scroll_y + window->TitleBarHeight() + window->MenuBarHeight(); // title bar height canceled out when using ScrollTargetRelY[m
[32m+[m[32m    window->ScrollTargetCenterRatio.y = 0.0f;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetScrollFromPosY(float local_y, float center_y_ratio)[m
[32m+[m[32m{[m
[32m+[m[32m    // We store a target position so centering can occur on the next frame when we are guaranteed to have a known window size[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    IM_ASSERT(center_y_ratio >= 0.0f && center_y_ratio <= 1.0f);[m
[32m+[m[32m    window->ScrollTarget.y = (float)(int)(local_y + window->Scroll.y);[m
[32m+[m[32m    window->ScrollTargetCenterRatio.y = center_y_ratio;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last item, 1.0f bottom of last item.[m
[32m+[m[32mvoid ImGui::SetScrollHereY(float center_y_ratio)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    float target_y = window->DC.CursorPosPrevLine.y - window->Pos.y; // Top of last item, in window space[m
[32m+[m[32m    target_y += (window->DC.PrevLineSize.y * center_y_ratio) + (GImGui->Style.ItemSpacing.y * (center_y_ratio - 0.5f) * 2.0f); // Precisely aim above, in the middle or below the last line.[m
[32m+[m[32m    SetScrollFromPosY(target_y, center_y_ratio);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::ActivateItem(ImGuiID id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.NavNextActivateId = id;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetKeyboardFocusHere(int offset)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(offset >= -1);    // -1 is allowed but not below[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    g.FocusRequestNextWindow = window;[m
[32m+[m[32m    g.FocusRequestNextCounterAll = window->DC.FocusCounterAll + 1 + offset;[m
[32m+[m[32m    g.FocusRequestNextCounterTab = INT_MAX;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetItemDefaultFocus()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (!window->Appearing)[m
[32m+[m[32m        return;[m
[32m+[m[32m    if (g.NavWindow == window->RootWindowForNav && (g.NavInitRequest || g.NavInitResultId != 0) && g.NavLayer == g.NavWindow->DC.NavLayerCurrent)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.NavInitRequest = false;[m
[32m+[m[32m        g.NavInitResultId = g.NavWindow->DC.LastItemId;[m
[32m+[m[32m        g.NavInitResultRectRel = ImRect(g.NavWindow->DC.LastItemRect.Min - g.NavWindow->Pos, g.NavWindow->DC.LastItemRect.Max - g.NavWindow->Pos);[m
[32m+[m[32m        NavUpdateAnyRequestFlag();[m
[32m+[m[32m        if (!IsItemVisible())[m
[32m+[m[32m            SetScrollHereY();[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetStateStorage(ImGuiStorage* tree)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    window->DC.StateStorage = tree ? tree : &window->StateStorage;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiStorage* ImGui::GetStateStorage()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    return window->DC.StateStorage;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PushID(const char* str_id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    window->IDStack.push_back(window->GetIDNoKeepAlive(str_id));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PushID(const char* str_id_begin, const char* str_id_end)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    window->IDStack.push_back(window->GetIDNoKeepAlive(str_id_begin, str_id_end));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PushID(const void* ptr_id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    window->IDStack.push_back(window->GetIDNoKeepAlive(ptr_id));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PushID(int int_id)[m
[32m+[m[32m{[m
[32m+[m[32m    const void* ptr_id = (void*)(intptr_t)int_id;[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    window->IDStack.push_back(window->GetIDNoKeepAlive(ptr_id));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Push a given id value ignoring the ID stack as a seed.[m
[32m+[m[32mvoid ImGui::PushOverrideID(ImGuiID id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    window->IDStack.push_back(id);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PopID()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    window->IDStack.pop_back();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiID ImGui::GetID(const char* str_id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    return window->GetID(str_id);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    return window->GetID(str_id_begin, str_id_end);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiID ImGui::GetID(const void* ptr_id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    return window->GetID(ptr_id);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsRectVisible(const ImVec2& size)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    return window->ClipRect.Overlaps(ImRect(window->DC.CursorPos, window->DC.CursorPos + size));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)[m
[32m+[m[32mvoid ImGui::BeginGroup()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m
[32m+[m[32m    window->DC.GroupStack.resize(window->DC.GroupStack.Size + 1);[m
[32m+[m[32m    ImGuiGroupData& group_data = window->DC.GroupStack.back();[m
[32m+[m[32m    group_data.BackupCursorPos = window->DC.CursorPos;[m
[32m+[m[32m    group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;[m
[32m+[m[32m    group_data.BackupIndent = window->DC.Indent;[m
[32m+[m[32m    group_data.BackupGroupOffset = window->DC.GroupOffset;[m
[32m+[m[32m    group_data.BackupCurrentLineSize = window->DC.CurrentLineSize;[m
[32m+[m[32m    group_data.BackupCurrentLineTextBaseOffset = window->DC.CurrentLineTextBaseOffset;[m
[32m+[m[32m    group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;[m
[32m+[m[32m    group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive;[m
[32m+[m[32m    group_data.AdvanceCursor = true;[m
[32m+[m
[32m+[m[32m    window->DC.GroupOffset.x = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffset.x;[m
[32m+[m[32m    window->DC.Indent = window->DC.GroupOffset;[m
[32m+[m[32m    window->DC.CursorMaxPos = window->DC.CursorPos;[m
[32m+[m[32m    window->DC.CurrentLineSize = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    if (g.LogEnabled)[m
[32m+[m[32m        g.LogLinePosY = -FLT_MAX; // To enforce Log carriage return[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::EndGroup()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    IM_ASSERT(!window->DC.GroupStack.empty());  // Mismatched BeginGroup()/EndGroup() calls[m
[32m+[m
[32m+[m[32m    ImGuiGroupData& group_data = window->DC.GroupStack.back();[m
[32m+[m
[32m+[m[32m    ImRect group_bb(group_data.BackupCursorPos, window->DC.CursorMaxPos);[m
[32m+[m[32m    group_bb.Max = ImMax(group_bb.Min, group_bb.Max);[m
[32m+[m
[32m+[m[32m    window->DC.CursorPos = group_data.BackupCursorPos;[m
[32m+[m[32m    window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);[m
[32m+[m[32m    window->DC.Indent = group_data.BackupIndent;[m
[32m+[m[32m    window->DC.GroupOffset = group_data.BackupGroupOffset;[m
[32m+[m[32m    window->DC.CurrentLineSize = group_data.BackupCurrentLineSize;[m
[32m+[m[32m    window->DC.CurrentLineTextBaseOffset = group_data.BackupCurrentLineTextBaseOffset;[m
[32m+[m[32m    if (g.LogEnabled)[m
[32m+[m[32m        g.LogLinePosY = -FLT_MAX; // To enforce Log carriage return[m
[32m+[m
[32m+[m[32m    if (group_data.AdvanceCursor)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrentLineTextBaseOffset);      // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.[m
[32m+[m[32m        ItemSize(group_bb.GetSize(), 0.0f);[m
[32m+[m[32m        ItemAdd(group_bb, 0);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be functional on the entire group.[m
[32m+[m[32m    // It would be be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but would put a little more burden on individual widgets.[m
[32m+[m[32m    // (and if you grep for LastItemId you'll notice it is only used in that context.[m
[32m+[m[32m    if ((group_data.BackupActiveIdIsAlive != g.ActiveId) && (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId) // && g.ActiveIdWindow->RootWindow == window->RootWindow)[m
[32m+[m[32m        window->DC.LastItemId = g.ActiveId;[m
[32m+[m[32m    else if (!group_data.BackupActiveIdPreviousFrameIsAlive && g.ActiveIdPreviousFrameIsAlive) // && g.ActiveIdPreviousFrameWindow->RootWindow == window->RootWindow)[m
[32m+[m[32m        window->DC.LastItemId = g.ActiveIdPreviousFrame;[m
[32m+[m[32m    window->DC.LastItemRect = group_bb;[m
[32m+[m
[32m+[m[32m    window->DC.GroupStack.pop_back();[m
[32m+[m
[32m+[m[32m    //window->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug][m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Gets back to previous line and continue with horizontal layout[m
[32m+[m[32m//      offset_from_start_x == 0 : follow right after previous item[m
[32m+[m[32m//      offset_from_start_x != 0 : align to specified x position (relative to window/group left)[m
[32m+[m[32m//      spacing_w < 0            : use default spacing if pos_x == 0, no spacing if pos_x != 0[m
[32m+[m[32m//      spacing_w >= 0           : enforce spacing amount[m
[32m+[m[32mvoid ImGui::SameLine(float offset_from_start_x, float spacing_w)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (offset_from_start_x != 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (spacing_w < 0.0f) spacing_w = 0.0f;[m
[32m+[m[32m        window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + offset_from_start_x + spacing_w + window->DC.GroupOffset.x + window->DC.ColumnsOffset.x;[m
[32m+[m[32m        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        if (spacing_w < 0.0f) spacing_w = g.Style.ItemSpacing.x;[m
[32m+[m[32m        window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;[m
[32m+[m[32m        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;[m
[32m+[m[32m    }[m
[32m+[m[32m    window->DC.CurrentLineSize = window->DC.PrevLineSize;[m
[32m+[m[32m    window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::Indent(float indent_w)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->DC.Indent.x += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;[m
[32m+[m[32m    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::Unindent(float indent_w)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    window->DC.Indent.x -= (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;[m
[32m+[m[32m    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] TOOLTIPS[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mvoid ImGui::BeginTooltip()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.DragDropWithinSourceOrTarget)[m
[32m+[m[32m    {[m
[32m+[m[32m        // The default tooltip position is a little offset to give space to see the context menu (it's also clamped within the current viewport/monitor)[m
[32m+[m[32m        // In the context of a dragging tooltip we try to reduce that offset and we enforce following the cursor.[m
[32m+[m[32m        // Whatever we do we want to call SetNextWindowPos() to enforce a tooltip position and disable clipping the tooltip without our display area, like regular tooltip do.[m
[32m+[m[32m        //ImVec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;[m
[32m+[m[32m        ImVec2 tooltip_pos = g.IO.MousePos + ImVec2(16 * g.Style.MouseCursorScale, 8 * g.Style.MouseCursorScale);[m
[32m+[m[32m        SetNextWindowPos(tooltip_pos);[m
[32m+[m[32m        SetNextWindowBgAlpha(g.Style.Colors[ImGuiCol_PopupBg].w * 0.60f);[m
[32m+[m[32m        //PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :([m
[32m+[m[32m        BeginTooltipEx(0, true);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        BeginTooltipEx(0, false);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Not exposed publicly as BeginTooltip() because bool parameters are evil. Let's see if other needs arise first.[m
[32m+[m[32mvoid ImGui::BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    char window_name[16];[m
[32m+[m[32m    ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", g.TooltipOverrideCount);[m
[32m+[m[32m    if (override_previous_tooltip)[m
[32m+[m[32m        if (ImGuiWindow* window = FindWindowByName(window_name))[m
[32m+[m[32m            if (window->Active)[m
[32m+[m[32m            {[m
[32m+[m[32m                // Hide previous tooltip from being displayed. We can't easily "reset" the content of a window so we create a new one.[m
[32m+[m[32m                window->Hidden = true;[m
[32m+[m[32m                window->HiddenFramesCanSkipItems = 1;[m
[32m+[m[32m                ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", ++g.TooltipOverrideCount);[m
[32m+[m[32m            }[m
[32m+[m[32m    ImGuiWindowFlags flags = ImGuiWindowFlags_Tooltip|ImGuiWindowFlags_NoInputs|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoMove|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_AlwaysAutoResize;[m
[32m+[m[32m    Begin(window_name, NULL, flags | extra_flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::EndTooltip()[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip);   // Mismatched BeginTooltip()/EndTooltip() calls[m
[32m+[m[32m    End();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetTooltipV(const char* fmt, va_list args)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.DragDropWithinSourceOrTarget)[m
[32m+[m[32m        BeginTooltip();[m
[32m+[m[32m    else[m
[32m+[m[32m        BeginTooltipEx(0, true);[m
[32m+[m[32m    TextV(fmt, args);[m
[32m+[m[32m    EndTooltip();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetTooltip(const char* fmt, ...)[m
[32m+[m[32m{[m
[32m+[m[32m    va_list args;[m
[32m+[m[32m    va_start(args, fmt);[m
[32m+[m[32m    SetTooltipV(fmt, args);[m
[32m+[m[32m    va_end(args);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] POPUPS[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mbool ImGui::IsPopupOpen(ImGuiID id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsPopupOpen(const char* str_id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == g.CurrentWindow->GetID(str_id);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiWindow* ImGui::GetFrontMostPopupModal()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    for (int n = g.OpenPopupStack.Size-1; n >= 0; n--)[m
[32m+[m[32m        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)[m
[32m+[m[32m            if (popup->Flags & ImGuiWindowFlags_Modal)[m
[32m+[m[32m                return popup;[m
[32m+[m[32m    return NULL;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::OpenPopup(const char* str_id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    OpenPopupEx(g.CurrentWindow->GetID(str_id));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Mark popup as open (toggle toward open state).[m
[32m+[m[32m// Popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block.[m
[32m+[m[32m// Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).[m
[32m+[m[32m// One open popup per level of the popup hierarchy (NB: when assigning we reset the Window member of ImGuiPopupRef to NULL)[m
[32m+[m[32mvoid ImGui::OpenPopupEx(ImGuiID id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* parent_window = g.CurrentWindow;[m
[32m+[m[32m    int current_stack_size = g.BeginPopupStack.Size;[m
[32m+[m[32m    ImGuiPopupData popup_ref; // Tagged as new ref as Window will be set back to NULL if we write this into OpenPopupStack.[m
[32m+[m[32m    popup_ref.PopupId = id;[m
[32m+[m[32m    popup_ref.Window = NULL;[m
[32m+[m[32m    popup_ref.SourceWindow = g.NavWindow;[m
[32m+[m[32m    popup_ref.OpenFrameCount = g.FrameCount;[m
[32m+[m[32m    popup_ref.OpenParentId = parent_window->IDStack.back();[m
[32m+[m[32m    popup_ref.OpenPopupPos = NavCalcPreferredRefPos();[m
[32m+[m[32m    popup_ref.OpenMousePos = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : popup_ref.OpenPopupPos;[m
[32m+[m
[32m+[m[32m    //IMGUI_DEBUG_LOG("OpenPopupEx(0x%08X)\n", g.FrameCount, id);[m
[32m+[m[32m    if (g.OpenPopupStack.Size < current_stack_size + 1)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.OpenPopupStack.push_back(popup_ref);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // Gently handle the user mistakenly calling OpenPopup() every frame. It is a programming mistake! However, if we were to run the regular code path, the ui[m
[32m+[m[32m        // would become completely unusable because the popup will always be in hidden-while-calculating-size state _while_ claiming focus. Which would be a very confusing[m
[32m+[m[32m        // situation for the programmer. Instead, we silently allow the popup to proceed, it will keep reappearing and the programming error will be more obvious to understand.[m
[32m+[m[32m        if (g.OpenPopupStack[current_stack_size].PopupId == id && g.OpenPopupStack[current_stack_size].OpenFrameCount == g.FrameCount - 1)[m
[32m+[m[32m        {[m
[32m+[m[32m            g.OpenPopupStack[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount;[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            // Close child popups if any, then flag popup for open/reopen[m
[32m+[m[32m            g.OpenPopupStack.resize(current_stack_size + 1);[m
[32m+[m[32m            g.OpenPopupStack[current_stack_size] = popup_ref;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by ClosePopupsOverWindow().[m
[32m+[m[32m        // This is equivalent to what ClosePopupToLevel() does.[m
[32m+[m[32m        //if (g.OpenPopupStack[current_stack_size].PopupId == id)[m
[32m+[m[32m        //    FocusWindow(parent_window);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::OpenPopupOnItemClick(const char* str_id, int mouse_button)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict![m
[32m+[m[32m        IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)[m
[32m+[m[32m        OpenPopupEx(id);[m
[32m+[m[32m        return true;[m
[32m+[m[32m    }[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.OpenPopupStack.empty())[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.[m
[32m+[m[32m    // Don't close our own child popup windows.[m
[32m+[m[32m    int popup_count_to_keep = 0;[m
[32m+[m[32m    if (ref_window)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)[m
[32m+[m[32m        for (; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGuiPopupData& popup = g.OpenPopupStack[popup_count_to_keep];[m
[32m+[m[32m            if (!popup.Window)[m
[32m+[m[32m                continue;[m
[32m+[m[32m            IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);[m
[32m+[m[32m            if (popup.Window->Flags & ImGuiWindowFlags_ChildWindow)[m
[32m+[m[32m                continue;[m
[32m+[m
[32m+[m[32m            // Trim the stack when popups are not direct descendant of the reference window (the reference window is often the NavWindow)[m
[32m+[m[32m            bool popup_or_descendent_is_ref_window = false;[m
[32m+[m[32m            for (int m = popup_count_to_keep; m < g.OpenPopupStack.Size && !popup_or_descendent_is_ref_window; m++)[m
[32m+[m[32m                if (ImGuiWindow* popup_window = g.OpenPopupStack[m].Window)[m
[32m+[m[32m                    if (popup_window->RootWindow == ref_window->RootWindow)[m
[32m+[m[32m                        popup_or_descendent_is_ref_window = true;[m
[32m+[m[32m            if (!popup_or_descendent_is_ref_window)[m
[32m+[m[32m                break;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below[m
[32m+[m[32m    {[m
[32m+[m[32m        //IMGUI_DEBUG_LOG("ClosePopupsOverWindow(%s) -> ClosePopupToLevel(%d)\n", ref_window->Name, popup_count_to_keep);[m
[32m+[m[32m        ClosePopupToLevel(popup_count_to_keep, restore_focus_to_window_under_popup);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(remaining >= 0 && remaining < g.OpenPopupStack.Size);[m
[32m+[m[32m    ImGuiWindow* focus_window = g.OpenPopupStack[remaining].SourceWindow;[m
[32m+[m[32m    ImGuiWindow* popup_window = g.OpenPopupStack[remaining].Window;[m
[32m+[m[32m    g.OpenPopupStack.resize(remaining);[m
[32m+[m
[32m+[m[32m    if (restore_focus_to_window_under_popup)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (focus_window && !focus_window->WasActive && popup_window)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Fallback[m
[32m+[m[32m            FocusTopMostWindowUnderOne(popup_window, NULL);[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            if (g.NavLayer == 0 && focus_window)[m
[32m+[m[32m                focus_window = NavRestoreLastChildNavWindow(focus_window);[m
[32m+[m[32m            FocusWindow(focus_window);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Close the popup we have begin-ed into.[m
[32m+[m[32mvoid ImGui::CloseCurrentPopup()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    int popup_idx = g.BeginPopupStack.Size - 1;[m
[32m+[m[32m    if (popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.BeginPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // Closing a menu closes its top-most parent popup (unless a modal)[m
[32m+[m[32m    while (popup_idx > 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiWindow* popup_window = g.OpenPopupStack[popup_idx].Window;[m
[32m+[m[32m        ImGuiWindow* parent_popup_window = g.OpenPopupStack[popup_idx - 1].Window;[m
[32m+[m[32m        bool close_parent = false;[m
[32m+[m[32m        if (popup_window && (popup_window->Flags & ImGuiWindowFlags_ChildMenu))[m
[32m+[m[32m            if (parent_popup_window == NULL || !(parent_popup_window->Flags & ImGuiWindowFlags_Modal))[m
[32m+[m[32m                close_parent = true;[m
[32m+[m[32m        if (!close_parent)[m
[32m+[m[32m            break;[m
[32m+[m[32m        popup_idx--;[m
[32m+[m[32m    }[m
[32m+[m[32m    //IMGUI_DEBUG_LOG("CloseCurrentPopup %d -> %d\n", g.BeginPopupStack.Size - 1, popup_idx);[m
[32m+[m[32m    ClosePopupToLevel(popup_idx, true);[m
[32m+[m
[32m+[m[32m    // A common pattern is to close a popup when selecting a menu item/selectable that will open another window.[m
[32m+[m[32m    // To improve this usage pattern, we avoid nav highlight for a single frame in the parent window.[m
[32m+[m[32m    // Similarly, we could avoid mouse hover highlight in this window but it is less visually problematic.[m
[32m+[m[32m    if (ImGuiWindow* window = g.NavWindow)[m
[32m+[m[32m        window->DC.NavHideHighlightOneFrame = true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (!IsPopupOpen(id))[m
[32m+[m[32m    {[m
[32m+[m[32m        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    char name[20];[m
[32m+[m[32m    if (extra_flags & ImGuiWindowFlags_ChildMenu)[m
[32m+[m[32m        ImFormatString(name, IM_ARRAYSIZE(name), "##Menu_%02d", g.BeginPopupStack.Size); // Recycle windows based on depth[m
[32m+[m[32m    else[m
[32m+[m[32m        ImFormatString(name, IM_ARRAYSIZE(name), "##Popup_%08x", id); // Not recycling, so we can close/open during the same frame[m
[32m+[m
[32m+[m[32m    bool is_open = Begin(name, NULL, extra_flags | ImGuiWindowFlags_Popup);[m
[32m+[m[32m    if (!is_open) // NB: Begin can return false when the popup is completely clipped (e.g. zero size display)[m
[32m+[m[32m        EndPopup();[m
[32m+[m
[32m+[m[32m    return is_open;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::BeginPopup(const char* str_id, ImGuiWindowFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.OpenPopupStack.Size <= g.BeginPopupStack.Size) // Early out for performance[m
[32m+[m[32m    {[m
[32m+[m[32m        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m[32m    flags |= ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings;[m
[32m+[m[32m    return BeginPopupEx(g.CurrentWindow->GetID(str_id), flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// If 'p_open' is specified for a modal popup window, the popup will have a regular close button which will close the popup.[m
[32m+[m[32m// Note that popup visibility status is owned by imgui (and manipulated with e.g. OpenPopup) so the actual value of *p_open is meaningless here.[m
[32m+[m[32mbool ImGui::BeginPopupModal(const char* name, bool* p_open, ImGuiWindowFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    const ImGuiID id = window->GetID(name);[m
[32m+[m[32m    if (!IsPopupOpen(id))[m
[32m+[m[32m    {[m
[32m+[m[32m        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Center modal windows by default[m
[32m+[m[32m    // FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags) with the upcoming window.[m
[32m+[m[32m    if (g.NextWindowData.PosCond == 0)[m
[32m+[m[32m        SetNextWindowPos(g.IO.DisplaySize * 0.5f, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));[m
[32m+[m
[32m+[m[32m    flags |= ImGuiWindowFlags_Popup | ImGuiWindowFlags_Modal | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings;[m
[32m+[m[32m    const bool is_open = Begin(name, p_open, flags);[m
[32m+[m[32m    if (!is_open || (p_open && !*p_open)) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)[m
[32m+[m[32m    {[m
[32m+[m[32m        EndPopup();[m
[32m+[m[32m        if (is_open)[m
[32m+[m[32m            ClosePopupToLevel(g.BeginPopupStack.Size, true);[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m[32m    return is_open;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::EndPopup()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(g.CurrentWindow->Flags & ImGuiWindowFlags_Popup);  // Mismatched BeginPopup()/EndPopup() calls[m
[32m+[m[32m    IM_ASSERT(g.BeginPopupStack.Size > 0);[m
[32m+[m
[32m+[m[32m    // Make all menus and popups wrap around for now, may need to expose that policy.[m
[32m+[m[32m    NavMoveRequestTryWrapping(g.CurrentWindow, ImGuiNavMoveFlags_LoopY);[m
[32m+[m
[32m+[m[32m    End();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// This is a helper to handle the simplest case of associating one named popup to one given widget.[m
[32m+[m[32m// You may want to handle this on user side if you have specific needs (e.g. tweaking IsItemHovered() parameters).[m
[32m+[m[32m// You can pass a NULL str_id to use the identifier of the last item.[m
[32m+[m[32mbool ImGui::BeginPopupContextItem(const char* str_id, int mouse_button)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m    ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict![m
[32m+[m[32m    IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)[m
[32m+[m[32m    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))[m
[32m+[m[32m        OpenPopupEx(id);[m
[32m+[m[32m    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::BeginPopupContextWindow(const char* str_id, int mouse_button, bool also_over_items)[m
[32m+[m[32m{[m
[32m+[m[32m    if (!str_id)[m
[32m+[m[32m        str_id = "window_context";[m
[32m+[m[32m    ImGuiID id = GImGui->CurrentWindow->GetID(str_id);[m
[32m+[m[32m    if (IsMouseReleased(mouse_button) && IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))[m
[32m+[m[32m        if (also_over_items || !IsAnyItemHovered())[m
[32m+[m[32m            OpenPopupEx(id);[m
[32m+[m[32m    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::BeginPopupContextVoid(const char* str_id, int mouse_button)[m
[32m+[m[32m{[m
[32m+[m[32m    if (!str_id)[m
[32m+[m[32m        str_id = "void_context";[m
[32m+[m[32m    ImGuiID id = GImGui->CurrentWindow->GetID(str_id);[m
[32m+[m[32m    if (IsMouseReleased(mouse_button) && !IsWindowHovered(ImGuiHoveredFlags_AnyWindow))[m
[32m+[m[32m        OpenPopupEx(id);[m
[32m+[m[32m    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around the mouse cursor which we want to avoid. for popups it's a small point around the cursor.)[m
[32m+[m[32m// r_outer = the visible area rectangle, minus safe area padding. If our popup size won't fit because of safe area padding we ignore it.[m
[32m+[m[32mImVec2 ImGui::FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy)[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2 base_pos_clamped = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size);[m
[32m+[m[32m    //GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));[m
[32m+[m[32m    //GetForegroundDrawList()->AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));[m
[32m+[m
[32m+[m[32m    // Combo Box policy (we want a connecting edge)[m
[32m+[m[32m    if (policy == ImGuiPopupPositionPolicy_ComboBox)[m
[32m+[m[32m    {[m
[32m+[m[32m        const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Down, ImGuiDir_Right, ImGuiDir_Left, ImGuiDir_Up };[m
[32m+[m[32m        for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)[m
[32m+[m[32m        {[m
[32m+[m[32m            const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];[m
[32m+[m[32m            if (n != -1 && dir == *last_dir) // Already tried this direction?[m
[32m+[m[32m                continue;[m
[32m+[m[32m            ImVec2 pos;[m
[32m+[m[32m            if (dir == ImGuiDir_Down)  pos = ImVec2(r_avoid.Min.x, r_avoid.Max.y);          // Below, Toward Right (default)[m
[32m+[m[32m            if (dir == ImGuiDir_Right) pos = ImVec2(r_avoid.Min.x, r_avoid.Min.y - size.y); // Above, Toward Right[m
[32m+[m[32m            if (dir == ImGuiDir_Left)  pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Max.y); // Below, Toward Left[m
[32m+[m[32m            if (dir == ImGuiDir_Up)    pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y); // Above, Toward Left[m
[32m+[m[32m            if (!r_outer.Contains(ImRect(pos, pos + size)))[m
[32m+[m[32m                continue;[m
[32m+[m[32m            *last_dir = dir;[m
[32m+[m[32m            return pos;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Default popup policy[m
[32m+[m[32m    const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Right, ImGuiDir_Down, ImGuiDir_Up, ImGuiDir_Left };[m
[32m+[m[32m    for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)[m
[32m+[m[32m    {[m
[32m+[m[32m        const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];[m
[32m+[m[32m        if (n != -1 && dir == *last_dir) // Already tried this direction?[m
[32m+[m[32m            continue;[m
[32m+[m[32m        float avail_w = (dir == ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x);[m
[32m+[m[32m        float avail_h = (dir == ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y);[m
[32m+[m[32m        if (avail_w < size.x || avail_h < size.y)[m
[32m+[m[32m            continue;[m
[32m+[m[32m        ImVec2 pos;[m
[32m+[m[32m        pos.x = (dir == ImGuiDir_Left) ? r_avoid.Min.x - size.x : (dir == ImGuiDir_Right) ? r_avoid.Max.x : base_pos_clamped.x;[m
[32m+[m[32m        pos.y = (dir == ImGuiDir_Up)   ? r_avoid.Min.y - size.y : (dir == ImGuiDir_Down)  ? r_avoid.Max.y : base_pos_clamped.y;[m
[32m+[m[32m        *last_dir = dir;[m
[32m+[m[32m        return pos;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Fallback, try to keep within display[m
[32m+[m[32m    *last_dir = ImGuiDir_None;[m
[32m+[m[32m    ImVec2 pos = ref_pos;[m
[32m+[m[32m    pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);[m
[32m+[m[32m    pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);[m
[32m+[m[32m    return pos;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImRect ImGui::GetWindowAllowedExtentRect(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_UNUSED(window);[m
[32m+[m[32m    ImVec2 padding = GImGui->Style.DisplaySafeAreaPadding;[m
[32m+[m[32m    ImRect r_screen = GetViewportRect();[m
[32m+[m[32m    r_screen.Expand(ImVec2((r_screen.GetWidth() > padding.x * 2) ? -padding.x : 0.0f, (r_screen.GetHeight() > padding.y * 2) ? -padding.y : 0.0f));[m
[32m+[m[32m    return r_screen;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImGui::FindBestWindowPosForPopup(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    ImRect r_outer = GetWindowAllowedExtentRect(window);[m
[32m+[m[32m    if (window->Flags & ImGuiWindowFlags_ChildMenu)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Child menus typically request _any_ position within the parent menu item, and then we move the new menu outside the parent bounds.[m
[32m+[m[32m        // This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.[m
[32m+[m[32m        IM_ASSERT(g.CurrentWindow == window);[m
[32m+[m[32m        ImGuiWindow* parent_window = g.CurrentWindowStack[g.CurrentWindowStack.Size - 2];[m
[32m+[m[32m        float horizontal_overlap = g.Style.ItemInnerSpacing.x; // We want some overlap to convey the relative depth of each menu (currently the amount of overlap is hard-coded to style.ItemSpacing.x).[m
[32m+[m[32m        ImRect r_avoid;[m
[32m+[m[32m        if (parent_window->DC.MenuBarAppending)[m
[32m+[m[32m            r_avoid = ImRect(-FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight(), FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight() + parent_window->MenuBarHeight());[m
[32m+[m[32m        else[m
[32m+[m[32m            r_avoid = ImRect(parent_window->Pos.x + horizontal_overlap, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - horizontal_overlap - parent_window->ScrollbarSizes.x, FLT_MAX);[m
[32m+[m[32m        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);[m
[32m+[m[32m    }[m
[32m+[m[32m    if (window->Flags & ImGuiWindowFlags_Popup)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImRect r_avoid = ImRect(window->Pos.x - 1, window->Pos.y - 1, window->Pos.x + 1, window->Pos.y + 1);[m
[32m+[m[32m        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);[m
[32m+[m[32m    }[m
[32m+[m[32m    if (window->Flags & ImGuiWindowFlags_Tooltip)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Position tooltip (always follows mouse)[m
[32m+[m[32m        float sc = g.Style.MouseCursorScale;[m
[32m+[m[32m        ImVec2 ref_pos = NavCalcPreferredRefPos();[m
[32m+[m[32m        ImRect r_avoid;[m
[32m+[m[32m        if (!g.NavDisableHighlight && g.NavDisableMouseHover && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos))[m
[32m+[m[32m            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8);[m
[32m+[m[32m        else[m
[32m+[m[32m            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * sc, ref_pos.y + 24 * sc); // FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.[m
[32m+[m[32m        ImVec2 pos = FindBestWindowPosForPopupEx(ref_pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);[m
[32m+[m[32m        if (window->AutoPosLastDirection == ImGuiDir_None)[m
[32m+[m[32m            pos = ref_pos + ImVec2(2, 2); // If there's not enough room, for tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.[m
[32m+[m[32m        return pos;[m
[32m+[m[32m    }[m
[32m+[m[32m    IM_ASSERT(0);[m
[32m+[m[32m    return window->Pos;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] KEYBOARD/GAMEPAD NAVIGATION[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy)[m
[32m+[m[32m{[m
[32m+[m[32m    if (ImFabs(dx) > ImFabs(dy))[m
[32m+[m[32m        return (dx > 0.0f) ? ImGuiDir_Right : ImGuiDir_Left;[m
[32m+[m[32m    return (dy > 0.0f) ? ImGuiDir_Down : ImGuiDir_Up;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic float inline NavScoreItemDistInterval(float a0, float a1, float b0, float b1)[m
[32m+[m[32m{[m
[32m+[m[32m    if (a1 < b0)[m
[32m+[m[32m        return a1 - b0;[m
[32m+[m[32m    if (b1 < a0)[m
[32m+[m[32m        return a0 - b1;[m
[32m+[m[32m    return 0.0f;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void inline NavClampRectToVisibleAreaForMoveDir(ImGuiDir move_dir, ImRect& r, const ImRect& clip_rect)[m
[32m+[m[32m{[m
[32m+[m[32m    if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)[m
[32m+[m[32m    {[m
[32m+[m[32m        r.Min.y = ImClamp(r.Min.y, clip_rect.Min.y, clip_rect.Max.y);[m
[32m+[m[32m        r.Max.y = ImClamp(r.Max.y, clip_rect.Min.y, clip_rect.Max.y);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        r.Min.x = ImClamp(r.Min.x, clip_rect.Min.x, clip_rect.Max.x);[m
[32m+[m[32m        r.Max.x = ImClamp(r.Max.x, clip_rect.Min.x, clip_rect.Max.x);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Scoring function for directional navigation. Based on https://gist.github.com/rygorous/6981057[m
[32m+[m[32mstatic bool NavScoreItem(ImGuiNavMoveResult* result, ImRect cand)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (g.NavLayer != window->DC.NavLayerCurrent)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    const ImRect& curr = g.NavScoringRectScreen; // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)[m
[32m+[m[32m    g.NavScoringCount++;[m
[32m+[m
[32m+[m[32m    // When entering through a NavFlattened border, we consider child window items as fully clipped for scoring[m
[32m+[m[32m    if (window->ParentWindow == g.NavWindow)[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened);[m
[32m+[m[32m        if (!window->ClipRect.Contains(cand))[m
[32m+[m[32m            return false;[m
[32m+[m[32m        cand.ClipWithFull(window->ClipRect); // This allows the scored item to not overlap other candidates in the parent window[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // We perform scoring on items bounding box clipped by the current clipping rectangle on the other axis (clipping on our movement axis would give us equal scores for all clipped items)[m
[32m+[m[32m    // For example, this ensure that items in one column are not reached when moving vertically from items in another column.[m
[32m+[m[32m    NavClampRectToVisibleAreaForMoveDir(g.NavMoveClipDir, cand, window->ClipRect);[m
[32m+[m
[32m+[m[32m    // Compute distance between boxes[m
[32m+[m[32m    // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.[m
[32m+[m[32m    float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);[m
[32m+[m[32m    float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Scale down on Y to keep using box-distance for vertically touching items[m
[32m+[m[32m    if (dby != 0.0f && dbx != 0.0f)[m
[32m+[m[32m       dbx = (dbx/1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);[m
[32m+[m[32m    float dist_box = ImFabs(dbx) + ImFabs(dby);[m
[32m+[m
[32m+[m[32m    // Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)[m
[32m+[m[32m    float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);[m
[32m+[m[32m    float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);[m
[32m+[m[32m    float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)[m
[32m+[m
[32m+[m[32m    // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance[m
[32m+[m[32m    ImGuiDir quadrant;[m
[32m+[m[32m    float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;[m
[32m+[m[32m    if (dbx != 0.0f || dby != 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        // For non-overlapping boxes, use distance between boxes[m
[32m+[m[32m        dax = dbx;[m
[32m+[m[32m        day = dby;[m
[32m+[m[32m        dist_axial = dist_box;[m
[32m+[m[32m        quadrant = ImGetDirQuadrantFromDelta(dbx, dby);[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (dcx != 0.0f || dcy != 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        // For overlapping boxes with different centers, use distance between centers[m
[32m+[m[32m        dax = dcx;[m
[32m+[m[32m        day = dcy;[m
[32m+[m[32m        dist_axial = dist_center;[m
[32m+[m[32m        quadrant = ImGetDirQuadrantFromDelta(dcx, dcy);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)[m
[32m+[m[32m        quadrant = (window->DC.LastItemId < g.NavId) ? ImGuiDir_Left : ImGuiDir_Right;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m#if IMGUI_DEBUG_NAV_SCORING[m
[32m+[m[32m    char buf[128];[m
[32m+[m[32m    if (ImGui::IsMouseHoveringRect(cand.Min, cand.Max))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImFormatString(buf, IM_ARRAYSIZE(buf), "dbox (%.2f,%.2f->%.4f)\ndcen (%.2f,%.2f->%.4f)\nd (%.2f,%.2f->%.4f)\nnav %c, quadrant %c", dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "WENS"[g.NavMoveDir], "WENS"[quadrant]);[m
[32m+[m[32m        ImDrawList* draw_list = ImGui::GetForegroundDrawList(window);[m
[32m+[m[32m        draw_list->AddRect(curr.Min, curr.Max, IM_COL32(255,200,0,100));[m
[32m+[m[32m        draw_list->AddRect(cand.Min, cand.Max, IM_COL32(255,255,0,200));[m
[32m+[m[32m        draw_list->AddRectFilled(cand.Max-ImVec2(4,4), cand.Max+ImGui::CalcTextSize(buf)+ImVec2(4,4), IM_COL32(40,0,0,150));[m
[32m+[m[32m        draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Max, ~0U, buf);[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (g.IO.KeyCtrl) // Hold to preview score in matching quadrant. Press C to rotate.[m
[32m+[m[32m    {[m
[32m+[m[32m        if (ImGui::IsKeyPressedMap(ImGuiKey_C)) { g.NavMoveDirLast = (ImGuiDir)((g.NavMoveDirLast + 1) & 3); g.IO.KeysDownDuration[g.IO.KeyMap[ImGuiKey_C]] = 0.01f; }[m
[32m+[m[32m        if (quadrant == g.NavMoveDir)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center);[m
[32m+[m[32m            ImDrawList* draw_list = ImGui::GetForegroundDrawList(window);[m
[32m+[m[32m            draw_list->AddRectFilled(cand.Min, cand.Max, IM_COL32(255, 0, 0, 200));[m
[32m+[m[32m            draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Min, IM_COL32(255, 255, 255, 255), buf);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m #endif[m
[32m+[m
[32m+[m[32m    // Is it in the quadrant we're interesting in moving to?[m
[32m+[m[32m    bool new_best = false;[m
[32m+[m[32m    if (quadrant == g.NavMoveDir)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Does it beat the current best candidate?[m
[32m+[m[32m        if (dist_box < result->DistBox)[m
[32m+[m[32m        {[m
[32m+[m[32m            result->DistBox = dist_box;[m
[32m+[m[32m            result->DistCenter = dist_center;[m
[32m+[m[32m            return true;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (dist_box == result->DistBox)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Try using distance between center points to break ties[m
[32m+[m[32m            if (dist_center < result->DistCenter)[m
[32m+[m[32m            {[m
[32m+[m[32m                result->DistCenter = dist_center;[m
[32m+[m[32m                new_best = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (dist_center == result->DistCenter)[m
[32m+[m[32m            {[m
[32m+[m[32m                // Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items[m
[32m+[m[32m                // (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),[m
[32m+[m[32m                // this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.[m
[32m+[m[32m                if (((g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance[m
[32m+[m[32m                    new_best = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches[m
[32m+[m[32m    // are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)[m
[32m+[m[32m    // This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.[m
[32m+[m[32m    // 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.[m
[32m+[m[32m    // Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?[m
[32m+[m[32m    if (result->DistBox == FLT_MAX && dist_axial < result->DistAxial)  // Check axial match[m
[32m+[m[32m        if (g.NavLayer == 1 && !(g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))[m
[32m+[m[32m            if ((g.NavMoveDir == ImGuiDir_Left && dax < 0.0f) || (g.NavMoveDir == ImGuiDir_Right && dax > 0.0f) || (g.NavMoveDir == ImGuiDir_Up && day < 0.0f) || (g.NavMoveDir == ImGuiDir_Down && day > 0.0f))[m
[32m+[m[32m            {[m
[32m+[m[32m                result->DistAxial = dist_axial;[m
[32m+[m[32m                new_best = true;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m    return new_best;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)[m
[32m+[m[32mstatic void ImGui::NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, const ImGuiID id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    //if (!g.IO.NavActive)  // [2017/10/06] Removed this possibly redundant test but I am not sure of all the side-effects yet. Some of the feature here will need to work regardless of using a _NoNavInputs flag.[m
[32m+[m[32m    //    return;[m
[32m+[m
[32m+[m[32m    const ImGuiItemFlags item_flags = window->DC.ItemFlags;[m
[32m+[m[32m    const ImRect nav_bb_rel(nav_bb.Min - window->Pos, nav_bb.Max - window->Pos);[m
[32m+[m
[32m+[m[32m    // Process Init Request[m
[32m+[m[32m    if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback[m
[32m+[m[32m        if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus) || g.NavInitResultId == 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            g.NavInitResultId = id;[m
[32m+[m[32m            g.NavInitResultRectRel = nav_bb_rel;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus))[m
[32m+[m[32m        {[m
[32m+[m[32m            g.NavInitRequest = false; // Found a match, clear request[m
[32m+[m[32m            NavUpdateAnyRequestFlag();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Process Move Request (scoring for navigation)[m
[32m+[m[32m    // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRectScreen + scoring from a rect wrapped according to current wrapping policy)[m
[32m+[m[32m    if ((g.NavId != id || (g.NavMoveRequestFlags & ImGuiNavMoveFlags_AllowCurrentNavId)) && !(item_flags & (ImGuiItemFlags_Disabled|ImGuiItemFlags_NoNav)))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiNavMoveResult* result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;[m
[32m+[m[32m#if IMGUI_DEBUG_NAV_SCORING[m
[32m+[m[32m        // [DEBUG] Score all items in NavWindow at all times[m
[32m+[m[32m        if (!g.NavMoveRequest)[m
[32m+[m[32m            g.NavMoveDir = g.NavMoveDirLast;[m
[32m+[m[32m        bool new_best = NavScoreItem(result, nav_bb) && g.NavMoveRequest;[m
[32m+[m[32m#else[m
[32m+[m[32m        bool new_best = g.NavMoveRequest && NavScoreItem(result, nav_bb);[m
[32m+[m[32m#endif[m
[32m+[m[32m        if (new_best)[m
[32m+[m[32m        {[m
[32m+[m[32m            result->ID = id;[m
[32m+[m[32m            result->SelectScopeId = g.MultiSelectScopeId;[m
[32m+[m[32m            result->Window = window;[m
[32m+[m[32m            result->RectRel = nav_bb_rel;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        const float VISIBLE_RATIO = 0.70f;[m
[32m+[m[32m        if ((g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet) && window->ClipRect.Overlaps(nav_bb))[m
[32m+[m[32m            if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)[m
[32m+[m[32m                if (NavScoreItem(&g.NavMoveResultLocalVisibleSet, nav_bb))[m
[32m+[m[32m                {[m
[32m+[m[32m                    result = &g.NavMoveResultLocalVisibleSet;[m
[32m+[m[32m                    result->ID = id;[m
[32m+[m[32m                    result->SelectScopeId = g.MultiSelectScopeId;[m
[32m+[m[32m                    result->Window = window;[m
[32m+[m[32m                    result->RectRel = nav_bb_rel;[m
[32m+[m[32m                }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Update window-relative bounding box of navigated item[m
[32m+[m[32m    if (g.NavId == id)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.NavWindow = window;                                           // Always refresh g.NavWindow, because some operations such as FocusItem() don't have a window.[m
[32m+[m[32m        g.NavLayer = window->DC.NavLayerCurrent;[m
[32m+[m[32m        g.NavIdIsAlive = true;[m
[32m+[m[32m        g.NavIdTabCounter = window->DC.FocusCounterTab;[m
[32m+[m[32m        window->NavRectRel[window->DC.NavLayerCurrent] = nav_bb_rel;    // Store item bounding box (relative to window position)[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::NavMoveRequestButNoResultYet()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.NavMoveRequest && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::NavMoveRequestCancel()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.NavMoveRequest = false;[m
[32m+[m[32m    NavUpdateAnyRequestFlag();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_None);[m
[32m+[m[32m    ImGui::NavMoveRequestCancel();[m
[32m+[m[32m    g.NavMoveDir = move_dir;[m
[32m+[m[32m    g.NavMoveClipDir = clip_dir;[m
[32m+[m[32m    g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;[m
[32m+[m[32m    g.NavMoveRequestFlags = move_flags;[m
[32m+[m[32m    g.NavWindow->NavRectRel[g.NavLayer] = bb_rel;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.NavWindow != window || !NavMoveRequestButNoResultYet() || g.NavMoveRequestForward != ImGuiNavForward_None || g.NavLayer != 0)[m
[32m+[m[32m        return;[m
[32m+[m[32m    IM_ASSERT(move_flags != 0); // No points calling this with no wrapping[m
[32m+[m[32m    ImRect bb_rel = window->NavRectRel[0];[m
[32m+[m
[32m+[m[32m    ImGuiDir clip_dir = g.NavMoveDir;[m
[32m+[m[32m    if (g.NavMoveDir == ImGuiDir_Left && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))[m
[32m+[m[32m    {[m
[32m+[m[32m        bb_rel.Min.x = bb_rel.Max.x = ImMax(window->SizeFull.x, window->SizeContents.x) - window->Scroll.x;[m
[32m+[m[32m        if (move_flags & ImGuiNavMoveFlags_WrapX) { bb_rel.TranslateY(-bb_rel.GetHeight()); clip_dir = ImGuiDir_Up; }[m
[32m+[m[32m        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);[m
[32m+[m[32m    }[m
[32m+[m[32m    if (g.NavMoveDir == ImGuiDir_Right && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))[m
[32m+[m[32m    {[m
[32m+[m[32m        bb_rel.Min.x = bb_rel.Max.x = -window->Scroll.x;[m
[32m+[m[32m        if (move_flags & ImGuiNavMoveFlags_WrapX) { bb_rel.TranslateY(+bb_rel.GetHeight()); clip_dir = ImGuiDir_Down; }[m
[32m+[m[32m        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);[m
[32m+[m[32m    }[m
[32m+[m[32m    if (g.NavMoveDir == ImGuiDir_Up && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))[m
[32m+[m[32m    {[m
[32m+[m[32m        bb_rel.Min.y = bb_rel.Max.y = ImMax(window->SizeFull.y, window->SizeContents.y) - window->Scroll.y;[m
[32m+[m[32m        if (move_flags & ImGuiNavMoveFlags_WrapY) { bb_rel.TranslateX(-bb_rel.GetWidth()); clip_dir = ImGuiDir_Left; }[m
[32m+[m[32m        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);[m
[32m+[m[32m    }[m
[32m+[m[32m    if (g.NavMoveDir == ImGuiDir_Down && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))[m
[32m+[m[32m    {[m
[32m+[m[32m        bb_rel.Min.y = bb_rel.Max.y = -window->Scroll.y;[m
[32m+[m[32m        if (move_flags & ImGuiNavMoveFlags_WrapY) { bb_rel.TranslateX(+bb_rel.GetWidth()); clip_dir = ImGuiDir_Right; }[m
[32m+[m[32m        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// FIXME: This could be replaced by updating a frame number in each window when (window == NavWindow) and (NavLayer == 0).[m
[32m+[m[32m// This way we could find the last focused window among our children. It would be much less confusing this way?[m
[32m+[m[32mstatic void ImGui::NavSaveLastChildNavWindowIntoParent(ImGuiWindow* nav_window)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* parent_window = nav_window;[m
[32m+[m[32m    while (parent_window && (parent_window->Flags & ImGuiWindowFlags_ChildWindow) != 0 && (parent_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)[m
[32m+[m[32m        parent_window = parent_window->ParentWindow;[m
[32m+[m[32m    if (parent_window && parent_window != nav_window)[m
[32m+[m[32m        parent_window->NavLastChildNavWindow = nav_window;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Restore the last focused child.[m
[32m+[m[32m// Call when we are expected to land on the Main Layer (0) after FocusWindow()[m
[32m+[m[32mstatic ImGuiWindow* ImGui::NavRestoreLastChildNavWindow(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    return window->NavLastChildNavWindow ? window->NavLastChildNavWindow : window;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void NavRestoreLayer(ImGuiNavLayer layer)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.NavLayer = layer;[m
[32m+[m[32m    if (layer == 0)[m
[32m+[m[32m        g.NavWindow = ImGui::NavRestoreLastChildNavWindow(g.NavWindow);[m
[32m+[m[32m    if (layer == 0 && g.NavWindow->NavLastIds[0] != 0)[m
[32m+[m[32m        ImGui::SetNavIDWithRectRel(g.NavWindow->NavLastIds[0], layer, g.NavWindow->NavRectRel[0]);[m
[32m+[m[32m    else[m
[32m+[m[32m        ImGui::NavInitWindow(g.NavWindow, true);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic inline void ImGui::NavUpdateAnyRequestFlag()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.NavAnyRequest = g.NavMoveRequest || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);[m
[32m+[m[32m    if (g.NavAnyRequest)[m
[32m+[m[32m        IM_ASSERT(g.NavWindow != NULL);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// This needs to be called before we submit any widget (aka in or before Begin)[m
[32m+[m[32mvoid ImGui::NavInitWindow(ImGuiWindow* window, bool force_reinit)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(window == g.NavWindow);[m
[32m+[m[32m    bool init_for_nav = false;[m
[32m+[m[32m    if (!(window->Flags & ImGuiWindowFlags_NoNavInputs))[m
[32m+[m[32m        if (!(window->Flags & ImGuiWindowFlags_ChildWindow) || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)[m
[32m+[m[32m            init_for_nav = true;[m
[32m+[m[32m    if (init_for_nav)[m
[32m+[m[32m    {[m
[32m+[m[32m        SetNavID(0, g.NavLayer);[m
[32m+[m[32m        g.NavInitRequest = true;[m
[32m+[m[32m        g.NavInitRequestFromMove = false;[m
[32m+[m[32m        g.NavInitResultId = 0;[m
[32m+[m[32m        g.NavInitResultRectRel = ImRect();[m
[32m+[m[32m        NavUpdateAnyRequestFlag();[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        g.NavId = window->NavLastIds[0];[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic ImVec2 ImGui::NavCalcPreferredRefPos()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Mouse (we need a fallback in case the mouse becomes invalid after being used)[m
[32m+[m[32m        if (IsMousePosValid(&g.IO.MousePos))[m
[32m+[m[32m            return g.IO.MousePos;[m
[32m+[m[32m        return g.LastValidMousePos;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // When navigation is active and mouse is disabled, decide on an arbitrary position around the bottom left of the currently navigated item.[m
[32m+[m[32m        const ImRect& rect_rel = g.NavWindow->NavRectRel[g.NavLayer];[m
[32m+[m[32m        ImVec2 pos = g.NavWindow->Pos + ImVec2(rect_rel.Min.x + ImMin(g.Style.FramePadding.x * 4, rect_rel.GetWidth()), rect_rel.Max.y - ImMin(g.Style.FramePadding.y, rect_rel.GetHeight()));[m
[32m+[m[32m        ImRect visible_rect = GetViewportRect();[m
[32m+[m[32m        return ImFloor(ImClamp(pos, visible_rect.Min, visible_rect.Max));   // ImFloor() is important because non-integer mouse position application in back-end might be lossy and result in undesirable non-zero delta.[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (mode == ImGuiInputReadMode_Down)[m
[32m+[m[32m        return g.IO.NavInputs[n];                         // Instant, read analog input (0.0f..1.0f, as provided by user)[m
[32m+[m
[32m+[m[32m    const float t = g.IO.NavInputsDownDuration[n];[m
[32m+[m[32m    if (t < 0.0f && mode == ImGuiInputReadMode_Released)  // Return 1.0f when just released, no repeat, ignore analog input.[m
[32m+[m[32m        return (g.IO.NavInputsDownDurationPrev[n] >= 0.0f ? 1.0f : 0.0f);[m
[32m+[m[32m    if (t < 0.0f)[m
[32m+[m[32m        return 0.0f;[m
[32m+[m[32m    if (mode == ImGuiInputReadMode_Pressed)               // Return 1.0f when just pressed, no repeat, ignore analog input.[m
[32m+[m[32m        return (t == 0.0f) ? 1.0f : 0.0f;[m
[32m+[m[32m    if (mode == ImGuiInputReadMode_Repeat)[m
[32m+[m[32m        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.80f);[m
[32m+[m[32m    if (mode == ImGuiInputReadMode_RepeatSlow)[m
[32m+[m[32m        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 1.00f, g.IO.KeyRepeatRate * 2.00f);[m
[32m+[m[32m    if (mode == ImGuiInputReadMode_RepeatFast)[m
[32m+[m[32m        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.30f);[m
[32m+[m[32m    return 0.0f;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImGui::GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor, float fast_factor)[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2 delta(0.0f, 0.0f);[m
[32m+[m[32m    if (dir_sources & ImGuiNavDirSourceFlags_Keyboard)[m
[32m+[m[32m        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_KeyRight_, mode)   - GetNavInputAmount(ImGuiNavInput_KeyLeft_,   mode), GetNavInputAmount(ImGuiNavInput_KeyDown_,   mode) - GetNavInputAmount(ImGuiNavInput_KeyUp_,   mode));[m
[32m+[m[32m    if (dir_sources & ImGuiNavDirSourceFlags_PadDPad)[m
[32m+[m[32m        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_DpadRight, mode)   - GetNavInputAmount(ImGuiNavInput_DpadLeft,   mode), GetNavInputAmount(ImGuiNavInput_DpadDown,   mode) - GetNavInputAmount(ImGuiNavInput_DpadUp,   mode));[m
[32m+[m[32m    if (dir_sources & ImGuiNavDirSourceFlags_PadLStick)[m
[32m+[m[32m        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_LStickRight, mode) - GetNavInputAmount(ImGuiNavInput_LStickLeft, mode), GetNavInputAmount(ImGuiNavInput_LStickDown, mode) - GetNavInputAmount(ImGuiNavInput_LStickUp, mode));[m
[32m+[m[32m    if (slow_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakSlow))[m
[32m+[m[32m        delta *= slow_factor;[m
[32m+[m[32m    if (fast_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakFast))[m
[32m+[m[32m        delta *= fast_factor;[m
[32m+[m[32m    return delta;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Scroll to keep newly navigated item fully into view[m
[32m+[m[32m// NB: We modify rect_rel by the amount we scrolled for, so it is immediately updated.[m
[32m+[m[32mstatic void NavScrollToBringItemIntoView(ImGuiWindow* window, const ImRect& item_rect)[m
[32m+[m[32m{[m
[32m+[m[32m    ImRect window_rect(window->InnerMainRect.Min - ImVec2(1, 1), window->InnerMainRect.Max + ImVec2(1, 1));[m
[32m+[m[32m    //GetForegroundDrawList(window)->AddRect(window_rect.Min, window_rect.Max, IM_COL32_WHITE); // [DEBUG][m
[32m+[m[32m    if (window_rect.Contains(item_rect))[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (window->ScrollbarX && item_rect.Min.x < window_rect.Min.x)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->ScrollTarget.x = item_rect.Min.x - window->Pos.x + window->Scroll.x - g.Style.ItemSpacing.x;[m
[32m+[m[32m        window->ScrollTargetCenterRatio.x = 0.0f;[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (window->ScrollbarX && item_rect.Max.x >= window_rect.Max.x)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->ScrollTarget.x = item_rect.Max.x - window->Pos.x + window->Scroll.x + g.Style.ItemSpacing.x;[m
[32m+[m[32m        window->ScrollTargetCenterRatio.x = 1.0f;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (item_rect.Min.y < window_rect.Min.y)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->ScrollTarget.y = item_rect.Min.y - window->Pos.y + window->Scroll.y - g.Style.ItemSpacing.y;[m
[32m+[m[32m        window->ScrollTargetCenterRatio.y = 0.0f;[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (item_rect.Max.y >= window_rect.Max.y)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->ScrollTarget.y = item_rect.Max.y - window->Pos.y + window->Scroll.y + g.Style.ItemSpacing.y;[m
[32m+[m[32m        window->ScrollTargetCenterRatio.y = 1.0f;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void ImGui::NavUpdate()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.IO.WantSetMousePos = false;[m
[32m+[m[32m#if 0[m
[32m+[m[32m    if (g.NavScoringCount > 0) IMGUI_DEBUG_LOG("NavScoringCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.FrameCount, g.NavScoringCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m    // Set input source as Gamepad when buttons are pressed before we map Keyboard (some features differs when used with Gamepad vs Keyboard)[m
[32m+[m[32m    bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;[m
[32m+[m[32m    bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;[m
[32m+[m[32m    if (nav_gamepad_active)[m
[32m+[m[32m        if (g.IO.NavInputs[ImGuiNavInput_Activate] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Input] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Cancel] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Menu] > 0.0f)[m
[32m+[m[32m            g.NavInputSource = ImGuiInputSource_NavGamepad;[m
[32m+[m
[32m+[m[32m    // Update Keyboard->Nav inputs mapping[m
[32m+[m[32m    if (nav_keyboard_active)[m
[32m+[m[32m    {[m
[32m+[m[32m        #define NAV_MAP_KEY(_KEY, _NAV_INPUT) if (IsKeyDown(g.IO.KeyMap[_KEY])) { g.IO.NavInputs[_NAV_INPUT] = 1.0f; g.NavInputSource = ImGuiInputSource_NavKeyboard; }[m
[32m+[m[32m        NAV_MAP_KEY(ImGuiKey_Space,     ImGuiNavInput_Activate );[m
[32m+[m[32m        NAV_MAP_KEY(ImGuiKey_Enter,     ImGuiNavInput_Input    );[m
[32m+[m[32m        NAV_MAP_KEY(ImGuiKey_Escape,    ImGuiNavInput_Cancel   );[m
[32m+[m[32m        NAV_MAP_KEY(ImGuiKey_LeftArrow, ImGuiNavInput_KeyLeft_ );[m
[32m+[m[32m        NAV_MAP_KEY(ImGuiKey_RightArrow,ImGuiNavInput_KeyRight_);[m
[32m+[m[32m        NAV_MAP_KEY(ImGuiKey_UpArrow,   ImGuiNavInput_KeyUp_   );[m
[32m+[m[32m        NAV_MAP_KEY(ImGuiKey_DownArrow, ImGuiNavInput_KeyDown_ );[m
[32m+[m[32m        NAV_MAP_KEY(ImGuiKey_Tab,       ImGuiNavInput_KeyTab_  );[m
[32m+[m[32m        if (g.IO.KeyCtrl)[m
[32m+[m[32m            g.IO.NavInputs[ImGuiNavInput_TweakSlow] = 1.0f;[m
[32m+[m[32m        if (g.IO.KeyShift)[m
[32m+[m[32m            g.IO.NavInputs[ImGuiNavInput_TweakFast] = 1.0f;[m
[32m+[m[32m        if (g.IO.KeyAlt && !g.IO.KeyCtrl) // AltGR is Alt+Ctrl, also even on keyboards without AltGR we don't want Alt+Ctrl to open menu.[m
[32m+[m[32m            g.IO.NavInputs[ImGuiNavInput_KeyMenu_]  = 1.0f;[m
[32m+[m[32m        #undef NAV_MAP_KEY[m
[32m+[m[32m    }[m
[32m+[m[32m    memcpy(g.IO.NavInputsDownDurationPrev, g.IO.NavInputsDownDuration, sizeof(g.IO.NavInputsDownDuration));[m
[32m+[m[32m    for (int i = 0; i < IM_ARRAYSIZE(g.IO.NavInputs); i++)[m
[32m+[m[32m        g.IO.NavInputsDownDuration[i] = (g.IO.NavInputs[i] > 0.0f) ? (g.IO.NavInputsDownDuration[i] < 0.0f ? 0.0f : g.IO.NavInputsDownDuration[i] + g.IO.DeltaTime) : -1.0f;[m
[32m+[m
[32m+[m[32m    // Process navigation init request (select first/default focus)[m
[32m+[m[32m    if (g.NavInitResultId != 0 && (!g.NavDisableHighlight || g.NavInitRequestFromMove))[m
[32m+[m[32m    {[m
[32m+[m[32m        // Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)[m
[32m+[m[32m        IM_ASSERT(g.NavWindow);[m
[32m+[m[32m        if (g.NavInitRequestFromMove)[m
[32m+[m[32m            SetNavIDWithRectRel(g.NavInitResultId, g.NavLayer, g.NavInitResultRectRel);[m
[32m+[m[32m        else[m
[32m+[m[32m            SetNavID(g.NavInitResultId, g.NavLayer);[m
[32m+[m[32m        g.NavWindow->NavRectRel[g.NavLayer] = g.NavInitResultRectRel;[m
[32m+[m[32m    }[m
[32m+[m[32m    g.NavInitRequest = false;[m
[32m+[m[32m    g.NavInitRequestFromMove = false;[m
[32m+[m[32m    g.NavInitResultId = 0;[m
[32m+[m[32m    g.NavJustMovedToId = 0;[m
[32m+[m
[32m+[m[32m    // Process navigation move request[m
[32m+[m[32m    if (g.NavMoveRequest)[m
[32m+[m[32m        NavUpdateMoveResult();[m
[32m+[m
[32m+[m[32m    // When a forwarded move request failed, we restore the highlight that we disabled during the forward frame[m
[32m+[m[32m    if (g.NavMoveRequestForward == ImGuiNavForward_ForwardActive)[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(g.NavMoveRequest);[m
[32m+[m[32m        if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)[m
[32m+[m[32m            g.NavDisableHighlight = false;[m
[32m+[m[32m        g.NavMoveRequestForward = ImGuiNavForward_None;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Apply application mouse position movement, after we had a chance to process move request result.[m
[32m+[m[32m    if (g.NavMousePosDirty && g.NavIdIsAlive)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Set mouse position given our knowledge of the navigated item position from last frame[m
[32m+[m[32m        if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (g.IO.BackendFlags & ImGuiBackendFlags_HasSetMousePos))[m
[32m+[m[32m        {[m
[32m+[m[32m            if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)[m
[32m+[m[32m            {[m
[32m+[m[32m                g.IO.MousePos = g.IO.MousePosPrev = NavCalcPreferredRefPos();[m
[32m+[m[32m                g.IO.WantSetMousePos = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        g.NavMousePosDirty = false;[m
[32m+[m[32m    }[m
[32m+[m[32m    g.NavIdIsAlive = false;[m
[32m+[m[32m    g.NavJustTabbedId = 0;[m
[32m+[m[32m    IM_ASSERT(g.NavLayer == 0 || g.NavLayer == 1);[m
[32m+[m
[32m+[m[32m    // Store our return window (for returning from Layer 1 to Layer 0) and clear it as soon as we step back in our own Layer 0[m
[32m+[m[32m    if (g.NavWindow)[m
[32m+[m[32m        NavSaveLastChildNavWindowIntoParent(g.NavWindow);[m
[32m+[m[32m    if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == 0)[m
[32m+[m[32m        g.NavWindow->NavLastChildNavWindow = NULL;[m
[32m+[m
[32m+[m[32m    // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)[m
[32m+[m[32m    NavUpdateWindowing();[m
[32m+[m
[32m+[m[32m    // Set output flags for user application[m
[32m+[m[32m    g.IO.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);[m
[32m+[m[32m    g.IO.NavVisible = (g.IO.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL);[m
[32m+[m
[32m+[m[32m    // Process NavCancel input (to close a popup, get back to parent, clear focus)[m
[32m+[m[32m    if (IsNavInputPressed(ImGuiNavInput_Cancel, ImGuiInputReadMode_Pressed))[m
[32m+[m[32m    {[m
[32m+[m[32m        if (g.ActiveId != 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (!(g.ActiveIdBlockNavInputFlags & (1 << ImGuiNavInput_Cancel)))[m
[32m+[m[32m                ClearActiveID();[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow) && !(g.NavWindow->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->ParentWindow)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Exit child window[m
[32m+[m[32m            ImGuiWindow* child_window = g.NavWindow;[m
[32m+[m[32m            ImGuiWindow* parent_window = g.NavWindow->ParentWindow;[m
[32m+[m[32m            IM_ASSERT(child_window->ChildId != 0);[m
[32m+[m[32m            FocusWindow(parent_window);[m
[32m+[m[32m            SetNavID(child_window->ChildId, 0);[m
[32m+[m[32m            g.NavIdIsAlive = false;[m
[32m+[m[32m            if (g.NavDisableMouseHover)[m
[32m+[m[32m                g.NavMousePosDirty = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (g.OpenPopupStack.Size > 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Close open popup/menu[m
[32m+[m[32m            if (!(g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal))[m
[32m+[m[32m                ClosePopupToLevel(g.OpenPopupStack.Size - 1, true);[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (g.NavLayer != 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Leave the "menu" layer[m
[32m+[m[32m            NavRestoreLayer(ImGuiNavLayer_Main);[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were[m
[32m+[m[32m            if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))[m
[32m+[m[32m                g.NavWindow->NavLastIds[0] = 0;[m
[32m+[m[32m            g.NavId = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Process manual activation request[m
[32m+[m[32m    g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = 0;[m
[32m+[m[32m    if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))[m
[32m+[m[32m    {[m
[32m+[m[32m        bool activate_down = IsNavInputDown(ImGuiNavInput_Activate);[m
[32m+[m[32m        bool activate_pressed = activate_down && IsNavInputPressed(ImGuiNavInput_Activate, ImGuiInputReadMode_Pressed);[m
[32m+[m[32m        if (g.ActiveId == 0 && activate_pressed)[m
[32m+[m[32m            g.NavActivateId = g.NavId;[m
[32m+[m[32m        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_down)[m
[32m+[m[32m            g.NavActivateDownId = g.NavId;[m
[32m+[m[32m        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_pressed)[m
[32m+[m[32m            g.NavActivatePressedId = g.NavId;[m
[32m+[m[32m        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && IsNavInputPressed(ImGuiNavInput_Input, ImGuiInputReadMode_Pressed))[m
[32m+[m[32m            g.NavInputId = g.NavId;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))[m
[32m+[m[32m        g.NavDisableHighlight = true;[m
[32m+[m[32m    if (g.NavActivateId != 0)[m
[32m+[m[32m        IM_ASSERT(g.NavActivateDownId == g.NavActivateId);[m
[32m+[m[32m    g.NavMoveRequest = false;[m
[32m+[m
[32m+[m[32m    // Process programmatic activation request[m
[32m+[m[32m    if (g.NavNextActivateId != 0)[m
[32m+[m[32m        g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = g.NavNextActivateId;[m
[32m+[m[32m    g.NavNextActivateId = 0;[m
[32m+[m
[32m+[m[32m    // Initiate directional inputs request[m
[32m+[m[32m    const int allowed_dir_flags = (g.ActiveId == 0) ? ~0 : g.ActiveIdAllowNavDirFlags;[m
[32m+[m[32m    if (g.NavMoveRequestForward == ImGuiNavForward_None)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.NavMoveDir = ImGuiDir_None;[m
[32m+[m[32m        g.NavMoveRequestFlags = ImGuiNavMoveFlags_None;[m
[32m+[m[32m        if (g.NavWindow && !g.NavWindowingTarget && allowed_dir_flags && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))[m
[32m+[m[32m        {[m
[32m+[m[32m            if ((allowed_dir_flags & (1<<ImGuiDir_Left))  && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadLeft, ImGuiNavInput_KeyLeft_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Left;[m
[32m+[m[32m            if ((allowed_dir_flags & (1<<ImGuiDir_Right)) && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadRight,ImGuiNavInput_KeyRight_,ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Right;[m
[32m+[m[32m            if ((allowed_dir_flags & (1<<ImGuiDir_Up))    && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadUp,   ImGuiNavInput_KeyUp_,   ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Up;[m
[32m+[m[32m            if ((allowed_dir_flags & (1<<ImGuiDir_Down))  && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadDown, ImGuiNavInput_KeyDown_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Down;[m
[32m+[m[32m        }[m
[32m+[m[32m        g.NavMoveClipDir = g.NavMoveDir;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)[m
[32m+[m[32m        // (Preserve g.NavMoveRequestFlags, g.NavMoveClipDir which were set by the NavMoveRequestForward() function)[m
[32m+[m[32m        IM_ASSERT(g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None);[m
[32m+[m[32m        IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_ForwardQueued);[m
[32m+[m[32m        g.NavMoveRequestForward = ImGuiNavForward_ForwardActive;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Update PageUp/PageDown scroll[m
[32m+[m[32m    float nav_scoring_rect_offset_y = 0.0f;[m
[32m+[m[32m    if (nav_keyboard_active)[m
[32m+[m[32m        nav_scoring_rect_offset_y = NavUpdatePageUpPageDown(allowed_dir_flags);[m
[32m+[m
[32m+[m[32m    // If we initiate a movement request and have no current NavId, we initiate a InitDefautRequest that will be used as a fallback if the direction fails to find a match[m
[32m+[m[32m    if (g.NavMoveDir != ImGuiDir_None)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.NavMoveRequest = true;[m
[32m+[m[32m        g.NavMoveDirLast = g.NavMoveDir;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (g.NavMoveRequest && g.NavId == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.NavInitRequest = g.NavInitRequestFromMove = true;[m
[32m+[m[32m        g.NavInitResultId = 0;[m
[32m+[m[32m        g.NavDisableHighlight = false;[m
[32m+[m[32m    }[m
[32m+[m[32m    NavUpdateAnyRequestFlag();[m
[32m+[m
[32m+[m[32m    // Scrolling[m
[32m+[m[32m    if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)[m
[32m+[m[32m    {[m
[32m+[m[32m        // *Fallback* manual-scroll with Nav directional keys when window has no navigable item[m
[32m+[m[32m        ImGuiWindow* window = g.NavWindow;[m
[32m+[m[32m        const float scroll_speed = ImFloor(window->CalcFontSize() * 100 * g.IO.DeltaTime + 0.5f); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.[m
[32m+[m[32m        if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll && g.NavMoveRequest)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right)[m
[32m+[m[32m                SetWindowScrollX(window, ImFloor(window->Scroll.x + ((g.NavMoveDir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));[m
[32m+[m[32m            if (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down)[m
[32m+[m[32m                SetWindowScrollY(window, ImFloor(window->Scroll.y + ((g.NavMoveDir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // *Normal* Manual scroll with NavScrollXXX keys[m
[32m+[m[32m        // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.[m
[32m+[m[32m        ImVec2 scroll_dir = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down, 1.0f/10.0f, 10.0f);[m
[32m+[m[32m        if (scroll_dir.x != 0.0f && window->ScrollbarX)[m
[32m+[m[32m        {[m
[32m+[m[32m            SetWindowScrollX(window, ImFloor(window->Scroll.x + scroll_dir.x * scroll_speed));[m
[32m+[m[32m            g.NavMoveFromClampedRefRect = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (scroll_dir.y != 0.0f)[m
[32m+[m[32m        {[m
[32m+[m[32m            SetWindowScrollY(window, ImFloor(window->Scroll.y + scroll_dir.y * scroll_speed));[m
[32m+[m[32m            g.NavMoveFromClampedRefRect = true;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Reset search results[m
[32m+[m[32m    g.NavMoveResultLocal.Clear();[m
[32m+[m[32m    g.NavMoveResultLocalVisibleSet.Clear();[m
[32m+[m[32m    g.NavMoveResultOther.Clear();[m
[32m+[m
[32m+[m[32m    // When we have manually scrolled (without using navigation) and NavId becomes out of bounds, we project its bounding box to the visible area to restart navigation within visible items[m
[32m+[m[32m    if (g.NavMoveRequest && g.NavMoveFromClampedRefRect && g.NavLayer == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiWindow* window = g.NavWindow;[m
[32m+[m[32m        ImRect window_rect_rel(window->InnerMainRect.Min - window->Pos - ImVec2(1,1), window->InnerMainRect.Max - window->Pos + ImVec2(1,1));[m
[32m+[m[32m        if (!window_rect_rel.Contains(window->NavRectRel[g.NavLayer]))[m
[32m+[m[32m        {[m
[32m+[m[32m            float pad = window->CalcFontSize() * 0.5f;[m
[32m+[m[32m            window_rect_rel.Expand(ImVec2(-ImMin(window_rect_rel.GetWidth(), pad), -ImMin(window_rect_rel.GetHeight(), pad))); // Terrible approximation for the intent of starting navigation from first fully visible item[m
[32m+[m[32m            window->NavRectRel[g.NavLayer].ClipWith(window_rect_rel);[m
[32m+[m[32m            g.NavId = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        g.NavMoveFromClampedRefRect = false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)[m
[32m+[m[32m    ImRect nav_rect_rel = (g.NavWindow && !g.NavWindow->NavRectRel[g.NavLayer].IsInverted()) ? g.NavWindow->NavRectRel[g.NavLayer] : ImRect(0,0,0,0);[m
[32m+[m[32m    g.NavScoringRectScreen = g.NavWindow ? ImRect(g.NavWindow->Pos + nav_rect_rel.Min, g.NavWindow->Pos + nav_rect_rel.Max) : GetViewportRect();[m
[32m+[m[32m    g.NavScoringRectScreen.TranslateY(nav_scoring_rect_offset_y);[m
[32m+[m[32m    g.NavScoringRectScreen.Min.x = ImMin(g.NavScoringRectScreen.Min.x + 1.0f, g.NavScoringRectScreen.Max.x);[m
[32m+[m[32m    g.NavScoringRectScreen.Max.x = g.NavScoringRectScreen.Min.x;[m
[32m+[m[32m    IM_ASSERT(!g.NavScoringRectScreen.IsInverted()); // Ensure if we have a finite, non-inverted bounding box here will allows us to remove extraneous ImFabs() calls in NavScoreItem().[m
[32m+[m[32m    //GetForegroundDrawList()->AddRect(g.NavScoringRectScreen.Min, g.NavScoringRectScreen.Max, IM_COL32(255,200,0,255)); // [DEBUG][m
[32m+[m[32m    g.NavScoringCount = 0;[m
[32m+[m[32m#if IMGUI_DEBUG_NAV_RECTS[m
[32m+[m[32m    if (g.NavWindow)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImDrawList* draw_list = GetForegroundDrawList(g.NavWindow);[m
[32m+[m[32m        if (1) { for (int layer = 0; layer < 2; layer++) draw_list->AddRect(g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Min, g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Max, IM_COL32(255,200,0,255)); } // [DEBUG][m
[32m+[m[32m        if (1) { ImU32 col = (!g.NavWindow->Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); draw_list->AddCircleFilled(p, 3.0f, col); draw_list->AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }[m
[32m+[m[32m    }[m
[32m+[m[32m#endif[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Apply result from previous frame navigation directional move request[m
[32m+[m[32mstatic void ImGui::NavUpdateMoveResult()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        // In a situation when there is no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)[m
[32m+[m[32m        if (g.NavId != 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            g.NavDisableHighlight = false;[m
[32m+[m[32m            g.NavDisableMouseHover = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Select which result to use[m
[32m+[m[32m    ImGuiNavMoveResult* result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;[m
[32m+[m
[32m+[m[32m    // PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.[m
[32m+[m[32m    if (g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet)[m
[32m+[m[32m        if (g.NavMoveResultLocalVisibleSet.ID != 0 && g.NavMoveResultLocalVisibleSet.ID != g.NavId)[m
[32m+[m[32m            result = &g.NavMoveResultLocalVisibleSet;[m
[32m+[m
[32m+[m[32m    // Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.[m
[32m+[m[32m    if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)[m
[32m+[m[32m        if ((g.NavMoveResultOther.DistBox < result->DistBox) || (g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter))[m
[32m+[m[32m            result = &g.NavMoveResultOther;[m
[32m+[m[32m    IM_ASSERT(g.NavWindow && result->Window);[m
[32m+[m
[32m+[m[32m    // Scroll to keep newly navigated item fully into view.[m
[32m+[m[32m    if (g.NavLayer == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImRect rect_abs = ImRect(result->RectRel.Min + result->Window->Pos, result->RectRel.Max + result->Window->Pos);[m
[32m+[m[32m        NavScrollToBringItemIntoView(result->Window, rect_abs);[m
[32m+[m
[32m+[m[32m        // Estimate upcoming scroll so we can offset our result position so mouse position can be applied immediately after in NavUpdate()[m
[32m+[m[32m        ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(result->Window, false);[m
[32m+[m[32m        ImVec2 delta_scroll = result->Window->Scroll - next_scroll;[m
[32m+[m[32m        result->RectRel.Translate(delta_scroll);[m
[32m+[m
[32m+[m[32m        // Also scroll parent window to keep us into view if necessary (we could/should technically recurse back the whole the parent hierarchy).[m
[32m+[m[32m        if (result->Window->Flags & ImGuiWindowFlags_ChildWindow)[m
[32m+[m[32m            NavScrollToBringItemIntoView(result->Window->ParentWindow, ImRect(rect_abs.Min + delta_scroll, rect_abs.Max + delta_scroll));[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    ClearActiveID();[m
[32m+[m[32m    g.NavWindow = result->Window;[m
[32m+[m[32m    if (g.NavId != result->ID)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Don't set NavJustMovedToId if just landed on the same spot (which may happen with ImGuiNavMoveFlags_AllowCurrentNavId)[m
[32m+[m[32m        g.NavJustMovedToId = result->ID;[m
[32m+[m[32m        g.NavJustMovedToMultiSelectScopeId = result->SelectScopeId;[m
[32m+[m[32m    }[m
[32m+[m[32m    SetNavIDWithRectRel(result->ID, g.NavLayer, result->RectRel);[m
[32m+[m[32m    g.NavMoveFromClampedRefRect = false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic float ImGui::NavUpdatePageUpPageDown(int allowed_dir_flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.NavMoveDir == ImGuiDir_None && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget && g.NavLayer == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiWindow* window = g.NavWindow;[m
[32m+[m[32m        bool page_up_held = IsKeyDown(g.IO.KeyMap[ImGuiKey_PageUp]) && (allowed_dir_flags & (1 << ImGuiDir_Up));[m
[32m+[m[32m        bool page_down_held = IsKeyDown(g.IO.KeyMap[ImGuiKey_PageDown]) && (allowed_dir_flags & (1 << ImGuiDir_Down));[m
[32m+[m[32m        if (page_up_held != page_down_held) // If either (not both) are pressed[m
[32m+[m[32m        {[m
[32m+[m[32m            if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll)[m
[32m+[m[32m            {[m
[32m+[m[32m                // Fallback manual-scroll when window has no navigable item[m
[32m+[m[32m                if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageUp], true))[m
[32m+[m[32m                    SetWindowScrollY(window, window->Scroll.y - window->InnerMainRect.GetHeight());[m
[32m+[m[32m                else if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageDown], true))[m
[32m+[m[32m                    SetWindowScrollY(window, window->Scroll.y + window->InnerMainRect.GetHeight());[m
[32m+[m[32m            }[m
[32m+[m[32m            else[m
[32m+[m[32m            {[m
[32m+[m[32m                const ImRect& nav_rect_rel = window->NavRectRel[g.NavLayer];[m
[32m+[m[32m                const float page_offset_y = ImMax(0.0f, window->InnerMainRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());[m
[32m+[m[32m                float nav_scoring_rect_offset_y = 0.0f;[m
[32m+[m[32m                if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageUp], true))[m
[32m+[m[32m                {[m
[32m+[m[32m                    nav_scoring_rect_offset_y = -page_offset_y;[m
[32m+[m[32m                    g.NavMoveDir = ImGuiDir_Down; // Because our scoring rect is offset, we intentionally request the opposite direction (so we can always land on the last item)[m
[32m+[m[32m                    g.NavMoveClipDir = ImGuiDir_Up;[m
[32m+[m[32m                    g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageDown], true))[m
[32m+[m[32m                {[m
[32m+[m[32m                    nav_scoring_rect_offset_y = +page_offset_y;[m
[32m+[m[32m                    g.NavMoveDir = ImGuiDir_Up; // Because our scoring rect is offset, we intentionally request the opposite direction (so we can always land on the last item)[m
[32m+[m[32m                    g.NavMoveClipDir = ImGuiDir_Down;[m
[32m+[m[32m                    g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;[m
[32m+[m[32m                }[m
[32m+[m[32m                return nav_scoring_rect_offset_y;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    return 0.0f;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int ImGui::FindWindowFocusIndex(ImGuiWindow* window) // FIXME-OPT O(N)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    for (int i = g.WindowsFocusOrder.Size-1; i >= 0; i--)[m
[32m+[m[32m        if (g.WindowsFocusOrder[i] == window)[m
[32m+[m[32m            return i;[m
[32m+[m[32m    return -1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic ImGuiWindow* FindWindowNavFocusable(int i_start, int i_stop, int dir) // FIXME-OPT O(N)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    for (int i = i_start; i >= 0 && i < g.WindowsFocusOrder.Size && i != i_stop; i += dir)[m
[32m+[m[32m        if (ImGui::IsWindowNavFocusable(g.WindowsFocusOrder[i]))[m
[32m+[m[32m            return g.WindowsFocusOrder[i];[m
[32m+[m[32m    return NULL;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void NavUpdateWindowingHighlightWindow(int focus_change_dir)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(g.NavWindowingTarget);[m
[32m+[m[32m    if (g.NavWindowingTarget->Flags & ImGuiWindowFlags_Modal)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    const int i_current = ImGui::FindWindowFocusIndex(g.NavWindowingTarget);[m
[32m+[m[32m    ImGuiWindow* window_target = FindWindowNavFocusable(i_current + focus_change_dir, -INT_MAX, focus_change_dir);[m
[32m+[m[32m    if (!window_target)[m
[32m+[m[32m        window_target = FindWindowNavFocusable((focus_change_dir < 0) ? (g.WindowsFocusOrder.Size - 1) : 0, i_current, focus_change_dir);[m
[32m+[m[32m    if (window_target) // Don't reset windowing target if there's a single window in the list[m
[32m+[m[32m        g.NavWindowingTarget = g.NavWindowingTargetAnim = window_target;[m
[32m+[m[32m    g.NavWindowingToggleLayer = false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Windowing management mode[m
[32m+[m[32m// Keyboard: CTRL+Tab (change focus/move/resize), Alt (toggle menu layer)[m
[32m+[m[32m// Gamepad:  Hold Menu/Square (change focus/move/resize), Tap Menu/Square (toggle menu layer)[m
[32m+[m[32mstatic void ImGui::NavUpdateWindowing()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* apply_focus_window = NULL;[m
[32m+[m[32m    bool apply_toggle_layer = false;[m
[32m+[m
[32m+[m[32m    ImGuiWindow* modal_window = GetFrontMostPopupModal();[m
[32m+[m[32m    if (modal_window != NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.NavWindowingTarget = NULL;[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Fade out[m
[32m+[m[32m    if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - g.IO.DeltaTime * 10.0f, 0.0f);[m
[32m+[m[32m        if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)[m
[32m+[m[32m            g.NavWindowingTargetAnim = NULL;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Start CTRL-TAB or Square+L/R window selection[m
[32m+[m[32m    bool start_windowing_with_gamepad = !g.NavWindowingTarget && IsNavInputPressed(ImGuiNavInput_Menu, ImGuiInputReadMode_Pressed);[m
[32m+[m[32m    bool start_windowing_with_keyboard = !g.NavWindowingTarget && g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab) && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard);[m
[32m+[m[32m    if (start_windowing_with_gamepad || start_windowing_with_keyboard)[m
[32m+[m[32m        if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1))[m
[32m+[m[32m        {[m
[32m+[m[32m            g.NavWindowingTarget = g.NavWindowingTargetAnim = window;[m
[32m+[m[32m            g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;[m
[32m+[m[32m            g.NavWindowingToggleLayer = start_windowing_with_keyboard ? false : true;[m
[32m+[m[32m            g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_NavKeyboard : ImGuiInputSource_NavGamepad;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m    // Gamepad update[m
[32m+[m[32m    g.NavWindowingTimer += g.IO.DeltaTime;[m
[32m+[m[32m    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavGamepad)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise[m
[32m+[m[32m        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));[m
[32m+[m
[32m+[m[32m        // Select window to focus[m
[32m+[m[32m        const int focus_change_dir = (int)IsNavInputPressed(ImGuiNavInput_FocusPrev, ImGuiInputReadMode_RepeatSlow) - (int)IsNavInputPressed(ImGuiNavInput_FocusNext, ImGuiInputReadMode_RepeatSlow);[m
[32m+[m[32m        if (focus_change_dir != 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            NavUpdateWindowingHighlightWindow(focus_change_dir);[m
[32m+[m[32m            g.NavWindowingHighlightAlpha = 1.0f;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered front-most)[m
[32m+[m[32m        if (!IsNavInputDown(ImGuiNavInput_Menu))[m
[32m+[m[32m        {[m
[32m+[m[32m            g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.[m
[32m+[m[32m            if (g.NavWindowingToggleLayer && g.NavWindow)[m
[32m+[m[32m                apply_toggle_layer = true;[m
[32m+[m[32m            else if (!g.NavWindowingToggleLayer)[m
[32m+[m[32m                apply_focus_window = g.NavWindowingTarget;[m
[32m+[m[32m            g.NavWindowingTarget = NULL;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Keyboard: Focus[m
[32m+[m[32m    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavKeyboard)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise[m
[32m+[m[32m        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f)); // 1.0f[m
[32m+[m[32m        if (IsKeyPressedMap(ImGuiKey_Tab, true))[m
[32m+[m[32m            NavUpdateWindowingHighlightWindow(g.IO.KeyShift ? +1 : -1);[m
[32m+[m[32m        if (!g.IO.KeyCtrl)[m
[32m+[m[32m            apply_focus_window = g.NavWindowingTarget;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Keyboard: Press and Release ALT to toggle menu layer[m
[32m+[m[32m    // FIXME: We lack an explicit IO variable for "is the imgui window focused", so compare mouse validity to detect the common case of back-end clearing releases all keys on ALT-TAB[m
[32m+[m[32m    if (IsNavInputPressed(ImGuiNavInput_KeyMenu_, ImGuiInputReadMode_Pressed))[m
[32m+[m[32m        g.NavWindowingToggleLayer = true;[m
[32m+[m[32m    if ((g.ActiveId == 0 || g.ActiveIdAllowOverlap) && g.NavWindowingToggleLayer && IsNavInputPressed(ImGuiNavInput_KeyMenu_, ImGuiInputReadMode_Released))[m
[32m+[m[32m        if (IsMousePosValid(&g.IO.MousePos) == IsMousePosValid(&g.IO.MousePosPrev))[m
[32m+[m[32m            apply_toggle_layer = true;[m
[32m+[m
[32m+[m[32m    // Move window[m
[32m+[m[32m    if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImVec2 move_delta;[m
[32m+[m[32m        if (g.NavInputSource == ImGuiInputSource_NavKeyboard && !g.IO.KeyShift)[m
[32m+[m[32m            move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);[m
[32m+[m[32m        if (g.NavInputSource == ImGuiInputSource_NavGamepad)[m
[32m+[m[32m            move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down);[m
[32m+[m[32m        if (move_delta.x != 0.0f || move_delta.y != 0.0f)[m
[32m+[m[32m        {[m
[32m+[m[32m            const float NAV_MOVE_SPEED = 800.0f;[m
[32m+[m[32m            const float move_speed = ImFloor(NAV_MOVE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y)); // FIXME: Doesn't code variable framerate very well[m
[32m+[m[32m            g.NavWindowingTarget->RootWindow->Pos += move_delta * move_speed;[m
[32m+[m[32m            g.NavDisableMouseHover = true;[m
[32m+[m[32m            MarkIniSettingsDirty(g.NavWindowingTarget);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Apply final focus[m
[32m+[m[32m    if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow))[m
[32m+[m[32m    {[m
[32m+[m[32m        ClearActiveID();[m
[32m+[m[32m        g.NavDisableHighlight = false;[m
[32m+[m[32m        g.NavDisableMouseHover = true;[m
[32m+[m[32m        apply_focus_window = NavRestoreLastChildNavWindow(apply_focus_window);[m
[32m+[m[32m        ClosePopupsOverWindow(apply_focus_window, false);[m
[32m+[m[32m        FocusWindow(apply_focus_window);[m
[32m+[m[32m        if (apply_focus_window->NavLastIds[0] == 0)[m
[32m+[m[32m            NavInitWindow(apply_focus_window, false);[m
[32m+[m
[32m+[m[32m        // If the window only has a menu layer, select it directly[m
[32m+[m[32m        if (apply_focus_window->DC.NavLayerActiveMask == (1 << ImGuiNavLayer_Menu))[m
[32m+[m[32m            g.NavLayer = ImGuiNavLayer_Menu;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (apply_focus_window)[m
[32m+[m[32m        g.NavWindowingTarget = NULL;[m
[32m+[m
[32m+[m[32m    // Apply menu/layer toggle[m
[32m+[m[32m    if (apply_toggle_layer && g.NavWindow)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Move to parent menu if necessary[m
[32m+[m[32m        ImGuiWindow* new_nav_window = g.NavWindow;[m
[32m+[m[32m        while (new_nav_window->ParentWindow[m
[32m+[m[32m            && (new_nav_window->DC.NavLayerActiveMask & (1 << ImGuiNavLayer_Menu)) == 0[m
[32m+[m[32m            && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0[m
[32m+[m[32m            && (new_nav_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)[m
[32m+[m[32m            new_nav_window = new_nav_window->ParentWindow;[m
[32m+[m[32m        if (new_nav_window != g.NavWindow)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGuiWindow* old_nav_window = g.NavWindow;[m
[32m+[m[32m            FocusWindow(new_nav_window);[m
[32m+[m[32m            new_nav_window->NavLastChildNavWindow = old_nav_window;[m
[32m+[m[32m        }[m
[32m+[m[32m        g.NavDisableHighlight = false;[m
[32m+[m[32m        g.NavDisableMouseHover = true;[m
[32m+[m
[32m+[m[32m        // When entering a regular menu bar with the Alt key, we always reinitialize the navigation ID.[m
[32m+[m[32m        const ImGuiNavLayer new_nav_layer = (g.NavWindow->DC.NavLayerActiveMask & (1 << ImGuiNavLayer_Menu)) ? (ImGuiNavLayer)((int)g.NavLayer ^ 1) : ImGuiNavLayer_Main;[m
[32m+[m[32m        NavRestoreLayer(new_nav_layer);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Window has already passed the IsWindowNavFocusable()[m
[32m+[m[32mstatic const char* GetFallbackWindowNameForWindowingList(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    if (window->Flags & ImGuiWindowFlags_Popup)[m
[32m+[m[32m        return "(Popup)";[m
[32m+[m[32m    if ((window->Flags & ImGuiWindowFlags_MenuBar) && strcmp(window->Name, "##MainMenuBar") == 0)[m
[32m+[m[32m        return "(Main menu bar)";[m
[32m+[m[32m    return "(Untitled)";[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Overlay displayed when using CTRL+TAB. Called by EndFrame().[m
[32m+[m[32mvoid ImGui::NavUpdateWindowingList()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(g.NavWindowingTarget != NULL);[m
[32m+[m
[32m+[m[32m    if (g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    if (g.NavWindowingList == NULL)[m
[32m+[m[32m        g.NavWindowingList = FindWindowByName("###NavWindowingList");[m
[32m+[m[32m    SetNextWindowSizeConstraints(ImVec2(g.IO.DisplaySize.x * 0.20f, g.IO.DisplaySize.y * 0.20f), ImVec2(FLT_MAX, FLT_MAX));[m
[32m+[m[32m    SetNextWindowPos(g.IO.DisplaySize * 0.5f, ImGuiCond_Always, ImVec2(0.5f, 0.5f));[m
[32m+[m[32m    PushStyleVar(ImGuiStyleVar_WindowPadding, g.Style.WindowPadding * 2.0f);[m
[32m+[m[32m    Begin("###NavWindowingList", NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings);[m
[32m+[m[32m    for (int n = g.WindowsFocusOrder.Size - 1; n >= 0; n--)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiWindow* window = g.WindowsFocusOrder[n];[m
[32m+[m[32m        if (!IsWindowNavFocusable(window))[m
[32m+[m[32m            continue;[m
[32m+[m[32m        const char* label = window->Name;[m
[32m+[m[32m        if (label == FindRenderedTextEnd(label))[m
[32m+[m[32m            label = GetFallbackWindowNameForWindowingList(window);[m
[32m+[m[32m        Selectable(label, g.NavWindowingTarget == window);[m
[32m+[m[32m    }[m
[32m+[m[32m    End();[m
[32m+[m[32m    PopStyleVar();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] COLUMNS[m
[32m+[m[32m// In the current version, Columns are very weak. Needs to be replaced with a more full-featured system.[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mvoid ImGui::NextColumn()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems || window->DC.CurrentColumns == NULL)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiColumns* columns = window->DC.CurrentColumns;[m
[32m+[m
[32m+[m[32m    if (columns->Count == 1)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);[m
[32m+[m[32m        IM_ASSERT(columns->Current == 0);[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    PopItemWidth();[m
[32m+[m[32m    PopClipRect();[m
[32m+[m
[32m+[m[32m    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);[m
[32m+[m[32m    if (++columns->Current < columns->Count)[m
[32m+[m[32m    {[m
[32m+[m[32m        // New column (columns 1+ cancels out IndentX)[m
[32m+[m[32m        window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + g.Style.ItemSpacing.x;[m
[32m+[m[32m        window->DrawList->ChannelsSetCurrent(columns->Current);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // New row/line[m
[32m+[m[32m        window->DC.ColumnsOffset.x = 0.0f;[m
[32m+[m[32m        window->DrawList->ChannelsSetCurrent(0);[m
[32m+[m[32m        columns->Current = 0;[m
[32m+[m[32m        columns->LineMinY = columns->LineMaxY;[m
[32m+[m[32m    }[m
[32m+[m[32m    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);[m
[32m+[m[32m    window->DC.CursorPos.y = columns->LineMinY;[m
[32m+[m[32m    window->DC.CurrentLineSize = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    window->DC.CurrentLineTextBaseOffset = 0.0f;[m
[32m+[m
[32m+[m[32m    PushColumnClipRect();[m
[32m+[m[32m    PushItemWidth(GetColumnWidth() * 0.65f);  // FIXME-COLUMNS: Move on columns setup[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImGui::GetColumnIndex()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->DC.CurrentColumns ? window->DC.CurrentColumns->Current : 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImGui::GetColumnsCount()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    return window->DC.CurrentColumns ? window->DC.CurrentColumns->Count : 1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic float OffsetNormToPixels(const ImGuiColumns* columns, float offset_norm)[m
[32m+[m[32m{[m
[32m+[m[32m    return offset_norm * (columns->MaxX - columns->MinX);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic float PixelsToOffsetNorm(const ImGuiColumns* columns, float offset)[m
[32m+[m[32m{[m
[32m+[m[32m    return offset / (columns->MaxX - columns->MinX);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic const float COLUMNS_HIT_RECT_HALF_WIDTH = 4.0f;[m
[32m+[m
[32m+[m[32mstatic float GetDraggedColumnOffset(ImGuiColumns* columns, int column_index)[m
[32m+[m[32m{[m
[32m+[m[32m    // Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing[m
[32m+[m[32m    // window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.[m
[32m+[m[32m    IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));[m
[32m+[m
[32m+[m[32m    float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + COLUMNS_HIT_RECT_HALF_WIDTH - window->Pos.x;[m
[32m+[m[32m    x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);[m
[32m+[m[32m    if ((columns->Flags & ImGuiColumnsFlags_NoPreserveWidths))[m
[32m+[m[32m        x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);[m
[32m+[m
[32m+[m[32m    return x;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetColumnOffset(int column_index)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    ImGuiColumns* columns = window->DC.CurrentColumns;[m
[32m+[m[32m    IM_ASSERT(columns != NULL);[m
[32m+[m
[32m+[m[32m    if (column_index < 0)[m
[32m+[m[32m        column_index = columns->Current;[m
[32m+[m[32m    IM_ASSERT(column_index < columns->Columns.Size);[m
[32m+[m
[32m+[m[32m    const float t = columns->Columns[column_index].OffsetNorm;[m
[32m+[m[32m    const float x_offset = ImLerp(columns->MinX, columns->MaxX, t);[m
[32m+[m[32m    return x_offset;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic float GetColumnWidthEx(ImGuiColumns* columns, int column_index, bool before_resize = false)[m
[32m+[m[32m{[m
[32m+[m[32m    if (column_index < 0)[m
[32m+[m[32m        column_index = columns->Current;[m
[32m+[m
[32m+[m[32m    float offset_norm;[m
[32m+[m[32m    if (before_resize)[m
[32m+[m[32m        offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;[m
[32m+[m[32m    else[m
[32m+[m[32m        offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;[m
[32m+[m[32m    return OffsetNormToPixels(columns, offset_norm);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGui::GetColumnWidth(int column_index)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    ImGuiColumns* columns = window->DC.CurrentColumns;[m
[32m+[m[32m    IM_ASSERT(columns != NULL);[m
[32m+[m
[32m+[m[32m    if (column_index < 0)[m
[32m+[m[32m        column_index = columns->Current;[m
[32m+[m[32m    return OffsetNormToPixels(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetColumnOffset(int column_index, float offset)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    ImGuiColumns* columns = window->DC.CurrentColumns;[m
[32m+[m[32m    IM_ASSERT(columns != NULL);[m
[32m+[m
[32m+[m[32m    if (column_index < 0)[m
[32m+[m[32m        column_index = columns->Current;[m
[32m+[m[32m    IM_ASSERT(column_index < columns->Columns.Size);[m
[32m+[m
[32m+[m[32m    const bool preserve_width = !(columns->Flags & ImGuiColumnsFlags_NoPreserveWidths) && (column_index < columns->Count-1);[m
[32m+[m[32m    const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;[m
[32m+[m
[32m+[m[32m    if (!(columns->Flags & ImGuiColumnsFlags_NoForceWithinWindow))[m
[32m+[m[32m        offset = ImMin(offset, columns->MaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));[m
[32m+[m[32m    columns->Columns[column_index].OffsetNorm = PixelsToOffsetNorm(columns, offset - columns->MinX);[m
[32m+[m
[32m+[m[32m    if (preserve_width)[m
[32m+[m[32m        SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetColumnWidth(int column_index, float width)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    ImGuiColumns* columns = window->DC.CurrentColumns;[m
[32m+[m[32m    IM_ASSERT(columns != NULL);[m
[32m+[m
[32m+[m[32m    if (column_index < 0)[m
[32m+[m[32m        column_index = columns->Current;[m
[32m+[m[32m    SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PushColumnClipRect(int column_index)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindowRead();[m
[32m+[m[32m    ImGuiColumns* columns = window->DC.CurrentColumns;[m
[32m+[m[32m    if (column_index < 0)[m
[32m+[m[32m        column_index = columns->Current;[m
[32m+[m
[32m+[m[32m    ImGuiColumnData* column = &columns->Columns[column_index];[m
[32m+[m[32m    PushClipRect(column->ClipRect.Min, column->ClipRect.Max, false);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiColumns* ImGui::FindOrCreateColumns(ImGuiWindow* window, ImGuiID id)[m
[32m+[m[32m{[m
[32m+[m[32m    // We have few columns per window so for now we don't need bother much with turning this into a faster lookup.[m
[32m+[m[32m    for (int n = 0; n < window->ColumnsStorage.Size; n++)[m
[32m+[m[32m        if (window->ColumnsStorage[n].ID == id)[m
[32m+[m[32m            return &window->ColumnsStorage[n];[m
[32m+[m
[32m+[m[32m    window->ColumnsStorage.push_back(ImGuiColumns());[m
[32m+[m[32m    ImGuiColumns* columns = &window->ColumnsStorage.back();[m
[32m+[m[32m    columns->ID = id;[m
[32m+[m[32m    return columns;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiID ImGui::GetColumnsID(const char* str_id, int columns_count)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m
[32m+[m[32m    // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.[m
[32m+[m[32m    // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.[m
[32m+[m[32m    PushID(0x11223347 + (str_id ? 0 : columns_count));[m
[32m+[m[32m    ImGuiID id = window->GetID(str_id ? str_id : "columns");[m
[32m+[m[32m    PopID();[m
[32m+[m
[32m+[m[32m    return id;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::BeginColumns(const char* str_id, int columns_count, ImGuiColumnsFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m
[32m+[m[32m    IM_ASSERT(columns_count >= 1);[m
[32m+[m[32m    IM_ASSERT(window->DC.CurrentColumns == NULL); // Nested columns are currently not supported[m
[32m+[m
[32m+[m[32m    ImGuiID id = GetColumnsID(str_id, columns_count);[m
[32m+[m
[32m+[m[32m    // Acquire storage for the columns set[m
[32m+[m[32m    ImGuiColumns* columns = FindOrCreateColumns(window, id);[m
[32m+[m[32m    IM_ASSERT(columns->ID == id);[m
[32m+[m[32m    columns->Current = 0;[m
[32m+[m[32m    columns->Count = columns_count;[m
[32m+[m[32m    columns->Flags = flags;[m
[32m+[m[32m    window->DC.CurrentColumns = columns;[m
[32m+[m
[32m+[m[32m    // Set state for first column[m
[32m+[m[32m    const float content_region_width = (window->SizeContentsExplicit.x != 0.0f) ? (window->SizeContentsExplicit.x) : (window->InnerClipRect.Max.x - window->Pos.x);[m
[32m+[m[32m    columns->MinX = window->DC.Indent.x - g.Style.ItemSpacing.x; // Lock our horizontal range[m
[32m+[m[32m    columns->MaxX = ImMax(content_region_width - window->Scroll.x, columns->MinX + 1.0f);[m
[32m+[m[32m    columns->BackupCursorPosY = window->DC.CursorPos.y;[m
[32m+[m[32m    columns->BackupCursorMaxPosX = window->DC.CursorMaxPos.x;[m
[32m+[m[32m    columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;[m
[32m+[m[32m    window->DC.ColumnsOffset.x = 0.0f;[m
[32m+[m[32m    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);[m
[32m+[m
[32m+[m[32m    // Clear data if columns count changed[m
[32m+[m[32m    if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)[m
[32m+[m[32m        columns->Columns.resize(0);[m
[32m+[m
[32m+[m[32m    // Initialize defaults[m
[32m+[m[32m    columns->IsFirstFrame = (columns->Columns.Size == 0);[m
[32m+[m[32m    if (columns->Columns.Size == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        columns->Columns.reserve(columns_count + 1);[m
[32m+[m[32m        for (int n = 0; n < columns_count + 1; n++)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGuiColumnData column;[m
[32m+[m[32m            column.OffsetNorm = n / (float)columns_count;[m
[32m+[m[32m            columns->Columns.push_back(column);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    for (int n = 0; n < columns_count; n++)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Compute clipping rectangle[m
[32m+[m[32m        ImGuiColumnData* column = &columns->Columns[n];[m
[32m+[m[32m        float clip_x1 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n));[m
[32m+[m[32m        float clip_x2 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n + 1) - 1.0f);[m
[32m+[m[32m        column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);[m
[32m+[m[32m        column->ClipRect.ClipWith(window->ClipRect);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (columns->Count > 1)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->DrawList->ChannelsSplit(columns->Count);[m
[32m+[m[32m        PushColumnClipRect();[m
[32m+[m[32m    }[m
[32m+[m[32m    PushItemWidth(GetColumnWidth() * 0.65f);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::EndColumns()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    ImGuiColumns* columns = window->DC.CurrentColumns;[m
[32m+[m[32m    IM_ASSERT(columns != NULL);[m
[32m+[m
[32m+[m[32m    PopItemWidth();[m
[32m+[m[32m    if (columns->Count > 1)[m
[32m+[m[32m    {[m
[32m+[m[32m        PopClipRect();[m
[32m+[m[32m        window->DrawList->ChannelsMerge();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);[m
[32m+[m[32m    window->DC.CursorPos.y = columns->LineMaxY;[m
[32m+[m[32m    if (!(columns->Flags & ImGuiColumnsFlags_GrowParentContentsSize))[m
[32m+[m[32m        window->DC.CursorMaxPos.x = columns->BackupCursorMaxPosX;  // Restore cursor max pos, as columns don't grow parent[m
[32m+[m
[32m+[m[32m    // Draw columns borders and handle resize[m
[32m+[m[32m    bool is_being_resized = false;[m
[32m+[m[32m    if (!(columns->Flags & ImGuiColumnsFlags_NoBorder) && !window->SkipItems)[m
[32m+[m[32m    {[m
[32m+[m[32m        // We clip Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.[m
[32m+[m[32m        const float y1 = ImMax(columns->BackupCursorPosY, window->ClipRect.Min.y);[m
[32m+[m[32m        const float y2 = ImMin(window->DC.CursorPos.y, window->ClipRect.Max.y);[m
[32m+[m[32m        int dragging_column = -1;[m
[32m+[m[32m        for (int n = 1; n < columns->Count; n++)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGuiColumnData* column = &columns->Columns[n];[m
[32m+[m[32m            float x = window->Pos.x + GetColumnOffset(n);[m
[32m+[m[32m            const ImGuiID column_id = columns->ID + ImGuiID(n);[m
[32m+[m[32m            const float column_hit_hw = COLUMNS_HIT_RECT_HALF_WIDTH;[m
[32m+[m[32m            const ImRect column_hit_rect(ImVec2(x - column_hit_hw, y1), ImVec2(x + column_hit_hw, y2));[m
[32m+[m[32m            KeepAliveID(column_id);[m
[32m+[m[32m            if (IsClippedEx(column_hit_rect, column_id, false))[m
[32m+[m[32m                continue;[m
[32m+[m
[32m+[m[32m            bool hovered = false, held = false;[m
[32m+[m[32m            if (!(columns->Flags & ImGuiColumnsFlags_NoResize))[m
[32m+[m[32m            {[m
[32m+[m[32m                ButtonBehavior(column_hit_rect, column_id, &hovered, &held);[m
[32m+[m[32m                if (hovered || held)[m
[32m+[m[32m                    g.MouseCursor = ImGuiMouseCursor_ResizeEW;[m
[32m+[m[32m                if (held && !(column->Flags & ImGuiColumnsFlags_NoResize))[m
[32m+[m[32m                    dragging_column = n;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Draw column[m
[32m+[m[32m            const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);[m
[32m+[m[32m            const float xi = (float)(int)x;[m
[32m+[m[32m            window->DrawList->AddLine(ImVec2(xi, y1 + 1.0f), ImVec2(xi, y2), col);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.[m
[32m+[m[32m        if (dragging_column != -1)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (!columns->IsBeingResized)[m
[32m+[m[32m                for (int n = 0; n < columns->Count + 1; n++)[m
[32m+[m[32m                    columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;[m
[32m+[m[32m            columns->IsBeingResized = is_being_resized = true;[m
[32m+[m[32m            float x = GetDraggedColumnOffset(columns, dragging_column);[m
[32m+[m[32m            SetColumnOffset(dragging_column, x);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    columns->IsBeingResized = is_being_resized;[m
[32m+[m
[32m+[m[32m    window->DC.CurrentColumns = NULL;[m
[32m+[m[32m    window->DC.ColumnsOffset.x = 0.0f;[m
[32m+[m[32m    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// [2018-03: This is currently the only public API, while we are working on making BeginColumns/EndColumns user-facing][m
[32m+[m[32mvoid ImGui::Columns(int columns_count, const char* id, bool border)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    IM_ASSERT(columns_count >= 1);[m
[32m+[m
[32m+[m[32m    ImGuiColumnsFlags flags = (border ? 0 : ImGuiColumnsFlags_NoBorder);[m
[32m+[m[32m    //flags |= ImGuiColumnsFlags_NoPreserveWidths; // NB: Legacy behavior[m
[32m+[m[32m    ImGuiColumns* columns = window->DC.CurrentColumns;[m
[32m+[m[32m    if (columns != NULL && columns->Count == columns_count && columns->Flags == flags)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    if (columns != NULL)[m
[32m+[m[32m        EndColumns();[m
[32m+[m
[32m+[m[32m    if (columns_count != 1)[m
[32m+[m[32m        BeginColumns(id, columns_count, flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] DRAG AND DROP[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mvoid ImGui::ClearDragDrop()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.DragDropActive = false;[m
[32m+[m[32m    g.DragDropPayload.Clear();[m
[32m+[m[32m    g.DragDropAcceptFlags = ImGuiDragDropFlags_None;[m
[32m+[m[32m    g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;[m
[32m+[m[32m    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;[m
[32m+[m[32m    g.DragDropAcceptFrameCount = -1;[m
[32m+[m
[32m+[m[32m    g.DragDropPayloadBufHeap.clear();[m
[32m+[m[32m    memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Call when current ID is active.[m
[32m+[m[32m// When this returns true you need to: a) call SetDragDropPayload() exactly once, b) you may render the payload visual/description, c) call EndDragDropSource()[m
[32m+[m[32mbool ImGui::BeginDragDropSource(ImGuiDragDropFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m
[32m+[m[32m    bool source_drag_active = false;[m
[32m+[m[32m    ImGuiID source_id = 0;[m
[32m+[m[32m    ImGuiID source_parent_id = 0;[m
[32m+[m[32m    int mouse_button = 0;[m
[32m+[m[32m    if (!(flags & ImGuiDragDropFlags_SourceExtern))[m
[32m+[m[32m    {[m
[32m+[m[32m        source_id = window->DC.LastItemId;[m
[32m+[m[32m        if (source_id != 0 && g.ActiveId != source_id) // Early out for most common case[m
[32m+[m[32m            return false;[m
[32m+[m[32m        if (g.IO.MouseDown[mouse_button] == false)[m
[32m+[m[32m            return false;[m
[32m+[m
[32m+[m[32m        if (source_id == 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            // If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:[m
[32m+[m[32m            // A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag, C) Swallow your programmer pride.[m
[32m+[m[32m            if (!(flags & ImGuiDragDropFlags_SourceAllowNullID))[m
[32m+[m[32m            {[m
[32m+[m[32m                IM_ASSERT(0);[m
[32m+[m[32m                return false;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Early out[m
[32m+[m[32m            if ((window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) == 0 && (g.ActiveId == 0 || g.ActiveIdWindow != window))[m
[32m+[m[32m                return false;[m
[32m+[m
[32m+[m[32m            // Magic fallback (=somehow reprehensible) to handle items with no assigned ID, e.g. Text(), Image()[m
[32m+[m[32m            // We build a throwaway ID based on current ID stack + relative AABB of items in window.[m
[32m+[m[32m            // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING OF THE WIDGET, so if your widget moves your dragging operation will be canceled.[m
[32m+[m[32m            // We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.[m
[32m+[m[32m            source_id = window->DC.LastItemId = window->GetIDFromRectangle(window->DC.LastItemRect);[m
[32m+[m[32m            bool is_hovered = ItemHoverable(window->DC.LastItemRect, source_id);[m
[32m+[m[32m            if (is_hovered && g.IO.MouseClicked[mouse_button])[m
[32m+[m[32m            {[m
[32m+[m[32m                SetActiveID(source_id, window);[m
[32m+[m[32m                FocusWindow(window);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.[m
[32m+[m[32m                g.ActiveIdAllowOverlap = is_hovered;[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            g.ActiveIdAllowOverlap = false;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (g.ActiveId != source_id)[m
[32m+[m[32m            return false;[m
[32m+[m[32m        source_parent_id = window->IDStack.back();[m
[32m+[m[32m        source_drag_active = IsMouseDragging(mouse_button);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        window = NULL;[m
[32m+[m[32m        source_id = ImHashStr("#SourceExtern");[m
[32m+[m[32m        source_drag_active = true;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (source_drag_active)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (!g.DragDropActive)[m
[32m+[m[32m        {[m
[32m+[m[32m            IM_ASSERT(source_id != 0);[m
[32m+[m[32m            ClearDragDrop();[m
[32m+[m[32m            ImGuiPayload& payload = g.DragDropPayload;[m
[32m+[m[32m            payload.SourceId = source_id;[m
[32m+[m[32m            payload.SourceParentId = source_parent_id;[m
[32m+[m[32m            g.DragDropActive = true;[m
[32m+[m[32m            g.DragDropSourceFlags = flags;[m
[32m+[m[32m            g.DragDropMouseButton = mouse_button;[m
[32m+[m[32m        }[m
[32m+[m[32m        g.DragDropSourceFrameCount = g.FrameCount;[m
[32m+[m[32m        g.DragDropWithinSourceOrTarget = true;[m
[32m+[m
[32m+[m[32m        if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip))[m
[32m+[m[32m        {[m
[32m+[m[32m            // Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)[m
[32m+[m[32m            // We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents.[m
[32m+[m[32m            BeginTooltip();[m
[32m+[m[32m            if (g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & ImGuiDragDropFlags_AcceptNoPreviewTooltip))[m
[32m+[m[32m            {[m
[32m+[m[32m                ImGuiWindow* tooltip_window = g.CurrentWindow;[m
[32m+[m[32m                tooltip_window->SkipItems = true;[m
[32m+[m[32m                tooltip_window->HiddenFramesCanSkipItems = 1;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))[m
[32m+[m[32m            window->DC.LastItemStatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;[m
[32m+[m
[32m+[m[32m        return true;[m
[32m+[m[32m    }[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::EndDragDropSource()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(g.DragDropActive);[m
[32m+[m[32m    IM_ASSERT(g.DragDropWithinSourceOrTarget && "Not after a BeginDragDropSource()?");[m
[32m+[m
[32m+[m[32m    if (!(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))[m
[32m+[m[32m        EndTooltip();[m
[32m+[m
[32m+[m[32m    // Discard the drag if have not called SetDragDropPayload()[m
[32m+[m[32m    if (g.DragDropPayload.DataFrameCount == -1)[m
[32m+[m[32m        ClearDragDrop();[m
[32m+[m[32m    g.DragDropWithinSourceOrTarget = false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Use 'cond' to choose to submit payload on drag start or every frame[m
[32m+[m[32mbool ImGui::SetDragDropPayload(const char* type, const void* data, size_t data_size, ImGuiCond cond)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiPayload& payload = g.DragDropPayload;[m
[32m+[m[32m    if (cond == 0)[m
[32m+[m[32m        cond = ImGuiCond_Always;[m
[32m+[m
[32m+[m[32m    IM_ASSERT(type != NULL);[m
[32m+[m[32m    IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType) && "Payload type can be at most 32 characters long");[m
[32m+[m[32m    IM_ASSERT((data != NULL && data_size > 0) || (data == NULL && data_size == 0));[m
[32m+[m[32m    IM_ASSERT(cond == ImGuiCond_Always || cond == ImGuiCond_Once);[m
[32m+[m[32m    IM_ASSERT(payload.SourceId != 0);                               // Not called between BeginDragDropSource() and EndDragDropSource()[m
[32m+[m
[32m+[m[32m    if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Copy payload[m
[32m+[m[32m        ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType));[m
[32m+[m[32m        g.DragDropPayloadBufHeap.resize(0);[m
[32m+[m[32m        if (data_size > sizeof(g.DragDropPayloadBufLocal))[m
[32m+[m[32m        {[m
[32m+[m[32m            // Store in heap[m
[32m+[m[32m            g.DragDropPayloadBufHeap.resize((int)data_size);[m
[32m+[m[32m            payload.Data = g.DragDropPayloadBufHeap.Data;[m
[32m+[m[32m            memcpy(payload.Data, data, data_size);[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (data_size > 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Store locally[m
[32m+[m[32m            memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));[m
[32m+[m[32m            payload.Data = g.DragDropPayloadBufLocal;[m
[32m+[m[32m            memcpy(payload.Data, data, data_size);[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            payload.Data = NULL;[m
[32m+[m[32m        }[m
[32m+[m[32m        payload.DataSize = (int)data_size;[m
[32m+[m[32m    }[m
[32m+[m[32m    payload.DataFrameCount = g.FrameCount;[m
[32m+[m
[32m+[m[32m    return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (!g.DragDropActive)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)[m
[32m+[m[32m        return false;[m
[32m+[m[32m    IM_ASSERT(id != 0);[m
[32m+[m[32m    if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))[m
[32m+[m[32m        return false;[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    IM_ASSERT(g.DragDropWithinSourceOrTarget == false);[m
[32m+[m[32m    g.DragDropTargetRect = bb;[m
[32m+[m[32m    g.DragDropTargetId = id;[m
[32m+[m[32m    g.DragDropWithinSourceOrTarget = true;[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// We don't use BeginDragDropTargetCustom() and duplicate its code because:[m
[32m+[m[32m// 1) we use LastItemRectHoveredRect which handles items that pushes a temporarily clip rectangle in their code. Calling BeginDragDropTargetCustom(LastItemRect) would not handle them.[m
[32m+[m[32m// 2) and it's faster. as this code may be very frequently called, we want to early out as fast as we can.[m
[32m+[m[32m// Also note how the HoveredWindow test is positioned differently in both functions (in both functions we optimize for the cheapest early out case)[m
[32m+[m[32mbool ImGui::BeginDragDropTarget()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (!g.DragDropActive)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))[m
[32m+[m[32m        return false;[m
[32m+[m[32m    if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    const ImRect& display_rect = (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect) ? window->DC.LastItemDisplayRect : window->DC.LastItemRect;[m
[32m+[m[32m    ImGuiID id = window->DC.LastItemId;[m
[32m+[m[32m    if (id == 0)[m
[32m+[m[32m        id = window->GetIDFromRectangle(display_rect);[m
[32m+[m[32m    if (g.DragDropPayload.SourceId == id)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    IM_ASSERT(g.DragDropWithinSourceOrTarget == false);[m
[32m+[m[32m    g.DragDropTargetRect = display_rect;[m
[32m+[m[32m    g.DragDropTargetId = id;[m
[32m+[m[32m    g.DragDropWithinSourceOrTarget = true;[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::IsDragDropPayloadBeingAccepted()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.DragDropActive && g.DragDropAcceptIdPrev != 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst ImGuiPayload* ImGui::AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    ImGuiPayload& payload = g.DragDropPayload;[m
[32m+[m[32m    IM_ASSERT(g.DragDropActive);                        // Not called between BeginDragDropTarget() and EndDragDropTarget() ?[m
[32m+[m[32m    IM_ASSERT(payload.DataFrameCount != -1);            // Forgot to call EndDragDropTarget() ?[m
[32m+[m[32m    if (type != NULL && !payload.IsDataType(type))[m
[32m+[m[32m        return NULL;[m
[32m+[m
[32m+[m[32m    // Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.[m
[32m+[m[32m    // NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function![m
[32m+[m[32m    const bool was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);[m
[32m+[m[32m    ImRect r = g.DragDropTargetRect;[m
[32m+[m[32m    float r_surface = r.GetWidth() * r.GetHeight();[m
[32m+[m[32m    if (r_surface < g.DragDropAcceptIdCurrRectSurface)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.DragDropAcceptFlags = flags;[m
[32m+[m[32m        g.DragDropAcceptIdCurr = g.DragDropTargetId;[m
[32m+[m[32m        g.DragDropAcceptIdCurrRectSurface = r_surface;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Render default drop visuals[m
[32m+[m[32m    payload.Preview = was_accepted_previously;[m
[32m+[m[32m    flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that lives for 1 frame)[m
[32m+[m[32m    if (!(flags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)[m
[32m+[m[32m    {[m
[32m+[m[32m        // FIXME-DRAG: Settle on a proper default visuals for drop target.[m
[32m+[m[32m        r.Expand(3.5f);[m
[32m+[m[32m        bool push_clip_rect = !window->ClipRect.Contains(r);[m
[32m+[m[32m        if (push_clip_rect) window->DrawList->PushClipRect(r.Min-ImVec2(1,1), r.Max+ImVec2(1,1));[m
[32m+[m[32m        window->DrawList->AddRect(r.Min, r.Max, GetColorU32(ImGuiCol_DragDropTarget), 0.0f, ~0, 2.0f);[m
[32m+[m[32m        if (push_clip_rect) window->DrawList->PopClipRect();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    g.DragDropAcceptFrameCount = g.FrameCount;[m
[32m+[m[32m    payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton); // For extern drag sources affecting os window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()[m
[32m+[m[32m    if (!payload.Delivery && !(flags & ImGuiDragDropFlags_AcceptBeforeDelivery))[m
[32m+[m[32m        return NULL;[m
[32m+[m
[32m+[m[32m    return &payload;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst ImGuiPayload* ImGui::GetDragDropPayload()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.DragDropActive ? &g.DragDropPayload : NULL;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// We don't really use/need this now, but added it for the sake of consistency and because we might need it later.[m
[32m+[m[32mvoid ImGui::EndDragDropTarget()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(g.DragDropActive);[m
[32m+[m[32m    IM_ASSERT(g.DragDropWithinSourceOrTarget);[m
[32m+[m[32m    g.DragDropWithinSourceOrTarget = false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] LOGGING/CAPTURING[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// All text output from the interface can be captured into tty/file/clipboard.[m
[32m+[m[32m// By default, tree nodes are automatically opened during logging.[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Pass text data straight to log (without being displayed)[m
[32m+[m[32mvoid ImGui::LogText(const char* fmt, ...)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (!g.LogEnabled)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    va_list args;[m
[32m+[m[32m    va_start(args, fmt);[m
[32m+[m[32m    if (g.LogFile)[m
[32m+[m[32m        vfprintf(g.LogFile, fmt, args);[m
[32m+[m[32m    else[m
[32m+[m[32m        g.LogBuffer.appendfv(fmt, args);[m
[32m+[m[32m    va_end(args);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Internal version that takes a position to decide on newline placement and pad items according to their depth.[m
[32m+[m[32m// We split text into individual lines to add current tree level padding[m
[32m+[m[32mvoid ImGui::LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m
[32m+[m[32m    if (!text_end)[m
[32m+[m[32m        text_end = FindRenderedTextEnd(text, text_end);[m
[32m+[m
[32m+[m[32m    const bool log_new_line = ref_pos && (ref_pos->y > g.LogLinePosY + 1);[m
[32m+[m[32m    if (ref_pos)[m
[32m+[m[32m        g.LogLinePosY = ref_pos->y;[m
[32m+[m[32m    if (log_new_line)[m
[32m+[m[32m        g.LogLineFirstItem = true;[m
[32m+[m
[32m+[m[32m    const char* text_remaining = text;[m
[32m+[m[32m    if (g.LogDepthRef > window->DC.TreeDepth)  // Re-adjust padding if we have popped out of our starting depth[m
[32m+[m[32m        g.LogDepthRef = window->DC.TreeDepth;[m
[32m+[m[32m    const int tree_depth = (window->DC.TreeDepth - g.LogDepthRef);[m
[32m+[m[32m    for (;;)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Split the string. Each new line (after a '\n') is followed by spacing corresponding to the current depth of our log entry.[m
[32m+[m[32m        // We don't add a trailing \n to allow a subsequent item on the same line to be captured.[m
[32m+[m[32m        const char* line_start = text_remaining;[m
[32m+[m[32m        const char* line_end = ImStreolRange(line_start, text_end);[m
[32m+[m[32m        const bool is_first_line = (line_start == text);[m
[32m+[m[32m        const bool is_last_line = (line_end == text_end);[m
[32m+[m[32m        if (!is_last_line || (line_start != line_end))[m
[32m+[m[32m        {[m
[32m+[m[32m            const int char_count = (int)(line_end - line_start);[m
[32m+[m[32m            if (log_new_line || !is_first_line)[m
[32m+[m[32m                LogText(IM_NEWLINE "%*s%.*s", tree_depth * 4, "", char_count, line_start);[m
[32m+[m[32m            else if (g.LogLineFirstItem)[m
[32m+[m[32m                LogText("%*s%.*s", tree_depth * 4, "", char_count, line_start);[m
[32m+[m[32m            else[m
[32m+[m[32m                LogText(" %.*s", char_count, line_start);[m
[32m+[m[32m            g.LogLineFirstItem = false;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (log_new_line)[m
[32m+[m[32m        {[m
[32m+[m[32m            // An empty "" string at a different Y position should output a carriage return.[m
[32m+[m[32m            LogText(IM_NEWLINE);[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (is_last_line)[m
[32m+[m[32m            break;[m
[32m+[m[32m        text_remaining = line_end + 1;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Start logging/capturing text output[m
[32m+[m[32mvoid ImGui::LogBegin(ImGuiLogType type, int auto_open_depth)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    IM_ASSERT(g.LogEnabled == false);[m
[32m+[m[32m    IM_ASSERT(g.LogFile == NULL);[m
[32m+[m[32m    IM_ASSERT(g.LogBuffer.empty());[m
[32m+[m[32m    g.LogEnabled = true;[m
[32m+[m[32m    g.LogType = type;[m
[32m+[m[32m    g.LogDepthRef = window->DC.TreeDepth;[m
[32m+[m[32m    g.LogDepthToExpand = ((auto_open_depth >= 0) ? auto_open_depth : g.LogDepthToExpandDefault);[m
[32m+[m[32m    g.LogLinePosY = FLT_MAX;[m
[32m+[m[32m    g.LogLineFirstItem = true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::LogToTTY(int auto_open_depth)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.LogEnabled)[m
[32m+[m[32m        return;[m
[32m+[m[32m    LogBegin(ImGuiLogType_TTY, auto_open_depth);[m
[32m+[m[32m    g.LogFile = stdout;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Start logging/capturing text output to given file[m
[32m+[m[32mvoid ImGui::LogToFile(int auto_open_depth, const char* filename)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.LogEnabled)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // FIXME: We could probably open the file in text mode "at", however note that clipboard/buffer logging will still[m
[32m+[m[32m    // be subject to outputting OS-incompatible carriage return if within strings the user doesn't use IM_NEWLINE.[m
[32m+[m[32m    // By opening the file in binary mode "ab" we have consistent output everywhere.[m
[32m+[m[32m    if (!filename)[m
[32m+[m[32m        filename = g.IO.LogFilename;[m
[32m+[m[32m    if (!filename || !filename[0])[m
[32m+[m[32m        return;[m
[32m+[m[32m    FILE* f = ImFileOpen(filename, "ab");[m
[32m+[m[32m    if (f == NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(0);[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    LogBegin(ImGuiLogType_File, auto_open_depth);[m
[32m+[m[32m    g.LogFile = f;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Start logging/capturing text output to clipboard[m
[32m+[m[32mvoid ImGui::LogToClipboard(int auto_open_depth)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.LogEnabled)[m
[32m+[m[32m        return;[m
[32m+[m[32m    LogBegin(ImGuiLogType_Clipboard, auto_open_depth);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::LogToBuffer(int auto_open_depth)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.LogEnabled)[m
[32m+[m[32m        return;[m
[32m+[m[32m    LogBegin(ImGuiLogType_Buffer, auto_open_depth);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::LogFinish()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (!g.LogEnabled)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    LogText(IM_NEWLINE);[m
[32m+[m[32m    switch (g.LogType)[m
[32m+[m[32m    {[m
[32m+[m[32m    case ImGuiLogType_TTY:[m
[32m+[m[32m        fflush(g.LogFile);[m
[32m+[m[32m        break;[m
[32m+[m[32m    case ImGuiLogType_File:[m
[32m+[m[32m        fclose(g.LogFile);[m
[32m+[m[32m        break;[m
[32m+[m[32m    case ImGuiLogType_Buffer:[m
[32m+[m[32m        break;[m
[32m+[m[32m    case ImGuiLogType_Clipboard:[m
[32m+[m[32m        if (!g.LogBuffer.empty())[m
[32m+[m[32m            SetClipboardText(g.LogBuffer.begin());[m
[32m+[m[32m        break;[m
[32m+[m[32m    case ImGuiLogType_None:[m
[32m+[m[32m        IM_ASSERT(0);[m
[32m+[m[32m        break;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    g.LogEnabled = false;[m
[32m+[m[32m    g.LogType = ImGuiLogType_None;[m
[32m+[m[32m    g.LogFile = NULL;[m
[32m+[m[32m    g.LogBuffer.clear();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Helper to display logging buttons[m
[32m+[m[32m// FIXME-OBSOLETE: We should probably obsolete this and let the user have their own helper (this is one of the oldest function alive!)[m
[32m+[m[32mvoid ImGui::LogButtons()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    PushID("LogButtons");[m
[32m+[m[32m    const bool log_to_tty = Button("Log To TTY"); SameLine();[m
[32m+[m[32m    const bool log_to_file = Button("Log To File"); SameLine();[m
[32m+[m[32m    const bool log_to_clipboard = Button("Log To Clipboard"); SameLine();[m
[32m+[m[32m    PushAllowKeyboardFocus(false);[m
[32m+[m[32m    SetNextItemWidth(80.0f);[m
[32m+[m[32m    SliderInt("Default Depth", &g.LogDepthToExpandDefault, 0, 9, NULL);[m
[32m+[m[32m    PopAllowKeyboardFocus();[m
[32m+[m[32m    PopID();[m
[32m+[m
[32m+[m[32m    // Start logging at the end of the function so that the buttons don't appear in the log[m
[32m+[m[32m    if (log_to_tty)[m
[32m+[m[32m        LogToTTY();[m
[32m+[m[32m    if (log_to_file)[m
[32m+[m[32m        LogToFile();[m
[32m+[m[32m    if (log_to_clipboard)[m
[32m+[m[32m        LogToClipboard();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] SETTINGS[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mvoid ImGui::MarkIniSettingsDirty()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.SettingsDirtyTimer <= 0.0f)[m
[32m+[m[32m        g.SettingsDirtyTimer = g.IO.IniSavingRate;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::MarkIniSettingsDirty(ImGuiWindow* window)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))[m
[32m+[m[32m        if (g.SettingsDirtyTimer <= 0.0f)[m
[32m+[m[32m            g.SettingsDirtyTimer = g.IO.IniSavingRate;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiWindowSettings* ImGui::CreateNewWindowSettings(const char* name)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.SettingsWindows.push_back(ImGuiWindowSettings());[m
[32m+[m[32m    ImGuiWindowSettings* settings = &g.SettingsWindows.back();[m
[32m+[m[32m    settings->Name = ImStrdup(name);[m
[32m+[m[32m    settings->ID = ImHashStr(name);[m
[32m+[m[32m    return settings;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiWindowSettings* ImGui::FindWindowSettings(ImGuiID id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    for (int i = 0; i != g.SettingsWindows.Size; i++)[m
[32m+[m[32m        if (g.SettingsWindows[i].ID == id)[m
[32m+[m[32m            return &g.SettingsWindows[i];[m
[32m+[m[32m    return NULL;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiWindowSettings* ImGui::FindOrCreateWindowSettings(const char* name)[m
[32m+[m[32m{[m
[32m+[m[32m    if (ImGuiWindowSettings* settings = FindWindowSettings(ImHashStr(name)))[m
[32m+[m[32m        return settings;[m
[32m+[m[32m    return CreateNewWindowSettings(name);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::LoadIniSettingsFromDisk(const char* ini_filename)[m
[32m+[m[32m{[m
[32m+[m[32m    size_t file_data_size = 0;[m
[32m+[m[32m    char* file_data = (char*)ImFileLoadToMemory(ini_filename, "rb", &file_data_size);[m
[32m+[m[32m    if (!file_data)[m
[32m+[m[32m        return;[m
[32m+[m[32m    LoadIniSettingsFromMemory(file_data, (size_t)file_data_size);[m
[32m+[m[32m    IM_FREE(file_data);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiSettingsHandler* ImGui::FindSettingsHandler(const char* type_name)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiID type_hash = ImHashStr(type_name);[m
[32m+[m[32m    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)[m
[32m+[m[32m        if (g.SettingsHandlers[handler_n].TypeHash == type_hash)[m
[32m+[m[32m            return &g.SettingsHandlers[handler_n];[m
[32m+[m[32m    return NULL;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Zero-tolerance, no error reporting, cheap .ini parsing[m
[32m+[m[32mvoid ImGui::LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(g.Initialized);[m
[32m+[m[32m    IM_ASSERT(g.SettingsLoaded == false && g.FrameCount == 0);[m
[32m+[m
[32m+[m[32m    // For user convenience, we allow passing a non zero-terminated string (hence the ini_size parameter).[m
[32m+[m[32m    // For our convenience and to make the code simpler, we'll also write zero-terminators within the buffer. So let's create a writable copy..[m
[32m+[m[32m    if (ini_size == 0)[m
[32m+[m[32m        ini_size = strlen(ini_data);[m
[32m+[m[32m    char* buf = (char*)IM_ALLOC(ini_size + 1);[m
[32m+[m[32m    char* buf_end = buf + ini_size;[m
[32m+[m[32m    memcpy(buf, ini_data, ini_size);[m
[32m+[m[32m    buf[ini_size] = 0;[m
[32m+[m
[32m+[m[32m    void* entry_data = NULL;[m
[32m+[m[32m    ImGuiSettingsHandler* entry_handler = NULL;[m
[32m+[m
[32m+[m[32m    char* line_end = NULL;[m
[32m+[m[32m    for (char* line = buf; line < buf_end; line = line_end + 1)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Skip new lines markers, then find end of the line[m
[32m+[m[32m        while (*line == '\n' || *line == '\r')[m
[32m+[m[32m            line++;[m
[32m+[m[32m        line_end = line;[m
[32m+[m[32m        while (line_end < buf_end && *line_end != '\n' && *line_end != '\r')[m
[32m+[m[32m            line_end++;[m
[32m+[m[32m        line_end[0] = 0;[m
[32m+[m[32m        if (line[0] == ';')[m
[32m+[m[32m            continue;[m
[32m+[m[32m        if (line[0] == '[' && line_end > line && line_end[-1] == ']')[m
[32m+[m[32m        {[m
[32m+[m[32m            // Parse "[Type][Name]". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.[m
[32m+[m[32m            line_end[-1] = 0;[m
[32m+[m[32m            const char* name_end = line_end - 1;[m
[32m+[m[32m            const char* type_start = line + 1;[m
[32m+[m[32m            char* type_end = (char*)(intptr_t)ImStrchrRange(type_start, name_end, ']');[m
[32m+[m[32m            const char* name_start = type_end ? ImStrchrRange(type_end + 1, name_end, '[') : NULL;[m
[32m+[m[32m            if (!type_end || !name_start)[m
[32m+[m[32m            {[m
[32m+[m[32m                name_start = type_start; // Import legacy entries that have no type[m
[32m+[m[32m                type_start = "Window";[m
[32m+[m[32m            }[m
[32m+[m[32m            else[m
[32m+[m[32m            {[m
[32m+[m[32m                *type_end = 0; // Overwrite first ']'[m
[32m+[m[32m                name_start++;  // Skip second '['[m
[32m+[m[32m            }[m
[32m+[m[32m            entry_handler = FindSettingsHandler(type_start);[m
[32m+[m[32m            entry_data = entry_handler ? entry_handler->ReadOpenFn(&g, entry_handler, name_start) : NULL;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (entry_handler != NULL && entry_data != NULL)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Let type handler parse the line[m
[32m+[m[32m            entry_handler->ReadLineFn(&g, entry_handler, entry_data, line);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    IM_FREE(buf);[m
[32m+[m[32m    g.SettingsLoaded = true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SaveIniSettingsToDisk(const char* ini_filename)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.SettingsDirtyTimer = 0.0f;[m
[32m+[m[32m    if (!ini_filename)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    size_t ini_data_size = 0;[m
[32m+[m[32m    const char* ini_data = SaveIniSettingsToMemory(&ini_data_size);[m
[32m+[m[32m    FILE* f = ImFileOpen(ini_filename, "wt");[m
[32m+[m[32m    if (!f)[m
[32m+[m[32m        return;[m
[32m+[m[32m    fwrite(ini_data, sizeof(char), ini_data_size, f);[m
[32m+[m[32m    fclose(f);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Call registered handlers (e.g. SettingsHandlerWindow_WriteAll() + custom handlers) to write their stuff into a text buffer[m
[32m+[m[32mconst char* ImGui::SaveIniSettingsToMemory(size_t* out_size)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.SettingsDirtyTimer = 0.0f;[m
[32m+[m[32m    g.SettingsIniData.Buf.resize(0);[m
[32m+[m[32m    g.SettingsIniData.Buf.push_back(0);[m
[32m+[m[32m    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiSettingsHandler* handler = &g.SettingsHandlers[handler_n];[m
[32m+[m[32m        handler->WriteAllFn(&g, handler, &g.SettingsIniData);[m
[32m+[m[32m    }[m
[32m+[m[32m    if (out_size)[m
[32m+[m[32m        *out_size = (size_t)g.SettingsIniData.size();[m
[32m+[m[32m    return g.SettingsIniData.c_str();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void* SettingsHandlerWindow_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindowSettings* settings = ImGui::FindWindowSettings(ImHashStr(name));[m
[32m+[m[32m    if (!settings)[m
[32m+[m[32m        settings = ImGui::CreateNewWindowSettings(name);[m
[32m+[m[32m    return (void*)settings;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void SettingsHandlerWindow_ReadLine(ImGuiContext* ctx, ImGuiSettingsHandler*, void* entry, const char* line)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *ctx;[m
[32m+[m[32m    ImGuiWindowSettings* settings = (ImGuiWindowSettings*)entry;[m
[32m+[m[32m    float x, y;[m
[32m+[m[32m    int i;[m
[32m+[m[32m    if (sscanf(line, "Pos=%f,%f", &x, &y) == 2)         settings->Pos = ImVec2(x, y);[m
[32m+[m[32m    else if (sscanf(line, "Size=%f,%f", &x, &y) == 2)   settings->Size = ImMax(ImVec2(x, y), g.Style.WindowMinSize);[m
[32m+[m[32m    else if (sscanf(line, "Collapsed=%d", &i) == 1)     settings->Collapsed = (i != 0);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void SettingsHandlerWindow_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)[m
[32m+[m[32m{[m
[32m+[m[32m    // Gather data from windows that were active during this session[m
[32m+[m[32m    // (if a window wasn't opened in this session we preserve its settings)[m
[32m+[m[32m    ImGuiContext& g = *ctx;[m
[32m+[m[32m    for (int i = 0; i != g.Windows.Size; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiWindow* window = g.Windows[i];[m
[32m+[m[32m        if (window->Flags & ImGuiWindowFlags_NoSavedSettings)[m
[32m+[m[32m            continue;[m
[32m+[m
[32m+[m[32m        ImGuiWindowSettings* settings = (window->SettingsIdx != -1) ? &g.SettingsWindows[window->SettingsIdx] : ImGui::FindWindowSettings(window->ID);[m
[32m+[m[32m        if (!settings)[m
[32m+[m[32m        {[m
[32m+[m[32m            settings = ImGui::CreateNewWindowSettings(window->Name);[m
[32m+[m[32m            window->SettingsIdx = g.SettingsWindows.index_from_ptr(settings);[m
[32m+[m[32m        }[m
[32m+[m[32m        IM_ASSERT(settings->ID == window->ID);[m
[32m+[m[32m        settings->Pos = window->Pos;[m
[32m+[m[32m        settings->Size = window->SizeFull;[m
[32m+[m[32m        settings->Collapsed = window->Collapsed;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Write to text buffer[m
[32m+[m[32m    buf->reserve(buf->size() + g.SettingsWindows.Size * 96); // ballpark reserve[m
[32m+[m[32m    for (int i = 0; i != g.SettingsWindows.Size; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        const ImGuiWindowSettings* settings = &g.SettingsWindows[i];[m
[32m+[m[32m        if (settings->Pos.x == FLT_MAX)[m
[32m+[m[32m            continue;[m
[32m+[m[32m        const char* name = settings->Name;[m
[32m+[m[32m        if (const char* p = strstr(name, "###"))  // Skip to the "###" marker if any. We don't skip past to match the behavior of GetID()[m
[32m+[m[32m            name = p;[m
[32m+[m[32m        buf->appendf("[%s][%s]\n", handler->TypeName, name);[m
[32m+[m[32m        buf->appendf("Pos=%d,%d\n", (int)settings->Pos.x, (int)settings->Pos.y);[m
[32m+[m[32m        buf->appendf("Size=%d,%d\n", (int)settings->Size.x, (int)settings->Size.y);[m
[32m+[m[32m        buf->appendf("Collapsed=%d\n", settings->Collapsed);[m
[32m+[m[32m        buf->appendf("\n");[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] VIEWPORTS, PLATFORM WINDOWS[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// (this section is filled in the 'docking' branch)[m
[32m+[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] DOCKING[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// (this section is filled in the 'docking' branch)[m
[32m+[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] PLATFORM DEPENDENT HELPERS[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m#if defined(_WIN32) && !defined(_WINDOWS_) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && (!defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS) || !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS))[m
[32m+[m[32m#ifndef WIN32_LEAN_AND_MEAN[m
[32m+[m[32m#define WIN32_LEAN_AND_MEAN[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifndef __MINGW32__[m
[32m+[m[32m#include <Windows.h>[m
[32m+[m[32m#else[m
[32m+[m[32m#include <windows.h>[m
[32m+[m[32m#endif[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Win32 API clipboard implementation[m
[32m+[m[32m#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)[m
[32m+[m
[32m+[m[32m#ifdef _MSC_VER[m
[32m+[m[32m#pragma comment(lib, "user32")[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32mstatic const char* GetClipboardTextFn_DefaultImpl(void*)[m
[32m+[m[32m{[m
[32m+[m[32m    static ImVector<char> buf_local;[m
[32m+[m[32m    buf_local.clear();[m
[32m+[m[32m    if (!::OpenClipboard(NULL))[m
[32m+[m[32m        return NULL;[m
[32m+[m[32m    HANDLE wbuf_handle = ::GetClipboardData(CF_UNICODETEXT);[m
[32m+[m[32m    if (wbuf_handle == NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        ::CloseClipboard();[m
[32m+[m[32m        return NULL;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (ImWchar* wbuf_global = (ImWchar*)::GlobalLock(wbuf_handle))[m
[32m+[m[32m    {[m
[32m+[m[32m        int buf_len = ImTextCountUtf8BytesFromStr(wbuf_global, NULL) + 1;[m
[32m+[m[32m        buf_local.resize(buf_len);[m
[32m+[m[32m        ImTextStrToUtf8(buf_local.Data, buf_len, wbuf_global, NULL);[m
[32m+[m[32m    }[m
[32m+[m[32m    ::GlobalUnlock(wbuf_handle);[m
[32m+[m[32m    ::CloseClipboard();[m
[32m+[m[32m    return buf_local.Data;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void SetClipboardTextFn_DefaultImpl(void*, const char* text)[m
[32m+[m[32m{[m
[32m+[m[32m    if (!::OpenClipboard(NULL))[m
[32m+[m[32m        return;[m
[32m+[m[32m    const int wbuf_length = ImTextCountCharsFromUtf8(text, NULL) + 1;[m
[32m+[m[32m    HGLOBAL wbuf_handle = ::GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)wbuf_length * sizeof(ImWchar));[m
[32m+[m[32m    if (wbuf_handle == NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        ::CloseClipboard();[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    ImWchar* wbuf_global = (ImWchar*)::GlobalLock(wbuf_handle);[m
[32m+[m[32m    ImTextStrFromUtf8(wbuf_global, wbuf_length, text, NULL);[m
[32m+[m[32m    ::GlobalUnlock(wbuf_handle);[m
[32m+[m[32m    ::EmptyClipboard();[m
[32m+[m[32m    if (::SetClipboardData(CF_UNICODETEXT, wbuf_handle) == NULL)[m
[32m+[m[32m        ::GlobalFree(wbuf_handle);[m
[32m+[m[32m    ::CloseClipboard();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#else[m
[32m+[m
[32m+[m[32m// Local ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers[m
[32m+[m[32mstatic const char* GetClipboardTextFn_DefaultImpl(void*)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.PrivateClipboard.empty() ? NULL : g.PrivateClipboard.begin();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Local ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers[m
[32m+[m[32mstatic void SetClipboardTextFn_DefaultImpl(void*, const char* text)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.PrivateClipboard.clear();[m
[32m+[m[32m    const char* text_end = text + strlen(text);[m
[32m+[m[32m    g.PrivateClipboard.resize((int)(text_end - text) + 1);[m
[32m+[m[32m    memcpy(&g.PrivateClipboard[0], text, (size_t)(text_end - text));[m
[32m+[m[32m    g.PrivateClipboard[(int)(text_end - text)] = 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Win32 API IME support (for Asian languages, etc.)[m
[32m+[m[32m#if defined(_WIN32) && !defined(__GNUC__) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)[m
[32m+[m
[32m+[m[32m#include <imm.h>[m
[32m+[m[32m#ifdef _MSC_VER[m
[32m+[m[32m#pragma comment(lib, "imm32")[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32mstatic void ImeSetInputScreenPosFn_DefaultImpl(int x, int y)[m
[32m+[m[32m{[m
[32m+[m[32m    // Notify OS Input Method Editor of text input position[m
[32m+[m[32m    if (HWND hwnd = (HWND)GImGui->IO.ImeWindowHandle)[m
[32m+[m[32m        if (HIMC himc = ::ImmGetContext(hwnd))[m
[32m+[m[32m        {[m
[32m+[m[32m            COMPOSITIONFORM cf;[m
[32m+[m[32m            cf.ptCurrentPos.x = x;[m
[32m+[m[32m            cf.ptCurrentPos.y = y;[m
[32m+[m[32m            cf.dwStyle = CFS_FORCE_POSITION;[m
[32m+[m[32m            ::ImmSetCompositionWindow(himc, &cf);[m
[32m+[m[32m            ::ImmReleaseContext(hwnd, himc);[m
[32m+[m[32m        }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#else[m
[32m+[m
[32m+[m[32mstatic void ImeSetInputScreenPosFn_DefaultImpl(int, int) {}[m
[32m+[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] METRICS/DEBUG WINDOW[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mvoid ImGui::ShowMetricsWindow(bool* p_open)[m
[32m+[m[32m{[m
[32m+[m[32m    if (!ImGui::Begin("ImGui Metrics", p_open))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::End();[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    enum { RT_OuterRect, RT_OuterRectClipped, RT_InnerMainRect, RT_InnerClipRect, RT_ContentsRegionRect, RT_ContentsFullRect };[m
[32m+[m[32m    static bool show_windows_begin_order = false;[m
[32m+[m[32m    static bool show_windows_rects = false;[m
[32m+[m[32m    static int  show_windows_rect_type = RT_ContentsRegionRect;[m
[32m+[m[32m    static bool show_drawcmd_clip_rects = true;[m
[32m+[m
[32m+[m[32m    ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m    ImGui::Text("Dear ImGui %s", ImGui::GetVersion());[m
[32m+[m[32m    ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);[m
[32m+[m[32m    ImGui::Text("%d vertices, %d indices (%d triangles)", io.MetricsRenderVertices, io.MetricsRenderIndices, io.MetricsRenderIndices / 3);[m
[32m+[m[32m    ImGui::Text("%d active windows (%d visible)", io.MetricsActiveWindows, io.MetricsRenderWindows);[m
[32m+[m[32m    ImGui::Text("%d active allocations", io.MetricsActiveAllocations);[m
[32m+[m[32m    ImGui::Separator();[m
[32m+[m
[32m+[m[32m    struct Funcs[m
[32m+[m[32m    {[m
[32m+[m[32m        static void NodeDrawList(ImGuiWindow* window, ImDrawList* draw_list, const char* label)[m
[32m+[m[32m        {[m
[32m+[m[32m            bool node_open = ImGui::TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label, draw_list->_OwnerName ? draw_list->_OwnerName : "", draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, draw_list->CmdBuffer.Size);[m
[32m+[m[32m            if (draw_list == ImGui::GetWindowDrawList())[m
[32m+[m[32m            {[m
[32m+[m[32m                ImGui::SameLine();[m
[32m+[m[32m                ImGui::TextColored(ImVec4(1.0f,0.4f,0.4f,1.0f), "CURRENTLY APPENDING"); // Can't display stats for active draw list! (we don't have the data double-buffered)[m
[32m+[m[32m                if (node_open) ImGui::TreePop();[m
[32m+[m[32m                return;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            ImDrawList* fg_draw_list = GetForegroundDrawList(window); // Render additional visuals into the top-most draw list[m
[32m+[m[32m            if (window && IsItemHovered())[m
[32m+[m[32m                fg_draw_list->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));[m
[32m+[m[32m            if (!node_open)[m
[32m+[m[32m                return;[m
[32m+[m
[32m+[m[32m            int elem_offset = 0;[m
[32m+[m[32m            for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (pcmd->UserCallback == NULL && pcmd->ElemCount == 0)[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                if (pcmd->UserCallback)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImGui::BulletText("Callback %p, user_data %p", pcmd->UserCallback, pcmd->UserCallbackData);[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                }[m
[32m+[m[32m                ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;[m
[32m+[m[32m                bool pcmd_node_open = ImGui::TreeNode((void*)(pcmd - draw_list->CmdBuffer.begin()), "Draw %4d %s vtx, tex 0x%p, clip_rect (%4.0f,%4.0f)-(%4.0f,%4.0f)", pcmd->ElemCount, draw_list->IdxBuffer.Size > 0 ? "indexed" : "non-indexed", pcmd->TextureId, pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);[m
[32m+[m[32m                if (show_drawcmd_clip_rects && fg_draw_list && ImGui::IsItemHovered())[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImRect clip_rect = pcmd->ClipRect;[m
[32m+[m[32m                    ImRect vtxs_rect;[m
[32m+[m[32m                    for (int i = elem_offset; i < elem_offset + (int)pcmd->ElemCount; i++)[m
[32m+[m[32m                        vtxs_rect.Add(draw_list->VtxBuffer[idx_buffer ? idx_buffer[i] : i].pos);[m
[32m+[m[32m                    clip_rect.Floor(); fg_draw_list->AddRect(clip_rect.Min, clip_rect.Max, IM_COL32(255,255,0,255));[m
[32m+[m[32m                    vtxs_rect.Floor(); fg_draw_list->AddRect(vtxs_rect.Min, vtxs_rect.Max, IM_COL32(255,0,255,255));[m
[32m+[m[32m                }[m
[32m+[m[32m                if (!pcmd_node_open)[m
[32m+[m[32m                    continue;[m
[32m+[m
[32m+[m[32m                // Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.[m
[32m+[m[32m                ImGuiListClipper clipper(pcmd->ElemCount/3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.[m
[32m+[m[32m                while (clipper.Step())[m
[32m+[m[32m                    for (int prim = clipper.DisplayStart, idx_i = elem_offset + clipper.DisplayStart*3; prim < clipper.DisplayEnd; prim++)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        char buf[300];[m
[32m+[m[32m                        char *buf_p = buf, *buf_end = buf + IM_ARRAYSIZE(buf);[m
[32m+[m[32m                        ImVec2 triangles_pos[3];[m
[32m+[m[32m                        for (int n = 0; n < 3; n++, idx_i++)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            int vtx_i = idx_buffer ? idx_buffer[idx_i] : idx_i;[m
[32m+[m[32m                            ImDrawVert& v = draw_list->VtxBuffer[vtx_i];[m
[32m+[m[32m                            triangles_pos[n] = v.pos;[m
[32m+[m[32m                            buf_p += ImFormatString(buf_p, buf_end - buf_p, "%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n",[m
[32m+[m[32m                                (n == 0) ? "idx" : "   ", idx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);[m
[32m+[m[32m                        }[m
[32m+[m[32m                        ImGui::Selectable(buf, false);[m
[32m+[m[32m                        if (fg_draw_list && ImGui::IsItemHovered())[m
[32m+[m[32m                        {[m
[32m+[m[32m                            ImDrawListFlags backup_flags = fg_draw_list->Flags;[m
[32m+[m[32m                            fg_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines at is more readable for very large and thin triangles.[m
[32m+[m[32m                            fg_draw_list->AddPolyline(triangles_pos, 3, IM_COL32(255,255,0,255), true, 1.0f);[m
[32m+[m[32m                            fg_draw_list->Flags = backup_flags;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                ImGui::TreePop();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        static void NodeColumns(const ImGuiColumns* columns)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (!ImGui::TreeNode((void*)(uintptr_t)columns->ID, "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", columns->ID, columns->Count, columns->Flags))[m
[32m+[m[32m                return;[m
[32m+[m[32m            ImGui::BulletText("Width: %.1f (MinX: %.1f, MaxX: %.1f)", columns->MaxX - columns->MinX, columns->MinX, columns->MaxX);[m
[32m+[m[32m            for (int column_n = 0; column_n < columns->Columns.Size; column_n++)[m
[32m+[m[32m                ImGui::BulletText("Column %02d: OffsetNorm %.3f (= %.1f px)", column_n, columns->Columns[column_n].OffsetNorm, OffsetNormToPixels(columns, columns->Columns[column_n].OffsetNorm));[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        static void NodeWindows(ImVector<ImGuiWindow*>& windows, const char* label)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (!ImGui::TreeNode(label, "%s (%d)", label, windows.Size))[m
[32m+[m[32m                return;[m
[32m+[m[32m            for (int i = 0; i < windows.Size; i++)[m
[32m+[m[32m                Funcs::NodeWindow(windows[i], "Window");[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        static void NodeWindow(ImGuiWindow* window, const char* label)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (!ImGui::TreeNode(window, "%s '%s', %d @ 0x%p", label, window->Name, window->Active || window->WasActive, window))[m
[32m+[m[32m                return;[m
[32m+[m[32m            ImGuiWindowFlags flags = window->Flags;[m
[32m+[m[32m            NodeDrawList(window, window->DrawList, "DrawList");[m
[32m+[m[32m            ImGui::BulletText("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), SizeContents (%.1f,%.1f)", window->Pos.x, window->Pos.y, window->Size.x, window->Size.y, window->SizeContents.x, window->SizeContents.y);[m
[32m+[m[32m            ImGui::BulletText("Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)", flags,[m
[32m+[m[32m                (flags & ImGuiWindowFlags_ChildWindow)  ? "Child " : "",      (flags & ImGuiWindowFlags_Tooltip)     ? "Tooltip "   : "",  (flags & ImGuiWindowFlags_Popup) ? "Popup " : "",[m
[32m+[m[32m                (flags & ImGuiWindowFlags_Modal)        ? "Modal " : "",      (flags & ImGuiWindowFlags_ChildMenu)   ? "ChildMenu " : "",  (flags & ImGuiWindowFlags_NoSavedSettings) ? "NoSavedSettings " : "",[m
[32m+[m[32m                (flags & ImGuiWindowFlags_NoMouseInputs)? "NoMouseInputs":"", (flags & ImGuiWindowFlags_NoNavInputs) ? "NoNavInputs" : "", (flags & ImGuiWindowFlags_AlwaysAutoResize) ? "AlwaysAutoResize" : "");[m
[32m+[m[32m            ImGui::BulletText("Scroll: (%.2f/%.2f,%.2f/%.2f)", window->Scroll.x, GetWindowScrollMaxX(window), window->Scroll.y, GetWindowScrollMaxY(window));[m
[32m+[m[32m            ImGui::BulletText("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d", window->Active, window->WasActive, window->WriteAccessed, (window->Active || window->WasActive) ? window->BeginOrderWithinContext : -1);[m
[32m+[m[32m            ImGui::BulletText("Appearing: %d, Hidden: %d (CanSkip %d Cannot %d), SkipItems: %d", window->Appearing, window->Hidden, window->HiddenFramesCanSkipItems, window->HiddenFramesCannotSkipItems, window->SkipItems);[m
[32m+[m[32m            ImGui::BulletText("NavLastIds: 0x%08X,0x%08X, NavLayerActiveMask: %X", window->NavLastIds[0], window->NavLastIds[1], window->DC.NavLayerActiveMask);[m
[32m+[m[32m            ImGui::BulletText("NavLastChildNavWindow: %s", window->NavLastChildNavWindow ? window->NavLastChildNavWindow->Name : "NULL");[m
[32m+[m[32m            if (!window->NavRectRel[0].IsInverted())[m
[32m+[m[32m                ImGui::BulletText("NavRectRel[0]: (%.1f,%.1f)(%.1f,%.1f)", window->NavRectRel[0].Min.x, window->NavRectRel[0].Min.y, window->NavRectRel[0].Max.x, window->NavRectRel[0].Max.y);[m
[32m+[m[32m            else[m
[32m+[m[32m                ImGui::BulletText("NavRectRel[0]: <None>");[m
[32m+[m[32m            if (window->RootWindow != window) NodeWindow(window->RootWindow, "RootWindow");[m
[32m+[m[32m            if (window->ParentWindow != NULL) NodeWindow(window->ParentWindow, "ParentWindow");[m
[32m+[m[32m            if (window->DC.ChildWindows.Size > 0) NodeWindows(window->DC.ChildWindows, "ChildWindows");[m
[32m+[m[32m            if (window->ColumnsStorage.Size > 0 && ImGui::TreeNode("Columns", "Columns sets (%d)", window->ColumnsStorage.Size))[m
[32m+[m[32m            {[m
[32m+[m[32m                for (int n = 0; n < window->ColumnsStorage.Size; n++)[m
[32m+[m[32m                    NodeColumns(&window->ColumnsStorage[n]);[m
[32m+[m[32m                ImGui::TreePop();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::BulletText("Storage: %d bytes", window->StateStorage.Data.Size * (int)sizeof(ImGuiStorage::Pair));[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        static void NodeTabBar(ImGuiTabBar* tab_bar)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Standalone tab bars (not associated to docking/windows functionality) currently hold no discernible strings.[m
[32m+[m[32m            char buf[256];[m
[32m+[m[32m            char* p = buf;[m
[32m+[m[32m            const char* buf_end = buf + IM_ARRAYSIZE(buf);[m
[32m+[m[32m            ImFormatString(p, buf_end - p, "TabBar (%d tabs)%s", tab_bar->Tabs.Size, (tab_bar->PrevFrameVisible < ImGui::GetFrameCount() - 2) ? " *Inactive*" : "");[m
[32m+[m[32m            if (ImGui::TreeNode(tab_bar, "%s", buf))[m
[32m+[m[32m            {[m
[32m+[m[32m                for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)[m
[32m+[m[32m                {[m
[32m+[m[32m                    const ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];[m
[32m+[m[32m                    ImGui::PushID(tab);[m
[32m+[m[32m                    if (ImGui::SmallButton("<")) { TabBarQueueChangeTabOrder(tab_bar, tab, -1); } ImGui::SameLine(0, 2);[m
[32m+[m[32m                    if (ImGui::SmallButton(">")) { TabBarQueueChangeTabOrder(tab_bar, tab, +1); } ImGui::SameLine();[m
[32m+[m[32m                    ImGui::Text("%02d%c Tab 0x%08X", tab_n, (tab->ID == tab_bar->SelectedTabId) ? '*' : ' ', tab->ID);[m
[32m+[m[32m                    ImGui::PopID();[m
[32m+[m[32m                }[m
[32m+[m[32m                ImGui::TreePop();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    // Access private state, we are going to display the draw lists from last frame[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    Funcs::NodeWindows(g.Windows, "Windows");[m
[32m+[m[32m    if (ImGui::TreeNode("DrawList", "Active DrawLists (%d)", g.DrawDataBuilder.Layers[0].Size))[m
[32m+[m[32m    {[m
[32m+[m[32m        for (int i = 0; i < g.DrawDataBuilder.Layers[0].Size; i++)[m
[32m+[m[32m            Funcs::NodeDrawList(NULL, g.DrawDataBuilder.Layers[0][i], "DrawList");[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Popups", "Popups (%d)", g.OpenPopupStack.Size))[m
[32m+[m[32m    {[m
[32m+[m[32m        for (int i = 0; i < g.OpenPopupStack.Size; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGuiWindow* window = g.OpenPopupStack[i].Window;[m
[32m+[m[32m            ImGui::BulletText("PopupID: %08x, Window: '%s'%s%s", g.OpenPopupStack[i].PopupId, window ? window->Name : "NULL", window && (window->Flags & ImGuiWindowFlags_ChildWindow) ? " ChildWindow" : "", window && (window->Flags & ImGuiWindowFlags_ChildMenu) ? " ChildMenu" : "");[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("TabBars", "Tab Bars (%d)", g.TabBars.Data.Size))[m
[32m+[m[32m    {[m
[32m+[m[32m        for (int n = 0; n < g.TabBars.Data.Size; n++)[m
[32m+[m[32m            Funcs::NodeTabBar(g.TabBars.GetByIndex(n));[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Internal state"))[m
[32m+[m[32m    {[m
[32m+[m[32m        const char* input_source_names[] = { "None", "Mouse", "Nav", "NavKeyboard", "NavGamepad" }; IM_ASSERT(IM_ARRAYSIZE(input_source_names) == ImGuiInputSource_COUNT);[m
[32m+[m[32m        ImGui::Text("HoveredWindow: '%s'", g.HoveredWindow ? g.HoveredWindow->Name : "NULL");[m
[32m+[m[32m        ImGui::Text("HoveredRootWindow: '%s'", g.HoveredRootWindow ? g.HoveredRootWindow->Name : "NULL");[m
[32m+[m[32m        ImGui::Text("HoveredId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d", g.HoveredId, g.HoveredIdPreviousFrame, g.HoveredIdTimer, g.HoveredIdAllowOverlap); // Data is "in-flight" so depending on when the Metrics window is called we may see current frame information or not[m
[32m+[m[32m        ImGui::Text("ActiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: %s", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, g.ActiveIdAllowOverlap, input_source_names[g.ActiveIdSource]);[m
[32m+[m[32m        ImGui::Text("ActiveIdWindow: '%s'", g.ActiveIdWindow ? g.ActiveIdWindow->Name : "NULL");[m
[32m+[m[32m        ImGui::Text("MovingWindow: '%s'", g.MovingWindow ? g.MovingWindow->Name : "NULL");[m
[32m+[m[32m        ImGui::Text("NavWindow: '%s'", g.NavWindow ? g.NavWindow->Name : "NULL");[m
[32m+[m[32m        ImGui::Text("NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer);[m
[32m+[m[32m        ImGui::Text("NavInputSource: %s", input_source_names[g.NavInputSource]);[m
[32m+[m[32m        ImGui::Text("NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible);[m
[32m+[m[32m        ImGui::Text("NavActivateId: 0x%08X, NavInputId: 0x%08X", g.NavActivateId, g.NavInputId);[m
[32m+[m[32m        ImGui::Text("NavDisableHighlight: %d, NavDisableMouseHover: %d", g.NavDisableHighlight, g.NavDisableMouseHover);[m
[32m+[m[32m        ImGui::Text("NavWindowingTarget: '%s'", g.NavWindowingTarget ? g.NavWindowingTarget->Name : "NULL");[m
[32m+[m[32m        ImGui::Text("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize);[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Tools"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::Checkbox("Show windows begin order", &show_windows_begin_order);[m
[32m+[m[32m        ImGui::Checkbox("Show windows rectangles", &show_windows_rects);[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m[32m        ImGui::SetNextItemWidth(ImGui::GetFontSize() * 12);[m
[32m+[m[32m        show_windows_rects |= ImGui::Combo("##rects_type", &show_windows_rect_type, "OuterRect\0" "OuterRectClipped\0" "InnerMainRect\0" "InnerClipRect\0" "ContentsRegionRect\0");[m
[32m+[m[32m        ImGui::Checkbox("Show clipping rectangle when hovering ImDrawCmd node", &show_drawcmd_clip_rects);[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (show_windows_rects || show_windows_begin_order)[m
[32m+[m[32m    {[m
[32m+[m[32m        for (int n = 0; n < g.Windows.Size; n++)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGuiWindow* window = g.Windows[n];[m
[32m+[m[32m            if (!window->WasActive)[m
[32m+[m[32m                continue;[m
[32m+[m[32m            ImDrawList* draw_list = GetForegroundDrawList(window);[m
[32m+[m[32m            if (show_windows_rects)[m
[32m+[m[32m            {[m
[32m+[m[32m                ImRect r;[m
[32m+[m[32m                if (show_windows_rect_type == RT_OuterRect)                 { r = window->Rect(); }[m
[32m+[m[32m                else if (show_windows_rect_type == RT_OuterRectClipped)     { r = window->OuterRectClipped; }[m
[32m+[m[32m                else if (show_windows_rect_type == RT_InnerMainRect)        { r = window->InnerMainRect; }[m
[32m+[m[32m                else if (show_windows_rect_type == RT_InnerClipRect)        { r = window->InnerClipRect; }[m
[32m+[m[32m                else if (show_windows_rect_type == RT_ContentsRegionRect)   { r = window->ContentsRegionRect; }[m
[32m+[m[32m                draw_list->AddRect(r.Min, r.Max, IM_COL32(255, 0, 128, 255));[m
[32m+[m[32m            }[m
[32m+[m[32m            if (show_windows_begin_order && !(window->Flags & ImGuiWindowFlags_ChildWindow))[m
[32m+[m[32m            {[m
[32m+[m[32m                char buf[32];[m
[32m+[m[32m                ImFormatString(buf, IM_ARRAYSIZE(buf), "%d", window->BeginOrderWithinContext);[m
[32m+[m[32m                float font_size = ImGui::GetFontSize();[m
[32m+[m[32m                draw_list->AddRectFilled(window->Pos, window->Pos + ImVec2(font_size, font_size), IM_COL32(200, 100, 100, 255));[m
[32m+[m[32m                draw_list->AddText(window->Pos, IM_COL32(255, 255, 255, 255), buf);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    ImGui::End();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Include imgui_user.inl at the end of imgui.cpp to access private data/functions that aren't exposed.[m
[32m+[m[32m// Prefer just including imgui_internal.h from your code rather than using this define. If a declaration is missing from imgui_internal.h add it or request it on the github.[m
[32m+[m[32m#ifdef IMGUI_INCLUDE_IMGUI_USER_INL[m
[32m+[m[32m#include "imgui_user.inl"[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[1mdiff --git a/vendor/source/ImGui/imgui.h b/vendor/source/ImGui/imgui.h[m
[1mnew file mode 100644[m
[1mindex 0000000..423ba3a[m
[1m--- /dev/null[m
[1m+++ b/vendor/source/ImGui/imgui.h[m
[36m@@ -0,0 +1,2190 @@[m
[32m+[m[32m// dear imgui, v1.70[m
[32m+[m[32m// (headers)[m
[32m+[m
[32m+[m[32m// See imgui.cpp file for documentation.[m
[32m+[m[32m// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.[m
[32m+[m[32m// Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.[m
[32m+[m[32m// Get latest version at https://github.com/ocornut/imgui[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m
[32m+[m[32mIndex of this file:[m
[32m+[m[32m// Header mess[m
[32m+[m[32m// Forward declarations and basic types[m
[32m+[m[32m// ImGui API (Dear ImGui end-user API)[m
[32m+[m[32m// Flags & Enumerations[m
[32m+[m[32m// Memory allocations macros[m
[32m+[m[32m// ImVector<>[m
[32m+[m[32m// ImGuiStyle[m
[32m+[m[32m// ImGuiIO[m
[32m+[m[32m// Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload)[m
[32m+[m[32m// Obsolete functions[m
[32m+[m[32m// Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, ImColor)[m
[32m+[m[32m// Draw List API (ImDrawCallback, ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListFlags, ImDrawList, ImDrawData)[m
[32m+[m[32m// Font API (ImFontConfig, ImFontGlyph, ImFontGlyphRangesBuilder, ImFontAtlasFlags, ImFontAtlas, ImFont)[m
[32m+[m
[32m+[m[32m*/[m
[32m+[m
[32m+[m[32m#pragma once[m
[32m+[m
[32m+[m[32m// Configuration file with compile-time options (edit imconfig.h or define IMGUI_USER_CONFIG to your own filename)[m
[32m+[m[32m#ifdef IMGUI_USER_CONFIG[m
[32m+[m[32m#include IMGUI_USER_CONFIG[m
[32m+[m[32m#endif[m
[32m+[m[32m#if !defined(IMGUI_DISABLE_INCLUDE_IMCONFIG_H) || defined(IMGUI_INCLUDE_IMCONFIG_H)[m
[32m+[m[32m#include "imconfig.h"[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Header mess[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m#include <float.h>                  // FLT_MAX[m
[32m+[m[32m#include <stdarg.h>                 // va_list[m
[32m+[m[32m#include <stddef.h>                 // ptrdiff_t, NULL[m
[32m+[m[32m#include <string.h>                 // memset, memmove, memcpy, strlen, strchr, strcpy, strcmp[m
[32m+[m
[32m+[m[32m// Version[m
[32m+[m[32m// (Integer encoded as XYYZZ for use in #if preprocessor conditionals. Work in progress versions typically starts at XYY99 then bounce up to XYY00, XYY01 etc. when release tagging happens)[m
[32m+[m[32m#define IMGUI_VERSION               "1.70"[m
[32m+[m[32m#define IMGUI_VERSION_NUM           17000[m
[32m+[m[32m#define IMGUI_CHECKVERSION()        ImGui::DebugCheckVersionAndDataLayout(IMGUI_VERSION, sizeof(ImGuiIO), sizeof(ImGuiStyle), sizeof(ImVec2), sizeof(ImVec4), sizeof(ImDrawVert), sizeof(ImDrawIdx))[m
[32m+[m
[32m+[m[32m// Define attributes of all API symbols declarations (e.g. for DLL under Windows)[m
[32m+[m[32m// IMGUI_API is used for core imgui functions, IMGUI_IMPL_API is used for the default bindings files (imgui_impl_xxx.h)[m
[32m+[m[32m#ifndef IMGUI_API[m
[32m+[m[32m#define IMGUI_API[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifndef IMGUI_IMPL_API[m
[32m+[m[32m#define IMGUI_IMPL_API              IMGUI_API[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Helper Macros[m
[32m+[m[32m#ifndef IM_ASSERT[m
[32m+[m[32m#include <assert.h>[m
[32m+[m[32m#define IM_ASSERT(_EXPR)            assert(_EXPR)                               // You can override the default assert handler by editing imconfig.h[m
[32m+[m[32m#endif[m
[32m+[m[32m#if defined(__clang__) || defined(__GNUC__)[m
[32m+[m[32m#define IM_FMTARGS(FMT)             __attribute__((format(printf, FMT, FMT+1))) // Apply printf-style warnings to user functions.[m
[32m+[m[32m#define IM_FMTLIST(FMT)             __attribute__((format(printf, FMT, 0)))[m
[32m+[m[32m#else[m
[32m+[m[32m#define IM_FMTARGS(FMT)[m
[32m+[m[32m#define IM_FMTLIST(FMT)[m
[32m+[m[32m#endif[m
[32m+[m[32m#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR)/sizeof(*_ARR)))         // Size of a static C-style array. Don't use on pointers![m
[32m+[m[32m#define IM_OFFSETOF(_TYPE,_MEMBER)  ((size_t)&(((_TYPE*)0)->_MEMBER))           // Offset of _MEMBER within _TYPE. Standardized as offsetof() in modern C++.[m
[32m+[m[32m#define IM_UNUSED(_VAR)             ((void)_VAR)                                // Used to silence "unused variable warnings". Often useful as asserts may be stripped out from final builds.[m
[32m+[m
[32m+[m[32m// Warnings[m
[32m+[m[32m#if defined(__clang__)[m
[32m+[m[32m#pragma clang diagnostic push[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wold-style-cast"[m
[32m+[m[32m#if __has_warning("-Wzero-as-null-pointer-constant")[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"[m
[32m+[m[32m#endif[m
[32m+[m[32m#elif defined(__GNUC__) && __GNUC__ >= 8[m
[32m+[m[32m#pragma GCC diagnostic push[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wclass-memaccess"[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Forward declarations and basic types[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mstruct ImDrawChannel;               // Temporary storage for ImDrawList ot output draw commands out of order, used by ImDrawList::ChannelsSplit()[m
[32m+[m[32mstruct ImDrawCmd;                   // A single draw command within a parent ImDrawList (generally maps to 1 GPU draw call, unless it is a callback)[m
[32m+[m[32mstruct ImDrawData;                  // All draw command lists required to render the frame + pos/size coordinates to use for the projection matrix.[m
[32m+[m[32mstruct ImDrawList;                  // A single draw command list (generally one per window, conceptually you may see this as a dynamic "mesh" builder)[m
[32m+[m[32mstruct ImDrawListSharedData;        // Data shared among multiple draw lists (typically owned by parent ImGui context, but you may create one yourself)[m
[32m+[m[32mstruct ImDrawVert;                  // A single vertex (pos + uv + col = 20 bytes by default. Override layout with IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT)[m
[32m+[m[32mstruct ImFont;                      // Runtime data for a single font within a parent ImFontAtlas[m
[32m+[m[32mstruct ImFontAtlas;                 // Runtime data for multiple fonts, bake multiple fonts into a single texture, TTF/OTF font loader[m
[32m+[m[32mstruct ImFontConfig;                // Configuration data when adding a font or merging fonts[m
[32m+[m[32mstruct ImFontGlyph;                 // A single font glyph (code point + coordinates within in ImFontAtlas + offset)[m
[32m+[m[32mstruct ImFontGlyphRangesBuilder;    // Helper to build glyph ranges from text/string data[m
[32m+[m[32mstruct ImColor;                     // Helper functions to create a color that can be converted to either u32 or float4 (*OBSOLETE* please avoid using)[m
[32m+[m[32mstruct ImGuiContext;                // Dear ImGui context (opaque structure, unless including imgui_internal.h)[m
[32m+[m[32mstruct ImGuiIO;                     // Main configuration and I/O between your application and ImGui[m
[32m+[m[32mstruct ImGuiInputTextCallbackData;  // Shared state of InputText() when using custom ImGuiInputTextCallback (rare/advanced use)[m
[32m+[m[32mstruct ImGuiListClipper;            // Helper to manually clip large list of items[m
[32m+[m[32mstruct ImGuiOnceUponAFrame;         // Helper for running a block of code not more than once a frame, used by IMGUI_ONCE_UPON_A_FRAME macro[m
[32m+[m[32mstruct ImGuiPayload;                // User data payload for drag and drop operations[m
[32m+[m[32mstruct ImGuiSizeCallbackData;       // Callback data when using SetNextWindowSizeConstraints() (rare/advanced use)[m
[32m+[m[32mstruct ImGuiStorage;                // Helper for key->value storage[m
[32m+[m[32mstruct ImGuiStyle;                  // Runtime data for styling/colors[m
[32m+[m[32mstruct ImGuiTextBuffer;             // Helper to hold and append into a text buffer (~string builder)[m
[32m+[m[32mstruct ImGuiTextFilter;             // Helper to parse and apply text filters (e.g. "aaaaa[,bbbb][,ccccc]")[m
[32m+[m
[32m+[m[32m// Typedefs and Enums/Flags (declared as int for compatibility with old C++, to allow using as flags and to not pollute the top of this file)[m
[32m+[m[32m// Use your programming IDE "Go to definition" facility on the names of the center columns to find the actual flags/enum lists.[m
[32m+[m[32m#ifndef ImTextureID[m
[32m+[m[32mtypedef void* ImTextureID;          // User data to identify a texture (this is whatever to you want it to be! read the FAQ about ImTextureID in imgui.cpp)[m
[32m+[m[32m#endif[m
[32m+[m[32mtypedef unsigned int ImGuiID;       // Unique ID used by widgets (typically hashed from a stack of string)[m
[32m+[m[32mtypedef unsigned short ImWchar;     // A single U16 character for keyboard input/display. We encode them as multi bytes UTF-8 when used in strings.[m
[32m+[m[32mtypedef int ImGuiCol;               // -> enum ImGuiCol_             // Enum: A color identifier for styling[m
[32m+[m[32mtypedef int ImGuiCond;              // -> enum ImGuiCond_            // Enum: A condition for Set*()[m
[32m+[m[32mtypedef int ImGuiDataType;          // -> enum ImGuiDataType_        // Enum: A primary data type[m
[32m+[m[32mtypedef int ImGuiDir;               // -> enum ImGuiDir_             // Enum: A cardinal direction[m
[32m+[m[32mtypedef int ImGuiKey;               // -> enum ImGuiKey_             // Enum: A key identifier (ImGui-side enum)[m
[32m+[m[32mtypedef int ImGuiNavInput;          // -> enum ImGuiNavInput_        // Enum: An input identifier for navigation[m
[32m+[m[32mtypedef int ImGuiMouseCursor;       // -> enum ImGuiMouseCursor_     // Enum: A mouse cursor identifier[m
[32m+[m[32mtypedef int ImGuiStyleVar;          // -> enum ImGuiStyleVar_        // Enum: A variable identifier for styling[m
[32m+[m[32mtypedef int ImDrawCornerFlags;      // -> enum ImDrawCornerFlags_    // Flags: for ImDrawList::AddRect*() etc.[m
[32m+[m[32mtypedef int ImDrawListFlags;        // -> enum ImDrawListFlags_      // Flags: for ImDrawList[m
[32m+[m[32mtypedef int ImFontAtlasFlags;       // -> enum ImFontAtlasFlags_     // Flags: for ImFontAtlas[m
[32m+[m[32mtypedef int ImGuiBackendFlags;      // -> enum ImGuiBackendFlags_    // Flags: for io.BackendFlags[m
[32m+[m[32mtypedef int ImGuiColorEditFlags;    // -> enum ImGuiColorEditFlags_  // Flags: for ColorEdit*(), ColorPicker*()[m
[32m+[m[32mtypedef int ImGuiColumnsFlags;      // -> enum ImGuiColumnsFlags_    // Flags: for Columns(), BeginColumns()[m
[32m+[m[32mtypedef int ImGuiConfigFlags;       // -> enum ImGuiConfigFlags_     // Flags: for io.ConfigFlags[m
[32m+[m[32mtypedef int ImGuiComboFlags;        // -> enum ImGuiComboFlags_      // Flags: for BeginCombo()[m
[32m+[m[32mtypedef int ImGuiDragDropFlags;     // -> enum ImGuiDragDropFlags_   // Flags: for *DragDrop*()[m
[32m+[m[32mtypedef int ImGuiFocusedFlags;      // -> enum ImGuiFocusedFlags_    // Flags: for IsWindowFocused()[m
[32m+[m[32mtypedef int ImGuiHoveredFlags;      // -> enum ImGuiHoveredFlags_    // Flags: for IsItemHovered(), IsWindowHovered() etc.[m
[32m+[m[32mtypedef int ImGuiInputTextFlags;    // -> enum ImGuiInputTextFlags_  // Flags: for InputText*()[m
[32m+[m[32mtypedef int ImGuiSelectableFlags;   // -> enum ImGuiSelectableFlags_ // Flags: for Selectable()[m
[32m+[m[32mtypedef int ImGuiTabBarFlags;       // -> enum ImGuiTabBarFlags_     // Flags: for BeginTabBar()[m
[32m+[m[32mtypedef int ImGuiTabItemFlags;      // -> enum ImGuiTabItemFlags_    // Flags: for BeginTabItem()[m
[32m+[m[32mtypedef int ImGuiTreeNodeFlags;     // -> enum ImGuiTreeNodeFlags_   // Flags: for TreeNode*(),CollapsingHeader()[m
[32m+[m[32mtypedef int ImGuiWindowFlags;       // -> enum ImGuiWindowFlags_     // Flags: for Begin*()[m
[32m+[m[32mtypedef int (*ImGuiInputTextCallback)(ImGuiInputTextCallbackData *data);[m
[32m+[m[32mtypedef void (*ImGuiSizeCallback)(ImGuiSizeCallbackData* data);[m
[32m+[m
[32m+[m[32m// Scalar data types[m
[32m+[m[32mtypedef signed char         ImS8;   // 8-bit signed integer == char[m
[32m+[m[32mtypedef unsigned char       ImU8;   // 8-bit unsigned integer[m
[32m+[m[32mtypedef signed short        ImS16;  // 16-bit signed integer[m
[32m+[m[32mtypedef unsigned short      ImU16;  // 16-bit unsigned integer[m
[32m+[m[32mtypedef signed int          ImS32;  // 32-bit signed integer == int[m
[32m+[m[32mtypedef unsigned int        ImU32;  // 32-bit unsigned integer (often used to store packed colors)[m
[32m+[m[32m#if defined(_MSC_VER) && !defined(__clang__)[m
[32m+[m[32mtypedef signed   __int64    ImS64;  // 64-bit signed integer (pre and post C++11 with Visual Studio)[m
[32m+[m[32mtypedef unsigned __int64    ImU64;  // 64-bit unsigned integer (pre and post C++11 with Visual Studio)[m
[32m+[m[32m#elif (defined(__clang__) || defined(__GNUC__)) && (__cplusplus < 201100)[m
[32m+[m[32m#include <stdint.h>[m
[32m+[m[32mtypedef int64_t             ImS64;  // 64-bit signed integer (pre C++11)[m
[32m+[m[32mtypedef uint64_t            ImU64;  // 64-bit unsigned integer (pre C++11)[m
[32m+[m[32m#else[m
[32m+[m[32mtypedef signed   long long  ImS64;  // 64-bit signed integer (post C++11)[m
[32m+[m[32mtypedef unsigned long long  ImU64;  // 64-bit unsigned integer (post C++11)[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// 2D vector (often used to store positions, sizes, etc.)[m
[32m+[m[32mstruct ImVec2[m
[32m+[m[32m{[m
[32m+[m[32m    float     x, y;[m
[32m+[m[32m    ImVec2()  { x = y = 0.0f; }[m
[32m+[m[32m    ImVec2(float _x, float _y) { x = _x; y = _y; }[m
[32m+[m[32m    float  operator[] (size_t idx) const { IM_ASSERT(idx <= 1); return (&x)[idx]; }    // We very rarely use this [] operator, the assert overhead is fine.[m
[32m+[m[32m    float& operator[] (size_t idx)       { IM_ASSERT(idx <= 1); return (&x)[idx]; }    // We very rarely use this [] operator, the assert overhead is fine.[m
[32m+[m[32m#ifdef IM_VEC2_CLASS_EXTRA[m
[32m+[m[32m    IM_VEC2_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec2.[m
[32m+[m[32m#endif[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// 4D vector (often used to store floating-point colors)[m
[32m+[m[32mstruct ImVec4[m
[32m+[m[32m{[m
[32m+[m[32m    float     x, y, z, w;[m
[32m+[m[32m    ImVec4()  { x = y = z = w = 0.0f; }[m
[32m+[m[32m    ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }[m
[32m+[m[32m#ifdef IM_VEC4_CLASS_EXTRA[m
[32m+[m[32m    IM_VEC4_CLASS_EXTRA     // Define additional constructors and implicit cast operators in imconfig.h to convert back and forth between your math types and ImVec4.[m
[32m+[m[32m#endif[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// ImGui: Dear ImGui end-user API[m
[32m+[m[32m// (Inside a namespace so you can add extra functions in your own separate file. Please don't modify imgui.cpp/.h!)[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mnamespace ImGui[m
[32m+[m[32m{[m
[32m+[m[32m    // Context creation and access[m
[32m+[m[32m    // Each context create its own ImFontAtlas by default. You may instance one yourself and pass it to CreateContext() to share a font atlas between imgui contexts.[m
[32m+[m[32m    // All those functions are not reliant on the current context.[m
[32m+[m[32m    IMGUI_API ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = NULL);[m
[32m+[m[32m    IMGUI_API void          DestroyContext(ImGuiContext* ctx = NULL);   // NULL = destroy current context[m
[32m+[m[32m    IMGUI_API ImGuiContext* GetCurrentContext();[m
[32m+[m[32m    IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);[m
[32m+[m[32m    IMGUI_API bool          DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert, size_t sz_drawidx);[m
[32m+[m
[32m+[m[32m    // Main[m
[32m+[m[32m    IMGUI_API ImGuiIO&      GetIO();                                    // access the IO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)[m
[32m+[m[32m    IMGUI_API ImGuiStyle&   GetStyle();                                 // access the Style structure (colors, sizes). Always use PushStyleCol(), PushStyleVar() to modify style mid-frame.[m
[32m+[m[32m    IMGUI_API void          NewFrame();                                 // start a new Dear ImGui frame, you can submit any command from this point until Render()/EndFrame().[m
[32m+[m[32m    IMGUI_API void          EndFrame();                                 // ends the Dear ImGui frame. automatically called by Render(), you likely don't need to call that yourself directly. If you don't need to render data (skipping rendering) you may call EndFrame() but you'll have wasted CPU already! If you don't need to render, better to not create any imgui windows and not call NewFrame() at all![m
[32m+[m[32m    IMGUI_API void          Render();                                   // ends the Dear ImGui frame, finalize the draw data. You can get call GetDrawData() to obtain it and run your rendering function. (Obsolete: this used to call io.RenderDrawListsFn(). Nowadays, we allow and prefer calling your render function yourself.)[m
[32m+[m[32m    IMGUI_API ImDrawData*   GetDrawData();                              // valid after Render() and until the next call to NewFrame(). this is what you have to render.[m
[32m+[m
[32m+[m[32m    // Demo, Debug, Information[m
[32m+[m[32m    IMGUI_API void          ShowDemoWindow(bool* p_open = NULL);        // create demo/test window (previously called ShowTestWindow). demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application![m
[32m+[m[32m    IMGUI_API void          ShowAboutWindow(bool* p_open = NULL);       // create about window. display Dear ImGui version, credits and build/system information.[m
[32m+[m[32m    IMGUI_API void          ShowMetricsWindow(bool* p_open = NULL);     // create metrics/debug window. display Dear ImGui internals: draw commands (with individual draw calls and vertices), window list, basic internal state, etc.[m
[32m+[m[32m    IMGUI_API void          ShowStyleEditor(ImGuiStyle* ref = NULL);    // add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)[m
[32m+[m[32m    IMGUI_API bool          ShowStyleSelector(const char* label);       // add style selector block (not a window), essentially a combo listing the default styles.[m
[32m+[m[32m    IMGUI_API void          ShowFontSelector(const char* label);        // add font selector block (not a window), essentially a combo listing the loaded fonts.[m
[32m+[m[32m    IMGUI_API void          ShowUserGuide();                            // add basic help/info block (not a window): how to manipulate ImGui as a end-user (mouse/keyboard controls).[m
[32m+[m[32m    IMGUI_API const char*   GetVersion();                               // get the compiled version string e.g. "1.23" (essentially the compiled value for IMGUI_VERSION)[m
[32m+[m
[32m+[m[32m    // Styles[m
[32m+[m[32m    IMGUI_API void          StyleColorsDark(ImGuiStyle* dst = NULL);    // new, recommended style (default)[m
[32m+[m[32m    IMGUI_API void          StyleColorsClassic(ImGuiStyle* dst = NULL); // classic imgui style[m
[32m+[m[32m    IMGUI_API void          StyleColorsLight(ImGuiStyle* dst = NULL);   // best used with borders and a custom, thicker font[m
[32m+[m
[32m+[m[32m    // Windows[m
[32m+[m[32m    // - Begin() = push window to the stack and start appending to it. End() = pop window from the stack.[m
[32m+[m[32m    // - You may append multiple times to the same window during the same frame.[m
[32m+[m[32m    // - Passing 'bool* p_open != NULL' shows a window-closing widget in the upper-right corner of the window,[m
[32m+[m[32m    //   which clicking will set the boolean to false when clicked.[m
[32m+[m[32m    // - Begin() return false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting[m
[32m+[m[32m    //   anything to the window. Always call a matching End() for each Begin() call, regardless of its return value![m
[32m+[m[32m    //   [this is due to legacy reason and is inconsistent with most other functions such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc.[m
[32m+[m[32m    //    where the EndXXX call should only be called if the corresponding BeginXXX function returned true.][m
[32m+[m[32m    // - Note that the bottom of window stack always contains a window called "Debug".[m
[32m+[m[32m    IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);[m
[32m+[m[32m    IMGUI_API void          End();[m
[32m+[m
[32m+[m[32m    // Child Windows[m
[32m+[m[32m    // - Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window. Child windows can embed their own child.[m
[32m+[m[32m    // - For each independent axis of 'size': ==0.0f: use remaining host window size / >0.0f: fixed size / <0.0f: use remaining window size minus abs(size) / Each axis can use a different mode, e.g. ImVec2(0,400).[m
[32m+[m[32m    // - BeginChild() returns false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting anything to the window.[m
[32m+[m[32m    //   Always call a matching EndChild() for each BeginChild() call, regardless of its return value [this is due to legacy reason and is inconsistent with most other functions such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding BeginXXX function returned true.][m
[32m+[m[32m    IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags flags = 0);[m
[32m+[m[32m    IMGUI_API void          EndChild();[m
[32m+[m
[32m+[m[32m    // Windows Utilities[m
[32m+[m[32m    // - "current window" = the window we are appending into while inside a Begin()/End() block. "next window" = next window we will Begin() into.[m
[32m+[m[32m    IMGUI_API bool          IsWindowAppearing();[m
[32m+[m[32m    IMGUI_API bool          IsWindowCollapsed();[m
[32m+[m[32m    IMGUI_API bool          IsWindowFocused(ImGuiFocusedFlags flags=0); // is current window focused? or its root/child, depending on flags. see flags for options.[m
[32m+[m[32m    IMGUI_API bool          IsWindowHovered(ImGuiHoveredFlags flags=0); // is current window hovered (and typically: not blocked by a popup/modal)? see flags for options. NB: If you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that! Please read the FAQ![m
[32m+[m[32m    IMGUI_API ImDrawList*   GetWindowDrawList();                        // get draw list associated to the current window, to append your own drawing primitives[m
[32m+[m[32m    IMGUI_API ImVec2        GetWindowPos();                             // get current window position in screen space (useful if you want to do your own drawing via the DrawList API)[m
[32m+[m[32m    IMGUI_API ImVec2        GetWindowSize();                            // get current window size[m
[32m+[m[32m    IMGUI_API float         GetWindowWidth();                           // get current window width (shortcut for GetWindowSize().x)[m
[32m+[m[32m    IMGUI_API float         GetWindowHeight();                          // get current window height (shortcut for GetWindowSize().y)[m
[32m+[m
[32m+[m[32m    // Prefer using SetNextXXX functions (before Begin) rather that SetXXX functions (after Begin).[m
[32m+[m[32m    IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiCond cond = 0, const ImVec2& pivot = ImVec2(0,0)); // set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.[m
[32m+[m[32m    IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiCond cond = 0);                  // set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()[m
[32m+[m[32m    IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback = NULL, void* custom_callback_data = NULL); // set next window size limits. use -1,-1 on either X/Y axis to preserve the current size. Sizes will be rounded down. Use callback to apply non-trivial programmatic constraints.[m
[32m+[m[32m    IMGUI_API void          SetNextWindowContentSize(const ImVec2& size);                               // set next window content size (~ enforce the range of scrollbars). not including window decorations (title bar, menu bar, etc.). set an axis to 0.0f to leave it automatic. call before Begin()[m
[32m+[m[32m    IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                 // set next window collapsed state. call before Begin()[m
[32m+[m[32m    IMGUI_API void          SetNextWindowFocus();                                                       // set next window to be focused / front-most. call before Begin()[m
[32m+[m[32m    IMGUI_API void          SetNextWindowBgAlpha(float alpha);                                          // set next window background color alpha. helper to easily modify ImGuiCol_WindowBg/ChildBg/PopupBg. you may also use ImGuiWindowFlags_NoBackground.[m
[32m+[m[32m    IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiCond cond = 0);                        // (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.[m
[32m+[m[32m    IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiCond cond = 0);                      // (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0,0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.[m
[32m+[m[32m    IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                     // (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().[m
[32m+[m[32m    IMGUI_API void          SetWindowFocus();                                                           // (not recommended) set current window to be focused / front-most. prefer using SetNextWindowFocus().[m
[32m+[m[32m    IMGUI_API void          SetWindowFontScale(float scale);                                            // set font scale. Adjust IO.FontGlobalScale if you want to scale all windows[m
[32m+[m[32m    IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond = 0);      // set named window position.[m
[32m+[m[32m    IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond = 0);    // set named window size. set axis to 0.0f to force an auto-fit on this axis.[m
[32m+[m[32m    IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond = 0);   // set named window collapsed state[m
[32m+[m[32m    IMGUI_API void          SetWindowFocus(const char* name);                                           // set named window to be focused / front-most. use NULL to remove focus.[m
[32m+[m
[32m+[m[32m    // Content region[m
[32m+[m[32m    // - Those functions are bound to be redesigned soon (they are confusing, incomplete and return values in local window coordinates which increases confusion)[m
[32m+[m[32m    IMGUI_API ImVec2        GetContentRegionMax();                                          // current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates[m
[32m+[m[32m    IMGUI_API ImVec2        GetContentRegionAvail();                                        // == GetContentRegionMax() - GetCursorPos()[m
[32m+[m[32m    IMGUI_API ImVec2        GetWindowContentRegionMin();                                    // content boundaries min (roughly (0,0)-Scroll), in window coordinates[m
[32m+[m[32m    IMGUI_API ImVec2        GetWindowContentRegionMax();                                    // content boundaries max (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates[m
[32m+[m[32m    IMGUI_API float         GetWindowContentRegionWidth();                                  //[m
[32m+[m
[32m+[m[32m    // Windows Scrolling[m
[32m+[m[32m    IMGUI_API float         GetScrollX();                                                   // get scrolling amount [0..GetScrollMaxX()][m
[32m+[m[32m    IMGUI_API float         GetScrollY();                                                   // get scrolling amount [0..GetScrollMaxY()][m
[32m+[m[32m    IMGUI_API float         GetScrollMaxX();                                                // get maximum scrolling amount ~~ ContentSize.X - WindowSize.X[m
[32m+[m[32m    IMGUI_API float         GetScrollMaxY();                                                // get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y[m
[32m+[m[32m    IMGUI_API void          SetScrollX(float scroll_x);                                     // set scrolling amount [0..GetScrollMaxX()][m
[32m+[m[32m    IMGUI_API void          SetScrollY(float scroll_y);                                     // set scrolling amount [0..GetScrollMaxY()][m
[32m+[m[32m    IMGUI_API void          SetScrollHereY(float center_y_ratio = 0.5f);                    // adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.[m
[32m+[m[32m    IMGUI_API void          SetScrollFromPosY(float local_y, float center_y_ratio = 0.5f);  // adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.[m
[32m+[m
[32m+[m[32m    // Parameters stacks (shared)[m
[32m+[m[32m    IMGUI_API void          PushFont(ImFont* font);                                         // use NULL as a shortcut to push default font[m
[32m+[m[32m    IMGUI_API void          PopFont();[m
[32m+[m[32m    IMGUI_API void          PushStyleColor(ImGuiCol idx, ImU32 col);[m
[32m+[m[32m    IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);[m
[32m+[m[32m    IMGUI_API void          PopStyleColor(int count = 1);[m
[32m+[m[32m    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);[m
[32m+[m[32m    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);[m
[32m+[m[32m    IMGUI_API void          PopStyleVar(int count = 1);[m
[32m+[m[32m    IMGUI_API const ImVec4& GetStyleColorVec4(ImGuiCol idx);                                // retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwise use GetColorU32() to get style color with style alpha baked in.[m
[32m+[m[32m    IMGUI_API ImFont*       GetFont();                                                      // get current font[m
[32m+[m[32m    IMGUI_API float         GetFontSize();                                                  // get current font size (= height in pixels) of current font with current scale applied[m
[32m+[m[32m    IMGUI_API ImVec2        GetFontTexUvWhitePixel();                                       // get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API[m
[32m+[m[32m    IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);              // retrieve given style color with style alpha applied and optional extra alpha multiplier[m
[32m+[m[32m    IMGUI_API ImU32         GetColorU32(const ImVec4& col);                                 // retrieve given color with style alpha applied[m
[32m+[m[32m    IMGUI_API ImU32         GetColorU32(ImU32 col);                                         // retrieve given color with style alpha applied[m
[32m+[m
[32m+[m[32m    // Parameters stacks (current window)[m
[32m+[m[32m    IMGUI_API void          PushItemWidth(float item_width);                                // set width of items for common large "item+label" widgets. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side). 0.0f = default to ~2/3 of windows width,[m[41m [m
[32m+[m[32m    IMGUI_API void          PopItemWidth();[m
[32m+[m[32m    IMGUI_API void          SetNextItemWidth(float item_width);                             // set width of the _next_ common large "item+label" widget. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)[m
[32m+[m[32m    IMGUI_API float         CalcItemWidth();                                                // width of item given pushed settings and current cursor position[m
[32m+[m[32m    IMGUI_API void          PushTextWrapPos(float wrap_local_pos_x = 0.0f);                 // word-wrapping for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space[m
[32m+[m[32m    IMGUI_API void          PopTextWrapPos();[m
[32m+[m[32m    IMGUI_API void          PushAllowKeyboardFocus(bool allow_keyboard_focus);              // allow focusing using TAB/Shift-TAB, enabled by default but you can disable it for certain widgets[m
[32m+[m[32m    IMGUI_API void          PopAllowKeyboardFocus();[m
[32m+[m[32m    IMGUI_API void          PushButtonRepeat(bool repeat);                                  // in 'repeat' mode, Button*() functions return repeated true in a typematic manner (using io.KeyRepeatDelay/io.KeyRepeatRate setting). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame.[m
[32m+[m[32m    IMGUI_API void          PopButtonRepeat();[m
[32m+[m
[32m+[m[32m    // Cursor / Layout[m
[32m+[m[32m    // - By "cursor" we mean the current output position.[m
[32m+[m[32m    // - The typical widget behavior is to output themselves at the current cursor position, then move the cursor one line down.[m
[32m+[m[32m    IMGUI_API void          Separator();                                                    // separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.[m
[32m+[m[32m    IMGUI_API void          SameLine(float offset_from_start_x=0.0f, float spacing=-1.0f);  // call between widgets or groups to layout them horizontally. X position given in window coordinates.[m
[32m+[m[32m    IMGUI_API void          NewLine();                                                      // undo a SameLine() or force a new line when in an horizontal-layout context.[m
[32m+[m[32m    IMGUI_API void          Spacing();                                                      // add vertical spacing.[m
[32m+[m[32m    IMGUI_API void          Dummy(const ImVec2& size);                                      // add a dummy item of given size. unlike InvisibleButton(), Dummy() won't take the mouse click or be navigable into.[m
[32m+[m[32m    IMGUI_API void          Indent(float indent_w = 0.0f);                                  // move content position toward the right, by style.IndentSpacing or indent_w if != 0[m
[32m+[m[32m    IMGUI_API void          Unindent(float indent_w = 0.0f);                                // move content position back to the left, by style.IndentSpacing or indent_w if != 0[m
[32m+[m[32m    IMGUI_API void          BeginGroup();                                                   // lock horizontal starting position[m
[32m+[m[32m    IMGUI_API void          EndGroup();                                                     // unlock horizontal starting position + capture the whole group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)[m
[32m+[m[32m    IMGUI_API ImVec2        GetCursorPos();                                                 // cursor position in window coordinates (relative to window position)[m
[32m+[m[32m    IMGUI_API float         GetCursorPosX();                                                //   (some functions are using window-relative coordinates, such as: GetCursorPos, GetCursorStartPos, GetContentRegionMax, GetWindowContentRegion* etc.[m
[32m+[m[32m    IMGUI_API float         GetCursorPosY();                                                //    other functions such as GetCursorScreenPos or everything in ImDrawList::[m
[32m+[m[32m    IMGUI_API void          SetCursorPos(const ImVec2& local_pos);                          //    are using the main, absolute coordinate system.[m
[32m+[m[32m    IMGUI_API void          SetCursorPosX(float local_x);                                   //    GetWindowPos() + GetCursorPos() == GetCursorScreenPos() etc.)[m
[32m+[m[32m    IMGUI_API void          SetCursorPosY(float local_y);                                   //[m
[32m+[m[32m    IMGUI_API ImVec2        GetCursorStartPos();                                            // initial cursor position in window coordinates[m
[32m+[m[32m    IMGUI_API ImVec2        GetCursorScreenPos();                                           // cursor position in absolute screen coordinates [0..io.DisplaySize] (useful to work with ImDrawList API)[m
[32m+[m[32m    IMGUI_API void          SetCursorScreenPos(const ImVec2& pos);                          // cursor position in absolute screen coordinates [0..io.DisplaySize][m
[32m+[m[32m    IMGUI_API void          AlignTextToFramePadding();                                      // vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item)[m
[32m+[m[32m    IMGUI_API float         GetTextLineHeight();                                            // ~ FontSize[m
[32m+[m[32m    IMGUI_API float         GetTextLineHeightWithSpacing();                                 // ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)[m
[32m+[m[32m    IMGUI_API float         GetFrameHeight();                                               // ~ FontSize + style.FramePadding.y * 2[m
[32m+[m[32m    IMGUI_API float         GetFrameHeightWithSpacing();                                    // ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)[m
[32m+[m
[32m+[m[32m    // ID stack/scopes[m
[32m+[m[32m    // - Read the FAQ for more details about how ID are handled in dear imgui. If you are creating widgets in a loop you most[m
[32m+[m[32m    //   likely want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.[m
[32m+[m[32m    // - The resulting ID are hashes of the entire stack.[m
[32m+[m[32m    // - You can also use the "Label##foobar" syntax within widget label to distinguish them from each others.[m
[32m+[m[32m    // - In this header file we use the "label"/"name" terminology to denote a string that will be displayed and used as an ID,[m
[32m+[m[32m    //   whereas "str_id" denote a string that is only used as an ID and not normally displayed.[m
[32m+[m[32m    IMGUI_API void          PushID(const char* str_id);                                     // push string into the ID stack (will hash string).[m
[32m+[m[32m    IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);       // push string into the ID stack (will hash string).[m
[32m+[m[32m    IMGUI_API void          PushID(const void* ptr_id);                                     // push pointer into the ID stack (will hash pointer).[m
[32m+[m[32m    IMGUI_API void          PushID(int int_id);                                             // push integer into the ID stack (will hash integer).[m
[32m+[m[32m    IMGUI_API void          PopID();                                                        // pop from the ID stack.[m
[32m+[m[32m    IMGUI_API ImGuiID       GetID(const char* str_id);                                      // calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself[m
[32m+[m[32m    IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);[m
[32m+[m[32m    IMGUI_API ImGuiID       GetID(const void* ptr_id);[m
[32m+[m
[32m+[m[32m    // Widgets: Text[m
[32m+[m[32m    IMGUI_API void          TextUnformatted(const char* text, const char* text_end = NULL);                // raw text without formatting. Roughly equivalent to Text("%s", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text.[m
[32m+[m[32m    IMGUI_API void          Text(const char* fmt, ...)                                      IM_FMTARGS(1); // simple formatted text[m
[32m+[m[32m    IMGUI_API void          TextV(const char* fmt, va_list args)                            IM_FMTLIST(1);[m
[32m+[m[32m    IMGUI_API void          TextColored(const ImVec4& col, const char* fmt, ...)            IM_FMTARGS(2); // shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();[m
[32m+[m[32m    IMGUI_API void          TextColoredV(const ImVec4& col, const char* fmt, va_list args)  IM_FMTLIST(2);[m
[32m+[m[32m    IMGUI_API void          TextDisabled(const char* fmt, ...)                              IM_FMTARGS(1); // shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();[m
[32m+[m[32m    IMGUI_API void          TextDisabledV(const char* fmt, va_list args)                    IM_FMTLIST(1);[m
[32m+[m[32m    IMGUI_API void          TextWrapped(const char* fmt, ...)                               IM_FMTARGS(1); // shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().[m
[32m+[m[32m    IMGUI_API void          TextWrappedV(const char* fmt, va_list args)                     IM_FMTLIST(1);[m
[32m+[m[32m    IMGUI_API void          LabelText(const char* label, const char* fmt, ...)              IM_FMTARGS(2); // display text+label aligned the same way as value+label widgets[m
[32m+[m[32m    IMGUI_API void          LabelTextV(const char* label, const char* fmt, va_list args)    IM_FMTLIST(2);[m
[32m+[m[32m    IMGUI_API void          BulletText(const char* fmt, ...)                                IM_FMTARGS(1); // shortcut for Bullet()+Text()[m
[32m+[m[32m    IMGUI_API void          BulletTextV(const char* fmt, va_list args)                      IM_FMTLIST(1);[m
[32m+[m
[32m+[m[32m    // Widgets: Main[m
[32m+[m[32m    // - Most widgets return true when the value has been changed or when pressed/selected[m
[32m+[m[32m    IMGUI_API bool          Button(const char* label, const ImVec2& size = ImVec2(0,0));    // button[m
[32m+[m[32m    IMGUI_API bool          SmallButton(const char* label);                                 // button with FramePadding=(0,0) to easily embed within text[m
[32m+[m[32m    IMGUI_API bool          InvisibleButton(const char* str_id, const ImVec2& size);        // button behavior without the visuals, frequently useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.)[m
[32m+[m[32m    IMGUI_API bool          ArrowButton(const char* str_id, ImGuiDir dir);                  // square button with an arrow shape[m
[32m+[m[32m    IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));[m
[32m+[m[32m    IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));    // <0 frame_padding uses default frame padding settings. 0 for no padding[m
[32m+[m[32m    IMGUI_API bool          Checkbox(const char* label, bool* v);[m
[32m+[m[32m    IMGUI_API bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);[m
[32m+[m[32m    IMGUI_API bool          RadioButton(const char* label, bool active);                    // use with e.g. if (RadioButton("one", my_value==1)) { my_value = 1; }[m
[32m+[m[32m    IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);           // shortcut to handle the above pattern when value is an integer[m
[32m+[m[32m    IMGUI_API void          ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1,0), const char* overlay = NULL);[m
[32m+[m[32m    IMGUI_API void          Bullet();                                                       // draw a small circle and keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses[m
[32m+[m
[32m+[m[32m    // Widgets: Combo Box[m
[32m+[m[32m    // - The new BeginCombo()/EndCombo() api allows you to manage your contents and selection state however you want it, by creating e.g. Selectable() items.[m
[32m+[m[32m    // - The old Combo() api are helpers over BeginCombo()/EndCombo() which are kept available for convenience purpose.[m
[32m+[m[32m    IMGUI_API bool          BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags = 0);[m
[32m+[m[32m    IMGUI_API void          EndCombo(); // only call EndCombo() if BeginCombo() returns true![m
[32m+[m[32m    IMGUI_API bool          Combo(const char* label, int* current_item, const char* const items[], int items_count, int popup_max_height_in_items = -1);[m
[32m+[m[32m    IMGUI_API bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1);      // Separate items with \0 within a string, end item-list with \0\0. e.g. "One\0Two\0Three\0"[m
[32m+[m[32m    IMGUI_API bool          Combo(const char* label, int* current_item, bool(*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int popup_max_height_in_items = -1);[m
[32m+[m
[32m+[m[32m    // Widgets: Drags[m
[32m+[m[32m    // - CTRL+Click on any drag box to turn them into an input box. Manually input values aren't clamped and can go off-bounds.[m
[32m+[m[32m    // - For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every functions, note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass address of your first element out of a contiguous set, e.g. &myvector.x[m
[32m+[m[32m    // - Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" -> 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.[m
[32m+[m[32m    // - Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to move by 5 pixels to increase value by 1). For gamepad/keyboard navigation, minimum speed is Max(v_speed, minimum_step_at_given_precision).[m
[32m+[m[32m    IMGUI_API bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);     // If v_min >= v_max we have no bound[m
[32m+[m[32m    IMGUI_API bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);[m
[32m+[m[32m    IMGUI_API bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);[m
[32m+[m[32m    IMGUI_API bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", float power = 1.0f);[m
[32m+[m[32m    IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", const char* format_max = NULL, float power = 1.0f);[m
[32m+[m[32m    IMGUI_API bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");                                       // If v_min >= v_max we have no bound[m
[32m+[m[32m    IMGUI_API bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");[m
[32m+[m[32m    IMGUI_API bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");[m
[32m+[m[32m    IMGUI_API bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d");[m
[32m+[m[32m    IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", const char* format_max = NULL);[m
[32m+[m[32m    IMGUI_API bool          DragScalar(const char* label, ImGuiDataType data_type, void* v, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f);[m
[32m+[m[32m    IMGUI_API bool          DragScalarN(const char* label, ImGuiDataType data_type, void* v, int components, float v_speed, const void* v_min = NULL, const void* v_max = NULL, const char* format = NULL, float power = 1.0f);[m
[32m+[m
[32m+[m[32m    // Widgets: Sliders[m
[32m+[m[32m    // - CTRL+Click on any slider to turn them into an input box. Manually input values aren't clamped and can go off-bounds.[m
[32m+[m[32m    // - Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" -> 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.[m
[32m+[m[32m    IMGUI_API bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);     // adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display. Use power!=1.0 for power curve sliders[m
[32m+[m[32m    IMGUI_API bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);[m
[32m+[m[32m    IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);[m
[32m+[m[32m    IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);[m
[32m+[m[32m    IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f, const char* format = "%.0f deg");[m
[32m+[m[32m    IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* format = "%d");[m
[32m+[m[32m    IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format = "%d");[m
[32m+[m[32m    IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format = "%d");[m
[32m+[m[32m    IMGUI_API bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format = "%d");[m
[32m+[m[32m    IMGUI_API bool          SliderScalar(const char* label, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);[m
[32m+[m[32m    IMGUI_API bool          SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);[m
[32m+[m[32m    IMGUI_API bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format = "%.3f", float power = 1.0f);[m
[32m+[m[32m    IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format = "%d");[m
[32m+[m[32m    IMGUI_API bool          VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format = NULL, float power = 1.0f);[m
[32m+[m
[32m+[m[32m    // Widgets: Input with Keyboard[m
[32m+[m[32m    // - If you want to use InputText() with a dynamic string type such as std::string or your own, see misc/cpp/imgui_stdlib.h[m
[32m+[m[32m    // - Most of the ImGuiInputTextFlags flags are only useful for InputText() and not for InputFloatX, InputIntX, InputDouble etc.[m
[32m+[m[32m    IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);[m
[32m+[m[32m    IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);[m
[32m+[m[32m    IMGUI_API bool          InputTextWithHint(const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);[m
[32m+[m[32m    IMGUI_API bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, const char* format = "%.3f", ImGuiInputTextFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          InputFloat2(const char* label, float v[2], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          InputFloat3(const char* label, float v[3], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          InputFloat4(const char* label, float v[4], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          InputDouble(const char* label, double* v, double step = 0.0, double step_fast = 0.0, const char* format = "%.6f", ImGuiInputTextFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          InputScalar(const char* label, ImGuiDataType data_type, void* v, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          InputScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* step = NULL, const void* step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags flags = 0);[m
[32m+[m
[32m+[m[32m    // Widgets: Color Editor/Picker (tip: the ColorEdit* functions have a little colored preview square that can be left-clicked to open a picker, and right-clicked to open an option menu.)[m
[32m+[m[32m    // - Note that in C++ a 'float v[X]' function argument is the _same_ as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible.[m
[32m+[m[32m    // - You can pass the address of a first float element out of a contiguous structure, e.g. &myvector.x[m
[32m+[m[32m    IMGUI_API bool          ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags = 0, const float* ref_col = NULL);[m
[32m+[m[32m    IMGUI_API bool          ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0));  // display a colored square/button, hover for details, return true when pressed.[m
[32m+[m[32m    IMGUI_API void          SetColorEditOptions(ImGuiColorEditFlags flags);                     // initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.[m
[32m+[m
[32m+[m[32m    // Widgets: Trees[m
[32m+[m[32m    // - TreeNode functions return true when the node is open, in which case you need to also call TreePop() when you are finished displaying the tree node contents.[m
[32m+[m[32m    IMGUI_API bool          TreeNode(const char* label);[m
[32m+[m[32m    IMGUI_API bool          TreeNode(const char* str_id, const char* fmt, ...) IM_FMTARGS(2);   // helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().[m
[32m+[m[32m    IMGUI_API bool          TreeNode(const void* ptr_id, const char* fmt, ...) IM_FMTARGS(2);   // "[m
[32m+[m[32m    IMGUI_API bool          TreeNodeV(const char* str_id, const char* fmt, va_list args) IM_FMTLIST(2);[m
[32m+[m[32m    IMGUI_API bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args) IM_FMTLIST(2);[m
[32m+[m[32m    IMGUI_API bool          TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);[m
[32m+[m[32m    IMGUI_API bool          TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);[m
[32m+[m[32m    IMGUI_API bool          TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);[m
[32m+[m[32m    IMGUI_API bool          TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);[m
[32m+[m[32m    IMGUI_API void          TreePush(const char* str_id);                                       // ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call TreePush/TreePop yourself if desired.[m
[32m+[m[32m    IMGUI_API void          TreePush(const void* ptr_id = NULL);                                // "[m
[32m+[m[32m    IMGUI_API void          TreePop();                                                          // ~ Unindent()+PopId()[m
[32m+[m[32m    IMGUI_API void          TreeAdvanceToLabelPos();                                            // advance cursor x position by GetTreeNodeToLabelSpacing()[m
[32m+[m[32m    IMGUI_API float         GetTreeNodeToLabelSpacing();                                        // horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode[m
[32m+[m[32m    IMGUI_API void          SetNextTreeNodeOpen(bool is_open, ImGuiCond cond = 0);              // set next TreeNode/CollapsingHeader open state.[m
[32m+[m[32m    IMGUI_API bool          CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);  // if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().[m
[32m+[m[32m    IMGUI_API bool          CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0); // when 'p_open' isn't NULL, display an additional small close button on upper right of the header[m
[32m+[m
[32m+[m[32m    // Widgets: Selectables[m
[32m+[m[32m    // - A selectable highlights when hovered, and can display another color when selected.[m
[32m+[m[32m    // - Neighbors selectable extend their highlight bounds in order to leave no gap between them.[m
[32m+[m[32m    IMGUI_API bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));  // "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height[m
[32m+[m[32m    IMGUI_API bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));       // "bool* p_selected" point to the selection state (read-write), as a convenient helper.[m
[32m+[m
[32m+[m[32m    // Widgets: List Boxes[m
[32m+[m[32m    // - FIXME: To be consistent with all the newer API, ListBoxHeader/ListBoxFooter should in reality be called BeginListBox/EndListBox. Will rename them.[m
[32m+[m[32m    IMGUI_API bool          ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items = -1);[m
[32m+[m[32m    IMGUI_API bool          ListBox(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);[m
[32m+[m[32m    IMGUI_API bool          ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0,0)); // use if you want to reimplement ListBox() will custom data or interactions. if the function return true, you can output elements then call ListBoxFooter() afterwards.[m
[32m+[m[32m    IMGUI_API bool          ListBoxHeader(const char* label, int items_count, int height_in_items = -1); // "[m
[32m+[m[32m    IMGUI_API void          ListBoxFooter();                                                    // terminate the scrolling region. only call ListBoxFooter() if ListBoxHeader() returned true![m
[32m+[m
[32m+[m[32m    // Widgets: Data Plotting[m
[32m+[m[32m    IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));[m
[32m+[m[32m    IMGUI_API void          PlotLines(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));[m
[32m+[m[32m    IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));[m
[32m+[m[32m    IMGUI_API void          PlotHistogram(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));[m
[32m+[m
[32m+[m[32m    // Widgets: Value() Helpers.[m
[32m+[m[32m    // - Those are merely shortcut to calling Text() with a format string. Output single value in "name: value" format (tip: freely declare more in your code to handle your types. you can add functions to the ImGui namespace)[m
[32m+[m[32m    IMGUI_API void          Value(const char* prefix, bool b);[m
[32m+[m[32m    IMGUI_API void          Value(const char* prefix, int v);[m
[32m+[m[32m    IMGUI_API void          Value(const char* prefix, unsigned int v);[m
[32m+[m[32m    IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);[m
[32m+[m
[32m+[m[32m    // Widgets: Menus[m
[32m+[m[32m    IMGUI_API bool          BeginMainMenuBar();                                                 // create and append to a full screen menu-bar.[m
[32m+[m[32m    IMGUI_API void          EndMainMenuBar();                                                   // only call EndMainMenuBar() if BeginMainMenuBar() returns true![m
[32m+[m[32m    IMGUI_API bool          BeginMenuBar();                                                     // append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window).[m
[32m+[m[32m    IMGUI_API void          EndMenuBar();                                                       // only call EndMenuBar() if BeginMenuBar() returns true![m
[32m+[m[32m    IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  // create a sub-menu entry. only call EndMenu() if this returns true![m
[32m+[m[32m    IMGUI_API void          EndMenu();                                                          // only call EndMenu() if BeginMenu() returns true![m
[32m+[m[32m    IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true);  // return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment[m
[32m+[m[32m    IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              // return true when activated + toggle (*p_selected) if p_selected != NULL[m
[32m+[m
[32m+[m[32m    // Tooltips[m
[32m+[m[32m    IMGUI_API void          BeginTooltip();                                                     // begin/append a tooltip window. to create full-featured tooltip (with any kind of items).[m
[32m+[m[32m    IMGUI_API void          EndTooltip();[m
[32m+[m[32m    IMGUI_API void          SetTooltip(const char* fmt, ...) IM_FMTARGS(1);                     // set a text-only tooltip, typically use with ImGui::IsItemHovered(). override any previous call to SetTooltip().[m
[32m+[m[32m    IMGUI_API void          SetTooltipV(const char* fmt, va_list args) IM_FMTLIST(1);[m
[32m+[m
[32m+[m[32m    // Popups, Modals[m
[32m+[m[32m    // The properties of popups windows are:[m
[32m+[m[32m    // - They block normal mouse hovering detection outside them. (*)[m
[32m+[m[32m    // - Unless modal, they can be closed by clicking anywhere outside them, or by pressing ESCAPE.[m
[32m+[m[32m    // - Their visibility state (~bool) is held internally by imgui instead of being held by the programmer as we are used to with regular Begin() calls.[m
[32m+[m[32m    //   User can manipulate the visibility state by calling OpenPopup().[m
[32m+[m[32m    // (*) One can use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup) to bypass it and detect hovering even when normally blocked by a popup.[m
[32m+[m[32m    // Those three properties are connected. The library needs to hold their visibility state because it can close popups at any time.[m
[32m+[m[32m    IMGUI_API void          OpenPopup(const char* str_id);                                      // call to mark popup as open (don't call every frame!). popups are closed when user click outside, or if CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block. By default, Selectable()/MenuItem() are calling CloseCurrentPopup(). Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).[m
[32m+[m[32m    IMGUI_API bool          BeginPopup(const char* str_id, ImGuiWindowFlags flags = 0);                                             // return true if the popup is open, and you can start outputting to it. only call EndPopup() if BeginPopup() returns true![m
[32m+[m[32m    IMGUI_API bool          BeginPopupContextItem(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked on last item. if you can pass a NULL str_id only if the previous item had an id. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp![m
[32m+[m[32m    IMGUI_API bool          BeginPopupContextWindow(const char* str_id = NULL, int mouse_button = 1, bool also_over_items = true);  // helper to open and begin popup when clicked on current window.[m
[32m+[m[32m    IMGUI_API bool          BeginPopupContextVoid(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked in void (where there are no imgui windows).[m
[32m+[m[32m    IMGUI_API bool          BeginPopupModal(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);                     // modal dialog (regular window with title bar, block interactions behind the modal window, can't close the modal window by clicking outside)[m
[32m+[m[32m    IMGUI_API void          EndPopup();                                                                                             // only call EndPopup() if BeginPopupXXX() returns true![m
[32m+[m[32m    IMGUI_API bool          OpenPopupOnItemClick(const char* str_id = NULL, int mouse_button = 1);                                  // helper to open popup when clicked on last item (note: actually triggers on the mouse _released_ event to be consistent with popup behaviors). return true when just opened.[m
[32m+[m[32m    IMGUI_API bool          IsPopupOpen(const char* str_id);                                    // return true if the popup is open at the current begin-ed level of the popup stack.[m
[32m+[m[32m    IMGUI_API void          CloseCurrentPopup();                                                // close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup.[m
[32m+[m
[32m+[m[32m    // Columns[m
[32m+[m[32m    // - You can also use SameLine(pos_x) to mimic simplified columns.[m
[32m+[m[32m    // - The columns API is work-in-progress and rather lacking (columns are arguably the worst part of dear imgui at the moment!)[m
[32m+[m[32m    IMGUI_API void          Columns(int count = 1, const char* id = NULL, bool border = true);[m
[32m+[m[32m    IMGUI_API void          NextColumn();                                                       // next column, defaults to current row or next row if the current row is finished[m
[32m+[m[32m    IMGUI_API int           GetColumnIndex();                                                   // get current column index[m
[32m+[m[32m    IMGUI_API float         GetColumnWidth(int column_index = -1);                              // get column width (in pixels). pass -1 to use current column[m
[32m+[m[32m    IMGUI_API void          SetColumnWidth(int column_index, float width);                      // set column width (in pixels). pass -1 to use current column[m
[32m+[m[32m    IMGUI_API float         GetColumnOffset(int column_index = -1);                             // get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f[m
[32m+[m[32m    IMGUI_API void          SetColumnOffset(int column_index, float offset_x);                  // set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column[m
[32m+[m[32m    IMGUI_API int           GetColumnsCount();[m
[32m+[m
[32m+[m[32m    // Tab Bars, Tabs[m
[32m+[m[32m    // [BETA API] API may evolve![m
[32m+[m[32m    IMGUI_API bool          BeginTabBar(const char* str_id, ImGuiTabBarFlags flags = 0);        // create and append into a TabBar[m
[32m+[m[32m    IMGUI_API void          EndTabBar();                                                        // only call EndTabBar() if BeginTabBar() returns true![m
[32m+[m[32m    IMGUI_API bool          BeginTabItem(const char* label, bool* p_open = NULL, ImGuiTabItemFlags flags = 0);// create a Tab. Returns true if the Tab is selected.[m
[32m+[m[32m    IMGUI_API void          EndTabItem();                                                       // only call EndTabItem() if BeginTabItem() returns true![m
[32m+[m[32m    IMGUI_API void          SetTabItemClosed(const char* tab_or_docked_window_label);           // notify TabBar or Docking system of a closed tab/window ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name.[m
[32m+[m
[32m+[m[32m    // Logging/Capture[m
[32m+[m[32m    // - All text output from the interface can be captured into tty/file/clipboard. By default, tree nodes are automatically opened during logging.[m
[32m+[m[32m    IMGUI_API void          LogToTTY(int auto_open_depth = -1);                                 // start logging to tty (stdout)[m
[32m+[m[32m    IMGUI_API void          LogToFile(int auto_open_depth = -1, const char* filename = NULL);   // start logging to file[m
[32m+[m[32m    IMGUI_API void          LogToClipboard(int auto_open_depth = -1);                           // start logging to OS clipboard[m
[32m+[m[32m    IMGUI_API void          LogFinish();                                                        // stop logging (close file, etc.)[m
[32m+[m[32m    IMGUI_API void          LogButtons();                                                       // helper to display buttons for logging to tty/file/clipboard[m
[32m+[m[32m    IMGUI_API void          LogText(const char* fmt, ...) IM_FMTARGS(1);                        // pass text data straight to log (without being displayed)[m
[32m+[m
[32m+[m[32m    // Drag and Drop[m
[32m+[m[32m    // [BETA API] API may evolve![m
[32m+[m[32m    IMGUI_API bool          BeginDragDropSource(ImGuiDragDropFlags flags = 0);                                      // call when the current item is active. If this return true, you can call SetDragDropPayload() + EndDragDropSource()[m
[32m+[m[32m    IMGUI_API bool          SetDragDropPayload(const char* type, const void* data, size_t sz, ImGuiCond cond = 0);  // type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui.[m
[32m+[m[32m    IMGUI_API void          EndDragDropSource();                                                                    // only call EndDragDropSource() if BeginDragDropSource() returns true![m
[32m+[m[32m    IMGUI_API bool                  BeginDragDropTarget();                                                          // call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()[m
[32m+[m[32m    IMGUI_API const ImGuiPayload*   AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);          // accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.[m
[32m+[m[32m    IMGUI_API void                  EndDragDropTarget();                                                            // only call EndDragDropTarget() if BeginDragDropTarget() returns true![m
[32m+[m[32m    IMGUI_API const ImGuiPayload*   GetDragDropPayload();                                                           // peek directly into the current payload from anywhere. may return NULL. use ImGuiPayload::IsDataType() to test for the payload type.[m
[32m+[m
[32m+[m[32m    // Clipping[m
[32m+[m[32m    IMGUI_API void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);[m
[32m+[m[32m    IMGUI_API void          PopClipRect();[m
[32m+[m
[32m+[m[32m    // Focus, Activation[m
[32m+[m[32m    // - Prefer using "SetItemDefaultFocus()" over "if (IsWindowAppearing()) SetScrollHereY()" when applicable to signify "this is the default item"[m
[32m+[m[32m    IMGUI_API void          SetItemDefaultFocus();                                              // make last item the default focused item of a window.[m
[32m+[m[32m    IMGUI_API void          SetKeyboardFocusHere(int offset = 0);                               // focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.[m
[32m+[m
[32m+[m[32m    // Item/Widgets Utilities[m
[32m+[m[32m    // - Most of the functions are referring to the last/previous item we submitted.[m
[32m+[m[32m    // - See Demo Window under "Widgets->Querying Status" for an interactive visualization of most of those functions.[m
[32m+[m[32m    IMGUI_API bool          IsItemHovered(ImGuiHoveredFlags flags = 0);                         // is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.[m
[32m+[m[32m    IMGUI_API bool          IsItemActive();                                                     // is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)[m
[32m+[m[32m    IMGUI_API bool          IsItemFocused();                                                    // is the last item focused for keyboard/gamepad navigation?[m
[32m+[m[32m    IMGUI_API bool          IsItemClicked(int mouse_button = 0);                                // is the last item clicked? (e.g. button/node just clicked on) == IsMouseClicked(mouse_button) && IsItemHovered()[m
[32m+[m[32m    IMGUI_API bool          IsItemVisible();                                                    // is the last item visible? (items may be out of sight because of clipping/scrolling)[m
[32m+[m[32m    IMGUI_API bool          IsItemEdited();                                                     // did the last item modify its underlying value this frame? or was pressed? This is generally the same as the "bool" return value of many widgets.[m
[32m+[m[32m    IMGUI_API bool          IsItemActivated();                                                  // was the last item just made active (item was previously inactive).[m
[32m+[m[32m    IMGUI_API bool          IsItemDeactivated();                                                // was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that requires continuous editing.[m
[32m+[m[32m    IMGUI_API bool          IsItemDeactivatedAfterEdit();                                       // was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that requires continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item).[m
[32m+[m[32m    IMGUI_API bool          IsAnyItemHovered();                                                 // is any item hovered?[m
[32m+[m[32m    IMGUI_API bool          IsAnyItemActive();                                                  // is any item active?[m
[32m+[m[32m    IMGUI_API bool          IsAnyItemFocused();                                                 // is any item focused?[m
[32m+[m[32m    IMGUI_API ImVec2        GetItemRectMin();                                                   // get upper-left bounding rectangle of the last item (screen space)[m
[32m+[m[32m    IMGUI_API ImVec2        GetItemRectMax();                                                   // get lower-right bounding rectangle of the last item (screen space)[m
[32m+[m[32m    IMGUI_API ImVec2        GetItemRectSize();                                                  // get size of last item[m
[32m+[m[32m    IMGUI_API void          SetItemAllowOverlap();                                              // allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area.[m
[32m+[m
[32m+[m[32m    // Miscellaneous Utilities[m
[32m+[m[32m    IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  // test if rectangle (of given size, starting from cursor position) is visible / not clipped.[m
[32m+[m[32m    IMGUI_API bool          IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);      // test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.[m
[32m+[m[32m    IMGUI_API double        GetTime();                                                          // get global imgui time. incremented by io.DeltaTime every frame.[m
[32m+[m[32m    IMGUI_API int           GetFrameCount();                                                    // get global imgui frame count. incremented by 1 every frame.[m
[32m+[m[32m    IMGUI_API ImDrawList*   GetBackgroundDrawList();                                            // this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.[m
[32m+[m[32m    IMGUI_API ImDrawList*   GetForegroundDrawList();                                            // this draw list will be the last rendered one. Useful to quickly draw shapes/text over dear imgui contents.[m
[32m+[m[32m    IMGUI_API ImDrawListSharedData* GetDrawListSharedData();                                    // you may use this when creating your own ImDrawList instances.[m
[32m+[m[32m    IMGUI_API const char*   GetStyleColorName(ImGuiCol idx);                                    // get a string corresponding to the enum value (for display, saving, etc.).[m
[32m+[m[32m    IMGUI_API void          SetStateStorage(ImGuiStorage* storage);                             // replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)[m
[32m+[m[32m    IMGUI_API ImGuiStorage* GetStateStorage();[m
[32m+[m[32m    IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);[m
[32m+[m[32m    IMGUI_API void          CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);    // calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can.[m
[32m+[m[32m    IMGUI_API bool          BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags flags = 0); // helper to create a child window / scrolling region that looks like a normal widget frame[m
[32m+[m[32m    IMGUI_API void          EndChildFrame();                                                    // always call EndChildFrame() regardless of BeginChildFrame() return values (which indicates a collapsed/clipped window)[m
[32m+[m
[32m+[m[32m    // Color Utilities[m
[32m+[m[32m    IMGUI_API ImVec4        ColorConvertU32ToFloat4(ImU32 in);[m
[32m+[m[32m    IMGUI_API ImU32         ColorConvertFloat4ToU32(const ImVec4& in);[m
[32m+[m[32m    IMGUI_API void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);[m
[32m+[m[32m    IMGUI_API void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);[m
[32m+[m
[32m+[m[32m    // Inputs Utilities[m
[32m+[m[32m    IMGUI_API int           GetKeyIndex(ImGuiKey imgui_key);                                    // map ImGuiKey_* values into user's key index. == io.KeyMap[key][m
[32m+[m[32m    IMGUI_API bool          IsKeyDown(int user_key_index);                                      // is key being held. == io.KeysDown[user_key_index]. note that imgui doesn't know the semantic of each entry of io.KeysDown[]. Use your own indices/enums according to how your backend/engine stored them into io.KeysDown[]![m
[32m+[m[32m    IMGUI_API bool          IsKeyPressed(int user_key_index, bool repeat = true);               // was key pressed (went from !Down to Down). if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate[m
[32m+[m[32m    IMGUI_API bool          IsKeyReleased(int user_key_index);                                  // was key released (went from Down to !Down)..[m
[32m+[m[32m    IMGUI_API int           GetKeyPressedAmount(int key_index, float repeat_delay, float rate); // uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate[m
[32m+[m[32m    IMGUI_API bool          IsMouseDown(int button);                                            // is mouse button held (0=left, 1=right, 2=middle)[m
[32m+[m[32m    IMGUI_API bool          IsAnyMouseDown();                                                   // is any mouse button held[m
[32m+[m[32m    IMGUI_API bool          IsMouseClicked(int button, bool repeat = false);                    // did mouse button clicked (went from !Down to Down) (0=left, 1=right, 2=middle)[m
[32m+[m[32m    IMGUI_API bool          IsMouseDoubleClicked(int button);                                   // did mouse button double-clicked. a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime.[m
[32m+[m[32m    IMGUI_API bool          IsMouseReleased(int button);                                        // did mouse button released (went from Down to !Down)[m
[32m+[m[32m    IMGUI_API bool          IsMouseDragging(int button = 0, float lock_threshold = -1.0f);      // is mouse dragging. if lock_threshold < -1.0f uses io.MouseDraggingThreshold[m
[32m+[m[32m    IMGUI_API bool          IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);  // is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focus/window ordering/popup-block.[m
[32m+[m[32m    IMGUI_API bool          IsMousePosValid(const ImVec2* mouse_pos = NULL);                    // by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse[m
[32m+[m[32m    IMGUI_API ImVec2        GetMousePos();                                                      // shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls[m
[32m+[m[32m    IMGUI_API ImVec2        GetMousePosOnOpeningCurrentPopup();                                 // retrieve backup of mouse position at the time of opening popup we have BeginPopup() into[m
[32m+[m[32m    IMGUI_API ImVec2        GetMouseDragDelta(int button = 0, float lock_threshold = -1.0f);    // return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once. If lock_threshold < -1.0f uses io.MouseDraggingThreshold.[m
[32m+[m[32m    IMGUI_API void          ResetMouseDragDelta(int button = 0);                                //[m
[32m+[m[32m    IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                // get desired cursor type, reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you[m
[32m+[m[32m    IMGUI_API void          SetMouseCursor(ImGuiMouseCursor type);                              // set desired cursor type[m
[32m+[m[32m    IMGUI_API void          CaptureKeyboardFromApp(bool want_capture_keyboard_value = true);    // attention: misleading name! manually override io.WantCaptureKeyboard flag next frame (said flag is entirely left for your application to handle). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting "io.WantCaptureKeyboard = want_capture_keyboard_value"; after the next NewFrame() call.[m
[32m+[m[32m    IMGUI_API void          CaptureMouseFromApp(bool want_capture_mouse_value = true);          // attention: misleading name! manually override io.WantCaptureMouse flag next frame (said flag is entirely left for your application to handle). This is equivalent to setting "io.WantCaptureMouse = want_capture_mouse_value;" after the next NewFrame() call.[m
[32m+[m
[32m+[m[32m    // Clipboard Utilities (also see the LogToClipboard() function to capture or output text data to the clipboard)[m
[32m+[m[32m    IMGUI_API const char*   GetClipboardText();[m
[32m+[m[32m    IMGUI_API void          SetClipboardText(const char* text);[m
[32m+[m
[32m+[m[32m    // Settings/.Ini Utilities[m
[32m+[m[32m    // - The disk functions are automatically called if io.IniFilename != NULL (default is "imgui.ini").[m
[32m+[m[32m    // - Set io.IniFilename to NULL to load/save manually. Read io.WantSaveIniSettings description about handling .ini saving manually.[m
[32m+[m[32m    IMGUI_API void          LoadIniSettingsFromDisk(const char* ini_filename);                  // call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).[m
[32m+[m[32m    IMGUI_API void          LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size=0); // call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.[m
[32m+[m[32m    IMGUI_API void          SaveIniSettingsToDisk(const char* ini_filename);                    // this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext).[m
[32m+[m[32m    IMGUI_API const char*   SaveIniSettingsToMemory(size_t* out_ini_size = NULL);               // return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.[m
[32m+[m
[32m+[m[32m    // Memory Allocators[m
[32m+[m[32m    // - All those functions are not reliant on the current context.[m
[32m+[m[32m    // - If you reload the contents of imgui.cpp at runtime, you may need to call SetCurrentContext() + SetAllocatorFunctions() again because we use global storage for those.[m
[32m+[m[32m    IMGUI_API void          SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void (*free_func)(void* ptr, void* user_data), void* user_data = NULL);[m
[32m+[m[32m    IMGUI_API void*         MemAlloc(size_t size);[m
[32m+[m[32m    IMGUI_API void          MemFree(void* ptr);[m
[32m+[m
[32m+[m[32m} // namespace ImGui[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Flags & Enumerations[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Flags for ImGui::Begin()[m
[32m+[m[32menum ImGuiWindowFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindowFlags_None                   = 0,[m
[32m+[m[32m    ImGuiWindowFlags_NoTitleBar             = 1 << 0,   // Disable title-bar[m
[32m+[m[32m    ImGuiWindowFlags_NoResize               = 1 << 1,   // Disable user resizing with the lower-right grip[m
[32m+[m[32m    ImGuiWindowFlags_NoMove                 = 1 << 2,   // Disable user moving the window[m
[32m+[m[32m    ImGuiWindowFlags_NoScrollbar            = 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programmatically)[m
[32m+[m[32m    ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.[m
[32m+[m[32m    ImGuiWindowFlags_NoCollapse             = 1 << 5,   // Disable user collapsing window by double-clicking on it[m
[32m+[m[32m    ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   // Resize every window to its content every frame[m
[32m+[m[32m    ImGuiWindowFlags_NoBackground           = 1 << 7,   // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).[m
[32m+[m[32m    ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   // Never load/save settings in .ini file[m
[32m+[m[32m    ImGuiWindowFlags_NoMouseInputs          = 1 << 9,   // Disable catching mouse, hovering test with pass through.[m
[32m+[m[32m    ImGuiWindowFlags_MenuBar                = 1 << 10,  // Has a menu-bar[m
[32m+[m[32m    ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.[m
[32m+[m[32m    ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  // Disable taking focus when transitioning from hidden to visible state[m
[32m+[m[32m    ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus)[m
[32m+[m[32m    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)[m
[32m+[m[32m    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)[m
[32m+[m[32m    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)[m
[32m+[m[32m    ImGuiWindowFlags_NoNavInputs            = 1 << 18,  // No gamepad/keyboard navigation within the window[m
[32m+[m[32m    ImGuiWindowFlags_NoNavFocus             = 1 << 19,  // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)[m
[32m+[m[32m    ImGuiWindowFlags_UnsavedDocument        = 1 << 20,  // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. When used in a tab/docking context, tab is selected on closure and closure is deferred by one frame to allow code to cancel the closure (with a confirmation popup, etc.) without flicker.[m
[32m+[m[32m    ImGuiWindowFlags_NoNav                  = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,[m
[32m+[m[32m    ImGuiWindowFlags_NoDecoration           = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,[m
[32m+[m[32m    ImGuiWindowFlags_NoInputs               = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,[m
[32m+[m
[32m+[m[32m    // [Internal][m
[32m+[m[32m    ImGuiWindowFlags_NavFlattened           = 1 << 23,  // [BETA] Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)[m
[32m+[m[32m    ImGuiWindowFlags_ChildWindow            = 1 << 24,  // Don't use! For internal use by BeginChild()[m
[32m+[m[32m    ImGuiWindowFlags_Tooltip                = 1 << 25,  // Don't use! For internal use by BeginTooltip()[m
[32m+[m[32m    ImGuiWindowFlags_Popup                  = 1 << 26,  // Don't use! For internal use by BeginPopup()[m
[32m+[m[32m    ImGuiWindowFlags_Modal                  = 1 << 27,  // Don't use! For internal use by BeginPopupModal()[m
[32m+[m[32m    ImGuiWindowFlags_ChildMenu              = 1 << 28   // Don't use! For internal use by BeginMenu()[m
[32m+[m
[32m+[m[32m    // [Obsolete][m
[32m+[m[32m    //ImGuiWindowFlags_ShowBorders          = 1 << 7,   // --> Set style.FrameBorderSize=1.0f / style.WindowBorderSize=1.0f to enable borders around windows and items[m
[32m+[m[32m    //ImGuiWindowFlags_ResizeFromAnySide    = 1 << 17,  // --> Set io.ConfigWindowsResizeFromEdges and make sure mouse cursors are supported by back-end (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors)[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Flags for ImGui::InputText()[m
[32m+[m[32menum ImGuiInputTextFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiInputTextFlags_None                = 0,[m
[32m+[m[32m    ImGuiInputTextFlags_CharsDecimal        = 1 << 0,   // Allow 0123456789.+-*/[m
[32m+[m[32m    ImGuiInputTextFlags_CharsHexadecimal    = 1 << 1,   // Allow 0123456789ABCDEFabcdef[m
[32m+[m[32m    ImGuiInputTextFlags_CharsUppercase      = 1 << 2,   // Turn a..z into A..Z[m
[32m+[m[32m    ImGuiInputTextFlags_CharsNoBlank        = 1 << 3,   // Filter out spaces, tabs[m
[32m+[m[32m    ImGuiInputTextFlags_AutoSelectAll       = 1 << 4,   // Select entire text when first taking mouse focus[m
[32m+[m[32m    ImGuiInputTextFlags_EnterReturnsTrue    = 1 << 5,   // Return 'true' when Enter is pressed (as opposed to every time the value was modified). Consider looking at the IsItemDeactivatedAfterEdit() function.[m
[32m+[m[32m    ImGuiInputTextFlags_CallbackCompletion  = 1 << 6,   // Callback on pressing TAB (for completion handling)[m
[32m+[m[32m    ImGuiInputTextFlags_CallbackHistory     = 1 << 7,   // Callback on pressing Up/Down arrows (for history handling)[m
[32m+[m[32m    ImGuiInputTextFlags_CallbackAlways      = 1 << 8,   // Callback on each iteration. User code may query cursor position, modify text buffer.[m
[32m+[m[32m    ImGuiInputTextFlags_CallbackCharFilter  = 1 << 9,   // Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.[m
[32m+[m[32m    ImGuiInputTextFlags_AllowTabInput       = 1 << 10,  // Pressing TAB input a '\t' character into the text field[m
[32m+[m[32m    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  // In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).[m
[32m+[m[32m    ImGuiInputTextFlags_NoHorizontalScroll  = 1 << 12,  // Disable following the cursor horizontally[m
[32m+[m[32m    ImGuiInputTextFlags_AlwaysInsertMode    = 1 << 13,  // Insert mode[m
[32m+[m[32m    ImGuiInputTextFlags_ReadOnly            = 1 << 14,  // Read-only mode[m
[32m+[m[32m    ImGuiInputTextFlags_Password            = 1 << 15,  // Password mode, display all characters as '*'[m
[32m+[m[32m    ImGuiInputTextFlags_NoUndoRedo          = 1 << 16,  // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().[m
[32m+[m[32m    ImGuiInputTextFlags_CharsScientific     = 1 << 17,  // Allow 0123456789.+-*/eE (Scientific notation input)[m
[32m+[m[32m    ImGuiInputTextFlags_CallbackResize      = 1 << 18,  // Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this)[m
[32m+[m[32m    // [Internal][m
[32m+[m[32m    ImGuiInputTextFlags_Multiline           = 1 << 20   // For internal use by InputTextMultiline()[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()[m
[32m+[m[32menum ImGuiTreeNodeFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiTreeNodeFlags_None                 = 0,[m
[32m+[m[32m    ImGuiTreeNodeFlags_Selected             = 1 << 0,   // Draw as selected[m
[32m+[m[32m    ImGuiTreeNodeFlags_Framed               = 1 << 1,   // Full colored frame (e.g. for CollapsingHeader)[m
[32m+[m[32m    ImGuiTreeNodeFlags_AllowItemOverlap     = 1 << 2,   // Hit testing to allow subsequent widgets to overlap this one[m
[32m+[m[32m    ImGuiTreeNodeFlags_NoTreePushOnOpen     = 1 << 3,   // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack[m
[32m+[m[32m    ImGuiTreeNodeFlags_NoAutoOpenOnLog      = 1 << 4,   // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)[m
[32m+[m[32m    ImGuiTreeNodeFlags_DefaultOpen          = 1 << 5,   // Default node to be open[m
[32m+[m[32m    ImGuiTreeNodeFlags_OpenOnDoubleClick    = 1 << 6,   // Need double-click to open node[m
[32m+[m[32m    ImGuiTreeNodeFlags_OpenOnArrow          = 1 << 7,   // Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.[m
[32m+[m[32m    ImGuiTreeNodeFlags_Leaf                 = 1 << 8,   // No collapsing, no arrow (use as a convenience for leaf nodes).[m
[32m+[m[32m    ImGuiTreeNodeFlags_Bullet               = 1 << 9,   // Display a bullet instead of arrow[m
[32m+[m[32m    ImGuiTreeNodeFlags_FramePadding         = 1 << 10,  // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().[m
[32m+[m[32m    //ImGuiTreeNodeFlags_SpanAllAvailWidth  = 1 << 11,  // FIXME: TODO: Extend hit box horizontally even if not framed[m
[32m+[m[32m    //ImGuiTreeNodeFlags_NoScrollOnOpen     = 1 << 12,  // FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible[m
[32m+[m[32m    ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 13,  // (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)[m
[32m+[m[32m    ImGuiTreeNodeFlags_CollapsingHeader     = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog[m
[32m+[m
[32m+[m[32m    // Obsolete names (will be removed)[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32m    , ImGuiTreeNodeFlags_AllowOverlapMode = ImGuiTreeNodeFlags_AllowItemOverlap[m
[32m+[m[32m#endif[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Flags for ImGui::Selectable()[m
[32m+[m[32menum ImGuiSelectableFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiSelectableFlags_None               = 0,[m
[32m+[m[32m    ImGuiSelectableFlags_DontClosePopups    = 1 << 0,   // Clicking this don't close parent popup window[m
[32m+[m[32m    ImGuiSelectableFlags_SpanAllColumns     = 1 << 1,   // Selectable frame can span all columns (text will still fit in current column)[m
[32m+[m[32m    ImGuiSelectableFlags_AllowDoubleClick   = 1 << 2,   // Generate press events on double clicks too[m
[32m+[m[32m    ImGuiSelectableFlags_Disabled           = 1 << 3    // Cannot be selected, display greyed out text[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Flags for ImGui::BeginCombo()[m
[32m+[m[32menum ImGuiComboFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiComboFlags_None                    = 0,[m
[32m+[m[32m    ImGuiComboFlags_PopupAlignLeft          = 1 << 0,   // Align the popup toward the left by default[m
[32m+[m[32m    ImGuiComboFlags_HeightSmall             = 1 << 1,   // Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()[m
[32m+[m[32m    ImGuiComboFlags_HeightRegular           = 1 << 2,   // Max ~8 items visible (default)[m
[32m+[m[32m    ImGuiComboFlags_HeightLarge             = 1 << 3,   // Max ~20 items visible[m
[32m+[m[32m    ImGuiComboFlags_HeightLargest           = 1 << 4,   // As many fitting items as possible[m
[32m+[m[32m    ImGuiComboFlags_NoArrowButton           = 1 << 5,   // Display on the preview box without the square arrow button[m
[32m+[m[32m    ImGuiComboFlags_NoPreview               = 1 << 6,   // Display only a square arrow button[m
[32m+[m[32m    ImGuiComboFlags_HeightMask_             = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Flags for ImGui::BeginTabBar()[m
[32m+[m[32menum ImGuiTabBarFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiTabBarFlags_None                           = 0,[m
[32m+[m[32m    ImGuiTabBarFlags_Reorderable                    = 1 << 0,   // Allow manually dragging tabs to re-order them + New tabs are appended at the end of list[m
[32m+[m[32m    ImGuiTabBarFlags_AutoSelectNewTabs              = 1 << 1,   // Automatically select new tabs when they appear[m
[32m+[m[32m    ImGuiTabBarFlags_TabListPopupButton             = 1 << 2,[m
[32m+[m[32m    ImGuiTabBarFlags_NoCloseWithMiddleMouseButton   = 1 << 3,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.[m
[32m+[m[32m    ImGuiTabBarFlags_NoTabListScrollingButtons      = 1 << 4,[m
[32m+[m[32m    ImGuiTabBarFlags_NoTooltip                      = 1 << 5,   // Disable tooltips when hovering a tab[m
[32m+[m[32m    ImGuiTabBarFlags_FittingPolicyResizeDown        = 1 << 6,   // Resize tabs when they don't fit[m
[32m+[m[32m    ImGuiTabBarFlags_FittingPolicyScroll            = 1 << 7,   // Add scroll buttons when tabs don't fit[m
[32m+[m[32m    ImGuiTabBarFlags_FittingPolicyMask_             = ImGuiTabBarFlags_FittingPolicyResizeDown | ImGuiTabBarFlags_FittingPolicyScroll,[m
[32m+[m[32m    ImGuiTabBarFlags_FittingPolicyDefault_          = ImGuiTabBarFlags_FittingPolicyResizeDown[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Flags for ImGui::BeginTabItem()[m
[32m+[m[32menum ImGuiTabItemFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiTabItemFlags_None                          = 0,[m
[32m+[m[32m    ImGuiTabItemFlags_UnsavedDocument               = 1 << 0,   // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. Also: tab is selected on closure and closure is deferred by one frame to allow code to undo it without flicker.[m
[32m+[m[32m    ImGuiTabItemFlags_SetSelected                   = 1 << 1,   // Trigger flag to programmatically make the tab selected when calling BeginTabItem()[m
[32m+[m[32m    ImGuiTabItemFlags_NoCloseWithMiddleMouseButton  = 1 << 2,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.[m
[32m+[m[32m    ImGuiTabItemFlags_NoPushId                      = 1 << 3    // Don't call PushID(tab->ID)/PopID() on BeginTabItem()/EndTabItem()[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Flags for ImGui::IsWindowFocused()[m
[32m+[m[32menum ImGuiFocusedFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiFocusedFlags_None                          = 0,[m
[32m+[m[32m    ImGuiFocusedFlags_ChildWindows                  = 1 << 0,   // IsWindowFocused(): Return true if any children of the window is focused[m
[32m+[m[32m    ImGuiFocusedFlags_RootWindow                    = 1 << 1,   // IsWindowFocused(): Test from root window (top most parent of the current hierarchy)[m
[32m+[m[32m    ImGuiFocusedFlags_AnyWindow                     = 1 << 2,   // IsWindowFocused(): Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use ImGui::GetIO().WantCaptureMouse instead.[m
[32m+[m[32m    ImGuiFocusedFlags_RootAndChildWindows           = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered()[m
[32m+[m[32m// Note: if you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that. Please read the FAQ![m
[32m+[m[32m// Note: windows with the ImGuiWindowFlags_NoInputs flag are ignored by IsWindowHovered() calls.[m
[32m+[m[32menum ImGuiHoveredFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiHoveredFlags_None                          = 0,        // Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.[m
[32m+[m[32m    ImGuiHoveredFlags_ChildWindows                  = 1 << 0,   // IsWindowHovered() only: Return true if any children of the window is hovered[m
[32m+[m[32m    ImGuiHoveredFlags_RootWindow                    = 1 << 1,   // IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)[m
[32m+[m[32m    ImGuiHoveredFlags_AnyWindow                     = 1 << 2,   // IsWindowHovered() only: Return true if any window is hovered[m
[32m+[m[32m    ImGuiHoveredFlags_AllowWhenBlockedByPopup       = 1 << 3,   // Return true even if a popup window is normally blocking access to this item/window[m
[32m+[m[32m    //ImGuiHoveredFlags_AllowWhenBlockedByModal     = 1 << 4,   // Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet.[m
[32m+[m[32m    ImGuiHoveredFlags_AllowWhenBlockedByActiveItem  = 1 << 5,   // Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.[m
[32m+[m[32m    ImGuiHoveredFlags_AllowWhenOverlapped           = 1 << 6,   // Return true even if the position is overlapped by another window[m
[32m+[m[32m    ImGuiHoveredFlags_AllowWhenDisabled             = 1 << 7,   // Return true even if the item is disabled[m
[32m+[m[32m    ImGuiHoveredFlags_RectOnly                      = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,[m
[32m+[m[32m    ImGuiHoveredFlags_RootAndChildWindows           = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()[m
[32m+[m[32menum ImGuiDragDropFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiDragDropFlags_None                         = 0,[m
[32m+[m[32m    // BeginDragDropSource() flags[m
[32m+[m[32m    ImGuiDragDropFlags_SourceNoPreviewTooltip       = 1 << 0,   // By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.[m
[32m+[m[32m    ImGuiDragDropFlags_SourceNoDisableHover         = 1 << 1,   // By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.[m
[32m+[m[32m    ImGuiDragDropFlags_SourceNoHoldToOpenOthers     = 1 << 2,   // Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.[m
[32m+[m[32m    ImGuiDragDropFlags_SourceAllowNullID            = 1 << 3,   // Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.[m
[32m+[m[32m    ImGuiDragDropFlags_SourceExtern                 = 1 << 4,   // External source (from outside of imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.[m
[32m+[m[32m    ImGuiDragDropFlags_SourceAutoExpirePayload      = 1 << 5,   // Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)[m
[32m+[m[32m    // AcceptDragDropPayload() flags[m
[32m+[m[32m    ImGuiDragDropFlags_AcceptBeforeDelivery         = 1 << 10,  // AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.[m
[32m+[m[32m    ImGuiDragDropFlags_AcceptNoDrawDefaultRect      = 1 << 11,  // Do not draw the default highlight rectangle when hovering over target.[m
[32m+[m[32m    ImGuiDragDropFlags_AcceptNoPreviewTooltip       = 1 << 12,  // Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.[m
[32m+[m[32m    ImGuiDragDropFlags_AcceptPeekOnly               = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect  // For peeking ahead and inspecting the payload before delivery.[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Standard Drag and Drop payload types. You can define you own payload types using short strings. Types starting with '_' are defined by Dear ImGui.[m
[32m+[m[32m#define IMGUI_PAYLOAD_TYPE_COLOR_3F     "_COL3F"    // float[3]: Standard type for colors, without alpha. User code may use this type.[m
[32m+[m[32m#define IMGUI_PAYLOAD_TYPE_COLOR_4F     "_COL4F"    // float[4]: Standard type for colors. User code may use this type.[m
[32m+[m
[32m+[m[32m// A primary data type[m
[32m+[m[32menum ImGuiDataType_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiDataType_S8,       // char[m
[32m+[m[32m    ImGuiDataType_U8,       // unsigned char[m
[32m+[m[32m    ImGuiDataType_S16,      // short[m
[32m+[m[32m    ImGuiDataType_U16,      // unsigned short[m
[32m+[m[32m    ImGuiDataType_S32,      // int[m
[32m+[m[32m    ImGuiDataType_U32,      // unsigned int[m
[32m+[m[32m    ImGuiDataType_S64,      // long long / __int64[m
[32m+[m[32m    ImGuiDataType_U64,      // unsigned long long / unsigned __int64[m
[32m+[m[32m    ImGuiDataType_Float,    // float[m
[32m+[m[32m    ImGuiDataType_Double,   // double[m
[32m+[m[32m    ImGuiDataType_COUNT[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// A cardinal direction[m
[32m+[m[32menum ImGuiDir_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiDir_None    = -1,[m
[32m+[m[32m    ImGuiDir_Left    = 0,[m
[32m+[m[32m    ImGuiDir_Right   = 1,[m
[32m+[m[32m    ImGuiDir_Up      = 2,[m
[32m+[m[32m    ImGuiDir_Down    = 3,[m
[32m+[m[32m    ImGuiDir_COUNT[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// User fill ImGuiIO.KeyMap[] array with indices into the ImGuiIO.KeysDown[512] array[m
[32m+[m[32menum ImGuiKey_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiKey_Tab,[m
[32m+[m[32m    ImGuiKey_LeftArrow,[m
[32m+[m[32m    ImGuiKey_RightArrow,[m
[32m+[m[32m    ImGuiKey_UpArrow,[m
[32m+[m[32m    ImGuiKey_DownArrow,[m
[32m+[m[32m    ImGuiKey_PageUp,[m
[32m+[m[32m    ImGuiKey_PageDown,[m
[32m+[m[32m    ImGuiKey_Home,[m
[32m+[m[32m    ImGuiKey_End,[m
[32m+[m[32m    ImGuiKey_Insert,[m
[32m+[m[32m    ImGuiKey_Delete,[m
[32m+[m[32m    ImGuiKey_Backspace,[m
[32m+[m[32m    ImGuiKey_Space,[m
[32m+[m[32m    ImGuiKey_Enter,[m
[32m+[m[32m    ImGuiKey_Escape,[m
[32m+[m[32m    ImGuiKey_A,         // for text edit CTRL+A: select all[m
[32m+[m[32m    ImGuiKey_C,         // for text edit CTRL+C: copy[m
[32m+[m[32m    ImGuiKey_V,         // for text edit CTRL+V: paste[m
[32m+[m[32m    ImGuiKey_X,         // for text edit CTRL+X: cut[m
[32m+[m[32m    ImGuiKey_Y,         // for text edit CTRL+Y: redo[m
[32m+[m[32m    ImGuiKey_Z,         // for text edit CTRL+Z: undo[m
[32m+[m[32m    ImGuiKey_COUNT[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Gamepad/Keyboard directional navigation[m
[32m+[m[32m// Keyboard: Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable. NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.[m
[32m+[m[32m// Gamepad:  Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable. Back-end: set ImGuiBackendFlags_HasGamepad and fill the io.NavInputs[] fields before calling NewFrame(). Note that io.NavInputs[] is cleared by EndFrame().[m
[32m+[m[32m// Read instructions in imgui.cpp for more details. Download PNG/PSD at http://goo.gl/9LgVZW.[m
[32m+[m[32menum ImGuiNavInput_[m
[32m+[m[32m{[m
[32m+[m[32m    // Gamepad Mapping[m
[32m+[m[32m    ImGuiNavInput_Activate,      // activate / open / toggle / tweak value       // e.g. Cross  (PS4), A (Xbox), A (Switch), Space (Keyboard)[m
[32m+[m[32m    ImGuiNavInput_Cancel,        // cancel / close / exit                        // e.g. Circle (PS4), B (Xbox), B (Switch), Escape (Keyboard)[m
[32m+[m[32m    ImGuiNavInput_Input,         // text input / on-screen keyboard              // e.g. Triang.(PS4), Y (Xbox), X (Switch), Return (Keyboard)[m
[32m+[m[32m    ImGuiNavInput_Menu,          // tap: toggle menu / hold: focus, move, resize // e.g. Square (PS4), X (Xbox), Y (Switch), Alt (Keyboard)[m
[32m+[m[32m    ImGuiNavInput_DpadLeft,      // move / tweak / resize window (w/ PadMenu)    // e.g. D-pad Left/Right/Up/Down (Gamepads), Arrow keys (Keyboard)[m
[32m+[m[32m    ImGuiNavInput_DpadRight,     //[m
[32m+[m[32m    ImGuiNavInput_DpadUp,        //[m
[32m+[m[32m    ImGuiNavInput_DpadDown,      //[m
[32m+[m[32m    ImGuiNavInput_LStickLeft,    // scroll / move window (w/ PadMenu)            // e.g. Left Analog Stick Left/Right/Up/Down[m
[32m+[m[32m    ImGuiNavInput_LStickRight,   //[m
[32m+[m[32m    ImGuiNavInput_LStickUp,      //[m
[32m+[m[32m    ImGuiNavInput_LStickDown,    //[m
[32m+[m[32m    ImGuiNavInput_FocusPrev,     // next window (w/ PadMenu)                     // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)[m
[32m+[m[32m    ImGuiNavInput_FocusNext,     // prev window (w/ PadMenu)                     // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)[m
[32m+[m[32m    ImGuiNavInput_TweakSlow,     // slower tweaks                                // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)[m
[32m+[m[32m    ImGuiNavInput_TweakFast,     // faster tweaks                                // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)[m
[32m+[m
[32m+[m[32m    // [Internal] Don't use directly! This is used internally to differentiate keyboard from gamepad inputs for behaviors that require to differentiate them.[m
[32m+[m[32m    // Keyboard behavior that have no corresponding gamepad mapping (e.g. CTRL+TAB) will be directly reading from io.KeysDown[] instead of io.NavInputs[].[m
[32m+[m[32m    ImGuiNavInput_KeyMenu_,      // toggle menu                                  // = io.KeyAlt[m
[32m+[m[32m    ImGuiNavInput_KeyTab_,       // tab                                          // = Tab key[m
[32m+[m[32m    ImGuiNavInput_KeyLeft_,      // move left                                    // = Arrow keys[m
[32m+[m[32m    ImGuiNavInput_KeyRight_,     // move right[m
[32m+[m[32m    ImGuiNavInput_KeyUp_,        // move up[m
[32m+[m[32m    ImGuiNavInput_KeyDown_,      // move down[m
[32m+[m[32m    ImGuiNavInput_COUNT,[m
[32m+[m[32m    ImGuiNavInput_InternalStart_ = ImGuiNavInput_KeyMenu_[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Configuration flags stored in io.ConfigFlags. Set by user/application.[m
[32m+[m[32menum ImGuiConfigFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiConfigFlags_None                   = 0,[m
[32m+[m[32m    ImGuiConfigFlags_NavEnableKeyboard      = 1 << 0,   // Master keyboard navigation enable flag. NewFrame() will automatically fill io.NavInputs[] based on io.KeysDown[].[m
[32m+[m[32m    ImGuiConfigFlags_NavEnableGamepad       = 1 << 1,   // Master gamepad navigation enable flag. This is mostly to instruct your imgui back-end to fill io.NavInputs[]. Back-end also needs to set ImGuiBackendFlags_HasGamepad.[m
[32m+[m[32m    ImGuiConfigFlags_NavEnableSetMousePos   = 1 << 2,   // Instruct navigation to move the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is awkward. Will update io.MousePos and set io.WantSetMousePos=true. If enabled you MUST honor io.WantSetMousePos requests in your binding, otherwise ImGui will react as if the mouse is jumping around back and forth.[m
[32m+[m[32m    ImGuiConfigFlags_NavNoCaptureKeyboard   = 1 << 3,   // Instruct navigation to not set the io.WantCaptureKeyboard flag when io.NavActive is set.[m
[32m+[m[32m    ImGuiConfigFlags_NoMouse                = 1 << 4,   // Instruct imgui to clear mouse position/buttons in NewFrame(). This allows ignoring the mouse information set by the back-end.[m
[32m+[m[32m    ImGuiConfigFlags_NoMouseCursorChange    = 1 << 5,   // Instruct back-end to not alter mouse cursor shape and visibility. Use if the back-end cursor changes are interfering with yours and you don't want to use SetMouseCursor() to change mouse cursor. You may want to honor requests from imgui by reading GetMouseCursor() yourself instead.[m
[32m+[m
[32m+[m[32m    // User storage (to allow your back-end/engine to communicate to code that may be shared between multiple projects. Those flags are not used by core ImGui)[m
[32m+[m[32m    ImGuiConfigFlags_IsSRGB                 = 1 << 20,  // Application is SRGB-aware.[m
[32m+[m[32m    ImGuiConfigFlags_IsTouchScreen          = 1 << 21   // Application is using a touch screen instead of a mouse.[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Back-end capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom back-end.[m
[32m+[m[32menum ImGuiBackendFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiBackendFlags_None                  = 0,[m
[32m+[m[32m    ImGuiBackendFlags_HasGamepad            = 1 << 0,   // Back-end supports gamepad and currently has one connected.[m
[32m+[m[32m    ImGuiBackendFlags_HasMouseCursors       = 1 << 1,   // Back-end supports honoring GetMouseCursor() value to change the OS cursor shape.[m
[32m+[m[32m    ImGuiBackendFlags_HasSetMousePos        = 1 << 2    // Back-end supports io.WantSetMousePos requests to reposition the OS mouse position (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Enumeration for PushStyleColor() / PopStyleColor()[m
[32m+[m[32menum ImGuiCol_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiCol_Text,[m
[32m+[m[32m    ImGuiCol_TextDisabled,[m
[32m+[m[32m    ImGuiCol_WindowBg,              // Background of normal windows[m
[32m+[m[32m    ImGuiCol_ChildBg,               // Background of child windows[m
[32m+[m[32m    ImGuiCol_PopupBg,               // Background of popups, menus, tooltips windows[m
[32m+[m[32m    ImGuiCol_Border,[m
[32m+[m[32m    ImGuiCol_BorderShadow,[m
[32m+[m[32m    ImGuiCol_FrameBg,               // Background of checkbox, radio button, plot, slider, text input[m
[32m+[m[32m    ImGuiCol_FrameBgHovered,[m
[32m+[m[32m    ImGuiCol_FrameBgActive,[m
[32m+[m[32m    ImGuiCol_TitleBg,[m
[32m+[m[32m    ImGuiCol_TitleBgActive,[m
[32m+[m[32m    ImGuiCol_TitleBgCollapsed,[m
[32m+[m[32m    ImGuiCol_MenuBarBg,[m
[32m+[m[32m    ImGuiCol_ScrollbarBg,[m
[32m+[m[32m    ImGuiCol_ScrollbarGrab,[m
[32m+[m[32m    ImGuiCol_ScrollbarGrabHovered,[m
[32m+[m[32m    ImGuiCol_ScrollbarGrabActive,[m
[32m+[m[32m    ImGuiCol_CheckMark,[m
[32m+[m[32m    ImGuiCol_SliderGrab,[m
[32m+[m[32m    ImGuiCol_SliderGrabActive,[m
[32m+[m[32m    ImGuiCol_Button,[m
[32m+[m[32m    ImGuiCol_ButtonHovered,[m
[32m+[m[32m    ImGuiCol_ButtonActive,[m
[32m+[m[32m    ImGuiCol_Header,[m
[32m+[m[32m    ImGuiCol_HeaderHovered,[m
[32m+[m[32m    ImGuiCol_HeaderActive,[m
[32m+[m[32m    ImGuiCol_Separator,[m
[32m+[m[32m    ImGuiCol_SeparatorHovered,[m
[32m+[m[32m    ImGuiCol_SeparatorActive,[m
[32m+[m[32m    ImGuiCol_ResizeGrip,[m
[32m+[m[32m    ImGuiCol_ResizeGripHovered,[m
[32m+[m[32m    ImGuiCol_ResizeGripActive,[m
[32m+[m[32m    ImGuiCol_Tab,[m
[32m+[m[32m    ImGuiCol_TabHovered,[m
[32m+[m[32m    ImGuiCol_TabActive,[m
[32m+[m[32m    ImGuiCol_TabUnfocused,[m
[32m+[m[32m    ImGuiCol_TabUnfocusedActive,[m
[32m+[m[32m    ImGuiCol_PlotLines,[m
[32m+[m[32m    ImGuiCol_PlotLinesHovered,[m
[32m+[m[32m    ImGuiCol_PlotHistogram,[m
[32m+[m[32m    ImGuiCol_PlotHistogramHovered,[m
[32m+[m[32m    ImGuiCol_TextSelectedBg,[m
[32m+[m[32m    ImGuiCol_DragDropTarget,[m
[32m+[m[32m    ImGuiCol_NavHighlight,          // Gamepad/keyboard: current highlighted item[m
[32m+[m[32m    ImGuiCol_NavWindowingHighlight, // Highlight window when using CTRL+TAB[m
[32m+[m[32m    ImGuiCol_NavWindowingDimBg,     // Darken/colorize entire screen behind the CTRL+TAB window list, when active[m
[32m+[m[32m    ImGuiCol_ModalWindowDimBg,      // Darken/colorize entire screen behind a modal window, when one is active[m
[32m+[m[32m    ImGuiCol_COUNT[m
[32m+[m
[32m+[m[32m    // Obsolete names (will be removed)[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32m    , ImGuiCol_ModalWindowDarkening = ImGuiCol_ModalWindowDimBg                      // [renamed in 1.63][m
[32m+[m[32m    , ImGuiCol_ChildWindowBg = ImGuiCol_ChildBg                                      // [renamed in 1.53][m
[32m+[m[32m    , ImGuiCol_Column = ImGuiCol_Separator, ImGuiCol_ColumnHovered = ImGuiCol_SeparatorHovered, ImGuiCol_ColumnActive = ImGuiCol_SeparatorActive  // [renamed in 1.51][m
[32m+[m[32m    //ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered, // [unused since 1.60+] the close button now uses regular button colors.[m
[32m+[m[32m    //ImGuiCol_ComboBg,                                                              // [unused since 1.53+] ComboBg has been merged with PopupBg, so a redirect isn't accurate.[m
[32m+[m[32m#endif[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure.[m
[32m+[m[32m// NB: the enum only refers to fields of ImGuiStyle which makes sense to be pushed/popped inside UI code. During initialization, feel free to just poke into ImGuiStyle directly.[m
[32m+[m[32m// NB: if changing this enum, you need to update the associated internal table GStyleVarInfo[] accordingly. This is where we link enum values to members offset/type.[m
[32m+[m[32menum ImGuiStyleVar_[m
[32m+[m[32m{[m
[32m+[m[32m    // Enum name --------------------- // Member in ImGuiStyle structure (see ImGuiStyle for descriptions)[m
[32m+[m[32m    ImGuiStyleVar_Alpha,               // float     Alpha[m
[32m+[m[32m    ImGuiStyleVar_WindowPadding,       // ImVec2    WindowPadding[m
[32m+[m[32m    ImGuiStyleVar_WindowRounding,      // float     WindowRounding[m
[32m+[m[32m    ImGuiStyleVar_WindowBorderSize,    // float     WindowBorderSize[m
[32m+[m[32m    ImGuiStyleVar_WindowMinSize,       // ImVec2    WindowMinSize[m
[32m+[m[32m    ImGuiStyleVar_WindowTitleAlign,    // ImVec2    WindowTitleAlign[m
[32m+[m[32m    ImGuiStyleVar_ChildRounding,       // float     ChildRounding[m
[32m+[m[32m    ImGuiStyleVar_ChildBorderSize,     // float     ChildBorderSize[m
[32m+[m[32m    ImGuiStyleVar_PopupRounding,       // float     PopupRounding[m
[32m+[m[32m    ImGuiStyleVar_PopupBorderSize,     // float     PopupBorderSize[m
[32m+[m[32m    ImGuiStyleVar_FramePadding,        // ImVec2    FramePadding[m
[32m+[m[32m    ImGuiStyleVar_FrameRounding,       // float     FrameRounding[m
[32m+[m[32m    ImGuiStyleVar_FrameBorderSize,     // float     FrameBorderSize[m
[32m+[m[32m    ImGuiStyleVar_ItemSpacing,         // ImVec2    ItemSpacing[m
[32m+[m[32m    ImGuiStyleVar_ItemInnerSpacing,    // ImVec2    ItemInnerSpacing[m
[32m+[m[32m    ImGuiStyleVar_IndentSpacing,       // float     IndentSpacing[m
[32m+[m[32m    ImGuiStyleVar_ScrollbarSize,       // float     ScrollbarSize[m
[32m+[m[32m    ImGuiStyleVar_ScrollbarRounding,   // float     ScrollbarRounding[m
[32m+[m[32m    ImGuiStyleVar_GrabMinSize,         // float     GrabMinSize[m
[32m+[m[32m    ImGuiStyleVar_GrabRounding,        // float     GrabRounding[m
[32m+[m[32m    ImGuiStyleVar_TabRounding,         // float     TabRounding[m
[32m+[m[32m    ImGuiStyleVar_ButtonTextAlign,     // ImVec2    ButtonTextAlign[m
[32m+[m[32m    ImGuiStyleVar_SelectableTextAlign, // ImVec2    SelectableTextAlign[m
[32m+[m[32m    ImGuiStyleVar_COUNT[m
[32m+[m
[32m+[m[32m    // Obsolete names (will be removed)[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32m    , ImGuiStyleVar_Count_ = ImGuiStyleVar_COUNT, ImGuiStyleVar_ChildWindowRounding = ImGuiStyleVar_ChildRounding[m
[32m+[m[32m#endif[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Flags for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()[m
[32m+[m[32menum ImGuiColorEditFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiColorEditFlags_None            = 0,[m
[32m+[m[32m    ImGuiColorEditFlags_NoAlpha         = 1 << 1,   //              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer).[m
[32m+[m[32m    ImGuiColorEditFlags_NoPicker        = 1 << 2,   //              // ColorEdit: disable picker when clicking on colored square.[m
[32m+[m[32m    ImGuiColorEditFlags_NoOptions       = 1 << 3,   //              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.[m
[32m+[m[32m    ImGuiColorEditFlags_NoSmallPreview  = 1 << 4,   //              // ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs)[m
[32m+[m[32m    ImGuiColorEditFlags_NoInputs        = 1 << 5,   //              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview colored square).[m
[32m+[m[32m    ImGuiColorEditFlags_NoTooltip       = 1 << 6,   //              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.[m
[32m+[m[32m    ImGuiColorEditFlags_NoLabel         = 1 << 7,   //              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).[m
[32m+[m[32m    ImGuiColorEditFlags_NoSidePreview   = 1 << 8,   //              // ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead.[m
[32m+[m[32m    ImGuiColorEditFlags_NoDragDrop      = 1 << 9,   //              // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.[m
[32m+[m
[32m+[m[32m    // User Options (right-click on widget to change some of them).[m
[32m+[m[32m    ImGuiColorEditFlags_AlphaBar        = 1 << 16,  //              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.[m
[32m+[m[32m    ImGuiColorEditFlags_AlphaPreview    = 1 << 17,  //              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.[m
[32m+[m[32m    ImGuiColorEditFlags_AlphaPreviewHalf= 1 << 18,  //              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.[m
[32m+[m[32m    ImGuiColorEditFlags_HDR             = 1 << 19,  //              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).[m
[32m+[m[32m    ImGuiColorEditFlags_DisplayRGB      = 1 << 20,  // [Display]    // ColorEdit: override _display_ type among RGB/HSV/Hex. ColorPicker: select any combination using one or more of RGB/HSV/Hex.[m
[32m+[m[32m    ImGuiColorEditFlags_DisplayHSV      = 1 << 21,  // [Display]    // "[m
[32m+[m[32m    ImGuiColorEditFlags_DisplayHex      = 1 << 22,  // [Display]    // "[m
[32m+[m[32m    ImGuiColorEditFlags_Uint8           = 1 << 23,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.[m
[32m+[m[32m    ImGuiColorEditFlags_Float           = 1 << 24,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.[m
[32m+[m[32m    ImGuiColorEditFlags_PickerHueBar    = 1 << 25,  // [Picker]     // ColorPicker: bar for Hue, rectangle for Sat/Value.[m
[32m+[m[32m    ImGuiColorEditFlags_PickerHueWheel  = 1 << 26,  // [Picker]     // ColorPicker: wheel for Hue, triangle for Sat/Value.[m
[32m+[m[32m    ImGuiColorEditFlags_InputRGB        = 1 << 27,  // [Input]      // ColorEdit, ColorPicker: input and output data in RGB format.[m
[32m+[m[32m    ImGuiColorEditFlags_InputHSV        = 1 << 28,  // [Input]      // ColorEdit, ColorPicker: input and output data in HSV format.[m
[32m+[m
[32m+[m[32m    // Defaults Options. You can set application defaults using SetColorEditOptions(). The intent is that you probably don't want to[m
[32m+[m[32m    // override them in most of your calls. Let the user choose via the option menu and/or call SetColorEditOptions() once during startup.[m
[32m+[m[32m    ImGuiColorEditFlags__OptionsDefault = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_DisplayRGB|ImGuiColorEditFlags_InputRGB|ImGuiColorEditFlags_PickerHueBar,[m
[32m+[m
[32m+[m[32m    // [Internal] Masks[m
[32m+[m[32m    ImGuiColorEditFlags__DisplayMask    = ImGuiColorEditFlags_DisplayRGB|ImGuiColorEditFlags_DisplayHSV|ImGuiColorEditFlags_DisplayHex,[m
[32m+[m[32m    ImGuiColorEditFlags__DataTypeMask   = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_Float,[m
[32m+[m[32m    ImGuiColorEditFlags__PickerMask     = ImGuiColorEditFlags_PickerHueWheel|ImGuiColorEditFlags_PickerHueBar,[m
[32m+[m[32m    ImGuiColorEditFlags__InputMask      = ImGuiColorEditFlags_InputRGB|ImGuiColorEditFlags_InputHSV[m
[32m+[m
[32m+[m[32m    // Obsolete names (will be removed)[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32m    , ImGuiColorEditFlags_RGB = ImGuiColorEditFlags_DisplayRGB, ImGuiColorEditFlags_HSV = ImGuiColorEditFlags_DisplayHSV, ImGuiColorEditFlags_HEX = ImGuiColorEditFlags_DisplayHex[m
[32m+[m[32m#endif[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Enumeration for GetMouseCursor()[m
[32m+[m[32m// User code may request binding to display given cursor by calling SetMouseCursor(), which is why we have some cursors that are marked unused here[m
[32m+[m[32menum ImGuiMouseCursor_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiMouseCursor_None = -1,[m
[32m+[m[32m    ImGuiMouseCursor_Arrow = 0,[m
[32m+[m[32m    ImGuiMouseCursor_TextInput,         // When hovering over InputText, etc.[m
[32m+[m[32m    ImGuiMouseCursor_ResizeAll,         // (Unused by imgui functions)[m
[32m+[m[32m    ImGuiMouseCursor_ResizeNS,          // When hovering over an horizontal border[m
[32m+[m[32m    ImGuiMouseCursor_ResizeEW,          // When hovering over a vertical border or a column[m
[32m+[m[32m    ImGuiMouseCursor_ResizeNESW,        // When hovering over the bottom-left corner of a window[m
[32m+[m[32m    ImGuiMouseCursor_ResizeNWSE,        // When hovering over the bottom-right corner of a window[m
[32m+[m[32m    ImGuiMouseCursor_Hand,              // (Unused by imgui functions. Use for e.g. hyperlinks)[m
[32m+[m[32m    ImGuiMouseCursor_COUNT[m
[32m+[m
[32m+[m[32m    // Obsolete names (will be removed)[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32m    , ImGuiMouseCursor_Count_ = ImGuiMouseCursor_COUNT[m
[32m+[m[32m#endif[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Enumateration for ImGui::SetWindow***(), SetNextWindow***(), SetNextTreeNode***() functions[m
[32m+[m[32m// Represent a condition.[m
[32m+[m[32m// Important: Treat as a regular enum! Do NOT combine multiple values using binary operators! All the functions above treat 0 as a shortcut to ImGuiCond_Always.[m
[32m+[m[32menum ImGuiCond_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiCond_Always        = 1 << 0,   // Set the variable[m
[32m+[m[32m    ImGuiCond_Once          = 1 << 1,   // Set the variable once per runtime session (only the first call with succeed)[m
[32m+[m[32m    ImGuiCond_FirstUseEver  = 1 << 2,   // Set the variable if the object/window has no persistently saved data (no entry in .ini file)[m
[32m+[m[32m    ImGuiCond_Appearing     = 1 << 3    // Set the variable if the object/window is appearing after being hidden/inactive (or the first time)[m
[32m+[m
[32m+[m[32m    // Obsolete names (will be removed)[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32m    , ImGuiSetCond_Always = ImGuiCond_Always, ImGuiSetCond_Once = ImGuiCond_Once, ImGuiSetCond_FirstUseEver = ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing = ImGuiCond_Appearing[m
[32m+[m[32m#endif[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Helpers: Memory allocations macros[m
[32m+[m[32m// IM_MALLOC(), IM_FREE(), IM_NEW(), IM_PLACEMENT_NEW(), IM_DELETE()[m
[32m+[m[32m// We call C++ constructor on own allocated memory via the placement "new(ptr) Type()" syntax.[m
[32m+[m[32m// Defining a custom placement new() with a dummy parameter allows us to bypass including <new> which on some platforms complains when user has disabled exceptions.[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mstruct ImNewDummy {};[m
[32m+[m[32minline void* operator new(size_t, ImNewDummy, void* ptr) { return ptr; }[m
[32m+[m[32minline void  operator delete(void*, ImNewDummy, void*)   {} // This is only required so we can use the symmetrical new()[m
[32m+[m[32m#define IM_ALLOC(_SIZE)                     ImGui::MemAlloc(_SIZE)[m
[32m+[m[32m#define IM_FREE(_PTR)                       ImGui::MemFree(_PTR)[m
[32m+[m[32m#define IM_PLACEMENT_NEW(_PTR)              new(ImNewDummy(), _PTR)[m
[32m+[m[32m#define IM_NEW(_TYPE)                       new(ImNewDummy(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE[m
[32m+[m[32mtemplate<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Helper: ImVector<>[m
[32m+[m[32m// Lightweight std::vector<>-like class to avoid dragging dependencies (also, some implementations of STL with debug enabled are absurdly slow, we bypass it so our code runs fast in debug).[m
[32m+[m[32m// You generally do NOT need to care or use this ever. But we need to make it available in imgui.h because some of our data structures are relying on it.[m
[32m+[m[32m// Important: clear() frees memory, resize(0) keep the allocated buffer. We use resize(0) a lot to intentionally recycle allocated buffers across frames and amortize our costs.[m
[32m+[m[32m// Important: our implementation does NOT call C++ constructors/destructors, we treat everything as raw data! This is intentional but be extra mindful of that,[m
[32m+[m[32m// do NOT use this class as a std::vector replacement in your own code! Many of the structures used by dear imgui can be safely initialized by a zero-memset.[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mtemplate<typename T>[m
[32m+[m[32mstruct ImVector[m
[32m+[m[32m{[m
[32m+[m[32m    int                 Size;[m
[32m+[m[32m    int                 Capacity;[m
[32m+[m[32m    T*                  Data;[m
[32m+[m
[32m+[m[32m    // Provide standard typedefs but we don't use them ourselves.[m
[32m+[m[32m    typedef T                   value_type;[m
[32m+[m[32m    typedef value_type*         iterator;[m
[32m+[m[32m    typedef const value_type*   const_iterator;[m
[32m+[m
[32m+[m[32m    // Constructors, destructor[m
[32m+[m[32m    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }[m
[32m+[m[32m    inline ImVector(const ImVector<T>& src)                 { Size = Capacity = 0; Data = NULL; operator=(src); }[m
[32m+[m[32m    inline ImVector<T>& operator=(const ImVector<T>& src)   { clear(); resize(src.Size); memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }[m
[32m+[m[32m    inline ~ImVector()                                      { if (Data) IM_FREE(Data); }[m
[32m+[m
[32m+[m[32m    inline bool         empty() const                       { return Size == 0; }[m
[32m+[m[32m    inline int          size() const                        { return Size; }[m
[32m+[m[32m    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }[m
[32m+[m[32m    inline int          capacity() const                    { return Capacity; }[m
[32m+[m[32m    inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }[m
[32m+[m[32m    inline const T&     operator[](int i) const             { IM_ASSERT(i < Size); return Data[i]; }[m
[32m+[m
[32m+[m[32m    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }[m
[32m+[m[32m    inline T*           begin()                             { return Data; }[m
[32m+[m[32m    inline const T*     begin() const                       { return Data; }[m
[32m+[m[32m    inline T*           end()                               { return Data + Size; }[m
[32m+[m[32m    inline const T*     end() const                         { return Data + Size; }[m
[32m+[m[32m    inline T&           front()                             { IM_ASSERT(Size > 0); return Data[0]; }[m
[32m+[m[32m    inline const T&     front() const                       { IM_ASSERT(Size > 0); return Data[0]; }[m
[32m+[m[32m    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }[m
[32m+[m[32m    inline const T&     back() const                        { IM_ASSERT(Size > 0); return Data[Size - 1]; }[m
[32m+[m[32m    inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }[m
[32m+[m
[32m+[m[32m    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > sz ? new_capacity : sz; }[m
[32m+[m[32m    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }[m
[32m+[m[32m    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }[m
[32m+[m[32m    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }[m
[32m+[m
[32m+[m[32m    // NB: It is illegal to call push_back/push_front/insert with a reference pointing inside the ImVector data itself! e.g. v.push_back(v[10]) is forbidden.[m
[32m+[m[32m    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }[m
[32m+[m[32m    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }[m
[32m+[m[32m    inline void         push_front(const T& v)              { if (Size == 0) push_back(v); else insert(Data, v); }[m
[32m+[m[32m    inline T*           erase(const T* it)                  { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }[m
[32m+[m[32m    inline T*           erase(const T* it, const T* it_last){ IM_ASSERT(it >= Data && it < Data+Size && it_last > it && it_last <= Data+Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - count) * sizeof(T)); Size -= (int)count; return Data + off; }[m
[32m+[m[32m    inline T*           erase_unsorted(const T* it)         { IM_ASSERT(it >= Data && it < Data+Size);  const ptrdiff_t off = it - Data; if (it < Data+Size-1) memcpy(Data + off, Data + Size - 1, sizeof(T)); Size--; return Data + off; }[m
[32m+[m[32m    inline T*           insert(const T* it, const T& v)     { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }[m
[32m+[m[32m    inline bool         contains(const T& v) const          { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }[m
[32m+[m[32m    inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; return (int)off; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// ImGuiStyle[m
[32m+[m[32m// You may modify the ImGui::GetStyle() main instance during initialization and before NewFrame().[m
[32m+[m[32m// During the frame, use ImGui::PushStyleVar(ImGuiStyleVar_XXXX)/PopStyleVar() to alter the main style values,[m
[32m+[m[32m// and ImGui::PushStyleColor(ImGuiCol_XXX)/PopStyleColor() for colors.[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mstruct ImGuiStyle[m
[32m+[m[32m{[m
[32m+[m[32m    float       Alpha;                      // Global alpha applies to everything in ImGui.[m
[32m+[m[32m    ImVec2      WindowPadding;              // Padding within a window.[m
[32m+[m[32m    float       WindowRounding;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows.[m
[32m+[m[32m    float       WindowBorderSize;           // Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).[m
[32m+[m[32m    ImVec2      WindowMinSize;              // Minimum window size. This is a global setting. If you want to constraint individual windows, use SetNextWindowSizeConstraints().[m
[32m+[m[32m    ImVec2      WindowTitleAlign;           // Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.[m
[32m+[m[32m    float       ChildRounding;              // Radius of child window corners rounding. Set to 0.0f to have rectangular windows.[m
[32m+[m[32m    float       ChildBorderSize;            // Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).[m
[32m+[m[32m    float       PopupRounding;              // Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)[m
[32m+[m[32m    float       PopupBorderSize;            // Thickness of border around popup/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).[m
[32m+[m[32m    ImVec2      FramePadding;               // Padding within a framed rectangle (used by most widgets).[m
[32m+[m[32m    float       FrameRounding;              // Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).[m
[32m+[m[32m    float       FrameBorderSize;            // Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).[m
[32m+[m[32m    ImVec2      ItemSpacing;                // Horizontal and vertical spacing between widgets/lines.[m
[32m+[m[32m    ImVec2      ItemInnerSpacing;           // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).[m
[32m+[m[32m    ImVec2      TouchExtraPadding;          // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much![m
[32m+[m[32m    float       IndentSpacing;              // Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).[m
[32m+[m[32m    float       ColumnsMinSpacing;          // Minimum horizontal spacing between two columns.[m
[32m+[m[32m    float       ScrollbarSize;              // Width of the vertical scrollbar, Height of the horizontal scrollbar.[m
[32m+[m[32m    float       ScrollbarRounding;          // Radius of grab corners for scrollbar.[m
[32m+[m[32m    float       GrabMinSize;                // Minimum width/height of a grab box for slider/scrollbar.[m
[32m+[m[32m    float       GrabRounding;               // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.[m
[32m+[m[32m    float       TabRounding;                // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.[m
[32m+[m[32m    float       TabBorderSize;              // Thickness of border around tabs.[m
[32m+[m[32m    ImVec2      ButtonTextAlign;            // Alignment of button text when button is larger than text. Defaults to (0.5f, 0.5f) (centered).[m
[32m+[m[32m    ImVec2      SelectableTextAlign;        // Alignment of selectable text when selectable is larger than text. Defaults to (0.0f, 0.0f) (top-left aligned).[m
[32m+[m[32m    ImVec2      DisplayWindowPadding;       // Window position are clamped to be visible within the display area by at least this amount. Only applies to regular windows.[m
[32m+[m[32m    ImVec2      DisplaySafeAreaPadding;     // If you cannot see the edges of your screen (e.g. on a TV) increase the safe area padding. Apply to popups/tooltips as well regular windows. NB: Prefer configuring your TV sets correctly![m
[32m+[m[32m    float       MouseCursorScale;           // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.[m
[32m+[m[32m    bool        AntiAliasedLines;           // Enable anti-aliasing on lines/borders. Disable if you are really tight on CPU/GPU.[m
[32m+[m[32m    bool        AntiAliasedFill;            // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)[m
[32m+[m[32m    float       CurveTessellationTol;       // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.[m
[32m+[m[32m    ImVec4      Colors[ImGuiCol_COUNT];[m
[32m+[m
[32m+[m[32m    IMGUI_API ImGuiStyle();[m
[32m+[m[32m    IMGUI_API void ScaleAllSizes(float scale_factor);[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// ImGuiIO[m
[32m+[m[32m// Communicate most settings and inputs/outputs to Dear ImGui using this structure.[m
[32m+[m[32m// Access via ImGui::GetIO(). Read 'Programmer guide' section in .cpp file for general usage.[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mstruct ImGuiIO[m
[32m+[m[32m{[m
[32m+[m[32m    //------------------------------------------------------------------[m
[32m+[m[32m    // Configuration (fill once)                // Default value[m
[32m+[m[32m    //------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m    ImGuiConfigFlags   ConfigFlags;             // = 0              // See ImGuiConfigFlags_ enum. Set by user/application. Gamepad/keyboard navigation options, etc.[m
[32m+[m[32m    ImGuiBackendFlags  BackendFlags;            // = 0              // See ImGuiBackendFlags_ enum. Set by back-end (imgui_impl_xxx files or custom back-end) to communicate features supported by the back-end.[m
[32m+[m[32m    ImVec2      DisplaySize;                    // <unset>          // Main display size, in pixels.[m
[32m+[m[32m    float       DeltaTime;                      // = 1.0f/60.0f     // Time elapsed since last frame, in seconds.[m
[32m+[m[32m    float       IniSavingRate;                  // = 5.0f           // Minimum time between saving positions/sizes to .ini file, in seconds.[m
[32m+[m[32m    const char* IniFilename;                    // = "imgui.ini"    // Path to .ini file. Set NULL to disable automatic .ini loading/saving, if e.g. you want to manually load/save from memory.[m
[32m+[m[32m    const char* LogFilename;                    // = "imgui_log.txt"// Path to .log file (default parameter to ImGui::LogToFile when no file is specified).[m
[32m+[m[32m    float       MouseDoubleClickTime;           // = 0.30f          // Time for a double-click, in seconds.[m
[32m+[m[32m    float       MouseDoubleClickMaxDist;        // = 6.0f           // Distance threshold to stay in to validate a double-click, in pixels.[m
[32m+[m[32m    float       MouseDragThreshold;             // = 6.0f           // Distance threshold before considering we are dragging.[m
[32m+[m[32m    int         KeyMap[ImGuiKey_COUNT];         // <unset>          // Map of indices into the KeysDown[512] entries array which represent your "native" keyboard state.[m
[32m+[m[32m    float       KeyRepeatDelay;                 // = 0.250f         // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).[m
[32m+[m[32m    float       KeyRepeatRate;                  // = 0.050f         // When holding a key/button, rate at which it repeats, in seconds.[m
[32m+[m[32m    void*       UserData;                       // = NULL           // Store your own data for retrieval by callbacks.[m
[32m+[m
[32m+[m[32m    ImFontAtlas*Fonts;                          // <auto>           // Load, rasterize and pack one or more fonts into a single texture.[m
[32m+[m[32m    float       FontGlobalScale;                // = 1.0f           // Global scale all fonts[m
[32m+[m[32m    bool        FontAllowUserScaling;           // = false          // Allow user scaling text of individual window with CTRL+Wheel.[m
[32m+[m[32m    ImFont*     FontDefault;                    // = NULL           // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].[m
[32m+[m[32m    ImVec2      DisplayFramebufferScale;        // = (1, 1)         // For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.[m
[32m+[m
[32m+[m[32m    // Miscellaneous options[m
[32m+[m[32m    bool        MouseDrawCursor;                // = false          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by back-end implementations.[m
[32m+[m[32m    bool        ConfigMacOSXBehaviors;          // = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl (was called io.OptMacOSXBehaviors prior to 1.63)[m
[32m+[m[32m    bool        ConfigInputTextCursorBlink;     // = true           // Set to false to disable blinking cursor, for users who consider it distracting. (was called: io.OptCursorBlink prior to 1.63)[m
[32m+[m[32m    bool        ConfigWindowsResizeFromEdges;   // = true           // Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)[m
[32m+[m[32m    bool        ConfigWindowsMoveFromTitleBarOnly; // = false       // [BETA] Set to true to only allow moving windows when clicked+dragged from the title bar. Windows without a title bar are not affected.[m
[32m+[m
[32m+[m[32m    //------------------------------------------------------------------[m
[32m+[m[32m    // Platform Functions[m
[32m+[m[32m    // (the imgui_impl_xxxx back-end files are setting those up for you)[m
[32m+[m[32m    //------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m    // Optional: Platform/Renderer back-end name (informational only! will be displayed in About Window) + User data for back-end/wrappers to store their own stuff.[m
[32m+[m[32m    const char* BackendPlatformName;            // = NULL[m
[32m+[m[32m    const char* BackendRendererName;            // = NULL[m
[32m+[m[32m    void*       BackendPlatformUserData;        // = NULL[m
[32m+[m[32m    void*       BackendRendererUserData;        // = NULL[m
[32m+[m[32m    void*       BackendLanguageUserData;        // = NULL[m
[32m+[m
[32m+[m[32m    // Optional: Access OS clipboard[m
[32m+[m[32m    // (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)[m
[32m+[m[32m    const char* (*GetClipboardTextFn)(void* user_data);[m
[32m+[m[32m    void        (*SetClipboardTextFn)(void* user_data, const char* text);[m
[32m+[m[32m    void*       ClipboardUserData;[m
[32m+[m
[32m+[m[32m    // Optional: Notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME on Windows)[m
[32m+[m[32m    // (default to use native imm32 api on Windows)[m
[32m+[m[32m    void        (*ImeSetInputScreenPosFn)(int x, int y);[m
[32m+[m[32m    void*       ImeWindowHandle;                // = NULL           // (Windows) Set this to your HWND to get automatic IME cursor positioning.[m
[32m+[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32m    // [OBSOLETE since 1.60+] Rendering function, will be automatically called in Render(). Please call your rendering function yourself now![m
[32m+[m[32m    // You can obtain the ImDrawData* by calling ImGui::GetDrawData() after Render(). See example applications if you are unsure of how to implement this.[m
[32m+[m[32m    void        (*RenderDrawListsFn)(ImDrawData* data);[m
[32m+[m[32m#else[m
[32m+[m[32m    // This is only here to keep ImGuiIO the same size/layout, so that IMGUI_DISABLE_OBSOLETE_FUNCTIONS can exceptionally be used outside of imconfig.h.[m
[32m+[m[32m    void*       RenderDrawListsFnUnused;[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m    //------------------------------------------------------------------[m
[32m+[m[32m    // Input - Fill before calling NewFrame()[m
[32m+[m[32m    //------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m    ImVec2      MousePos;                       // Mouse position, in pixels. Set to ImVec2(-FLT_MAX,-FLT_MAX) if mouse is unavailable (on another screen, etc.)[m
[32m+[m[32m    bool        MouseDown[5];                   // Mouse buttons: 0=left, 1=right, 2=middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.[m
[32m+[m[32m    float       MouseWheel;                     // Mouse wheel Vertical: 1 unit scrolls about 5 lines text.[m
[32m+[m[32m    float       MouseWheelH;                    // Mouse wheel Horizontal. Most users don't have a mouse with an horizontal wheel, may not be filled by all back-ends.[m
[32m+[m[32m    bool        KeyCtrl;                        // Keyboard modifier pressed: Control[m
[32m+[m[32m    bool        KeyShift;                       // Keyboard modifier pressed: Shift[m
[32m+[m[32m    bool        KeyAlt;                         // Keyboard modifier pressed: Alt[m
[32m+[m[32m    bool        KeySuper;                       // Keyboard modifier pressed: Cmd/Super/Windows[m
[32m+[m[32m    bool        KeysDown[512];                  // Keyboard keys that are pressed (ideally left in the "native" order your engine has access to keyboard keys, so you can use your own defines/enums for keys).[m
[32m+[m[32m    float       NavInputs[ImGuiNavInput_COUNT]; // Gamepad inputs. Cleared back to zero by EndFrame(). Keyboard keys will be auto-mapped and be written here by NewFrame().[m
[32m+[m
[32m+[m[32m    // Functions[m
[32m+[m[32m    IMGUI_API void  AddInputCharacter(ImWchar c);               // Queue new character input[m
[32m+[m[32m    IMGUI_API void  AddInputCharactersUTF8(const char* str);    // Queue new characters input from an UTF-8 string[m
[32m+[m[32m    IMGUI_API void  ClearInputCharacters();                     // Clear the text input buffer manually[m
[32m+[m
[32m+[m[32m    //------------------------------------------------------------------[m
[32m+[m[32m    // Output - Retrieve after calling NewFrame()[m
[32m+[m[32m    //------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m    bool        WantCaptureMouse;               // When io.WantCaptureMouse is true, imgui will use the mouse inputs, do not dispatch them to your main game/application (in both cases, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).[m
[32m+[m[32m    bool        WantCaptureKeyboard;            // When io.WantCaptureKeyboard is true, imgui will use the keyboard inputs, do not dispatch them to your main game/application (in both cases, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).[m
[32m+[m[32m    bool        WantTextInput;                  // Mobile/console: when io.WantTextInput is true, you may display an on-screen keyboard. This is set by ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).[m
[32m+[m[32m    bool        WantSetMousePos;                // MousePos has been altered, back-end should reposition mouse on next frame. Set only when ImGuiConfigFlags_NavEnableSetMousePos flag is enabled.[m
[32m+[m[32m    bool        WantSaveIniSettings;            // When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. IMPORTANT: You need to clear io.WantSaveIniSettings yourself.[m
[32m+[m[32m    bool        NavActive;                      // Directional navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.[m
[32m+[m[32m    bool        NavVisible;                     // Directional navigation is visible and allowed (will handle ImGuiKey_NavXXX events).[m
[32m+[m[32m    float       Framerate;                      // Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames[m
[32m+[m[32m    int         MetricsRenderVertices;          // Vertices output during last call to Render()[m
[32m+[m[32m    int         MetricsRenderIndices;           // Indices output during last call to Render() = number of triangles * 3[m
[32m+[m[32m    int         MetricsRenderWindows;           // Number of visible windows[m
[32m+[m[32m    int         MetricsActiveWindows;           // Number of active windows[m
[32m+[m[32m    int         MetricsActiveAllocations;       // Number of active allocations, updated by MemAlloc/MemFree based on current context. May be off if you have multiple imgui contexts.[m
[32m+[m[32m    ImVec2      MouseDelta;                     // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.[m
[32m+[m
[32m+[m[32m    //------------------------------------------------------------------[m
[32m+[m[32m    // [Internal] ImGui will maintain those fields. Forward compatibility not guaranteed![m
[32m+[m[32m    //------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m    ImVec2      MousePosPrev;                   // Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)[m
[32m+[m[32m    ImVec2      MouseClickedPos[5];             // Position at time of clicking[m
[32m+[m[32m    double      MouseClickedTime[5];            // Time of last click (used to figure out double-click)[m
[32m+[m[32m    bool        MouseClicked[5];                // Mouse button went from !Down to Down[m
[32m+[m[32m    bool        MouseDoubleClicked[5];          // Has mouse button been double-clicked?[m
[32m+[m[32m    bool        MouseReleased[5];               // Mouse button went from Down to !Down[m
[32m+[m[32m    bool        MouseDownOwned[5];              // Track if button was clicked inside an imgui window. We don't request mouse capture from the application if click started outside ImGui bounds.[m
[32m+[m[32m    bool        MouseDownWasDoubleClick[5];     // Track if button down was a double-click[m
[32m+[m[32m    float       MouseDownDuration[5];           // Duration the mouse button has been down (0.0f == just clicked)[m
[32m+[m[32m    float       MouseDownDurationPrev[5];       // Previous time the mouse button has been down[m
[32m+[m[32m    ImVec2      MouseDragMaxDistanceAbs[5];     // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point[m
[32m+[m[32m    float       MouseDragMaxDistanceSqr[5];     // Squared maximum distance of how much mouse has traveled from the clicking point[m
[32m+[m[32m    float       KeysDownDuration[512];          // Duration the keyboard key has been down (0.0f == just pressed)[m
[32m+[m[32m    float       KeysDownDurationPrev[512];      // Previous duration the key has been down[m
[32m+[m[32m    float       NavInputsDownDuration[ImGuiNavInput_COUNT];[m
[32m+[m[32m    float       NavInputsDownDurationPrev[ImGuiNavInput_COUNT];[m
[32m+[m[32m    ImVector<ImWchar> InputQueueCharacters;     // Queue of _characters_ input (obtained by platform back-end). Fill using AddInputCharacter() helper.[m
[32m+[m
[32m+[m[32m    IMGUI_API   ImGuiIO();[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Misc data structures[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.[m
[32m+[m[32m// The callback function should return 0 by default.[m
[32m+[m[32m// Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)[m
[32m+[m[32m// - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB[m
[32m+[m[32m// - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows[m
[32m+[m[32m// - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration[m
[32m+[m[32m// - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.[m
[32m+[m[32m// - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.[m
[32m+[m[32mstruct ImGuiInputTextCallbackData[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiInputTextFlags EventFlag;      // One ImGuiInputTextFlags_Callback*    // Read-only[m
[32m+[m[32m    ImGuiInputTextFlags Flags;          // What user passed to InputText()      // Read-only[m
[32m+[m[32m    void*               UserData;       // What user passed to InputText()      // Read-only[m
[32m+[m
[32m+[m[32m    // Arguments for the different callback events[m
[32m+[m[32m    // - To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.[m
[32m+[m[32m    // - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize) and set 'BufDirty'' to true so InputText can update its internal state.[m
[32m+[m[32m    ImWchar             EventChar;      // Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;[m
[32m+[m[32m    ImGuiKey            EventKey;       // Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History][m
[32m+[m[32m    char*               Buf;            // Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer![m
[32m+[m[32m    int                 BufTextLen;     // Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()[m
[32m+[m[32m    int                 BufSize;        // Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1[m
[32m+[m[32m    bool                BufDirty;       // Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always][m
[32m+[m[32m    int                 CursorPos;      //                                      // Read-write   // [Completion,History,Always][m
[32m+[m[32m    int                 SelectionStart; //                                      // Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)[m
[32m+[m[32m    int                 SelectionEnd;   //                                      // Read-write   // [Completion,History,Always][m
[32m+[m
[32m+[m[32m    // Helper functions for text manipulation.[m
[32m+[m[32m    // Use those function to benefit from the CallbackResize behaviors. Calling those function reset the selection.[m
[32m+[m[32m    IMGUI_API ImGuiInputTextCallbackData();[m
[32m+[m[32m    IMGUI_API void      DeleteChars(int pos, int bytes_count);[m
[32m+[m[32m    IMGUI_API void      InsertChars(int pos, const char* text, const char* text_end = NULL);[m
[32m+[m[32m    bool                HasSelection() const { return SelectionStart != SelectionEnd; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().[m
[32m+[m[32m// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.[m
[32m+[m[32mstruct ImGuiSizeCallbackData[m
[32m+[m[32m{[m
[32m+[m[32m    void*   UserData;       // Read-only.   What user passed to SetNextWindowSizeConstraints()[m
[32m+[m[32m    ImVec2  Pos;            // Read-only.   Window position, for reference.[m
[32m+[m[32m    ImVec2  CurrentSize;    // Read-only.   Current window size.[m
[32m+[m[32m    ImVec2  DesiredSize;    // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()[m
[32m+[m[32mstruct ImGuiPayload[m
[32m+[m[32m{[m
[32m+[m[32m    // Members[m
[32m+[m[32m    void*           Data;               // Data (copied and owned by dear imgui)[m
[32m+[m[32m    int             DataSize;           // Data size[m
[32m+[m
[32m+[m[32m    // [Internal][m
[32m+[m[32m    ImGuiID         SourceId;           // Source item id[m
[32m+[m[32m    ImGuiID         SourceParentId;     // Source parent id (if available)[m
[32m+[m[32m    int             DataFrameCount;     // Data timestamp[m
[32m+[m[32m    char            DataType[32+1];     // Data type tag (short user-supplied string, 32 characters max)[m
[32m+[m[32m    bool            Preview;            // Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)[m
[32m+[m[32m    bool            Delivery;           // Set when AcceptDragDropPayload() was called and mouse button is released over the target item.[m
[32m+[m
[32m+[m[32m    ImGuiPayload()  { Clear(); }[m
[32m+[m[32m    void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }[m
[32m+[m[32m    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }[m
[32m+[m[32m    bool IsPreview() const                  { return Preview; }[m
[32m+[m[32m    bool IsDelivery() const                 { return Delivery; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Obsolete functions (Will be removed! Read 'API BREAKING CHANGES' section in imgui.cpp for details)[m
[32m+[m[32m// Please keep your copy of dear imgui up to date! Occasionally set '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' in imconfig.h to stay ahead.[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32mnamespace ImGui[m
[32m+[m[32m{[m
[32m+[m[32m    // OBSOLETED in 1.70 (from May 2019)[m
[32m+[m[32m    static inline float GetContentRegionAvailWidth()          { return GetContentRegionAvail().x; }[m
[32m+[m[32m    // OBSOLETED in 1.69 (from Mar 2019)[m
[32m+[m[32m    static inline ImDrawList* GetOverlayDrawList()            { return GetForegroundDrawList(); }[m
[32m+[m[32m    // OBSOLETED in 1.66 (from Sep 2018)[m
[32m+[m[32m    static inline void  SetScrollHere(float center_ratio=0.5f){ SetScrollHereY(center_ratio); }[m
[32m+[m[32m    // OBSOLETED in 1.63 (between Aug 2018 and Sept 2018)[m
[32m+[m[32m    static inline bool  IsItemDeactivatedAfterChange()        { return IsItemDeactivatedAfterEdit(); }[m
[32m+[m[32m    // OBSOLETED in 1.61 (between Apr 2018 and Aug 2018)[m
[32m+[m[32m    IMGUI_API bool      InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags flags = 0); // Use the 'const char* format' version instead of 'decimal_precision'![m
[32m+[m[32m    IMGUI_API bool      InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool      InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool      InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags flags = 0);[m
[32m+[m[32m    // OBSOLETED in 1.60 (between Dec 2017 and Apr 2018)[m
[32m+[m[32m    static inline bool  IsAnyWindowFocused()                  { return IsWindowFocused(ImGuiFocusedFlags_AnyWindow); }[m
[32m+[m[32m    static inline bool  IsAnyWindowHovered()                  { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }[m
[32m+[m[32m    static inline ImVec2 CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge = false, float outward = 0.f) { IM_UNUSED(on_edge); IM_UNUSED(outward); IM_ASSERT(0); return pos; }[m
[32m+[m[32m    // OBSOLETED in 1.53 (between Oct 2017 and Dec 2017)[m
[32m+[m[32m    static inline void  ShowTestWindow()                      { return ShowDemoWindow(); }[m
[32m+[m[32m    static inline bool  IsRootWindowFocused()                 { return IsWindowFocused(ImGuiFocusedFlags_RootWindow); }[m
[32m+[m[32m    static inline bool  IsRootWindowOrAnyChildFocused()       { return IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows); }[m
[32m+[m[32m    static inline void  SetNextWindowContentWidth(float w)    { SetNextWindowContentSize(ImVec2(w, 0.0f)); }[m
[32m+[m[32m    static inline float GetItemsLineHeightWithSpacing()       { return GetFrameHeightWithSpacing(); }[m
[32m+[m[32m    // OBSOLETED in 1.52 (between Aug 2017 and Oct 2017)[m
[32m+[m[32m    IMGUI_API bool      Begin(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha_override = -1.0f, ImGuiWindowFlags flags = 0); // Use SetNextWindowSize(size, ImGuiCond_FirstUseEver) + SetNextWindowBgAlpha() instead.[m
[32m+[m[32m    static inline bool  IsRootWindowOrAnyChildHovered()       { return IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows); }[m
[32m+[m[32m    static inline void  AlignFirstTextHeightToWidgets()       { AlignTextToFramePadding(); }[m
[32m+[m[32m    static inline void  SetNextWindowPosCenter(ImGuiCond c=0) { ImGuiIO& io = GetIO(); SetNextWindowPos(ImVec2(io.DisplaySize.x * 0.5f, io.DisplaySize.y * 0.5f), c, ImVec2(0.5f, 0.5f)); }[m
[32m+[m[32m    // OBSOLETED in 1.51 (between Jun 2017 and Aug 2017)[m
[32m+[m[32m    static inline bool  IsItemHoveredRect()                   { return IsItemHovered(ImGuiHoveredFlags_RectOnly); }[m
[32m+[m[32m    static inline bool  IsPosHoveringAnyWindow(const ImVec2&) { IM_ASSERT(0); return false; } // This was misleading and partly broken. You probably want to use the ImGui::GetIO().WantCaptureMouse flag instead.[m
[32m+[m[32m    static inline bool  IsMouseHoveringAnyWindow()            { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }[m
[32m+[m[32m    static inline bool  IsMouseHoveringWindow()               { return IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem); }[m
[32m+[m[32m}[m
[32m+[m[32mtypedef ImGuiInputTextCallback      ImGuiTextEditCallback;    // OBSOLETE in 1.63 (from Aug 2018): made the names consistent[m
[32m+[m[32mtypedef ImGuiInputTextCallbackData  ImGuiTextEditCallbackData;[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Helpers[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create an UI within deep-nested code that runs multiple times every frame.[m
[32m+[m[32m// Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text("This will be called only once per frame");[m
[32m+[m[32mstruct ImGuiOnceUponAFrame[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiOnceUponAFrame() { RefFrame = -1; }[m
[32m+[m[32m    mutable int RefFrame;[m
[32m+[m[32m    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Helper: Macro for ImGuiOnceUponAFrame. Attention: The macro expands into 2 statement so make sure you don't use it within e.g. an if() statement without curly braces.[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32m#define IMGUI_ONCE_UPON_A_FRAME     static ImGuiOnceUponAFrame imgui_oaf; if (imgui_oaf)    // OBSOLETED in 1.51, will remove![m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"[m
[32m+[m[32mstruct ImGuiTextFilter[m
[32m+[m[32m{[m
[32m+[m[32m    IMGUI_API           ImGuiTextFilter(const char* default_filter = "");[m
[32m+[m[32m    IMGUI_API bool      Draw(const char* label = "Filter (inc,-exc)", float width = 0.0f);  // Helper calling InputText+Build[m
[32m+[m[32m    IMGUI_API bool      PassFilter(const char* text, const char* text_end = NULL) const;[m
[32m+[m[32m    IMGUI_API void      Build();[m
[32m+[m[32m    void                Clear()          { InputBuf[0] = 0; Build(); }[m
[32m+[m[32m    bool                IsActive() const { return !Filters.empty(); }[m
[32m+[m
[32m+[m[32m    // [Internal][m
[32m+[m[32m    struct TextRange[m
[32m+[m[32m    {[m
[32m+[m[32m        const char* b;[m
[32m+[m[32m        const char* e;[m
[32m+[m
[32m+[m[32m        TextRange() { b = e = NULL; }[m
[32m+[m[32m        TextRange(const char* _b, const char* _e) { b = _b; e = _e; }[m
[32m+[m[32m        const char*     begin() const   { return b; }[m
[32m+[m[32m        const char*     end () const    { return e; }[m
[32m+[m[32m        bool            empty() const   { return b == e; }[m
[32m+[m[32m        IMGUI_API void  split(char separator, ImVector<TextRange>* out) const;[m
[32m+[m[32m    };[m
[32m+[m[32m    char                InputBuf[256];[m
[32m+[m[32m    ImVector<TextRange> Filters;[m
[32m+[m[32m    int                 CountGrep;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Helper: Growable text buffer for logging/accumulating text[m
[32m+[m[32m// (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')[m
[32m+[m[32mstruct ImGuiTextBuffer[m
[32m+[m[32m{[m
[32m+[m[32m    ImVector<char>      Buf;[m
[32m+[m[32m    static char         EmptyString[1];[m
[32m+[m
[32m+[m[32m    ImGuiTextBuffer()   { }[m
[32m+[m[32m    inline char         operator[](int i)       { IM_ASSERT(Buf.Data != NULL); return Buf.Data[i]; }[m
[32m+[m[32m    const char*         begin() const           { return Buf.Data ? &Buf.front() : EmptyString; }[m
[32m+[m[32m    const char*         end() const             { return Buf.Data ? &Buf.back() : EmptyString; }   // Buf is zero-terminated, so end() will point on the zero-terminator[m
[32m+[m[32m    int                 size() const            { return Buf.Size ? Buf.Size - 1 : 0; }[m
[32m+[m[32m    bool                empty()                 { return Buf.Size <= 1; }[m
[32m+[m[32m    void                clear()                 { Buf.clear(); }[m
[32m+[m[32m    void                reserve(int capacity)   { Buf.reserve(capacity); }[m
[32m+[m[32m    const char*         c_str() const           { return Buf.Data ? Buf.Data : EmptyString; }[m
[32m+[m[32m    IMGUI_API void      append(const char* str, const char* str_end = NULL);[m
[32m+[m[32m    IMGUI_API void      appendf(const char* fmt, ...) IM_FMTARGS(2);[m
[32m+[m[32m    IMGUI_API void      appendfv(const char* fmt, va_list args) IM_FMTLIST(2);[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Helper: Key->Value storage[m
[32m+[m[32m// Typically you don't have to worry about this since a storage is held within each Window.[m
[32m+[m[32m// We use it to e.g. store collapse state for a tree (Int 0/1)[m
[32m+[m[32m// This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)[m
[32m+[m[32m// You can use it as custom user storage for temporary values. Declare your own storage if, for example:[m
[32m+[m[32m// - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).[m
[32m+[m[32m// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)[m
[32m+[m[32m// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.[m
[32m+[m[32mstruct ImGuiStorage[m
[32m+[m[32m{[m
[32m+[m[32m    struct Pair[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiID key;[m
[32m+[m[32m        union { int val_i; float val_f; void* val_p; };[m
[32m+[m[32m        Pair(ImGuiID _key, int _val_i)   { key = _key; val_i = _val_i; }[m
[32m+[m[32m        Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }[m
[32m+[m[32m        Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }[m
[32m+[m[32m    };[m
[32m+[m[32m    ImVector<Pair>      Data;[m
[32m+[m
[32m+[m[32m    // - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)[m
[32m+[m[32m    // - Set***() functions find pair, insertion on demand if missing.[m
[32m+[m[32m    // - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.[m
[32m+[m[32m    void                Clear() { Data.clear(); }[m
[32m+[m[32m    IMGUI_API int       GetInt(ImGuiID key, int default_val = 0) const;[m
[32m+[m[32m    IMGUI_API void      SetInt(ImGuiID key, int val);[m
[32m+[m[32m    IMGUI_API bool      GetBool(ImGuiID key, bool default_val = false) const;[m
[32m+[m[32m    IMGUI_API void      SetBool(ImGuiID key, bool val);[m
[32m+[m[32m    IMGUI_API float     GetFloat(ImGuiID key, float default_val = 0.0f) const;[m
[32m+[m[32m    IMGUI_API void      SetFloat(ImGuiID key, float val);[m
[32m+[m[32m    IMGUI_API void*     GetVoidPtr(ImGuiID key) const; // default_val is NULL[m
[32m+[m[32m    IMGUI_API void      SetVoidPtr(ImGuiID key, void* val);[m
[32m+[m
[32m+[m[32m    // - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.[m
[32m+[m[32m    // - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.[m
[32m+[m[32m    // - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)[m
[32m+[m[32m    //      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat("var", pvar, 0, 100.0f); some_var += *pvar;[m
[32m+[m[32m    IMGUI_API int*      GetIntRef(ImGuiID key, int default_val = 0);[m
[32m+[m[32m    IMGUI_API bool*     GetBoolRef(ImGuiID key, bool default_val = false);[m
[32m+[m[32m    IMGUI_API float*    GetFloatRef(ImGuiID key, float default_val = 0.0f);[m
[32m+[m[32m    IMGUI_API void**    GetVoidPtrRef(ImGuiID key, void* default_val = NULL);[m
[32m+[m
[32m+[m[32m    // Use on your own storage if you know only integer are being stored (open/close all tree nodes)[m
[32m+[m[32m    IMGUI_API void      SetAllInt(int val);[m
[32m+[m
[32m+[m[32m    // For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.[m
[32m+[m[32m    IMGUI_API void      BuildSortByKey();[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Helper: Manually clip large list of items.[m
[32m+[m[32m// If you are submitting lots of evenly spaced items and you have a random access to the list, you can perform coarse clipping based on visibility to save yourself from processing those items at all.[m
[32m+[m[32m// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.[m
[32m+[m[32m// ImGui already clip items based on their bounds but it needs to measure text size to do so. Coarse clipping before submission makes this cost and your own data fetching/submission cost null.[m
[32m+[m[32m// Usage:[m
[32m+[m[32m//     ImGuiListClipper clipper(1000);  // we have 1000 elements, evenly spaced.[m
[32m+[m[32m//     while (clipper.Step())[m
[32m+[m[32m//         for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)[m
[32m+[m[32m//             ImGui::Text("line number %d", i);[m
[32m+[m[32m// - Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height (step skipped if we passed a known height as second arg to constructor).[m
[32m+[m[32m// - Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.[m
[32m+[m[32m// - (Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user call Step(). Does nothing and switch to Step 3.)[m
[32m+[m[32m// - Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.[m
[32m+[m[32mstruct ImGuiListClipper[m
[32m+[m[32m{[m
[32m+[m[32m    float   StartPosY;[m
[32m+[m[32m    float   ItemsHeight;[m
[32m+[m[32m    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;[m
[32m+[m
[32m+[m[32m    // items_count:  Use -1 to ignore (you can call Begin later). Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step).[m
[32m+[m[32m    // items_height: Use -1.0f to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetFrameHeightWithSpacing().[m
[32m+[m[32m    // If you don't specify an items_height, you NEED to call Step(). If you specify items_height you may call the old Begin()/End() api directly, but prefer calling Step().[m
[32m+[m[32m    ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).[m
[32m+[m[32m    ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.[m
[32m+[m
[32m+[m[32m    IMGUI_API bool Step();                                              // Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.[m
[32m+[m[32m    IMGUI_API void Begin(int items_count, float items_height = -1.0f);  // Automatically called by constructor if you passed 'items_count' or by Step() in Step 1.[m
[32m+[m[32m    IMGUI_API void End();                                               // Automatically called on the last call of Step() that returns false.[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Helpers macros to generate 32-bits encoded colors[m
[32m+[m[32m#ifdef IMGUI_USE_BGRA_PACKED_COLOR[m
[32m+[m[32m#define IM_COL32_R_SHIFT    16[m
[32m+[m[32m#define IM_COL32_G_SHIFT    8[m
[32m+[m[32m#define IM_COL32_B_SHIFT    0[m
[32m+[m[32m#define IM_COL32_A_SHIFT    24[m
[32m+[m[32m#define IM_COL32_A_MASK     0xFF000000[m
[32m+[m[32m#else[m
[32m+[m[32m#define IM_COL32_R_SHIFT    0[m
[32m+[m[32m#define IM_COL32_G_SHIFT    8[m
[32m+[m[32m#define IM_COL32_B_SHIFT    16[m
[32m+[m[32m#define IM_COL32_A_SHIFT    24[m
[32m+[m[32m#define IM_COL32_A_MASK     0xFF000000[m
[32m+[m[32m#endif[m
[32m+[m[32m#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))[m
[32m+[m[32m#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF[m
[32m+[m[32m#define IM_COL32_BLACK       IM_COL32(0,0,0,255)        // Opaque black[m
[32m+[m[32m#define IM_COL32_BLACK_TRANS IM_COL32(0,0,0,0)          // Transparent black = 0x00000000[m
[32m+[m
[32m+[m[32m// Helper: ImColor() implicitly converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)[m
[32m+[m[32m// Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.[m
[32m+[m[32m// **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.[m
[32m+[m[32m// **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.[m
[32m+[m[32mstruct ImColor[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec4              Value;[m
[32m+[m
[32m+[m[32m    ImColor()                                                       { Value.x = Value.y = Value.z = Value.w = 0.0f; }[m
[32m+[m[32m    ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }[m
[32m+[m[32m    ImColor(ImU32 rgba)                                             { float sc = 1.0f/255.0f; Value.x = (float)((rgba>>IM_COL32_R_SHIFT)&0xFF) * sc; Value.y = (float)((rgba>>IM_COL32_G_SHIFT)&0xFF) * sc; Value.z = (float)((rgba>>IM_COL32_B_SHIFT)&0xFF) * sc; Value.w = (float)((rgba>>IM_COL32_A_SHIFT)&0xFF) * sc; }[m
[32m+[m[32m    ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }[m
[32m+[m[32m    ImColor(const ImVec4& col)                                      { Value = col; }[m
[32m+[m[32m    inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }[m
[32m+[m[32m    inline operator ImVec4() const                                  { return Value; }[m
[32m+[m
[32m+[m[32m    // FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.[m
[32m+[m[32m    inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }[m
[32m+[m[32m    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Draw List API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListFlags, ImDrawList, ImDrawData)[m
[32m+[m[32m// Hold a series of drawing commands. The user provides a renderer for ImDrawData which essentially contains an array of ImDrawList.[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Draw callbacks for advanced uses.[m
[32m+[m[32m// NB: You most likely do NOT need to use draw callbacks just to create your own widget or customized UI rendering,[m
[32m+[m[32m// you can poke into the draw list for that! Draw callback may be useful for example to:[m[41m [m
[32m+[m[32m//  A) Change your GPU render state,[m
[32m+[m[32m//  B) render a complex 3D scene inside a UI element without an intermediate texture/render target, etc.[m
[32m+[m[32m// The expected behavior from your rendering function is 'if (cmd.UserCallback != NULL) { cmd.UserCallback(parent_list, cmd); } else { RenderTriangles() }'[m
[32m+[m[32mtypedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);[m
[32m+[m
[32m+[m[32m// Special Draw Callback value to request renderer back-end to reset the graphics/render state.[m
[32m+[m[32m// The renderer back-end needs to handle this special value, otherwise it will crash trying to call a function at this address.[m
[32m+[m[32m// This is useful for example if you submitted callbacks which you know have altered the render state and you want it to be restored.[m
[32m+[m[32m// It is not done by default because they are many perfectly useful way of altering render state for imgui contents (e.g. changing shader/blending settings before an Image call).[m
[32m+[m[32m#define ImDrawCallback_ResetRenderState     (ImDrawCallback)(-1)[m
[32m+[m
[32m+[m[32m// Typically, 1 command = 1 GPU draw call (unless command is a callback)[m
[32m+[m[32mstruct ImDrawCmd[m
[32m+[m[32m{[m
[32m+[m[32m    unsigned int    ElemCount;              // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].[m
[32m+[m[32m    ImVec4          ClipRect;               // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in "viewport" coordinates[m
[32m+[m[32m    ImTextureID     TextureId;              // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.[m
[32m+[m[32m    ImDrawCallback  UserCallback;           // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.[m
[32m+[m[32m    void*           UserCallbackData;       // The draw callback code can access this.[m
[32m+[m
[32m+[m[32m    ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = ClipRect.z = ClipRect.w = 0.0f; TextureId = (ImTextureID)NULL; UserCallback = NULL; UserCallbackData = NULL; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Vertex index (override with '#define ImDrawIdx unsigned int' in imconfig.h)[m
[32m+[m[32m#ifndef ImDrawIdx[m
[32m+[m[32mtypedef unsigned short ImDrawIdx;[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Vertex layout[m
[32m+[m[32m#ifndef IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT[m
[32m+[m[32mstruct ImDrawVert[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2  pos;[m
[32m+[m[32m    ImVec2  uv;[m
[32m+[m[32m    ImU32   col;[m
[32m+[m[32m};[m
[32m+[m[32m#else[m
[32m+[m[32m// You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h[m
[32m+[m[32m// The code expect ImVec2 pos (8 bytes), ImVec2 uv (8 bytes), ImU32 col (4 bytes), but you can re-order them or add other fields as needed to simplify integration in your engine.[m
[32m+[m[32m// The type has to be described within the macro (you can either declare the struct or use a typedef)[m
[32m+[m[32m// NOTE: IMGUI DOESN'T CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM.[m
[32m+[m[32mIMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT;[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Draw channels are used by the Columns API to "split" the render list into different channels while building, so items of each column can be batched together.[m
[32m+[m[32m// You can also use them to simulate drawing layers and submit primitives in a different order than how they will be rendered.[m
[32m+[m[32mstruct ImDrawChannel[m
[32m+[m[32m{[m
[32m+[m[32m    ImVector<ImDrawCmd>     CmdBuffer;[m
[32m+[m[32m    ImVector<ImDrawIdx>     IdxBuffer;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImDrawCornerFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImDrawCornerFlags_TopLeft   = 1 << 0, // 0x1[m
[32m+[m[32m    ImDrawCornerFlags_TopRight  = 1 << 1, // 0x2[m
[32m+[m[32m    ImDrawCornerFlags_BotLeft   = 1 << 2, // 0x4[m
[32m+[m[32m    ImDrawCornerFlags_BotRight  = 1 << 3, // 0x8[m
[32m+[m[32m    ImDrawCornerFlags_Top       = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_TopRight,   // 0x3[m
[32m+[m[32m    ImDrawCornerFlags_Bot       = ImDrawCornerFlags_BotLeft | ImDrawCornerFlags_BotRight,   // 0xC[m
[32m+[m[32m    ImDrawCornerFlags_Left      = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft,    // 0x5[m
[32m+[m[32m    ImDrawCornerFlags_Right     = ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight,  // 0xA[m
[32m+[m[32m    ImDrawCornerFlags_All       = 0xF     // In your function calls you may use ~0 (= all bits sets) instead of ImDrawCornerFlags_All, as a convenience[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImDrawListFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImDrawListFlags_None             = 0,[m
[32m+[m[32m    ImDrawListFlags_AntiAliasedLines = 1 << 0,  // Lines are anti-aliased (*2 the number of triangles for 1.0f wide line, otherwise *3 the number of triangles)[m
[32m+[m[32m    ImDrawListFlags_AntiAliasedFill  = 1 << 1   // Filled shapes have anti-aliased edges (*2 the number of vertices)[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Draw command list[m
[32m+[m[32m// This is the low-level list of polygons that ImGui functions are filling. At the end of the frame, all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.[m
[32m+[m[32m// Each ImGui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to access the current window draw list and draw custom primitives.[m
[32m+[m[32m// You can interleave normal ImGui:: calls and adding primitives to the current draw list.[m
[32m+[m[32m// All positions are generally in pixel coordinates (top-left at (0,0), bottom-right at io.DisplaySize), but you are totally free to apply whatever transformation matrix to want to the data (if you apply such transformation you'll want to apply it to ClipRect as well)[m
[32m+[m[32m// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.[m
[32m+[m[32mstruct ImDrawList[m
[32m+[m[32m{[m
[32m+[m[32m    // This is what you have to render[m
[32m+[m[32m    ImVector<ImDrawCmd>     CmdBuffer;          // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.[m
[32m+[m[32m    ImVector<ImDrawIdx>     IdxBuffer;          // Index buffer. Each command consume ImDrawCmd::ElemCount of those[m
[32m+[m[32m    ImVector<ImDrawVert>    VtxBuffer;          // Vertex buffer.[m
[32m+[m[32m    ImDrawListFlags         Flags;              // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.[m
[32m+[m
[32m+[m[32m    // [Internal, used while building lists][m
[32m+[m[32m    const ImDrawListSharedData* _Data;          // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)[m
[32m+[m[32m    const char*             _OwnerName;         // Pointer to owner window's name for debugging[m
[32m+[m[32m    unsigned int            _VtxCurrentIdx;     // [Internal] == VtxBuffer.Size[m
[32m+[m[32m    ImDrawVert*             _VtxWritePtr;       // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)[m
[32m+[m[32m    ImDrawIdx*              _IdxWritePtr;       // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)[m
[32m+[m[32m    ImVector<ImVec4>        _ClipRectStack;     // [Internal][m
[32m+[m[32m    ImVector<ImTextureID>   _TextureIdStack;    // [Internal][m
[32m+[m[32m    ImVector<ImVec2>        _Path;              // [Internal] current path building[m
[32m+[m[32m    int                     _ChannelsCurrent;   // [Internal] current channel number (0)[m
[32m+[m[32m    int                     _ChannelsCount;     // [Internal] number of active channels (1+)[m
[32m+[m[32m    ImVector<ImDrawChannel> _Channels;          // [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)[m
[32m+[m
[32m+[m[32m    // If you want to create ImDrawList instances, pass them ImGui::GetDrawListSharedData() or create and use your own ImDrawListSharedData (so you can use ImDrawList without ImGui)[m
[32m+[m[32m    ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }[m
[32m+[m[32m    ~ImDrawList() { ClearFreeMemory(); }[m
[32m+[m[32m    IMGUI_API void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)[m
[32m+[m[32m    IMGUI_API void  PushClipRectFullScreen();[m
[32m+[m[32m    IMGUI_API void  PopClipRect();[m
[32m+[m[32m    IMGUI_API void  PushTextureID(ImTextureID texture_id);[m
[32m+[m[32m    IMGUI_API void  PopTextureID();[m
[32m+[m[32m    inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }[m
[32m+[m[32m    inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }[m
[32m+[m
[32m+[m[32m    // Primitives[m
[32m+[m[32m    IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);[m
[32m+[m[32m    IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All, float thickness = 1.0f);   // a: upper-left, b: lower-right (== upper-left + size), rounding_corners_flags: 4-bits corresponding to which corner to round[m
[32m+[m[32m    IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);                     // a: upper-left, b: lower-right (== upper-left + size)[m
[32m+[m[32m    IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);[m
[32m+[m[32m    IMGUI_API void  AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f);[m
[32m+[m[32m    IMGUI_API void  AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col);[m
[32m+[m[32m    IMGUI_API void  AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f);[m
[32m+[m[32m    IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);[m
[32m+[m[32m    IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);[m
[32m+[m[32m    IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);[m
[32m+[m[32m    IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);[m
[32m+[m[32m    IMGUI_API void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL);[m
[32m+[m[32m    IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = IM_COL32_WHITE);[m
[32m+[m[32m    IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = IM_COL32_WHITE);[m
[32m+[m[32m    IMGUI_API void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners = ImDrawCornerFlags_All);[m
[32m+[m[32m    IMGUI_API void  AddPolyline(const ImVec2* points, int num_points, ImU32 col, bool closed, float thickness);[m
[32m+[m[32m    IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, int num_points, ImU32 col); // Note: Anti-aliased filling requires points to be in clockwise order.[m
[32m+[m[32m    IMGUI_API void  AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments = 0);[m
[32m+[m
[32m+[m[32m    // Stateful path API, add points then finish with PathFillConvex() or PathStroke()[m
[32m+[m[32m    inline    void  PathClear()                                                 { _Path.Size = 0; }[m
[32m+[m[32m    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }[m
[32m+[m[32m    inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path.Data[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }[m
[32m+[m[32m    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.[m
[32m+[m[32m    inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); _Path.Size = 0; }[m
[32m+[m[32m    IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);[m
[32m+[m[32m    IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);                                            // Use precomputed angles for a 12 steps circle[m
[32m+[m[32m    IMGUI_API void  PathBezierCurveTo(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, int num_segments = 0);[m
[32m+[m[32m    IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);[m
[32m+[m
[32m+[m[32m    // Channels[m
[32m+[m[32m    // - Use to simulate layers. By switching channels to can render out-of-order (e.g. submit foreground primitives before background primitives)[m
[32m+[m[32m    // - Use to minimize draw calls (e.g. if going back-and-forth between multiple non-overlapping clipping rectangles, prefer to append into separate channels then merge at the end)[m
[32m+[m[32m    IMGUI_API void  ChannelsSplit(int channels_count);[m
[32m+[m[32m    IMGUI_API void  ChannelsMerge();[m
[32m+[m[32m    IMGUI_API void  ChannelsSetCurrent(int channel_index);[m
[32m+[m
[32m+[m[32m    // Advanced[m
[32m+[m[32m    IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  // Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.[m
[32m+[m[32m    IMGUI_API void  AddDrawCmd();                                               // This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible[m
[32m+[m[32m    IMGUI_API ImDrawList* CloneOutput() const;                                  // Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.[m
[32m+[m
[32m+[m[32m    // Internal helpers[m
[32m+[m[32m    // NB: all primitives needs to be reserved via PrimReserve() beforehand![m
[32m+[m[32m    IMGUI_API void  Clear();[m
[32m+[m[32m    IMGUI_API void  ClearFreeMemory();[m
[32m+[m[32m    IMGUI_API void  PrimReserve(int idx_count, int vtx_count);[m
[32m+[m[32m    IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      // Axis aligned rectangle (composed of two triangles)[m
[32m+[m[32m    IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);[m
[32m+[m[32m    IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);[m
[32m+[m[32m    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }[m
[32m+[m[32m    inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }[m
[32m+[m[32m    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }[m
[32m+[m[32m    IMGUI_API void  UpdateClipRect();[m
[32m+[m[32m    IMGUI_API void  UpdateTextureID();[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// All draw data to render an ImGui frame[m
[32m+[m[32m// (NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose,[m
[32m+[m[32m// as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)[m
[32m+[m[32mstruct ImDrawData[m
[32m+[m[32m{[m
[32m+[m[32m    bool            Valid;                  // Only valid after Render() is called and before the next NewFrame() is called.[m
[32m+[m[32m    ImDrawList**    CmdLists;               // Array of ImDrawList* to render. The ImDrawList are owned by ImGuiContext and only pointed to from here.[m
[32m+[m[32m    int             CmdListsCount;          // Number of ImDrawList* to render[m
[32m+[m[32m    int             TotalIdxCount;          // For convenience, sum of all ImDrawList's IdxBuffer.Size[m
[32m+[m[32m    int             TotalVtxCount;          // For convenience, sum of all ImDrawList's VtxBuffer.Size[m
[32m+[m[32m    ImVec2          DisplayPos;             // Upper-left position of the viewport to render (== upper-left of the orthogonal projection matrix to use)[m
[32m+[m[32m    ImVec2          DisplaySize;            // Size of the viewport to render (== io.DisplaySize for the main viewport) (DisplayPos + DisplaySize == lower-right of the orthogonal projection matrix to use)[m
[32m+[m[32m    ImVec2          FramebufferScale;       // Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.[m
[32m+[m
[32m+[m[32m    // Functions[m
[32m+[m[32m    ImDrawData()    { Valid = false; Clear(); }[m
[32m+[m[32m    ~ImDrawData()   { Clear(); }[m
[32m+[m[32m    void Clear()    { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; DisplayPos = DisplaySize = FramebufferScale = ImVec2(0.f, 0.f); } // The ImDrawList are owned by ImGuiContext![m
[32m+[m[32m    IMGUI_API void  DeIndexAllBuffers();                    // Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering![m
[32m+[m[32m    IMGUI_API void  ScaleClipRects(const ImVec2& fb_scale); // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFontGlyphRangesBuilder, ImFont)[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mstruct ImFontConfig[m
[32m+[m[32m{[m
[32m+[m[32m    void*           FontData;               //          // TTF/OTF data[m
[32m+[m[32m    int             FontDataSize;           //          // TTF/OTF data size[m
[32m+[m[32m    bool            FontDataOwnedByAtlas;   // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).[m
[32m+[m[32m    int             FontNo;                 // 0        // Index of font within TTF/OTF file[m
[32m+[m[32m    float           SizePixels;             //          // Size in pixels for rasterizer (more or less maps to the resulting font height).[m
[32m+[m[32m    int             OversampleH;            // 3        // Rasterize at higher quality for sub-pixel positioning. Read https://github.com/nothings/stb/blob/master/tests/oversample/README.md for details.[m
[32m+[m[32m    int             OversampleV;            // 1        // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.[m
[32m+[m[32m    bool            PixelSnapH;             // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.[m
[32m+[m[32m    ImVec2          GlyphExtraSpacing;      // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.[m
[32m+[m[32m    ImVec2          GlyphOffset;            // 0, 0     // Offset all glyphs from this font input.[m
[32m+[m[32m    const ImWchar*  GlyphRanges;            // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.[m
[32m+[m[32m    float           GlyphMinAdvanceX;       // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font[m
[32m+[m[32m    float           GlyphMaxAdvanceX;       // FLT_MAX  // Maximum AdvanceX for glyphs[m
[32m+[m[32m    bool            MergeMode;              // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.[m
[32m+[m[32m    unsigned int    RasterizerFlags;        // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.[m
[32m+[m[32m    float           RasterizerMultiply;     // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.[m
[32m+[m
[32m+[m[32m    // [Internal][m
[32m+[m[32m    char            Name[40];               // Name (strictly to ease debugging)[m
[32m+[m[32m    ImFont*         DstFont;[m
[32m+[m
[32m+[m[32m    IMGUI_API ImFontConfig();[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstruct ImFontGlyph[m
[32m+[m[32m{[m
[32m+[m[32m    ImWchar         Codepoint;          // 0x0000..0xFFFF[m
[32m+[m[32m    float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)[m
[32m+[m[32m    float           X0, Y0, X1, Y1;     // Glyph corners[m
[32m+[m[32m    float           U0, V0, U1, V1;     // Texture coordinates[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges().[m
[32m+[m[32m// This is essentially a tightly packed of vector of 64k booleans = 8KB storage.[m
[32m+[m[32mstruct ImFontGlyphRangesBuilder[m
[32m+[m[32m{[m
[32m+[m[32m    ImVector<int> UsedChars;            // Store 1-bit per Unicode code point (0=unused, 1=used)[m
[32m+[m
[32m+[m[32m    ImFontGlyphRangesBuilder()          { UsedChars.resize(0x10000 / sizeof(int)); memset(UsedChars.Data, 0, 0x10000 / sizeof(int)); }[m
[32m+[m[32m    bool            GetBit(int n) const { int off = (n >> 5); int mask = 1 << (n & 31); return (UsedChars[off] & mask) != 0; }  // Get bit n in the array[m
[32m+[m[32m    void            SetBit(int n)       { int off = (n >> 5); int mask = 1 << (n & 31); UsedChars[off] |= mask; }               // Set bit n in the array[m
[32m+[m[32m    void            AddChar(ImWchar c)  { SetBit(c); }                          // Add character[m
[32m+[m[32m    IMGUI_API void  AddText(const char* text, const char* text_end = NULL);     // Add string (each character of the UTF-8 string are added)[m
[32m+[m[32m    IMGUI_API void  AddRanges(const ImWchar* ranges);                           // Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCII/Latin+Ext[m
[32m+[m[32m    IMGUI_API void  BuildRanges(ImVector<ImWchar>* out_ranges);                 // Output new ranges[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImFontAtlasFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImFontAtlasFlags_None               = 0,[m
[32m+[m[32m    ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0,   // Don't round the height to next power of two[m
[32m+[m[32m    ImFontAtlasFlags_NoMouseCursors     = 1 << 1    // Don't build software mouse cursors into the atlas[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:[m
[32m+[m[32m//  - One or more fonts.[m
[32m+[m[32m//  - Custom graphics data needed to render the shapes needed by Dear ImGui.[m
[32m+[m[32m//  - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).[m
[32m+[m[32m// It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.[m
[32m+[m[32m//  - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.[m
[32m+[m[32m//  - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.[m
[32m+[m[32m//  - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)[m
[32m+[m[32m//  - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API.[m
[32m+[m[32m//    This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.[m
[32m+[m[32m// Common pitfalls:[m
[32m+[m[32m// - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the[m
[32m+[m[32m//   atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.[m
[32m+[m[32m// - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.[m
[32m+[m[32m//   You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed,[m
[32m+[m[32m// - Even though many functions are suffixed with "TTF", OTF data is supported just as well.[m
[32m+[m[32m// - This is an old API and it is currently awkward for those and and various other reasons! We will address them in the future![m
[32m+[m[32mstruct ImFontAtlas[m
[32m+[m[32m{[m
[32m+[m[32m    IMGUI_API ImFontAtlas();[m
[32m+[m[32m    IMGUI_API ~ImFontAtlas();[m
[32m+[m[32m    IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);[m
[32m+[m[32m    IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);[m
[32m+[m[32m    IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);[m
[32m+[m[32m    IMGUI_API ImFont*           AddFontFromMemoryTTF(void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.[m
[32m+[m[32m    IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.[m
[32m+[m[32m    IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              // 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.[m
[32m+[m[32m    IMGUI_API void              ClearInputData();           // Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.[m
[32m+[m[32m    IMGUI_API void              ClearTexData();             // Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.[m
[32m+[m[32m    IMGUI_API void              ClearFonts();               // Clear output font data (glyphs storage, UV coordinates).[m
[32m+[m[32m    IMGUI_API void              Clear();                    // Clear all input and output.[m
[32m+[m
[32m+[m[32m    // Build atlas, retrieve pixel data.[m
[32m+[m[32m    // User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().[m
[32m+[m[32m    // The pitch is always = Width * BytesPerPixels (1 or 4)[m
[32m+[m[32m    // Building in RGBA32 format is provided for convenience and compatibility, but note that unless you manually manipulate or copy color data into[m
[32m+[m[32m    // the texture (e.g. when using the AddCustomRect*** api), then the RGB pixels emitted will always be white (~75% of memory/bandwidth waste.[m
[32m+[m[32m    IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.[m
[32m+[m[32m    IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 1 byte per-pixel[m
[32m+[m[32m    IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 4 bytes-per-pixel[m
[32m+[m[32m    bool                        IsBuilt()                   { return Fonts.Size > 0 && (TexPixelsAlpha8 != NULL || TexPixelsRGBA32 != NULL); }[m
[32m+[m[32m    void                        SetTexID(ImTextureID id)    { TexID = id; }[m
[32m+[m
[32m+[m[32m    //-------------------------------------------[m
[32m+[m[32m    // Glyph Ranges[m
[32m+[m[32m    //-------------------------------------------[m
[32m+[m
[32m+[m[32m    // Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)[m
[32m+[m[32m    // NB: Make sure that your string are UTF-8 and NOT in your local code page. In C++11, you can create UTF-8 string literal using the u8"Hello world" syntax. See FAQ for details.[m
[32m+[m[32m    // NB: Consider using ImFontGlyphRangesBuilder to build glyph ranges from textual data.[m
[32m+[m[32m    IMGUI_API const ImWchar*    GetGlyphRangesDefault();                // Basic Latin, Extended Latin[m
[32m+[m[32m    IMGUI_API const ImWchar*    GetGlyphRangesKorean();                 // Default + Korean characters[m
[32m+[m[32m    IMGUI_API const ImWchar*    GetGlyphRangesJapanese();               // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs[m
[32m+[m[32m    IMGUI_API const ImWchar*    GetGlyphRangesChineseFull();            // Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs[m
[32m+[m[32m    IMGUI_API const ImWchar*    GetGlyphRangesChineseSimplifiedCommon();// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese[m
[32m+[m[32m    IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();               // Default + about 400 Cyrillic characters[m
[32m+[m[32m    IMGUI_API const ImWchar*    GetGlyphRangesThai();                   // Default + Thai characters[m
[32m+[m[32m    IMGUI_API const ImWchar*    GetGlyphRangesVietnamese();             // Default + Vietname characters[m
[32m+[m
[32m+[m[32m    //-------------------------------------------[m
[32m+[m[32m    // Custom Rectangles/Glyphs API[m
[32m+[m[32m    //-------------------------------------------[m
[32m+[m
[32m+[m[32m    // You can request arbitrary rectangles to be packed into the atlas, for your own purposes. After calling Build(), you can query the rectangle position and render your pixels.[m
[32m+[m[32m    // You can also request your rectangles to be mapped as font glyph (given a font + Unicode point), so you can render e.g. custom colorful icons and use them as regular glyphs.[m
[32m+[m[32m    struct CustomRect[m
[32m+[m[32m    {[m
[32m+[m[32m        unsigned int    ID;             // Input    // User ID. Use <0x10000 to map into a font glyph, >=0x10000 for other/internal/custom texture data.[m
[32m+[m[32m        unsigned short  Width, Height;  // Input    // Desired rectangle dimension[m
[32m+[m[32m        unsigned short  X, Y;           // Output   // Packed position in Atlas[m
[32m+[m[32m        float           GlyphAdvanceX;  // Input    // For custom font glyphs only (ID<0x10000): glyph xadvance[m
[32m+[m[32m        ImVec2          GlyphOffset;    // Input    // For custom font glyphs only (ID<0x10000): glyph display offset[m
[32m+[m[32m        ImFont*         Font;           // Input    // For custom font glyphs only (ID<0x10000): target font[m
[32m+[m[32m        CustomRect()            { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0,0); Font = NULL; }[m
[32m+[m[32m        bool IsPacked() const   { return X != 0xFFFF; }[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    IMGUI_API int       AddCustomRectRegular(unsigned int id, int width, int height);                                                                   // Id needs to be >= 0x10000. Id >= 0x80000000 are reserved for ImGui and ImDrawList[m
[32m+[m[32m    IMGUI_API int       AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0,0));   // Id needs to be < 0x10000 to register a rectangle to map into a specific font.[m
[32m+[m[32m    const CustomRect*   GetCustomRectByIndex(int index) const { if (index < 0) return NULL; return &CustomRects[index]; }[m
[32m+[m
[32m+[m[32m    // [Internal][m
[32m+[m[32m    IMGUI_API void      CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max);[m
[32m+[m[32m    IMGUI_API bool      GetMouseCursorTexData(ImGuiMouseCursor cursor, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2]);[m
[32m+[m
[32m+[m[32m    //-------------------------------------------[m
[32m+[m[32m    // Members[m
[32m+[m[32m    //-------------------------------------------[m
[32m+[m
[32m+[m[32m    bool                        Locked;             // Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.[m
[32m+[m[32m    ImFontAtlasFlags            Flags;              // Build flags (see ImFontAtlasFlags_)[m
[32m+[m[32m    ImTextureID                 TexID;              // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.[m
[32m+[m[32m    int                         TexDesiredWidth;    // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.[m
[32m+[m[32m    int                         TexGlyphPadding;    // Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0.[m
[32m+[m
[32m+[m[32m    // [Internal][m
[32m+[m[32m    // NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.[m
[32m+[m[32m    unsigned char*              TexPixelsAlpha8;    // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight[m
[32m+[m[32m    unsigned int*               TexPixelsRGBA32;    // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4[m
[32m+[m[32m    int                         TexWidth;           // Texture width calculated during Build().[m
[32m+[m[32m    int                         TexHeight;          // Texture height calculated during Build().[m
[32m+[m[32m    ImVec2                      TexUvScale;         // = (1.0f/TexWidth, 1.0f/TexHeight)[m
[32m+[m[32m    ImVec2                      TexUvWhitePixel;    // Texture coordinates to a white pixel[m
[32m+[m[32m    ImVector<ImFont*>           Fonts;              // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.[m
[32m+[m[32m    ImVector<CustomRect>        CustomRects;        // Rectangles for packing custom texture data into the atlas.[m
[32m+[m[32m    ImVector<ImFontConfig>      ConfigData;         // Internal data[m
[32m+[m[32m    int                         CustomRectIds[1];   // Identifiers of custom texture rectangle used by ImFontAtlas/ImDrawList[m
[32m+[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32m    typedef ImFontGlyphRangesBuilder GlyphRangesBuilder; // OBSOLETE 1.67+[m
[32m+[m[32m#endif[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Font runtime data and rendering[m
[32m+[m[32m// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().[m
[32m+[m[32mstruct ImFont[m
[32m+[m[32m{[m
[32m+[m[32m    // Members: Hot ~20/24 bytes (for CalcTextSize)[m
[32m+[m[32m    ImVector<float>             IndexAdvanceX;      // 12-16 // out //            // Sparse. Glyphs->AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this this info, and are often bottleneck in large UI).[m
[32m+[m[32m    float                       FallbackAdvanceX;   // 4     // out // = FallbackGlyph->AdvanceX[m
[32m+[m[32m    float                       FontSize;           // 4     // in  //            // Height of characters/line, set during loading (don't change after loading)[m
[32m+[m
[32m+[m[32m    // Members: Hot ~36/48 bytes (for CalcTextSize + render loop)[m
[32m+[m[32m    ImVector<ImWchar>           IndexLookup;        // 12-16 // out //            // Sparse. Index glyphs by Unicode code-point.[m
[32m+[m[32m    ImVector<ImFontGlyph>       Glyphs;             // 12-16 // out //            // All glyphs.[m
[32m+[m[32m    const ImFontGlyph*          FallbackGlyph;      // 4-8   // out // = FindGlyph(FontFallbackChar)[m
[32m+[m[32m    ImVec2                      DisplayOffset;      // 8     // in  // = (0,0)    // Offset font rendering by xx pixels[m
[32m+[m
[32m+[m[32m    // Members: Cold ~32/40 bytes[m
[32m+[m[32m    ImFontAtlas*                ContainerAtlas;     // 4-8   // out //            // What we has been loaded into[m
[32m+[m[32m    const ImFontConfig*         ConfigData;         // 4-8   // in  //            // Pointer within ContainerAtlas->ConfigData[m
[32m+[m[32m    short                       ConfigDataCount;    // 2     // in  // ~ 1        // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.[m
[32m+[m[32m    ImWchar                     FallbackChar;       // 2     // in  // = '?'      // Replacement glyph if one isn't found. Only set via SetFallbackChar()[m
[32m+[m[32m    float                       Scale;              // 4     // in  // = 1.f      // Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()[m
[32m+[m[32m    float                       Ascent, Descent;    // 4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize][m
[32m+[m[32m    int                         MetricsTotalSurface;// 4     // out //            // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)[m
[32m+[m[32m    bool                        DirtyLookupTables;  // 1     // out //[m
[32m+[m
[32m+[m[32m    // Methods[m
[32m+[m[32m    IMGUI_API ImFont();[m
[32m+[m[32m    IMGUI_API ~ImFont();[m
[32m+[m[32m    IMGUI_API const ImFontGlyph*FindGlyph(ImWchar c) const;[m
[32m+[m[32m    IMGUI_API const ImFontGlyph*FindGlyphNoFallback(ImWchar c) const;[m
[32m+[m[32m    float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }[m
[32m+[m[32m    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }[m
[32m+[m[32m    const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : "<unknown>"; }[m
[32m+[m
[32m+[m[32m    // 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.[m
[32m+[m[32m    // 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.[m
[32m+[m[32m    IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; // utf8[m
[32m+[m[32m    IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;[m
[32m+[m[32m    IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, ImWchar c) const;[m
[32m+[m[32m    IMGUI_API void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;[m
[32m+[m
[32m+[m[32m    // [Internal] Don't use![m
[32m+[m[32m    IMGUI_API void              BuildLookupTable();[m
[32m+[m[32m    IMGUI_API void              ClearOutputData();[m
[32m+[m[32m    IMGUI_API void              GrowIndex(int new_size);[m
[32m+[m[32m    IMGUI_API void              AddGlyph(ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);[m
[32m+[m[32m    IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); // Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.[m
[32m+[m[32m    IMGUI_API void              SetFallbackChar(ImWchar c);[m
[32m+[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32m    typedef ImFontGlyph Glyph; // OBSOLETE 1.52+[m
[32m+[m[32m#endif[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m#if defined(__clang__)[m
[32m+[m[32m#pragma clang diagnostic pop[m
[32m+[m[32m#elif defined(__GNUC__) && __GNUC__ >= 8[m
[32m+[m[32m#pragma GCC diagnostic pop[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Include imgui_user.h at the end of imgui.h (convenient for user to only explicitly include vanilla imgui.h)[m
[32m+[m[32m#ifdef IMGUI_INCLUDE_IMGUI_USER_H[m
[32m+[m[32m#include "imgui_user.h"[m
[32m+[m[32m#endif[m
[1mdiff --git a/vendor/source/ImGui/imgui_demo.cpp b/vendor/source/ImGui/imgui_demo.cpp[m
[1mnew file mode 100644[m
[1mindex 0000000..62196c6[m
[1m--- /dev/null[m
[1m+++ b/vendor/source/ImGui/imgui_demo.cpp[m
[36m@@ -0,0 +1,4501 @@[m
[32m+[m[32m// dear imgui, v1.70[m
[32m+[m[32m// (demo code)[m
[32m+[m
[32m+[m[32m// Message to the person tempted to delete this file when integrating Dear ImGui into their code base:[m
[32m+[m[32m// Do NOT remove this file from your project! Think again! It is the most useful reference code that you and other coders[m
[32m+[m[32m// will want to refer to and call. Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of[m
[32m+[m[32m// your game/app! Removing this file from your project is hindering access to documentation for everyone in your team,[m
[32m+[m[32m// likely leading you to poorer usage of the library.[m
[32m+[m[32m// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().[m
[32m+[m[32m// If you want to link core Dear ImGui in your shipped builds but want an easy guarantee that the demo will not be linked,[m
[32m+[m[32m// you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.[m
[32m+[m[32m// In other situation, whenever you have Dear ImGui available you probably want this to be available for reference.[m
[32m+[m[32m// Thank you,[m
[32m+[m[32m// -Your beloved friend, imgui_demo.cpp (that you won't delete)[m
[32m+[m
[32m+[m[32m// Message to beginner C/C++ programmers about the meaning of the 'static' keyword:[m
[32m+[m[32m// In this demo code, we frequently we use 'static' variables inside functions. A static variable persist across calls, so it is[m
[32m+[m[32m// essentially like a global variable but declared inside the scope of the function. We do this as a way to gather code and data[m
[32m+[m[32m// in the same place, to make the demo source code faster to read, faster to write, and smaller in size.[m
[32m+[m[32m// It also happens to be a convenient way of storing simple UI related information as long as your function doesn't need to be reentrant[m
[32m+[m[32m// or used in threads. This might be a pattern you will want to use in your code, but most of the real data you would be editing is[m
[32m+[m[32m// likely going to be stored outside your functions.[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m
[32m+[m[32mIndex of this file:[m
[32m+[m
[32m+[m[32m// [SECTION] Forward Declarations, Helpers[m
[32m+[m[32m// [SECTION] Demo Window / ShowDemoWindow()[m
[32m+[m[32m// [SECTION] About Window / ShowAboutWindow()[m
[32m+[m[32m// [SECTION] Style Editor / ShowStyleEditor()[m
[32m+[m[32m// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()[m
[32m+[m[32m// [SECTION] Example App: Debug Console / ShowExampleAppConsole()[m
[32m+[m[32m// [SECTION] Example App: Debug Log / ShowExampleAppLog()[m
[32m+[m[32m// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()[m
[32m+[m[32m// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()[m
[32m+[m[32m// [SECTION] Example App: Long Text / ShowExampleAppLongText()[m
[32m+[m[32m// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()[m
[32m+[m[32m// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()[m
[32m+[m[32m// [SECTION] Example App: Simple Overlay / ShowExampleAppSimpleOverlay()[m
[32m+[m[32m// [SECTION] Example App: Manipulating Window Titles / ShowExampleAppWindowTitles()[m
[32m+[m[32m// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()[m
[32m+[m[32m// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()[m
[32m+[m
[32m+[m[32m*/[m
[32m+[m
[32m+[m[32m#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)[m
[32m+[m[32m#define _CRT_SECURE_NO_WARNINGS[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#include "imgui.h"[m
[32m+[m[32m#include <ctype.h>          // toupper[m
[32m+[m[32m#include <limits.h>         // INT_MIN, INT_MAX[m
[32m+[m[32m#include <math.h>           // sqrtf, powf, cosf, sinf, floorf, ceilf[m
[32m+[m[32m#include <stdio.h>          // vsnprintf, sscanf, printf[m
[32m+[m[32m#include <stdlib.h>         // NULL, malloc, free, atoi[m
[32m+[m[32m#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier[m
[32m+[m[32m#include <stddef.h>         // intptr_t[m
[32m+[m[32m#else[m
[32m+[m[32m#include <stdint.h>         // intptr_t[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef _MSC_VER[m
[32m+[m[32m#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef __clang__[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wold-style-cast"             // warning : use of old-style cast                              // yes, they are more terse.[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wdeprecated-declarations"    // warning : 'xx' is deprecated: The POSIX name for this item.. // for strdup used in demo code (so user can copy & paste the code)[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"   // warning : cast to 'void *' from smaller integer type 'int'[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wformat-security"            // warning : warning: format string is not a string literal[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wexit-time-destructors"      // warning : declaration requires an exit-time destructor       // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wunused-macros"              // warning : warning: macro is not used                         // we define snprintf/vsnprintf on Windows so they are available, but not always used.[m
[32m+[m[32m#if __has_warning("-Wzero-as-null-pointer-constant")[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning : zero as null pointer constant                  // some standard header variations use #define NULL 0[m
[32m+[m[32m#endif[m
[32m+[m[32m#if __has_warning("-Wdouble-promotion")[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wdouble-promotion"           // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.[m
[32m+[m[32m#endif[m
[32m+[m[32m#if __has_warning("-Wreserved-id-macro")[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wreserved-id-macro"          // warning : macro name is a reserved identifier                //[m
[32m+[m[32m#endif[m
[32m+[m[32m#elif defined(__GNUC__)[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"          // warning: cast to pointer from integer of different size[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wformat-security"              // warning : format string is not a string literal (potentially insecure)[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wdouble-promotion"             // warning: implicit conversion from 'float' to 'double' when passing argument to function[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wconversion"                   // warning: conversion to 'xxxx' from 'xxxx' may alter its value[m
[32m+[m[32m#if (__GNUC__ >= 6)[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wmisleading-indentation"       // warning: this 'if' clause does not guard this statement      // GCC 6.0+ only. See #883 on GitHub.[m
[32m+[m[32m#endif[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Play it nice with Windows users. Notepad in 2017 still doesn't display text data with Unix-style \n.[m
[32m+[m[32m#ifdef _WIN32[m
[32m+[m[32m#define IM_NEWLINE  "\r\n"[m
[32m+[m[32m#define snprintf    _snprintf[m
[32m+[m[32m#define vsnprintf   _vsnprintf[m
[32m+[m[32m#else[m
[32m+[m[32m#define IM_NEWLINE  "\n"[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#define IM_MAX(_A,_B)       (((_A) >= (_B)) ? (_A) : (_B))[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Forward Declarations, Helpers[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m#if !defined(IMGUI_DISABLE_OBSOLETE_FUNCTIONS) && defined(IMGUI_DISABLE_TEST_WINDOWS) && !defined(IMGUI_DISABLE_DEMO_WINDOWS)   // Obsolete name since 1.53, TEST->DEMO[m
[32m+[m[32m#define IMGUI_DISABLE_DEMO_WINDOWS[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if !defined(IMGUI_DISABLE_DEMO_WINDOWS)[m
[32m+[m
[32m+[m[32m// Forward Declarations[m
[32m+[m[32mstatic void ShowExampleAppDocuments(bool* p_open);[m
[32m+[m[32mstatic void ShowExampleAppMainMenuBar();[m
[32m+[m[32mstatic void ShowExampleAppConsole(bool* p_open);[m
[32m+[m[32mstatic void ShowExampleAppLog(bool* p_open);[m
[32m+[m[32mstatic void ShowExampleAppLayout(bool* p_open);[m
[32m+[m[32mstatic void ShowExampleAppPropertyEditor(bool* p_open);[m
[32m+[m[32mstatic void ShowExampleAppLongText(bool* p_open);[m
[32m+[m[32mstatic void ShowExampleAppAutoResize(bool* p_open);[m
[32m+[m[32mstatic void ShowExampleAppConstrainedResize(bool* p_open);[m
[32m+[m[32mstatic void ShowExampleAppSimpleOverlay(bool* p_open);[m
[32m+[m[32mstatic void ShowExampleAppWindowTitles(bool* p_open);[m
[32m+[m[32mstatic void ShowExampleAppCustomRendering(bool* p_open);[m
[32m+[m[32mstatic void ShowExampleMenuFile();[m
[32m+[m
[32m+[m[32m// Helper to display a little (?) mark which shows a tooltip when hovered.[m
[32m+[m[32m// In your own code you may want to display an actual icon if you are using a merged icon fonts (see misc/fonts/README.txt)[m
[32m+[m[32mstatic void HelpMarker(const char* desc)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGui::TextDisabled("(?)");[m
[32m+[m[32m    if (ImGui::IsItemHovered())[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::BeginTooltip();[m
[32m+[m[32m        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);[m
[32m+[m[32m        ImGui::TextUnformatted(desc);[m
[32m+[m[32m        ImGui::PopTextWrapPos();[m
[32m+[m[32m        ImGui::EndTooltip();[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Helper to display basic user controls.[m
[32m+[m[32mvoid ImGui::ShowUserGuide()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m    ImGui::BulletText("Double-click on title bar to collapse window.");[m
[32m+[m[32m    ImGui::BulletText("Click and drag on lower right corner to resize window\n(double-click to auto fit window to its contents).");[m
[32m+[m[32m    ImGui::BulletText("Click and drag on any empty space to move window.");[m
[32m+[m[32m    ImGui::BulletText("TAB/SHIFT+TAB to cycle through keyboard editable fields.");[m
[32m+[m[32m    ImGui::BulletText("CTRL+Click on a slider or drag box to input value as text.");[m
[32m+[m[32m    if (io.FontAllowUserScaling)[m
[32m+[m[32m        ImGui::BulletText("CTRL+Mouse Wheel to zoom window contents.");[m
[32m+[m[32m    ImGui::BulletText("Mouse Wheel to scroll.");[m
[32m+[m[32m    ImGui::BulletText("While editing text:\n");[m
[32m+[m[32m    ImGui::Indent();[m
[32m+[m[32m    ImGui::BulletText("Hold SHIFT or use mouse to select text.");[m
[32m+[m[32m    ImGui::BulletText("CTRL+Left/Right to word jump.");[m
[32m+[m[32m    ImGui::BulletText("CTRL+A or double-click to select all.");[m
[32m+[m[32m    ImGui::BulletText("CTRL+X,CTRL+C,CTRL+V to use clipboard.");[m
[32m+[m[32m    ImGui::BulletText("CTRL+Z,CTRL+Y to undo/redo.");[m
[32m+[m[32m    ImGui::BulletText("ESCAPE to revert.");[m
[32m+[m[32m    ImGui::BulletText("You can apply arithmetic operators +,*,/ on numerical values.\nUse +- to subtract.");[m
[32m+[m[32m    ImGui::Unindent();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Demo Window / ShowDemoWindow()[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// We split the contents of the big ShowDemoWindow() function into smaller functions (because the link time of very large functions grow non-linearly)[m
[32m+[m[32mstatic void ShowDemoWindowWidgets();[m
[32m+[m[32mstatic void ShowDemoWindowLayout();[m
[32m+[m[32mstatic void ShowDemoWindowPopups();[m
[32m+[m[32mstatic void ShowDemoWindowColumns();[m
[32m+[m[32mstatic void ShowDemoWindowMisc();[m
[32m+[m
[32m+[m[32m// Demonstrate most Dear ImGui features (this is big function!)[m
[32m+[m[32m// You may execute this function to experiment with the UI and understand what it does. You may then search for keywords in the code when you are interested by a specific feature.[m
[32m+[m[32mvoid ImGui::ShowDemoWindow(bool* p_open)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(ImGui::GetCurrentContext() != NULL && "Missing dear imgui context. Refer to examples app!"); // Exceptionally add an extra assert here for people confused with initial dear imgui setup[m
[32m+[m
[32m+[m[32m    // Examples Apps (accessible from the "Examples" menu)[m
[32m+[m[32m    static bool show_app_documents = false;[m
[32m+[m[32m    static bool show_app_main_menu_bar = false;[m
[32m+[m[32m    static bool show_app_console = false;[m
[32m+[m[32m    static bool show_app_log = false;[m
[32m+[m[32m    static bool show_app_layout = false;[m
[32m+[m[32m    static bool show_app_property_editor = false;[m
[32m+[m[32m    static bool show_app_long_text = false;[m
[32m+[m[32m    static bool show_app_auto_resize = false;[m
[32m+[m[32m    static bool show_app_constrained_resize = false;[m
[32m+[m[32m    static bool show_app_simple_overlay = false;[m
[32m+[m[32m    static bool show_app_window_titles = false;[m
[32m+[m[32m    static bool show_app_custom_rendering = false;[m
[32m+[m
[32m+[m[32m    if (show_app_documents)           ShowExampleAppDocuments(&show_app_documents);[m
[32m+[m[32m    if (show_app_main_menu_bar)       ShowExampleAppMainMenuBar();[m
[32m+[m[32m    if (show_app_console)             ShowExampleAppConsole(&show_app_console);[m
[32m+[m[32m    if (show_app_log)                 ShowExampleAppLog(&show_app_log);[m
[32m+[m[32m    if (show_app_layout)              ShowExampleAppLayout(&show_app_layout);[m
[32m+[m[32m    if (show_app_property_editor)     ShowExampleAppPropertyEditor(&show_app_property_editor);[m
[32m+[m[32m    if (show_app_long_text)           ShowExampleAppLongText(&show_app_long_text);[m
[32m+[m[32m    if (show_app_auto_resize)         ShowExampleAppAutoResize(&show_app_auto_resize);[m
[32m+[m[32m    if (show_app_constrained_resize)  ShowExampleAppConstrainedResize(&show_app_constrained_resize);[m
[32m+[m[32m    if (show_app_simple_overlay)      ShowExampleAppSimpleOverlay(&show_app_simple_overlay);[m
[32m+[m[32m    if (show_app_window_titles)       ShowExampleAppWindowTitles(&show_app_window_titles);[m
[32m+[m[32m    if (show_app_custom_rendering)    ShowExampleAppCustomRendering(&show_app_custom_rendering);[m
[32m+[m
[32m+[m[32m    // Dear ImGui Apps (accessible from the "Help" menu)[m
[32m+[m[32m    static bool show_app_metrics = false;[m
[32m+[m[32m    static bool show_app_style_editor = false;[m
[32m+[m[32m    static bool show_app_about = false;[m
[32m+[m
[32m+[m[32m    if (show_app_metrics)             { ImGui::ShowMetricsWindow(&show_app_metrics); }[m
[32m+[m[32m    if (show_app_style_editor)        { ImGui::Begin("Style Editor", &show_app_style_editor); ImGui::ShowStyleEditor(); ImGui::End(); }[m
[32m+[m[32m    if (show_app_about)               { ImGui::ShowAboutWindow(&show_app_about); }[m
[32m+[m
[32m+[m[32m    // Demonstrate the various window flags. Typically you would just use the default![m
[32m+[m[32m    static bool no_titlebar = false;[m
[32m+[m[32m    static bool no_scrollbar = false;[m
[32m+[m[32m    static bool no_menu = false;[m
[32m+[m[32m    static bool no_move = false;[m
[32m+[m[32m    static bool no_resize = false;[m
[32m+[m[32m    static bool no_collapse = false;[m
[32m+[m[32m    static bool no_close = false;[m
[32m+[m[32m    static bool no_nav = false;[m
[32m+[m[32m    static bool no_background = false;[m
[32m+[m[32m    static bool no_bring_to_front = false;[m
[32m+[m
[32m+[m[32m    ImGuiWindowFlags window_flags = 0;[m
[32m+[m[32m    if (no_titlebar)        window_flags |= ImGuiWindowFlags_NoTitleBar;[m
[32m+[m[32m    if (no_scrollbar)       window_flags |= ImGuiWindowFlags_NoScrollbar;[m
[32m+[m[32m    if (!no_menu)           window_flags |= ImGuiWindowFlags_MenuBar;[m
[32m+[m[32m    if (no_move)            window_flags |= ImGuiWindowFlags_NoMove;[m
[32m+[m[32m    if (no_resize)          window_flags |= ImGuiWindowFlags_NoResize;[m
[32m+[m[32m    if (no_collapse)        window_flags |= ImGuiWindowFlags_NoCollapse;[m
[32m+[m[32m    if (no_nav)             window_flags |= ImGuiWindowFlags_NoNav;[m
[32m+[m[32m    if (no_background)      window_flags |= ImGuiWindowFlags_NoBackground;[m
[32m+[m[32m    if (no_bring_to_front)  window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus;[m
[32m+[m[32m    if (no_close)           p_open = NULL; // Don't pass our bool* to Begin[m
[32m+[m
[32m+[m[32m    // We specify a default position/size in case there's no data in the .ini file. Typically this isn't required! We only do it to make the Demo applications a little more welcoming.[m
[32m+[m[32m    ImGui::SetNextWindowPos(ImVec2(650, 20), ImGuiCond_FirstUseEver);[m
[32m+[m[32m    ImGui::SetNextWindowSize(ImVec2(550, 680), ImGuiCond_FirstUseEver);[m
[32m+[m
[32m+[m[32m    // Main body of the Demo window starts here.[m
[32m+[m[32m    if (!ImGui::Begin("ImGui Demo", p_open, window_flags))[m
[32m+[m[32m    {[m
[32m+[m[32m        // Early out if the window is collapsed, as an optimization.[m
[32m+[m[32m        ImGui::End();[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Most "big" widgets share a common width settings by default.[m
[32m+[m[32m    //ImGui::PushItemWidth(ImGui::GetWindowWidth() * 0.65f);    // Use 2/3 of the space for widgets and 1/3 for labels (default)[m
[32m+[m[32m    ImGui::PushItemWidth(ImGui::GetFontSize() * -12);           // Use fixed width for labels (by passing a negative value), the rest goes to widgets. We choose a width proportional to our font size.[m
[32m+[m
[32m+[m[32m    // Menu Bar[m
[32m+[m[32m    if (ImGui::BeginMenuBar())[m
[32m+[m[32m    {[m
[32m+[m[32m        if (ImGui::BeginMenu("Menu"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ShowExampleMenuFile();[m
[32m+[m[32m            ImGui::EndMenu();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (ImGui::BeginMenu("Examples"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::MenuItem("Main menu bar", NULL, &show_app_main_menu_bar);[m
[32m+[m[32m            ImGui::MenuItem("Console", NULL, &show_app_console);[m
[32m+[m[32m            ImGui::MenuItem("Log", NULL, &show_app_log);[m
[32m+[m[32m            ImGui::MenuItem("Simple layout", NULL, &show_app_layout);[m
[32m+[m[32m            ImGui::MenuItem("Property editor", NULL, &show_app_property_editor);[m
[32m+[m[32m            ImGui::MenuItem("Long text display", NULL, &show_app_long_text);[m
[32m+[m[32m            ImGui::MenuItem("Auto-resizing window", NULL, &show_app_auto_resize);[m
[32m+[m[32m            ImGui::MenuItem("Constrained-resizing window", NULL, &show_app_constrained_resize);[m
[32m+[m[32m            ImGui::MenuItem("Simple overlay", NULL, &show_app_simple_overlay);[m
[32m+[m[32m            ImGui::MenuItem("Manipulating window titles", NULL, &show_app_window_titles);[m
[32m+[m[32m            ImGui::MenuItem("Custom rendering", NULL, &show_app_custom_rendering);[m
[32m+[m[32m            ImGui::MenuItem("Documents", NULL, &show_app_documents);[m
[32m+[m[32m            ImGui::EndMenu();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (ImGui::BeginMenu("Help"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::MenuItem("Metrics", NULL, &show_app_metrics);[m
[32m+[m[32m            ImGui::MenuItem("Style Editor", NULL, &show_app_style_editor);[m
[32m+[m[32m            ImGui::MenuItem("About Dear ImGui", NULL, &show_app_about);[m
[32m+[m[32m            ImGui::EndMenu();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::EndMenuBar();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    ImGui::Text("dear imgui says hello. (%s)", IMGUI_VERSION);[m
[32m+[m[32m    ImGui::Spacing();[m
[32m+[m
[32m+[m[32m    if (ImGui::CollapsingHeader("Help"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::Text("PROGRAMMER GUIDE:");[m
[32m+[m[32m        ImGui::BulletText("Please see the ShowDemoWindow() code in imgui_demo.cpp. <- you are here!");[m
[32m+[m[32m        ImGui::BulletText("Please see the comments in imgui.cpp.");[m
[32m+[m[32m        ImGui::BulletText("Please see the examples/ in application.");[m
[32m+[m[32m        ImGui::BulletText("Enable 'io.ConfigFlags |= NavEnableKeyboard' for keyboard controls.");[m
[32m+[m[32m        ImGui::BulletText("Enable 'io.ConfigFlags |= NavEnableGamepad' for gamepad controls.");[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m
[32m+[m[32m        ImGui::Text("USER GUIDE:");[m
[32m+[m[32m        ImGui::ShowUserGuide();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::CollapsingHeader("Configuration"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiIO& io = ImGui::GetIO();[m
[32m+[m
[32m+[m[32m        if (ImGui::TreeNode("Configuration##2"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::CheckboxFlags("io.ConfigFlags: NavEnableKeyboard", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NavEnableKeyboard);[m
[32m+[m[32m            ImGui::CheckboxFlags("io.ConfigFlags: NavEnableGamepad", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NavEnableGamepad);[m
[32m+[m[32m            ImGui::SameLine(); HelpMarker("Required back-end to feed in gamepad inputs in io.NavInputs[] and set io.BackendFlags |= ImGuiBackendFlags_HasGamepad.\n\nRead instructions in imgui.cpp for details.");[m
[32m+[m[32m            ImGui::CheckboxFlags("io.ConfigFlags: NavEnableSetMousePos", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NavEnableSetMousePos);[m
[32m+[m[32m            ImGui::SameLine(); HelpMarker("Instruct navigation to move the mouse cursor. See comment for ImGuiConfigFlags_NavEnableSetMousePos.");[m
[32m+[m[32m            ImGui::CheckboxFlags("io.ConfigFlags: NoMouse", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NoMouse);[m
[32m+[m[32m            if (io.ConfigFlags & ImGuiConfigFlags_NoMouse) // Create a way to restore this flag otherwise we could be stuck completely![m
[32m+[m[32m            {[m
[32m+[m[32m                if (fmodf((float)ImGui::GetTime(), 0.40f) < 0.20f)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImGui::SameLine();[m
[32m+[m[32m                    ImGui::Text("<<PRESS SPACE TO DISABLE>>");[m
[32m+[m[32m                }[m
[32m+[m[32m                if (ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_Space)))[m
[32m+[m[32m                    io.ConfigFlags &= ~ImGuiConfigFlags_NoMouse;[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::CheckboxFlags("io.ConfigFlags: NoMouseCursorChange", (unsigned int *)&io.ConfigFlags, ImGuiConfigFlags_NoMouseCursorChange);[m
[32m+[m[32m            ImGui::SameLine(); HelpMarker("Instruct back-end to not alter mouse cursor shape and visibility.");[m
[32m+[m[32m            ImGui::Checkbox("io.ConfigInputTextCursorBlink", &io.ConfigInputTextCursorBlink);[m
[32m+[m[32m            ImGui::SameLine(); HelpMarker("Set to false to disable blinking cursor, for users who consider it distracting");[m
[32m+[m[32m            ImGui::Checkbox("io.ConfigWindowsResizeFromEdges", &io.ConfigWindowsResizeFromEdges);[m
[32m+[m[32m            ImGui::SameLine(); HelpMarker("Enable resizing of windows from their edges and from the lower-left corner.\nThis requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback.");[m
[32m+[m[32m            ImGui::Checkbox("io.ConfigWindowsMoveFromTitleBarOnly", &io.ConfigWindowsMoveFromTitleBarOnly);[m
[32m+[m[32m            ImGui::Checkbox("io.MouseDrawCursor", &io.MouseDrawCursor);[m
[32m+[m[32m            ImGui::SameLine(); HelpMarker("Instruct Dear ImGui to render a mouse cursor for you. Note that a mouse cursor rendered via your application GPU rendering path will feel more laggy than hardware cursor, but will be more in sync with your other visuals.\n\nSome desktop applications may use both kinds of cursors (e.g. enable software cursor only when resizing/dragging something).");[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m            ImGui::Separator();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::TreeNode("Backend Flags"))[m
[32m+[m[32m        {[m
[32m+[m[32m            HelpMarker("Those flags are set by the back-ends (imgui_impl_xxx files) to specify their capabilities.");[m
[32m+[m[32m            ImGuiBackendFlags backend_flags = io.BackendFlags; // Make a local copy to avoid modifying actual back-end flags.[m
[32m+[m[32m            ImGui::CheckboxFlags("io.BackendFlags: HasGamepad", (unsigned int *)&backend_flags, ImGuiBackendFlags_HasGamepad);[m
[32m+[m[32m            ImGui::CheckboxFlags("io.BackendFlags: HasMouseCursors", (unsigned int *)&backend_flags, ImGuiBackendFlags_HasMouseCursors);[m
[32m+[m[32m            ImGui::CheckboxFlags("io.BackendFlags: HasSetMousePos", (unsigned int *)&backend_flags, ImGuiBackendFlags_HasSetMousePos);[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m            ImGui::Separator();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::TreeNode("Style"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::ShowStyleEditor();[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m            ImGui::Separator();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::TreeNode("Capture/Logging"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::TextWrapped("The logging API redirects all text output so you can easily capture the content of a window or a block. Tree nodes can be automatically expanded.");[m
[32m+[m[32m            HelpMarker("Try opening any of the contents below in this window and then click one of the \"Log To\" button.");[m
[32m+[m[32m            ImGui::LogButtons();[m
[32m+[m[32m            ImGui::TextWrapped("You can also call ImGui::LogText() to output directly to the log without a visual output.");[m
[32m+[m[32m            if (ImGui::Button("Copy \"Hello, world!\" to clipboard"))[m
[32m+[m[32m            {[m
[32m+[m[32m                ImGui::LogToClipboard();[m
[32m+[m[32m                ImGui::LogText("Hello, world!");[m
[32m+[m[32m                ImGui::LogFinish();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::CollapsingHeader("Window options"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::Checkbox("No titlebar", &no_titlebar); ImGui::SameLine(150);[m
[32m+[m[32m        ImGui::Checkbox("No scrollbar", &no_scrollbar); ImGui::SameLine(300);[m
[32m+[m[32m        ImGui::Checkbox("No menu", &no_menu);[m
[32m+[m[32m        ImGui::Checkbox("No move", &no_move); ImGui::SameLine(150);[m
[32m+[m[32m        ImGui::Checkbox("No resize", &no_resize); ImGui::SameLine(300);[m
[32m+[m[32m        ImGui::Checkbox("No collapse", &no_collapse);[m
[32m+[m[32m        ImGui::Checkbox("No close", &no_close); ImGui::SameLine(150);[m
[32m+[m[32m        ImGui::Checkbox("No nav", &no_nav); ImGui::SameLine(300);[m
[32m+[m[32m        ImGui::Checkbox("No background", &no_background);[m
[32m+[m[32m        ImGui::Checkbox("No bring to front", &no_bring_to_front);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // All demo contents[m
[32m+[m[32m    ShowDemoWindowWidgets();[m
[32m+[m[32m    ShowDemoWindowLayout();[m
[32m+[m[32m    ShowDemoWindowPopups();[m
[32m+[m[32m    ShowDemoWindowColumns();[m
[32m+[m[32m    ShowDemoWindowMisc();[m
[32m+[m
[32m+[m[32m    // End of ShowDemoWindow()[m
[32m+[m[32m    ImGui::End();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void ShowDemoWindowWidgets()[m
[32m+[m[32m{[m
[32m+[m[32m    if (!ImGui::CollapsingHeader("Widgets"))[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Basic"))[m
[32m+[m[32m    {[m
[32m+[m[32m        static int clicked = 0;[m
[32m+[m[32m        if (ImGui::Button("Button"))[m
[32m+[m[32m            clicked++;[m
[32m+[m[32m        if (clicked & 1)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::SameLine();[m
[32m+[m[32m            ImGui::Text("Thanks for clicking me!");[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        static bool check = true;[m
[32m+[m[32m        ImGui::Checkbox("checkbox", &check);[m
[32m+[m
[32m+[m[32m        static int e = 0;[m
[32m+[m[32m        ImGui::RadioButton("radio a", &e, 0); ImGui::SameLine();[m
[32m+[m[32m        ImGui::RadioButton("radio b", &e, 1); ImGui::SameLine();[m
[32m+[m[32m        ImGui::RadioButton("radio c", &e, 2);[m
[32m+[m
[32m+[m[32m        // Color buttons, demonstrate using PushID() to add unique identifier in the ID stack, and changing style.[m
[32m+[m[32m        for (int i = 0; i < 7; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (i > 0)[m
[32m+[m[32m                ImGui::SameLine();[m
[32m+[m[32m            ImGui::PushID(i);[m
[32m+[m[32m            ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4)ImColor::HSV(i/7.0f, 0.6f, 0.6f));[m
[32m+[m[32m            ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4)ImColor::HSV(i/7.0f, 0.7f, 0.7f));[m
[32m+[m[32m            ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4)ImColor::HSV(i/7.0f, 0.8f, 0.8f));[m
[32m+[m[32m            ImGui::Button("Click");[m
[32m+[m[32m            ImGui::PopStyleColor(3);[m
[32m+[m[32m            ImGui::PopID();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Use AlignTextToFramePadding() to align text baseline to the baseline of framed elements (otherwise a Text+SameLine+Button sequence will have the text a little too high by default)[m
[32m+[m[32m        ImGui::AlignTextToFramePadding();[m
[32m+[m[32m        ImGui::Text("Hold to repeat:");[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m
[32m+[m[32m        // Arrow buttons with Repeater[m
[32m+[m[32m        static int counter = 0;[m
[32m+[m[32m        float spacing = ImGui::GetStyle().ItemInnerSpacing.x;[m
[32m+[m[32m        ImGui::PushButtonRepeat(true);[m
[32m+[m[32m        if (ImGui::ArrowButton("##left", ImGuiDir_Left)) { counter--; }[m
[32m+[m[32m        ImGui::SameLine(0.0f, spacing);[m
[32m+[m[32m        if (ImGui::ArrowButton("##right", ImGuiDir_Right)) { counter++; }[m
[32m+[m[32m        ImGui::PopButtonRepeat();[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m[32m        ImGui::Text("%d", counter);[m
[32m+[m
[32m+[m[32m        ImGui::Text("Hover over me");[m
[32m+[m[32m        if (ImGui::IsItemHovered())[m
[32m+[m[32m            ImGui::SetTooltip("I am a tooltip");[m
[32m+[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m[32m        ImGui::Text("- or me");[m
[32m+[m[32m        if (ImGui::IsItemHovered())[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::BeginTooltip();[m
[32m+[m[32m            ImGui::Text("I am a fancy tooltip");[m
[32m+[m[32m            static float arr[] = { 0.6f, 0.1f, 1.0f, 0.5f, 0.92f, 0.1f, 0.2f };[m
[32m+[m[32m            ImGui::PlotLines("Curve", arr, IM_ARRAYSIZE(arr));[m
[32m+[m[32m            ImGui::EndTooltip();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m
[32m+[m[32m        ImGui::LabelText("label", "Value");[m
[32m+[m
[32m+[m[32m        {[m
[32m+[m[32m            // Using the _simplified_ one-liner Combo() api here[m
[32m+[m[32m            // See "Combo" section for examples of how to use the more complete BeginCombo()/EndCombo() api.[m
[32m+[m[32m            const char* items[] = { "AAAA", "BBBB", "CCCC", "DDDD", "EEEE", "FFFF", "GGGG", "HHHH", "IIII", "JJJJ", "KKKK", "LLLLLLL", "MMMM", "OOOOOOO" };[m
[32m+[m[32m            static int item_current = 0;[m
[32m+[m[32m            ImGui::Combo("combo", &item_current, items, IM_ARRAYSIZE(items));[m
[32m+[m[32m            ImGui::SameLine(); HelpMarker("Refer to the \"Combo\" section below for an explanation of the full BeginCombo/EndCombo API, and demonstration of various flags.\n");[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        {[m
[32m+[m[32m            static char str0[128] = "Hello, world!";[m
[32m+[m[32m            ImGui::InputText("input text", str0, IM_ARRAYSIZE(str0));[m
[32m+[m[32m            ImGui::SameLine(); HelpMarker("USER:\nHold SHIFT or use mouse to select text.\n" "CTRL+Left/Right to word jump.\n" "CTRL+A or double-click to select all.\n" "CTRL+X,CTRL+C,CTRL+V clipboard.\n" "CTRL+Z,CTRL+Y undo/redo.\n" "ESCAPE to revert.\n\nPROGRAMMER:\nYou can use the ImGuiInputTextFlags_CallbackResize facility if you need to wire InputText() to a dynamic string type. See misc/cpp/imgui_stdlib.h for an example (this is not demonstrated in imgui_demo.cpp).");[m
[32m+[m
[32m+[m[32m            static char str1[128] = "";[m
[32m+[m[32m            ImGui::InputTextWithHint("input text (w/ hint)", "enter text here", str1, IM_ARRAYSIZE(str1));[m
[32m+[m
[32m+[m[32m            static int i0 = 123;[m
[32m+[m[32m            ImGui::InputInt("input int", &i0);[m
[32m+[m[32m            ImGui::SameLine(); HelpMarker("You can apply arithmetic operators +,*,/ on numerical values.\n  e.g. [ 100 ], input \'*2\', result becomes [ 200 ]\nUse +- to subtract.\n");[m
[32m+[m
[32m+[m[32m            static float f0 = 0.001f;[m
[32m+[m[32m            ImGui::InputFloat("input float", &f0, 0.01f, 1.0f, "%.3f");[m
[32m+[m
[32m+[m[32m            static double d0 = 999999.00000001;[m
[32m+[m[32m            ImGui::InputDouble("input double", &d0, 0.01f, 1.0f, "%.8f");[m
[32m+[m
[32m+[m[32m            static float f1 = 1.e10f;[m
[32m+[m[32m            ImGui::InputFloat("input scientific", &f1, 0.0f, 0.0f, "%e");[m
[32m+[m[32m            ImGui::SameLine(); HelpMarker("You can input value using the scientific notation,\n  e.g. \"1e+8\" becomes \"100000000\".\n");[m
[32m+[m
[32m+[m[32m            static float vec4a[4] = { 0.10f, 0.20f, 0.30f, 0.44f };[m
[32m+[m[32m            ImGui::InputFloat3("input float3", vec4a);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        {[m
[32m+[m[32m            static int i1 = 50, i2 = 42;[m
[32m+[m[32m            ImGui::DragInt("drag int", &i1, 1);[m
[32m+[m[32m            ImGui::SameLine(); HelpMarker("Click and drag to edit value.\nHold SHIFT/ALT for faster/slower edit.\nDouble-click or CTRL+click to input value.");[m
[32m+[m
[32m+[m[32m            ImGui::DragInt("drag int 0..100", &i2, 1, 0, 100, "%d%%");[m
[32m+[m
[32m+[m[32m            static float f1=1.00f, f2=0.0067f;[m
[32m+[m[32m            ImGui::DragFloat("drag float", &f1, 0.005f);[m
[32m+[m[32m            ImGui::DragFloat("drag small float", &f2, 0.0001f, 0.0f, 0.0f, "%.06f ns");[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        {[m
[32m+[m[32m            static int i1=0;[m
[32m+[m[32m            ImGui::SliderInt("slider int", &i1, -1, 3);[m
[32m+[m[32m            ImGui::SameLine(); HelpMarker("CTRL+click to input value.");[m
[32m+[m
[32m+[m[32m            static float f1=0.123f, f2=0.0f;[m
[32m+[m[32m            ImGui::SliderFloat("slider float", &f1, 0.0f, 1.0f, "ratio = %.3f");[m
[32m+[m[32m            ImGui::SliderFloat("slider float (curve)", &f2, -10.0f, 10.0f, "%.4f", 2.0f);[m
[32m+[m[32m            static float angle = 0.0f;[m
[32m+[m[32m            ImGui::SliderAngle("slider angle", &angle);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        {[m
[32m+[m[32m            static float col1[3] = { 1.0f,0.0f,0.2f };[m
[32m+[m[32m            static float col2[4] = { 0.4f,0.7f,0.0f,0.5f };[m
[32m+[m[32m            ImGui::ColorEdit3("color 1", col1);[m
[32m+[m[32m            ImGui::SameLine(); HelpMarker("Click on the colored square to open a color picker.\nClick and hold to use drag and drop.\nRight-click on the colored square to show options.\nCTRL+click on individual component to input value.\n");[m
[32m+[m
[32m+[m[32m            ImGui::ColorEdit4("color 2", col2);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        {[m
[32m+[m[32m            // List box[m
[32m+[m[32m            const char* listbox_items[] = { "Apple", "Banana", "Cherry", "Kiwi", "Mango", "Orange", "Pineapple", "Strawberry", "Watermelon" };[m
[32m+[m[32m            static int listbox_item_current = 1;[m
[32m+[m[32m            ImGui::ListBox("listbox\n(single select)", &listbox_item_current, listbox_items, IM_ARRAYSIZE(listbox_items), 4);[m
[32m+[m
[32m+[m[32m            //static int listbox_item_current2 = 2;[m
[32m+[m[32m            //ImGui::SetNextItemWidth(-1);[m
[32m+[m[32m            //ImGui::ListBox("##listbox2", &listbox_item_current2, listbox_items, IM_ARRAYSIZE(listbox_items), 4);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Testing ImGuiOnceUponAFrame helper.[m
[32m+[m[32m    //static ImGuiOnceUponAFrame once;[m
[32m+[m[32m    //for (int i = 0; i < 5; i++)[m
[32m+[m[32m    //    if (once)[m
[32m+[m[32m    //        ImGui::Text("This will be displayed only once.");[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Trees"))[m
[32m+[m[32m    {[m
[32m+[m[32m        if (ImGui::TreeNode("Basic trees"))[m
[32m+[m[32m        {[m
[32m+[m[32m            for (int i = 0; i < 5; i++)[m
[32m+[m[32m                if (ImGui::TreeNode((void*)(intptr_t)i, "Child %d", i))[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImGui::Text("blah blah");[m
[32m+[m[32m                    ImGui::SameLine();[m
[32m+[m[32m                    if (ImGui::SmallButton("button")) { };[m
[32m+[m[32m                    ImGui::TreePop();[m
[32m+[m[32m                }[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::TreeNode("Advanced, with Selectable nodes"))[m
[32m+[m[32m        {[m
[32m+[m[32m            HelpMarker("This is a more typical looking tree with selectable nodes.\nClick to select, CTRL+Click to toggle, click on arrows or double-click to open.");[m
[32m+[m[32m            static bool align_label_with_current_x_position = false;[m
[32m+[m[32m            ImGui::Checkbox("Align label with current X position)", &align_label_with_current_x_position);[m
[32m+[m[32m            ImGui::Text("Hello!");[m
[32m+[m[32m            if (align_label_with_current_x_position)[m
[32m+[m[32m                ImGui::Unindent(ImGui::GetTreeNodeToLabelSpacing());[m
[32m+[m
[32m+[m[32m            static int selection_mask = (1 << 2); // Dumb representation of what may be user-side selection state. You may carry selection state inside or outside your objects in whatever format you see fit.[m
[32m+[m[32m            int node_clicked = -1;                // Temporary storage of what node we have clicked to process selection at the end of the loop. May be a pointer to your own node type, etc.[m
[32m+[m[32m            ImGui::PushStyleVar(ImGuiStyleVar_IndentSpacing, ImGui::GetFontSize()*3); // Increase spacing to differentiate leaves from expanded contents.[m
[32m+[m[32m            for (int i = 0; i < 6; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                // Disable the default open on single-click behavior and pass in Selected flag according to our selection state.[m
[32m+[m[32m                ImGuiTreeNodeFlags node_flags = ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick;[m
[32m+[m[32m                if (selection_mask & (1 << i))[m
[32m+[m[32m                    node_flags |= ImGuiTreeNodeFlags_Selected;[m
[32m+[m[32m                if (i < 3)[m
[32m+[m[32m                {[m
[32m+[m[32m                    // Items 0..2 are Tree Node[m
[32m+[m[32m                    bool node_open = ImGui::TreeNodeEx((void*)(intptr_t)i, node_flags, "Selectable Node %d", i);[m
[32m+[m[32m                    if (ImGui::IsItemClicked())[m
[32m+[m[32m                        node_clicked = i;[m
[32m+[m[32m                    if (node_open)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ImGui::Text("Blah blah\nBlah Blah");[m
[32m+[m[32m                        ImGui::TreePop();[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    // Items 3..5 are Tree Leaves[m
[32m+[m[32m                    // The only reason we use TreeNode at all is to allow selection of the leaf.[m
[32m+[m[32m                    // Otherwise we can use BulletText() or TreeAdvanceToLabelPos()+Text().[m
[32m+[m[32m                    node_flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen; // ImGuiTreeNodeFlags_Bullet[m
[32m+[m[32m                    ImGui::TreeNodeEx((void*)(intptr_t)i, node_flags, "Selectable Leaf %d", i);[m
[32m+[m[32m                    if (ImGui::IsItemClicked())[m
[32m+[m[32m                        node_clicked = i;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (node_clicked != -1)[m
[32m+[m[32m            {[m
[32m+[m[32m                // Update selection state. Process outside of tree loop to avoid visual inconsistencies during the clicking-frame.[m
[32m+[m[32m                if (ImGui::GetIO().KeyCtrl)[m
[32m+[m[32m                    selection_mask ^= (1 << node_clicked);          // CTRL+click to toggle[m
[32m+[m[32m                else //if (!(selection_mask & (1 << node_clicked))) // Depending on selection behavior you want, this commented bit preserve selection when clicking on item that is part of the selection[m
[32m+[m[32m                    selection_mask = (1 << node_clicked);           // Click to single-select[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::PopStyleVar();[m
[32m+[m[32m            if (align_label_with_current_x_position)[m
[32m+[m[32m                ImGui::Indent(ImGui::GetTreeNodeToLabelSpacing());[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Collapsing Headers"))[m
[32m+[m[32m    {[m
[32m+[m[32m        static bool closable_group = true;[m
[32m+[m[32m        ImGui::Checkbox("Show 2nd header", &closable_group);[m
[32m+[m[32m        if (ImGui::CollapsingHeader("Header"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::Text("IsItemHovered: %d", ImGui::IsItemHovered());[m
[32m+[m[32m            for (int i = 0; i < 5; i++)[m
[32m+[m[32m                ImGui::Text("Some content %d", i);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (ImGui::CollapsingHeader("Header with a close button", &closable_group))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::Text("IsItemHovered: %d", ImGui::IsItemHovered());[m
[32m+[m[32m            for (int i = 0; i < 5; i++)[m
[32m+[m[32m                ImGui::Text("More content %d", i);[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Bullets"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::BulletText("Bullet point 1");[m
[32m+[m[32m        ImGui::BulletText("Bullet point 2\nOn multiple lines");[m
[32m+[m[32m        ImGui::Bullet(); ImGui::Text("Bullet point 3 (two calls)");[m
[32m+[m[32m        ImGui::Bullet(); ImGui::SmallButton("Button");[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Text"))[m
[32m+[m[32m    {[m
[32m+[m[32m        if (ImGui::TreeNode("Colored Text"))[m
[32m+[m[32m        {[m
[32m+[m[32m            // Using shortcut. You can use PushStyleColor()/PopStyleColor() for more flexibility.[m
[32m+[m[32m            ImGui::TextColored(ImVec4(1.0f,0.0f,1.0f,1.0f), "Pink");[m
[32m+[m[32m            ImGui::TextColored(ImVec4(1.0f,1.0f,0.0f,1.0f), "Yellow");[m
[32m+[m[32m            ImGui::TextDisabled("Disabled");[m
[32m+[m[32m            ImGui::SameLine(); HelpMarker("The TextDisabled color is stored in ImGuiStyle.");[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::TreeNode("Word Wrapping"))[m
[32m+[m[32m        {[m
[32m+[m[32m            // Using shortcut. You can use PushTextWrapPos()/PopTextWrapPos() for more flexibility.[m
[32m+[m[32m            ImGui::TextWrapped("This text should automatically wrap on the edge of the window. The current implementation for text wrapping follows simple rules suitable for English and possibly other languages.");[m
[32m+[m[32m            ImGui::Spacing();[m
[32m+[m
[32m+[m[32m            static float wrap_width = 200.0f;[m
[32m+[m[32m            ImGui::SliderFloat("Wrap width", &wrap_width, -20, 600, "%.0f");[m
[32m+[m
[32m+[m[32m            ImGui::Text("Test paragraph 1:");[m
[32m+[m[32m            ImVec2 pos = ImGui::GetCursorScreenPos();[m
[32m+[m[32m            ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));[m
[32m+[m[32m            ImGui::PushTextWrapPos(ImGui::GetCursorPos().x + wrap_width);[m
[32m+[m[32m            ImGui::Text("The lazy dog is a good dog. This paragraph is made to fit within %.0f pixels. Testing a 1 character word. The quick brown fox jumps over the lazy dog.", wrap_width);[m
[32m+[m[32m            ImGui::GetWindowDrawList()->AddRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(255,255,0,255));[m
[32m+[m[32m            ImGui::PopTextWrapPos();[m
[32m+[m
[32m+[m[32m            ImGui::Text("Test paragraph 2:");[m
[32m+[m[32m            pos = ImGui::GetCursorScreenPos();[m
[32m+[m[32m            ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(pos.x + wrap_width, pos.y), ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight()), IM_COL32(255,0,255,255));[m
[32m+[m[32m            ImGui::PushTextWrapPos(ImGui::GetCursorPos().x + wrap_width);[m
[32m+[m[32m            ImGui::Text("aaaaaaaa bbbbbbbb, c cccccccc,dddddddd. d eeeeeeee   ffffffff. gggggggg!hhhhhhhh");[m
[32m+[m[32m            ImGui::GetWindowDrawList()->AddRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(255,255,0,255));[m
[32m+[m[32m            ImGui::PopTextWrapPos();[m
[32m+[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::TreeNode("UTF-8 Text"))[m
[32m+[m[32m        {[m
[32m+[m[32m            // UTF-8 test with Japanese characters[m
[32m+[m[32m            // (Needs a suitable font, try Noto, or Arial Unicode, or M+ fonts. Read misc/fonts/README.txt for details.)[m
[32m+[m[32m            // - From C++11 you can use the u8"my text" syntax to encode literal strings as UTF-8[m
[32m+[m[32m            // - For earlier compiler, you may be able to encode your sources as UTF-8 (e.g. Visual Studio save your file as 'UTF-8 without signature')[m
[32m+[m[32m            // - FOR THIS DEMO FILE ONLY, BECAUSE WE WANT TO SUPPORT OLD COMPILERS, WE ARE *NOT* INCLUDING RAW UTF-8 CHARACTERS IN THIS SOURCE FILE.[m
[32m+[m[32m            //   Instead we are encoding a few strings with hexadecimal constants. Don't do this in your application![m
[32m+[m[32m            //   Please use u8"text in any language" in your application![m
[32m+[m[32m            // Note that characters values are preserved even by InputText() if the font cannot be displayed, so you can safely copy & paste garbled characters into another application.[m
[32m+[m[32m            ImGui::TextWrapped("CJK text will only appears if the font was loaded with the appropriate CJK character ranges. Call io.Font->AddFontFromFileTTF() manually to load extra character ranges. Read misc/fonts/README.txt for details.");[m
[32m+[m[32m            ImGui::Text("Hiragana: \xe3\x81\x8b\xe3\x81\x8d\xe3\x81\x8f\xe3\x81\x91\xe3\x81\x93 (kakikukeko)"); // Normally we would use u8"blah blah" with the proper characters directly in the string.[m
[32m+[m[32m            ImGui::Text("Kanjis: \xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e (nihongo)");[m
[32m+[m[32m            static char buf[32] = "\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e";[m
[32m+[m[32m            //static char buf[32] = u8"NIHONGO"; // <- this is how you would write it with C++11, using real kanjis[m
[32m+[m[32m            ImGui::InputText("UTF-8 input", buf, IM_ARRAYSIZE(buf));[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Images"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m        ImGui::TextWrapped("Below we are displaying the font texture (which is the only texture we have access to in this demo). Use the 'ImTextureID' type as storage to pass pointers or identifier to your own texture data. Hover the texture for a zoomed view!");[m
[32m+[m
[32m+[m[32m        // Here we are grabbing the font texture because that's the only one we have access to inside the demo code.[m
[32m+[m[32m        // Remember that ImTextureID is just storage for whatever you want it to be, it is essentially a value that will be passed to the render function inside the ImDrawCmd structure.[m
[32m+[m[32m        // If you use one of the default imgui_impl_XXXX.cpp renderer, they all have comments at the top of their file to specify what they expect to be stored in ImTextureID.[m
[32m+[m[32m        // (for example, the imgui_impl_dx11.cpp renderer expect a 'ID3D11ShaderResourceView*' pointer. The imgui_impl_glfw_gl3.cpp renderer expect a GLuint OpenGL texture identifier etc.)[m
[32m+[m[32m        // If you decided that ImTextureID = MyEngineTexture*, then you can pass your MyEngineTexture* pointers to ImGui::Image(), and gather width/height through your own functions, etc.[m
[32m+[m[32m        // Using ShowMetricsWindow() as a "debugger" to inspect the draw data that are being passed to your render will help you debug issues if you are confused about this.[m
[32m+[m[32m        // Consider using the lower-level ImDrawList::AddImage() API, via ImGui::GetWindowDrawList()->AddImage().[m
[32m+[m[32m        ImTextureID my_tex_id = io.Fonts->TexID;[m
[32m+[m[32m        float my_tex_w = (float)io.Fonts->TexWidth;[m
[32m+[m[32m        float my_tex_h = (float)io.Fonts->TexHeight;[m
[32m+[m
[32m+[m[32m        ImGui::Text("%.0fx%.0f", my_tex_w, my_tex_h);[m
[32m+[m[32m        ImVec2 pos = ImGui::GetCursorScreenPos();[m
[32m+[m[32m        ImGui::Image(my_tex_id, ImVec2(my_tex_w, my_tex_h), ImVec2(0,0), ImVec2(1,1), ImVec4(1.0f,1.0f,1.0f,1.0f), ImVec4(1.0f,1.0f,1.0f,0.5f));[m
[32m+[m[32m        if (ImGui::IsItemHovered())[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::BeginTooltip();[m
[32m+[m[32m            float region_sz = 32.0f;[m
[32m+[m[32m            float region_x = io.MousePos.x - pos.x - region_sz * 0.5f; if (region_x < 0.0f) region_x = 0.0f; else if (region_x > my_tex_w - region_sz) region_x = my_tex_w - region_sz;[m
[32m+[m[32m            float region_y = io.MousePos.y - pos.y - region_sz * 0.5f; if (region_y < 0.0f) region_y = 0.0f; else if (region_y > my_tex_h - region_sz) region_y = my_tex_h - region_sz;[m
[32m+[m[32m            float zoom = 4.0f;[m
[32m+[m[32m            ImGui::Text("Min: (%.2f, %.2f)", region_x, region_y);[m
[32m+[m[32m            ImGui::Text("Max: (%.2f, %.2f)", region_x + region_sz, region_y + region_sz);[m
[32m+[m[32m            ImVec2 uv0 = ImVec2((region_x) / my_tex_w, (region_y) / my_tex_h);[m
[32m+[m[32m            ImVec2 uv1 = ImVec2((region_x + region_sz) / my_tex_w, (region_y + region_sz) / my_tex_h);[m
[32m+[m[32m            ImGui::Image(my_tex_id, ImVec2(region_sz * zoom, region_sz * zoom), uv0, uv1, ImVec4(1.0f, 1.0f, 1.0f, 1.0f), ImVec4(1.0f, 1.0f, 1.0f, 0.5f));[m
[32m+[m[32m            ImGui::EndTooltip();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::TextWrapped("And now some textured buttons..");[m
[32m+[m[32m        static int pressed_count = 0;[m
[32m+[m[32m        for (int i = 0; i < 8; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::PushID(i);[m
[32m+[m[32m            int frame_padding = -1 + i;     // -1 = uses default padding[m
[32m+[m[32m            if (ImGui::ImageButton(my_tex_id, ImVec2(32,32), ImVec2(0,0), ImVec2(32.0f/my_tex_w,32/my_tex_h), frame_padding, ImVec4(0.0f,0.0f,0.0f,1.0f)))[m
[32m+[m[32m                pressed_count += 1;[m
[32m+[m[32m            ImGui::PopID();[m
[32m+[m[32m            ImGui::SameLine();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::NewLine();[m
[32m+[m[32m        ImGui::Text("Pressed %d times.", pressed_count);[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Combo"))[m
[32m+[m[32m    {[m
[32m+[m[32m        // Expose flags as checkbox for the demo[m
[32m+[m[32m        static ImGuiComboFlags flags = 0;[m
[32m+[m[32m        ImGui::CheckboxFlags("ImGuiComboFlags_PopupAlignLeft", (unsigned int*)&flags, ImGuiComboFlags_PopupAlignLeft);[m
[32m+[m[32m        ImGui::SameLine(); HelpMarker("Only makes a difference if the popup is larger than the combo");[m
[32m+[m[32m        if (ImGui::CheckboxFlags("ImGuiComboFlags_NoArrowButton", (unsigned int*)&flags, ImGuiComboFlags_NoArrowButton))[m
[32m+[m[32m            flags &= ~ImGuiComboFlags_NoPreview;     // Clear the other flag, as we cannot combine both[m
[32m+[m[32m        if (ImGui::CheckboxFlags("ImGuiComboFlags_NoPreview", (unsigned int*)&flags, ImGuiComboFlags_NoPreview))[m
[32m+[m[32m            flags &= ~ImGuiComboFlags_NoArrowButton; // Clear the other flag, as we cannot combine both[m
[32m+[m
[32m+[m[32m        // General BeginCombo() API, you have full control over your selection data and display type.[m
[32m+[m[32m        // (your selection data could be an index, a pointer to the object, an id for the object, a flag stored in the object itself, etc.)[m
[32m+[m[32m        const char* items[] = { "AAAA", "BBBB", "CCCC", "DDDD", "EEEE", "FFFF", "GGGG", "HHHH", "IIII", "JJJJ", "KKKK", "LLLLLLL", "MMMM", "OOOOOOO" };[m
[32m+[m[32m        static const char* item_current = items[0];            // Here our selection is a single pointer stored outside the object.[m
[32m+[m[32m        if (ImGui::BeginCombo("combo 1", item_current, flags)) // The second parameter is the label previewed before opening the combo.[m
[32m+[m[32m        {[m
[32m+[m[32m            for (int n = 0; n < IM_ARRAYSIZE(items); n++)[m
[32m+[m[32m            {[m
[32m+[m[32m                bool is_selected = (item_current == items[n]);[m
[32m+[m[32m                if (ImGui::Selectable(items[n], is_selected))[m
[32m+[m[32m                    item_current = items[n];[m
[32m+[m[32m                if (is_selected)[m
[32m+[m[32m                    ImGui::SetItemDefaultFocus();   // Set the initial focus when opening the combo (scrolling + for keyboard navigation support in the upcoming navigation branch)[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::EndCombo();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Simplified one-liner Combo() API, using values packed in a single constant string[m
[32m+[m[32m        static int item_current_2 = 0;[m
[32m+[m[32m        ImGui::Combo("combo 2 (one-liner)", &item_current_2, "aaaa\0bbbb\0cccc\0dddd\0eeee\0\0");[m
[32m+[m
[32m+[m[32m        // Simplified one-liner Combo() using an array of const char*[m
[32m+[m[32m        static int item_current_3 = -1; // If the selection isn't within 0..count, Combo won't display a preview[m
[32m+[m[32m        ImGui::Combo("combo 3 (array)", &item_current_3, items, IM_ARRAYSIZE(items));[m
[32m+[m
[32m+[m[32m        // Simplified one-liner Combo() using an accessor function[m
[32m+[m[32m        struct FuncHolder { static bool ItemGetter(void* data, int idx, const char** out_str) { *out_str = ((const char**)data)[idx]; return true; } };[m
[32m+[m[32m        static int item_current_4 = 0;[m
[32m+[m[32m        ImGui::Combo("combo 4 (function)", &item_current_4, &FuncHolder::ItemGetter, items, IM_ARRAYSIZE(items));[m
[32m+[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Selectables"))[m
[32m+[m[32m    {[m
[32m+[m[32m        // Selectable() has 2 overloads:[m
[32m+[m[32m        // - The one taking "bool selected" as a read-only selection information. When Selectable() has been clicked is returns true and you can alter selection state accordingly.[m
[32m+[m[32m        // - The one taking "bool* p_selected" as a read-write selection information (convenient in some cases)[m
[32m+[m[32m        // The earlier is more flexible, as in real application your selection may be stored in a different manner (in flags within objects, as an external list, etc).[m
[32m+[m[32m        if (ImGui::TreeNode("Basic"))[m
[32m+[m[32m        {[m
[32m+[m[32m            static bool selection[5] = { false, true, false, false, false };[m
[32m+[m[32m            ImGui::Selectable("1. I am selectable", &selection[0]);[m
[32m+[m[32m            ImGui::Selectable("2. I am selectable", &selection[1]);[m
[32m+[m[32m            ImGui::Text("3. I am not selectable");[m
[32m+[m[32m            ImGui::Selectable("4. I am selectable", &selection[3]);[m
[32m+[m[32m            if (ImGui::Selectable("5. I am double clickable", selection[4], ImGuiSelectableFlags_AllowDoubleClick))[m
[32m+[m[32m                if (ImGui::IsMouseDoubleClicked(0))[m
[32m+[m[32m                    selection[4] = !selection[4];[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (ImGui::TreeNode("Selection State: Single Selection"))[m
[32m+[m[32m        {[m
[32m+[m[32m            static int selected = -1;[m
[32m+[m[32m            for (int n = 0; n < 5; n++)[m
[32m+[m[32m            {[m
[32m+[m[32m                char buf[32];[m
[32m+[m[32m                sprintf(buf, "Object %d", n);[m
[32m+[m[32m                if (ImGui::Selectable(buf, selected == n))[m
[32m+[m[32m                    selected = n;[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (ImGui::TreeNode("Selection State: Multiple Selection"))[m
[32m+[m[32m        {[m
[32m+[m[32m            HelpMarker("Hold CTRL and click to select multiple items.");[m
[32m+[m[32m            static bool selection[5] = { false, false, false, false, false };[m
[32m+[m[32m            for (int n = 0; n < 5; n++)[m
[32m+[m[32m            {[m
[32m+[m[32m                char buf[32];[m
[32m+[m[32m                sprintf(buf, "Object %d", n);[m
[32m+[m[32m                if (ImGui::Selectable(buf, selection[n]))[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (!ImGui::GetIO().KeyCtrl)    // Clear selection when CTRL is not held[m
[32m+[m[32m                        memset(selection, 0, sizeof(selection));[m
[32m+[m[32m                    selection[n] ^= 1;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (ImGui::TreeNode("Rendering more text into the same line"))[m
[32m+[m[32m        {[m
[32m+[m[32m            // Using the Selectable() override that takes "bool* p_selected" parameter and toggle your booleans automatically.[m
[32m+[m[32m            static bool selected[3] = { false, false, false };[m
[32m+[m[32m            ImGui::Selectable("main.c",    &selected[0]); ImGui::SameLine(300); ImGui::Text(" 2,345 bytes");[m
[32m+[m[32m            ImGui::Selectable("Hello.cpp", &selected[1]); ImGui::SameLine(300); ImGui::Text("12,345 bytes");[m
[32m+[m[32m            ImGui::Selectable("Hello.h",   &selected[2]); ImGui::SameLine(300); ImGui::Text(" 2,345 bytes");[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (ImGui::TreeNode("In columns"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::Columns(3, NULL, false);[m
[32m+[m[32m            static bool selected[16] = { 0 };[m
[32m+[m[32m            for (int i = 0; i < 16; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                char label[32]; sprintf(label, "Item %d", i);[m
[32m+[m[32m                if (ImGui::Selectable(label, &selected[i])) {}[m
[32m+[m[32m                ImGui::NextColumn();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::Columns(1);[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (ImGui::TreeNode("Grid"))[m
[32m+[m[32m        {[m
[32m+[m[32m            static bool selected[4*4] = { true, false, false, false, false, true, false, false, false, false, true, false, false, false, false, true };[m
[32m+[m[32m            for (int i = 0; i < 4*4; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                ImGui::PushID(i);[m
[32m+[m[32m                if (ImGui::Selectable("Sailor", &selected[i], 0, ImVec2(50,50)))[m
[32m+[m[32m                {[m
[32m+[m[32m                    // Note: We _unnecessarily_ test for both x/y and i here only to silence some static analyzer. The second part of each test is unnecessary.[m
[32m+[m[32m                    int x = i % 4;[m
[32m+[m[32m                    int y = i / 4;[m
[32m+[m[32m                    if (x > 0)           { selected[i - 1] ^= 1; }[m
[32m+[m[32m                    if (x < 3 && i < 15) { selected[i + 1] ^= 1; }[m
[32m+[m[32m                    if (y > 0 && i > 3)  { selected[i - 4] ^= 1; }[m
[32m+[m[32m                    if (y < 3 && i < 12) { selected[i + 4] ^= 1; }[m
[32m+[m[32m                }[m
[32m+[m[32m                if ((i % 4) < 3) ImGui::SameLine();[m
[32m+[m[32m                ImGui::PopID();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (ImGui::TreeNode("Alignment"))[m
[32m+[m[32m        {[m
[32m+[m[32m            HelpMarker("Alignment applies when a selectable is larger than its text content.\nBy default, Selectables uses style.SelectableTextAlign but it can be overriden on a per-item basis using PushStyleVar().");[m
[32m+[m[32m            static bool selected[3*3] = { true, false, true, false, true, false, true, false, true };[m
[32m+[m[32m            for (int y = 0; y < 3; y++)[m
[32m+[m[32m            {[m
[32m+[m[32m                for (int x = 0; x < 3; x++)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImVec2 alignment = ImVec2((float)x / 2.0f, (float)y / 2.0f);[m
[32m+[m[32m                    char name[32];[m
[32m+[m[32m                    sprintf(name, "(%.1f,%.1f)", alignment.x, alignment.y);[m
[32m+[m[32m                    if (x > 0) ImGui::SameLine();[m
[32m+[m[32m                    ImGui::PushStyleVar(ImGuiStyleVar_SelectableTextAlign, alignment);[m
[32m+[m[32m                    ImGui::Selectable(name, &selected[3*y+x], ImGuiSelectableFlags_None, ImVec2(80,80));[m
[32m+[m[32m                    ImGui::PopStyleVar();[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Text Input"))[m
[32m+[m[32m    {[m
[32m+[m[32m        if (ImGui::TreeNode("Multi-line Text Input"))[m
[32m+[m[32m        {[m
[32m+[m[32m            // Note: we are using a fixed-sized buffer for simplicity here. See ImGuiInputTextFlags_CallbackResize[m
[32m+[m[32m            // and the code in misc/cpp/imgui_stdlib.h for how to setup InputText() for dynamically resizing strings.[m
[32m+[m[32m            static char text[1024 * 16] =[m
[32m+[m[32m                "/*\n"[m
[32m+[m[32m                " The Pentium F00F bug, shorthand for F0 0F C7 C8,\n"[m
[32m+[m[32m                " the hexadecimal encoding of one offending instruction,\n"[m
[32m+[m[32m                " more formally, the invalid operand with locked CMPXCHG8B\n"[m
[32m+[m[32m                " instruction bug, is a design flaw in the majority of\n"[m
[32m+[m[32m                " Intel Pentium, Pentium MMX, and Pentium OverDrive\n"[m
[32m+[m[32m                " processors (all in the P5 microarchitecture).\n"[m
[32m+[m[32m                "*/\n\n"[m
[32m+[m[32m                "label:\n"[m
[32m+[m[32m                "\tlock cmpxchg8b eax\n";[m
[32m+[m
[32m+[m[32m            static ImGuiInputTextFlags flags = ImGuiInputTextFlags_AllowTabInput;[m
[32m+[m[32m            HelpMarker("You can use the ImGuiInputTextFlags_CallbackResize facility if you need to wire InputTextMultiline() to a dynamic string type. See misc/cpp/imgui_stdlib.h for an example. (This is not demonstrated in imgui_demo.cpp)");[m
[32m+[m[32m            ImGui::CheckboxFlags("ImGuiInputTextFlags_ReadOnly", (unsigned int*)&flags, ImGuiInputTextFlags_ReadOnly);[m
[32m+[m[32m            ImGui::CheckboxFlags("ImGuiInputTextFlags_AllowTabInput", (unsigned int*)&flags, ImGuiInputTextFlags_AllowTabInput);[m
[32m+[m[32m            ImGui::CheckboxFlags("ImGuiInputTextFlags_CtrlEnterForNewLine", (unsigned int*)&flags, ImGuiInputTextFlags_CtrlEnterForNewLine);[m
[32m+[m[32m            ImGui::InputTextMultiline("##source", text, IM_ARRAYSIZE(text), ImVec2(-1.0f, ImGui::GetTextLineHeight() * 16), flags);[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::TreeNode("Filtered Text Input"))[m
[32m+[m[32m        {[m
[32m+[m[32m            static char buf1[64] = ""; ImGui::InputText("default", buf1, 64);[m
[32m+[m[32m            static char buf2[64] = ""; ImGui::InputText("decimal", buf2, 64, ImGuiInputTextFlags_CharsDecimal);[m
[32m+[m[32m            static char buf3[64] = ""; ImGui::InputText("hexadecimal", buf3, 64, ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase);[m
[32m+[m[32m            static char buf4[64] = ""; ImGui::InputText("uppercase", buf4, 64, ImGuiInputTextFlags_CharsUppercase);[m
[32m+[m[32m            static char buf5[64] = ""; ImGui::InputText("no blank", buf5, 64, ImGuiInputTextFlags_CharsNoBlank);[m
[32m+[m[32m            struct TextFilters { static int FilterImGuiLetters(ImGuiInputTextCallbackData* data) { if (data->EventChar < 256 && strchr("imgui", (char)data->EventChar)) return 0; return 1; } };[m
[32m+[m[32m            static char buf6[64] = ""; ImGui::InputText("\"imgui\" letters", buf6, 64, ImGuiInputTextFlags_CallbackCharFilter, TextFilters::FilterImGuiLetters);[m
[32m+[m
[32m+[m[32m            ImGui::Text("Password input");[m
[32m+[m[32m            static char bufpass[64] = "password123";[m
[32m+[m[32m            ImGui::InputText("password", bufpass, 64, ImGuiInputTextFlags_Password | ImGuiInputTextFlags_CharsNoBlank);[m
[32m+[m[32m            ImGui::SameLine(); HelpMarker("Display all characters as '*'.\nDisable clipboard cut and copy.\nDisable logging.\n");[m
[32m+[m[32m            ImGui::InputTextWithHint("password (w/ hint)", "<password>", bufpass, 64, ImGuiInputTextFlags_Password | ImGuiInputTextFlags_CharsNoBlank);[m
[32m+[m[32m            ImGui::InputText("password (clear)", bufpass, 64, ImGuiInputTextFlags_CharsNoBlank);[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::TreeNode("Resize Callback"))[m
[32m+[m[32m        {[m
[32m+[m[32m            // If you have a custom string type you would typically create a ImGui::InputText() wrapper than takes your type as input.[m
[32m+[m[32m            // See misc/cpp/imgui_stdlib.h and .cpp for an implementation of this using std::string.[m
[32m+[m[32m            HelpMarker("Demonstrate using ImGuiInputTextFlags_CallbackResize to wire your resizable string type to InputText().\n\nSee misc/cpp/imgui_stdlib.h for an implementation of this for std::string.");[m
[32m+[m[32m            struct Funcs[m
[32m+[m[32m            {[m
[32m+[m[32m                static int MyResizeCallback(ImGuiInputTextCallbackData* data)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (data->EventFlag == ImGuiInputTextFlags_CallbackResize)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ImVector<char>* my_str = (ImVector<char>*)data->UserData;[m
[32m+[m[32m                        IM_ASSERT(my_str->begin() == data->Buf);[m
[32m+[m[32m                        my_str->resize(data->BufSize);  // NB: On resizing calls, generally data->BufSize == data->BufTextLen + 1[m
[32m+[m[32m                        data->Buf = my_str->begin();[m
[32m+[m[32m                    }[m
[32m+[m[32m                    return 0;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                // Tip: Because ImGui:: is a namespace you would typicall add your own function into the namespace in your own source files.[m
[32m+[m[32m                // For example, you may add a function called ImGui::InputText(const char* label, MyString* my_str).[m
[32m+[m[32m                static bool MyInputTextMultiline(const char* label, ImVector<char>* my_str, const ImVec2& size = ImVec2(0, 0), ImGuiInputTextFlags flags = 0)[m
[32m+[m[32m                {[m
[32m+[m[32m                    IM_ASSERT((flags & ImGuiInputTextFlags_CallbackResize) == 0);[m
[32m+[m[32m                    return ImGui::InputTextMultiline(label, my_str->begin(), (size_t)my_str->size(), size, flags | ImGuiInputTextFlags_CallbackResize, Funcs::MyResizeCallback, (void*)my_str);[m
[32m+[m[32m                }[m
[32m+[m[32m            };[m
[32m+[m
[32m+[m[32m            // For this demo we are using ImVector as a string container.[m
[32m+[m[32m            // Note that because we need to store a terminating zero character, our size/capacity are 1 more than usually reported by a typical string class.[m
[32m+[m[32m            static ImVector<char> my_str;[m
[32m+[m[32m            if (my_str.empty())[m
[32m+[m[32m                my_str.push_back(0);[m
[32m+[m[32m            Funcs::MyInputTextMultiline("##MyStr", &my_str, ImVec2(-1.0f, ImGui::GetTextLineHeight() * 16));[m
[32m+[m[32m            ImGui::Text("Data: %p\nSize: %d\nCapacity: %d", (void*)my_str.begin(), my_str.size(), my_str.capacity());[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Plots Widgets"))[m
[32m+[m[32m    {[m
[32m+[m[32m        static bool animate = true;[m
[32m+[m[32m        ImGui::Checkbox("Animate", &animate);[m
[32m+[m
[32m+[m[32m        static float arr[] = { 0.6f, 0.1f, 1.0f, 0.5f, 0.92f, 0.1f, 0.2f };[m
[32m+[m[32m        ImGui::PlotLines("Frame Times", arr, IM_ARRAYSIZE(arr));[m
[32m+[m
[32m+[m[32m        // Create a dummy array of contiguous float values to plot[m
[32m+[m[32m        // Tip: If your float aren't contiguous but part of a structure, you can pass a pointer to your first float and the sizeof() of your structure in the Stride parameter.[m
[32m+[m[32m        static float values[90] = { 0 };[m
[32m+[m[32m        static int values_offset = 0;[m
[32m+[m[32m        static double refresh_time = 0.0;[m
[32m+[m[32m        if (!animate || refresh_time == 0.0)[m
[32m+[m[32m            refresh_time = ImGui::GetTime();[m
[32m+[m[32m        while (refresh_time < ImGui::GetTime()) // Create dummy data at fixed 60 hz rate for the demo[m
[32m+[m[32m        {[m
[32m+[m[32m            static float phase = 0.0f;[m
[32m+[m[32m            values[values_offset] = cosf(phase);[m
[32m+[m[32m            values_offset = (values_offset+1) % IM_ARRAYSIZE(values);[m
[32m+[m[32m            phase += 0.10f*values_offset;[m
[32m+[m[32m            refresh_time += 1.0f/60.0f;[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::PlotLines("Lines", values, IM_ARRAYSIZE(values), values_offset, "avg 0.0", -1.0f, 1.0f, ImVec2(0,80));[m
[32m+[m[32m        ImGui::PlotHistogram("Histogram", arr, IM_ARRAYSIZE(arr), 0, NULL, 0.0f, 1.0f, ImVec2(0,80));[m
[32m+[m
[32m+[m[32m        // Use functions to generate output[m
[32m+[m[32m        // FIXME: This is rather awkward because current plot API only pass in indices. We probably want an API passing floats and user provide sample rate/count.[m
[32m+[m[32m        struct Funcs[m
[32m+[m[32m        {[m
[32m+[m[32m            static float Sin(void*, int i) { return sinf(i * 0.1f); }[m
[32m+[m[32m            static float Saw(void*, int i) { return (i & 1) ? 1.0f : -1.0f; }[m
[32m+[m[32m        };[m
[32m+[m[32m        static int func_type = 0, display_count = 70;[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        ImGui::SetNextItemWidth(100);[m
[32m+[m[32m        ImGui::Combo("func", &func_type, "Sin\0Saw\0");[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m[32m        ImGui::SliderInt("Sample count", &display_count, 1, 400);[m
[32m+[m[32m        float (*func)(void*, int) = (func_type == 0) ? Funcs::Sin : Funcs::Saw;[m
[32m+[m[32m        ImGui::PlotLines("Lines", func, NULL, display_count, 0, NULL, -1.0f, 1.0f, ImVec2(0,80));[m
[32m+[m[32m        ImGui::PlotHistogram("Histogram", func, NULL, display_count, 0, NULL, -1.0f, 1.0f, ImVec2(0,80));[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m
[32m+[m[32m        // Animate a simple progress bar[m
[32m+[m[32m        static float progress = 0.0f, progress_dir = 1.0f;[m
[32m+[m[32m        if (animate)[m
[32m+[m[32m        {[m
[32m+[m[32m            progress += progress_dir * 0.4f * ImGui::GetIO().DeltaTime;[m
[32m+[m[32m            if (progress >= +1.1f) { progress = +1.1f; progress_dir *= -1.0f; }[m
[32m+[m[32m            if (progress <= -0.1f) { progress = -0.1f; progress_dir *= -1.0f; }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Typically we would use ImVec2(-1.0f,0.0f) to use all available width, or ImVec2(width,0.0f) for a specified width. ImVec2(0.0f,0.0f) uses ItemWidth.[m
[32m+[m[32m        ImGui::ProgressBar(progress, ImVec2(0.0f,0.0f));[m
[32m+[m[32m        ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);[m
[32m+[m[32m        ImGui::Text("Progress Bar");[m
[32m+[m
[32m+[m[32m        float progress_saturated = (progress < 0.0f) ? 0.0f : (progress > 1.0f) ? 1.0f : progress;[m
[32m+[m[32m        char buf[32];[m
[32m+[m[32m        sprintf(buf, "%d/%d", (int)(progress_saturated*1753), 1753);[m
[32m+[m[32m        ImGui::ProgressBar(progress, ImVec2(0.f,0.f), buf);[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Color/Picker Widgets"))[m
[32m+[m[32m    {[m
[32m+[m[32m        static ImVec4 color = ImVec4(114.0f/255.0f, 144.0f/255.0f, 154.0f/255.0f, 200.0f/255.0f);[m
[32m+[m
[32m+[m[32m        static bool alpha_preview = true;[m
[32m+[m[32m        static bool alpha_half_preview = false;[m
[32m+[m[32m        static bool drag_and_drop = true;[m
[32m+[m[32m        static bool options_menu = true;[m
[32m+[m[32m        static bool hdr = false;[m
[32m+[m[32m        ImGui::Checkbox("With Alpha Preview", &alpha_preview);[m
[32m+[m[32m        ImGui::Checkbox("With Half Alpha Preview", &alpha_half_preview);[m
[32m+[m[32m        ImGui::Checkbox("With Drag and Drop", &drag_and_drop);[m
[32m+[m[32m        ImGui::Checkbox("With Options Menu", &options_menu); ImGui::SameLine(); HelpMarker("Right-click on the individual color widget to show options.");[m
[32m+[m[32m        ImGui::Checkbox("With HDR", &hdr); ImGui::SameLine(); HelpMarker("Currently all this does is to lift the 0..1 limits on dragging widgets.");[m
[32m+[m[32m        int misc_flags = (hdr ? ImGuiColorEditFlags_HDR : 0) | (drag_and_drop ? 0 : ImGuiColorEditFlags_NoDragDrop) | (alpha_half_preview ? ImGuiColorEditFlags_AlphaPreviewHalf : (alpha_preview ? ImGuiColorEditFlags_AlphaPreview : 0)) | (options_menu ? 0 : ImGuiColorEditFlags_NoOptions);[m
[32m+[m
[32m+[m[32m        ImGui::Text("Color widget:");[m
[32m+[m[32m        ImGui::SameLine(); HelpMarker("Click on the colored square to open a color picker.\nCTRL+click on individual component to input value.\n");[m
[32m+[m[32m        ImGui::ColorEdit3("MyColor##1", (float*)&color, misc_flags);[m
[32m+[m
[32m+[m[32m        ImGui::Text("Color widget HSV with Alpha:");[m
[32m+[m[32m        ImGui::ColorEdit4("MyColor##2", (float*)&color, ImGuiColorEditFlags_DisplayHSV | misc_flags);[m
[32m+[m
[32m+[m[32m        ImGui::Text("Color widget with Float Display:");[m
[32m+[m[32m        ImGui::ColorEdit4("MyColor##2f", (float*)&color, ImGuiColorEditFlags_Float | misc_flags);[m
[32m+[m
[32m+[m[32m        ImGui::Text("Color button with Picker:");[m
[32m+[m[32m        ImGui::SameLine(); HelpMarker("With the ImGuiColorEditFlags_NoInputs flag you can hide all the slider/text inputs.\nWith the ImGuiColorEditFlags_NoLabel flag you can pass a non-empty label which will only be used for the tooltip and picker popup.");[m
[32m+[m[32m        ImGui::ColorEdit4("MyColor##3", (float*)&color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel | misc_flags);[m
[32m+[m
[32m+[m[32m        ImGui::Text("Color button with Custom Picker Popup:");[m
[32m+[m
[32m+[m[32m        // Generate a dummy default palette. The palette will persist and can be edited.[m
[32m+[m[32m        static bool saved_palette_init = true;[m
[32m+[m[32m        static ImVec4 saved_palette[32] = { };[m
[32m+[m[32m        if (saved_palette_init)[m
[32m+[m[32m        {[m
[32m+[m[32m            for (int n = 0; n < IM_ARRAYSIZE(saved_palette); n++)[m
[32m+[m[32m            {[m
[32m+[m[32m                ImGui::ColorConvertHSVtoRGB(n / 31.0f, 0.8f, 0.8f, saved_palette[n].x, saved_palette[n].y, saved_palette[n].z);[m
[32m+[m[32m                saved_palette[n].w = 1.0f; // Alpha[m
[32m+[m[32m            }[m
[32m+[m[32m            saved_palette_init = false;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        static ImVec4 backup_color;[m
[32m+[m[32m        bool open_popup = ImGui::ColorButton("MyColor##3b", color, misc_flags);[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m[32m        open_popup |= ImGui::Button("Palette");[m
[32m+[m[32m        if (open_popup)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::OpenPopup("mypicker");[m
[32m+[m[32m            backup_color = color;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (ImGui::BeginPopup("mypicker"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::Text("MY CUSTOM COLOR PICKER WITH AN AMAZING PALETTE!");[m
[32m+[m[32m            ImGui::Separator();[m
[32m+[m[32m            ImGui::ColorPicker4("##picker", (float*)&color, misc_flags | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoSmallPreview);[m
[32m+[m[32m            ImGui::SameLine();[m
[32m+[m
[32m+[m[32m            ImGui::BeginGroup(); // Lock X position[m
[32m+[m[32m            ImGui::Text("Current");[m
[32m+[m[32m            ImGui::ColorButton("##current", color, ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_AlphaPreviewHalf, ImVec2(60,40));[m
[32m+[m[32m            ImGui::Text("Previous");[m
[32m+[m[32m            if (ImGui::ColorButton("##previous", backup_color, ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_AlphaPreviewHalf, ImVec2(60,40)))[m
[32m+[m[32m                color = backup_color;[m
[32m+[m[32m            ImGui::Separator();[m
[32m+[m[32m            ImGui::Text("Palette");[m
[32m+[m[32m            for (int n = 0; n < IM_ARRAYSIZE(saved_palette); n++)[m
[32m+[m[32m            {[m
[32m+[m[32m                ImGui::PushID(n);[m
[32m+[m[32m                if ((n % 8) != 0)[m
[32m+[m[32m                    ImGui::SameLine(0.0f, ImGui::GetStyle().ItemSpacing.y);[m
[32m+[m[32m                if (ImGui::ColorButton("##palette", saved_palette[n], ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_NoTooltip, ImVec2(20,20)))[m
[32m+[m[32m                    color = ImVec4(saved_palette[n].x, saved_palette[n].y, saved_palette[n].z, color.w); // Preserve alpha![m
[32m+[m
[32m+[m[32m                // Allow user to drop colors into each palette entry[m
[32m+[m[32m                // (Note that ColorButton is already a drag source by default, unless using ImGuiColorEditFlags_NoDragDrop)[m
[32m+[m[32m                if (ImGui::BeginDragDropTarget())[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))[m
[32m+[m[32m                        memcpy((float*)&saved_palette[n], payload->Data, sizeof(float) * 3);[m
[32m+[m[32m                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))[m
[32m+[m[32m                        memcpy((float*)&saved_palette[n], payload->Data, sizeof(float) * 4);[m
[32m+[m[32m                    ImGui::EndDragDropTarget();[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                ImGui::PopID();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::EndGroup();[m
[32m+[m[32m            ImGui::EndPopup();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        ImGui::Text("Color button only:");[m
[32m+[m[32m        ImGui::ColorButton("MyColor##3c", *(ImVec4*)&color, misc_flags, ImVec2(80,80));[m
[32m+[m
[32m+[m[32m        ImGui::Text("Color picker:");[m
[32m+[m[32m        static bool alpha = true;[m
[32m+[m[32m        static bool alpha_bar = true;[m
[32m+[m[32m        static bool side_preview = true;[m
[32m+[m[32m        static bool ref_color = false;[m
[32m+[m[32m        static ImVec4 ref_color_v(1.0f,0.0f,1.0f,0.5f);[m
[32m+[m[32m        static int display_mode = 0;[m
[32m+[m[32m        static int picker_mode = 0;[m
[32m+[m[32m        ImGui::Checkbox("With Alpha", &alpha);[m
[32m+[m[32m        ImGui::Checkbox("With Alpha Bar", &alpha_bar);[m
[32m+[m[32m        ImGui::Checkbox("With Side Preview", &side_preview);[m
[32m+[m[32m        if (side_preview)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::SameLine();[m
[32m+[m[32m            ImGui::Checkbox("With Ref Color", &ref_color);[m
[32m+[m[32m            if (ref_color)[m
[32m+[m[32m            {[m
[32m+[m[32m                ImGui::SameLine();[m
[32m+[m[32m                ImGui::ColorEdit4("##RefColor", &ref_color_v.x, ImGuiColorEditFlags_NoInputs | misc_flags);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::Combo("Display Mode", &display_mode, "Auto/Current\0None\0RGB Only\0HSV Only\0Hex Only\0");[m
[32m+[m[32m        ImGui::SameLine(); HelpMarker("ColorEdit defaults to displaying RGB inputs if you don't specify a display mode, but the user can change it with a right-click.\n\nColorPicker defaults to displaying RGB+HSV+Hex if you don't specify a display mode.\n\nYou can change the defaults using SetColorEditOptions().");[m
[32m+[m[32m        ImGui::Combo("Picker Mode", &picker_mode, "Auto/Current\0Hue bar + SV rect\0Hue wheel + SV triangle\0");[m
[32m+[m[32m        ImGui::SameLine(); HelpMarker("User can right-click the picker to change mode.");[m
[32m+[m[32m        ImGuiColorEditFlags flags = misc_flags;[m
[32m+[m[32m        if (!alpha)            flags |= ImGuiColorEditFlags_NoAlpha;        // This is by default if you call ColorPicker3() instead of ColorPicker4()[m
[32m+[m[32m        if (alpha_bar)         flags |= ImGuiColorEditFlags_AlphaBar;[m
[32m+[m[32m        if (!side_preview)     flags |= ImGuiColorEditFlags_NoSidePreview;[m
[32m+[m[32m        if (picker_mode == 1)  flags |= ImGuiColorEditFlags_PickerHueBar;[m
[32m+[m[32m        if (picker_mode == 2)  flags |= ImGuiColorEditFlags_PickerHueWheel;[m
[32m+[m[32m        if (display_mode == 1) flags |= ImGuiColorEditFlags_NoInputs;       // Disable all RGB/HSV/Hex displays[m
[32m+[m[32m        if (display_mode == 2) flags |= ImGuiColorEditFlags_DisplayRGB;     // Override display mode[m
[32m+[m[32m        if (display_mode == 3) flags |= ImGuiColorEditFlags_DisplayHSV;[m
[32m+[m[32m        if (display_mode == 4) flags |= ImGuiColorEditFlags_DisplayHex;[m
[32m+[m[32m        ImGui::ColorPicker4("MyColor##4", (float*)&color, flags, ref_color ? &ref_color_v.x : NULL);[m
[32m+[m
[32m+[m[32m        ImGui::Text("Programmatically set defaults:");[m
[32m+[m[32m        ImGui::SameLine(); HelpMarker("SetColorEditOptions() is designed to allow you to set boot-time default.\nWe don't have Push/Pop functions because you can force options on a per-widget basis if needed, and the user can change non-forced ones with the options menu.\nWe don't have a getter to avoid encouraging you to persistently save values that aren't forward-compatible.");[m
[32m+[m[32m        if (ImGui::Button("Default: Uint8 + HSV + Hue Bar"))[m
[32m+[m[32m            ImGui::SetColorEditOptions(ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_PickerHueBar);[m
[32m+[m[32m        if (ImGui::Button("Default: Float + HDR + Hue Wheel"))[m
[32m+[m[32m            ImGui::SetColorEditOptions(ImGuiColorEditFlags_Float | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_PickerHueWheel);[m
[32m+[m
[32m+[m[32m        // HSV encoded support (to avoid RGB<>HSV round trips and singularities when S==0 or V==0)[m
[32m+[m[32m        static ImVec4 color_stored_as_hsv(0.23f, 1.0f, 1.0f, 1.0f);[m
[32m+[m[32m        ImGui::Spacing();[m
[32m+[m[32m        ImGui::Text("HSV encoded colors");[m
[32m+[m[32m        ImGui::SameLine(); HelpMarker("By default, colors are given to ColorEdit and ColorPicker in RGB, but ImGuiColorEditFlags_InputHSV allows you to store colors as HSV and pass them to ColorEdit and ColorPicker as HSV. This comes with the added benefit that you can manipulate hue values with the picker even when saturation or value are zero.");[m
[32m+[m[32m        ImGui::Text("Color widget with InputHSV:");[m
[32m+[m[32m        ImGui::ColorEdit4("HSV shown as HSV##1", (float*)&color_stored_as_hsv, ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_InputHSV | ImGuiColorEditFlags_Float);[m
[32m+[m[32m        ImGui::ColorEdit4("HSV shown as RGB##1", (float*)&color_stored_as_hsv, ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_InputHSV | ImGuiColorEditFlags_Float);[m
[32m+[m[32m        ImGui::DragFloat4("Raw HSV values", (float*)&color_stored_as_hsv, 0.01f, 0.0f, 1.0f);[m
[32m+[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Range Widgets"))[m
[32m+[m[32m    {[m
[32m+[m[32m        static float begin = 10, end = 90;[m
[32m+[m[32m        static int begin_i = 100, end_i = 1000;[m
[32m+[m[32m        ImGui::DragFloatRange2("range", &begin, &end, 0.25f, 0.0f, 100.0f, "Min: %.1f %%", "Max: %.1f %%");[m
[32m+[m[32m        ImGui::DragIntRange2("range int (no bounds)", &begin_i, &end_i, 5, 0, 0, "Min: %d units", "Max: %d units");[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Data Types"))[m
[32m+[m[32m    {[m
[32m+[m[32m        // The DragScalar/InputScalar/SliderScalar functions allow various data types: signed/unsigned int/long long and float/double[m
[32m+[m[32m        // To avoid polluting the public API with all possible combinations, we use the ImGuiDataType enum to pass the type,[m
[32m+[m[32m        // and passing all arguments by address.[m
[32m+[m[32m        // This is the reason the test code below creates local variables to hold "zero" "one" etc. for each types.[m
[32m+[m[32m        // In practice, if you frequently use a given type that is not covered by the normal API entry points, you can wrap it[m
[32m+[m[32m        // yourself inside a 1 line function which can take typed argument as value instead of void*, and then pass their address[m
[32m+[m[32m        // to the generic function. For example:[m
[32m+[m[32m        //   bool MySliderU64(const char *label, u64* value, u64 min = 0, u64 max = 0, const char* format = "%lld")[m
[32m+[m[32m        //   {[m
[32m+[m[32m        //      return SliderScalar(label, ImGuiDataType_U64, value, &min, &max, format);[m
[32m+[m[32m        //   }[m
[32m+[m
[32m+[m[32m        // Limits (as helper variables that we can take the address of)[m
[32m+[m[32m        // Note that the SliderScalar function has a maximum usable range of half the natural type maximum, hence the /2 below.[m
[32m+[m[32m        #ifndef LLONG_MIN[m
[32m+[m[32m        ImS64 LLONG_MIN = -9223372036854775807LL - 1;[m
[32m+[m[32m        ImS64 LLONG_MAX = 9223372036854775807LL;[m
[32m+[m[32m        ImU64 ULLONG_MAX = (2ULL * 9223372036854775807LL + 1);[m
[32m+[m[32m        #endif[m
[32m+[m[32m        const char    s8_zero  = 0,   s8_one  = 1,   s8_fifty  = 50, s8_min  = -128,        s8_max = 127;[m
[32m+[m[32m        const ImU8    u8_zero  = 0,   u8_one  = 1,   u8_fifty  = 50, u8_min  = 0,           u8_max = 255;[m
[32m+[m[32m        const short   s16_zero = 0,   s16_one = 1,   s16_fifty = 50, s16_min = -32768,      s16_max = 32767;[m
[32m+[m[32m        const ImU16   u16_zero = 0,   u16_one = 1,   u16_fifty = 50, u16_min = 0,           u16_max = 65535;[m
[32m+[m[32m        const ImS32   s32_zero = 0,   s32_one = 1,   s32_fifty = 50, s32_min = INT_MIN/2,   s32_max = INT_MAX/2,    s32_hi_a = INT_MAX/2 - 100,    s32_hi_b = INT_MAX/2;[m
[32m+[m[32m        const ImU32   u32_zero = 0,   u32_one = 1,   u32_fifty = 50, u32_min = 0,           u32_max = UINT_MAX/2,   u32_hi_a = UINT_MAX/2 - 100,   u32_hi_b = UINT_MAX/2;[m
[32m+[m[32m        const ImS64   s64_zero = 0,   s64_one = 1,   s64_fifty = 50, s64_min = LLONG_MIN/2, s64_max = LLONG_MAX/2,  s64_hi_a = LLONG_MAX/2 - 100,  s64_hi_b = LLONG_MAX/2;[m
[32m+[m[32m        const ImU64   u64_zero = 0,   u64_one = 1,   u64_fifty = 50, u64_min = 0,           u64_max = ULLONG_MAX/2, u64_hi_a = ULLONG_MAX/2 - 100, u64_hi_b = ULLONG_MAX/2;[m
[32m+[m[32m        const float   f32_zero = 0.f, f32_one = 1.f, f32_lo_a = -10000000000.0f, f32_hi_a = +10000000000.0f;[m
[32m+[m[32m        const double  f64_zero = 0.,  f64_one = 1.,  f64_lo_a = -1000000000000000.0, f64_hi_a = +1000000000000000.0;[m
[32m+[m
[32m+[m[32m        // State[m
[32m+[m[32m        static char   s8_v  = 127;[m
[32m+[m[32m        static ImU8   u8_v  = 255;[m
[32m+[m[32m        static short  s16_v = 32767;[m
[32m+[m[32m        static ImU16  u16_v = 65535;[m
[32m+[m[32m        static ImS32  s32_v = -1;[m
[32m+[m[32m        static ImU32  u32_v = (ImU32)-1;[m
[32m+[m[32m        static ImS64  s64_v = -1;[m
[32m+[m[32m        static ImU64  u64_v = (ImU64)-1;[m
[32m+[m[32m        static float  f32_v = 0.123f;[m
[32m+[m[32m        static double f64_v = 90000.01234567890123456789;[m
[32m+[m
[32m+[m[32m        const float drag_speed = 0.2f;[m
[32m+[m[32m        static bool drag_clamp = false;[m
[32m+[m[32m        ImGui::Text("Drags:");[m
[32m+[m[32m        ImGui::Checkbox("Clamp integers to 0..50", &drag_clamp); ImGui::SameLine(); HelpMarker("As with every widgets in dear imgui, we never modify values unless there is a user interaction.\nYou can override the clamping limits by using CTRL+Click to input a value.");[m
[32m+[m[32m        ImGui::DragScalar("drag s8",        ImGuiDataType_S8,     &s8_v,  drag_speed, drag_clamp ? &s8_zero  : NULL, drag_clamp ? &s8_fifty  : NULL);[m
[32m+[m[32m        ImGui::DragScalar("drag u8",        ImGuiDataType_U8,     &u8_v,  drag_speed, drag_clamp ? &u8_zero  : NULL, drag_clamp ? &u8_fifty  : NULL, "%u ms");[m
[32m+[m[32m        ImGui::DragScalar("drag s16",       ImGuiDataType_S16,    &s16_v, drag_speed, drag_clamp ? &s16_zero : NULL, drag_clamp ? &s16_fifty : NULL);[m
[32m+[m[32m        ImGui::DragScalar("drag u16",       ImGuiDataType_U16,    &u16_v, drag_speed, drag_clamp ? &u16_zero : NULL, drag_clamp ? &u16_fifty : NULL, "%u ms");[m
[32m+[m[32m        ImGui::DragScalar("drag s32",       ImGuiDataType_S32,    &s32_v, drag_speed, drag_clamp ? &s32_zero : NULL, drag_clamp ? &s32_fifty : NULL);[m
[32m+[m[32m        ImGui::DragScalar("drag u32",       ImGuiDataType_U32,    &u32_v, drag_speed, drag_clamp ? &u32_zero : NULL, drag_clamp ? &u32_fifty : NULL, "%u ms");[m
[32m+[m[32m        ImGui::DragScalar("drag s64",       ImGuiDataType_S64,    &s64_v, drag_speed, drag_clamp ? &s64_zero : NULL, drag_clamp ? &s64_fifty : NULL);[m
[32m+[m[32m        ImGui::DragScalar("drag u64",       ImGuiDataType_U64,    &u64_v, drag_speed, drag_clamp ? &u64_zero : NULL, drag_clamp ? &u64_fifty : NULL);[m
[32m+[m[32m        ImGui::DragScalar("drag float",     ImGuiDataType_Float,  &f32_v, 0.005f,  &f32_zero, &f32_one, "%f", 1.0f);[m
[32m+[m[32m        ImGui::DragScalar("drag float ^2",  ImGuiDataType_Float,  &f32_v, 0.005f,  &f32_zero, &f32_one, "%f", 2.0f); ImGui::SameLine(); HelpMarker("You can use the 'power' parameter to increase tweaking precision on one side of the range.");[m
[32m+[m[32m        ImGui::DragScalar("drag double",    ImGuiDataType_Double, &f64_v, 0.0005f, &f64_zero, NULL,     "%.10f grams", 1.0f);[m
[32m+[m[32m        ImGui::DragScalar("drag double ^2", ImGuiDataType_Double, &f64_v, 0.0005f, &f64_zero, &f64_one, "0 < %.10f < 1", 2.0f);[m
[32m+[m
[32m+[m[32m        ImGui::Text("Sliders");[m
[32m+[m[32m        ImGui::SliderScalar("slider s8 full",     ImGuiDataType_S8,     &s8_v,  &s8_min,   &s8_max,   "%d");[m
[32m+[m[32m        ImGui::SliderScalar("slider u8 full",     ImGuiDataType_U8,     &u8_v,  &u8_min,   &u8_max,   "%u");[m
[32m+[m[32m        ImGui::SliderScalar("slider s16 full",    ImGuiDataType_S16,    &s16_v, &s16_min,  &s16_max,  "%d");[m
[32m+[m[32m        ImGui::SliderScalar("slider u16 full",    ImGuiDataType_U16,    &u16_v, &u16_min,  &u16_max,  "%u");[m
[32m+[m[32m        ImGui::SliderScalar("slider s32 low",     ImGuiDataType_S32,    &s32_v, &s32_zero, &s32_fifty,"%d");[m
[32m+[m[32m        ImGui::SliderScalar("slider s32 high",    ImGuiDataType_S32,    &s32_v, &s32_hi_a, &s32_hi_b, "%d");[m
[32m+[m[32m        ImGui::SliderScalar("slider s32 full",    ImGuiDataType_S32,    &s32_v, &s32_min,  &s32_max,  "%d");[m
[32m+[m[32m        ImGui::SliderScalar("slider u32 low",     ImGuiDataType_U32,    &u32_v, &u32_zero, &u32_fifty,"%u");[m
[32m+[m[32m        ImGui::SliderScalar("slider u32 high",    ImGuiDataType_U32,    &u32_v, &u32_hi_a, &u32_hi_b, "%u");[m
[32m+[m[32m        ImGui::SliderScalar("slider u32 full",    ImGuiDataType_U32,    &u32_v, &u32_min,  &u32_max,  "%u");[m
[32m+[m[32m        ImGui::SliderScalar("slider s64 low",     ImGuiDataType_S64,    &s64_v, &s64_zero, &s64_fifty,"%I64d");[m
[32m+[m[32m        ImGui::SliderScalar("slider s64 high",    ImGuiDataType_S64,    &s64_v, &s64_hi_a, &s64_hi_b, "%I64d");[m
[32m+[m[32m        ImGui::SliderScalar("slider s64 full",    ImGuiDataType_S64,    &s64_v, &s64_min,  &s64_max,  "%I64d");[m
[32m+[m[32m        ImGui::SliderScalar("slider u64 low",     ImGuiDataType_U64,    &u64_v, &u64_zero, &u64_fifty,"%I64u ms");[m
[32m+[m[32m        ImGui::SliderScalar("slider u64 high",    ImGuiDataType_U64,    &u64_v, &u64_hi_a, &u64_hi_b, "%I64u ms");[m
[32m+[m[32m        ImGui::SliderScalar("slider u64 full",    ImGuiDataType_U64,    &u64_v, &u64_min,  &u64_max,  "%I64u ms");[m
[32m+[m[32m        ImGui::SliderScalar("slider float low",   ImGuiDataType_Float,  &f32_v, &f32_zero, &f32_one);[m
[32m+[m[32m        ImGui::SliderScalar("slider float low^2", ImGuiDataType_Float,  &f32_v, &f32_zero, &f32_one,  "%.10f", 2.0f);[m
[32m+[m[32m        ImGui::SliderScalar("slider float high",  ImGuiDataType_Float,  &f32_v, &f32_lo_a, &f32_hi_a, "%e");[m
[32m+[m[32m        ImGui::SliderScalar("slider double low",  ImGuiDataType_Double, &f64_v, &f64_zero, &f64_one,  "%.10f grams", 1.0f);[m
[32m+[m[32m        ImGui::SliderScalar("slider double low^2",ImGuiDataType_Double, &f64_v, &f64_zero, &f64_one,  "%.10f", 2.0f);[m
[32m+[m[32m        ImGui::SliderScalar("slider double high", ImGuiDataType_Double, &f64_v, &f64_lo_a, &f64_hi_a, "%e grams", 1.0f);[m
[32m+[m
[32m+[m[32m        static bool inputs_step = true;[m
[32m+[m[32m        ImGui::Text("Inputs");[m
[32m+[m[32m        ImGui::Checkbox("Show step buttons", &inputs_step);[m
[32m+[m[32m        ImGui::InputScalar("input s8",      ImGuiDataType_S8,     &s8_v,  inputs_step ? &s8_one  : NULL, NULL, "%d");[m
[32m+[m[32m        ImGui::InputScalar("input u8",      ImGuiDataType_U8,     &u8_v,  inputs_step ? &u8_one  : NULL, NULL, "%u");[m
[32m+[m[32m        ImGui::InputScalar("input s16",     ImGuiDataType_S16,    &s16_v, inputs_step ? &s16_one : NULL, NULL, "%d");[m
[32m+[m[32m        ImGui::InputScalar("input u16",     ImGuiDataType_U16,    &u16_v, inputs_step ? &u16_one : NULL, NULL, "%u");[m
[32m+[m[32m        ImGui::InputScalar("input s32",     ImGuiDataType_S32,    &s32_v, inputs_step ? &s32_one : NULL, NULL, "%d");[m
[32m+[m[32m        ImGui::InputScalar("input s32 hex", ImGuiDataType_S32,    &s32_v, inputs_step ? &s32_one : NULL, NULL, "%08X", ImGuiInputTextFlags_CharsHexadecimal);[m
[32m+[m[32m        ImGui::InputScalar("input u32",     ImGuiDataType_U32,    &u32_v, inputs_step ? &u32_one : NULL, NULL, "%u");[m
[32m+[m[32m        ImGui::InputScalar("input u32 hex", ImGuiDataType_U32,    &u32_v, inputs_step ? &u32_one : NULL, NULL, "%08X", ImGuiInputTextFlags_CharsHexadecimal);[m
[32m+[m[32m        ImGui::InputScalar("input s64",     ImGuiDataType_S64,    &s64_v, inputs_step ? &s64_one : NULL);[m
[32m+[m[32m        ImGui::InputScalar("input u64",     ImGuiDataType_U64,    &u64_v, inputs_step ? &u64_one : NULL);[m
[32m+[m[32m        ImGui::InputScalar("input float",   ImGuiDataType_Float,  &f32_v, inputs_step ? &f32_one : NULL);[m
[32m+[m[32m        ImGui::InputScalar("input double",  ImGuiDataType_Double, &f64_v, inputs_step ? &f64_one : NULL);[m
[32m+[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Multi-component Widgets"))[m
[32m+[m[32m    {[m
[32m+[m[32m        static float vec4f[4] = { 0.10f, 0.20f, 0.30f, 0.44f };[m
[32m+[m[32m        static int vec4i[4] = { 1, 5, 100, 255 };[m
[32m+[m
[32m+[m[32m        ImGui::InputFloat2("input float2", vec4f);[m
[32m+[m[32m        ImGui::DragFloat2("drag float2", vec4f, 0.01f, 0.0f, 1.0f);[m
[32m+[m[32m        ImGui::SliderFloat2("slider float2", vec4f, 0.0f, 1.0f);[m
[32m+[m[32m        ImGui::InputInt2("input int2", vec4i);[m
[32m+[m[32m        ImGui::DragInt2("drag int2", vec4i, 1, 0, 255);[m
[32m+[m[32m        ImGui::SliderInt2("slider int2", vec4i, 0, 255);[m
[32m+[m[32m        ImGui::Spacing();[m
[32m+[m
[32m+[m[32m        ImGui::InputFloat3("input float3", vec4f);[m
[32m+[m[32m        ImGui::DragFloat3("drag float3", vec4f, 0.01f, 0.0f, 1.0f);[m
[32m+[m[32m        ImGui::SliderFloat3("slider float3", vec4f, 0.0f, 1.0f);[m
[32m+[m[32m        ImGui::InputInt3("input int3", vec4i);[m
[32m+[m[32m        ImGui::DragInt3("drag int3", vec4i, 1, 0, 255);[m
[32m+[m[32m        ImGui::SliderInt3("slider int3", vec4i, 0, 255);[m
[32m+[m[32m        ImGui::Spacing();[m
[32m+[m
[32m+[m[32m        ImGui::InputFloat4("input float4", vec4f);[m
[32m+[m[32m        ImGui::DragFloat4("drag float4", vec4f, 0.01f, 0.0f, 1.0f);[m
[32m+[m[32m        ImGui::SliderFloat4("slider float4", vec4f, 0.0f, 1.0f);[m
[32m+[m[32m        ImGui::InputInt4("input int4", vec4i);[m
[32m+[m[32m        ImGui::DragInt4("drag int4", vec4i, 1, 0, 255);[m
[32m+[m[32m        ImGui::SliderInt4("slider int4", vec4i, 0, 255);[m
[32m+[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Vertical Sliders"))[m
[32m+[m[32m    {[m
[32m+[m[32m        const float spacing = 4;[m
[32m+[m[32m        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, spacing));[m
[32m+[m
[32m+[m[32m        static int int_value = 0;[m
[32m+[m[32m        ImGui::VSliderInt("##int", ImVec2(18,160), &int_value, 0, 5);[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m
[32m+[m[32m        static float values[7] = { 0.0f, 0.60f, 0.35f, 0.9f, 0.70f, 0.20f, 0.0f };[m
[32m+[m[32m        ImGui::PushID("set1");[m
[32m+[m[32m        for (int i = 0; i < 7; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (i > 0) ImGui::SameLine();[m
[32m+[m[32m            ImGui::PushID(i);[m
[32m+[m[32m            ImGui::PushStyleColor(ImGuiCol_FrameBg, (ImVec4)ImColor::HSV(i/7.0f, 0.5f, 0.5f));[m
[32m+[m[32m            ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, (ImVec4)ImColor::HSV(i/7.0f, 0.6f, 0.5f));[m
[32m+[m[32m            ImGui::PushStyleColor(ImGuiCol_FrameBgActive, (ImVec4)ImColor::HSV(i/7.0f, 0.7f, 0.5f));[m
[32m+[m[32m            ImGui::PushStyleColor(ImGuiCol_SliderGrab, (ImVec4)ImColor::HSV(i/7.0f, 0.9f, 0.9f));[m
[32m+[m[32m            ImGui::VSliderFloat("##v", ImVec2(18,160), &values[i], 0.0f, 1.0f, "");[m
[32m+[m[32m            if (ImGui::IsItemActive() || ImGui::IsItemHovered())[m
[32m+[m[32m                ImGui::SetTooltip("%.3f", values[i]);[m
[32m+[m[32m            ImGui::PopStyleColor(4);[m
[32m+[m[32m            ImGui::PopID();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::PopID();[m
[32m+[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m[32m        ImGui::PushID("set2");[m
[32m+[m[32m        static float values2[4] = { 0.20f, 0.80f, 0.40f, 0.25f };[m
[32m+[m[32m        const int rows = 3;[m
[32m+[m[32m        const ImVec2 small_slider_size(18, (160.0f-(rows-1)*spacing)/rows);[m
[32m+[m[32m        for (int nx = 0; nx < 4; nx++)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (nx > 0) ImGui::SameLine();[m
[32m+[m[32m            ImGui::BeginGroup();[m
[32m+[m[32m            for (int ny = 0; ny < rows; ny++)[m
[32m+[m[32m            {[m
[32m+[m[32m                ImGui::PushID(nx*rows+ny);[m
[32m+[m[32m                ImGui::VSliderFloat("##v", small_slider_size, &values2[nx], 0.0f, 1.0f, "");[m
[32m+[m[32m                if (ImGui::IsItemActive() || ImGui::IsItemHovered())[m
[32m+[m[32m                    ImGui::SetTooltip("%.3f", values2[nx]);[m
[32m+[m[32m                ImGui::PopID();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::EndGroup();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::PopID();[m
[32m+[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m[32m        ImGui::PushID("set3");[m
[32m+[m[32m        for (int i = 0; i < 4; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (i > 0) ImGui::SameLine();[m
[32m+[m[32m            ImGui::PushID(i);[m
[32m+[m[32m            ImGui::PushStyleVar(ImGuiStyleVar_GrabMinSize, 40);[m
[32m+[m[32m            ImGui::VSliderFloat("##v", ImVec2(40,160), &values[i], 0.0f, 1.0f, "%.2f\nsec");[m
[32m+[m[32m            ImGui::PopStyleVar();[m
[32m+[m[32m            ImGui::PopID();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::PopID();[m
[32m+[m[32m        ImGui::PopStyleVar();[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Drag and Drop"))[m
[32m+[m[32m    {[m
[32m+[m[32m        {[m
[32m+[m[32m            // ColorEdit widgets automatically act as drag source and drag target.[m
[32m+[m[32m            // They are using standardized payload strings IMGUI_PAYLOAD_TYPE_COLOR_3F and IMGUI_PAYLOAD_TYPE_COLOR_4F to allow your own widgets[m
[32m+[m[32m            // to use colors in their drag and drop interaction. Also see the demo in Color Picker -> Palette demo.[m
[32m+[m[32m            ImGui::BulletText("Drag and drop in standard widgets");[m
[32m+[m[32m            ImGui::Indent();[m
[32m+[m[32m            static float col1[3] = { 1.0f,0.0f,0.2f };[m
[32m+[m[32m            static float col2[4] = { 0.4f,0.7f,0.0f,0.5f };[m
[32m+[m[32m            ImGui::ColorEdit3("color 1", col1);[m
[32m+[m[32m            ImGui::ColorEdit4("color 2", col2);[m
[32m+[m[32m            ImGui::Unindent();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::BulletText("Drag and drop to copy/swap items");[m
[32m+[m[32m            ImGui::Indent();[m
[32m+[m[32m            enum Mode[m
[32m+[m[32m            {[m
[32m+[m[32m                Mode_Copy,[m
[32m+[m[32m                Mode_Move,[m
[32m+[m[32m                Mode_Swap[m
[32m+[m[32m            };[m
[32m+[m[32m            static int mode = 0;[m
[32m+[m[32m            if (ImGui::RadioButton("Copy", mode == Mode_Copy)) { mode = Mode_Copy; } ImGui::SameLine();[m
[32m+[m[32m            if (ImGui::RadioButton("Move", mode == Mode_Move)) { mode = Mode_Move; } ImGui::SameLine();[m
[32m+[m[32m            if (ImGui::RadioButton("Swap", mode == Mode_Swap)) { mode = Mode_Swap; }[m
[32m+[m[32m            static const char* names[9] = { "Bobby", "Beatrice", "Betty", "Brianna", "Barry", "Bernard", "Bibi", "Blaine", "Bryn" };[m
[32m+[m[32m            for (int n = 0; n < IM_ARRAYSIZE(names); n++)[m
[32m+[m[32m            {[m
[32m+[m[32m                ImGui::PushID(n);[m
[32m+[m[32m                if ((n % 3) != 0)[m
[32m+[m[32m                    ImGui::SameLine();[m
[32m+[m[32m                ImGui::Button(names[n], ImVec2(60,60));[m
[32m+[m
[32m+[m[32m                // Our buttons are both drag sources and drag targets here![m
[32m+[m[32m                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImGui::SetDragDropPayload("DND_DEMO_CELL", &n, sizeof(int));        // Set payload to carry the index of our item (could be anything)[m
[32m+[m[32m                    if (mode == Mode_Copy) { ImGui::Text("Copy %s", names[n]); }        // Display preview (could be anything, e.g. when dragging an image we could decide to display the filename and a small preview of the image, etc.)[m
[32m+[m[32m                    if (mode == Mode_Move) { ImGui::Text("Move %s", names[n]); }[m
[32m+[m[32m                    if (mode == Mode_Swap) { ImGui::Text("Swap %s", names[n]); }[m
[32m+[m[32m                    ImGui::EndDragDropSource();[m
[32m+[m[32m                }[m
[32m+[m[32m                if (ImGui::BeginDragDropTarget())[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("DND_DEMO_CELL"))[m
[32m+[m[32m                    {[m
[32m+[m[32m                        IM_ASSERT(payload->DataSize == sizeof(int));[m
[32m+[m[32m                        int payload_n = *(const int*)payload->Data;[m
[32m+[m[32m                        if (mode == Mode_Copy)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            names[n] = names[payload_n];[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (mode == Mode_Move)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            names[n] = names[payload_n];[m
[32m+[m[32m                            names[payload_n] = "";[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (mode == Mode_Swap)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            const char* tmp = names[n];[m
[32m+[m[32m                            names[n] = names[payload_n];[m
[32m+[m[32m                            names[payload_n] = tmp;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    ImGui::EndDragDropTarget();[m
[32m+[m[32m                }[m
[32m+[m[32m                ImGui::PopID();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::Unindent();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Querying Status (Active/Focused/Hovered etc.)"))[m
[32m+[m[32m    {[m
[32m+[m[32m        // Display the value of IsItemHovered() and other common item state functions. Note that the flags can be combined.[m
[32m+[m[32m        // (because BulletText is an item itself and that would affect the output of IsItemHovered() we pass all state in a single call to simplify the code).[m
[32m+[m[32m        static int item_type = 1;[m
[32m+[m[32m        static bool b = false;[m
[32m+[m[32m        static float col4f[4] = { 1.0f, 0.5, 0.0f, 1.0f };[m
[32m+[m[32m        static char str[16] = {};[m
[32m+[m[32m        ImGui::RadioButton("Text", &item_type, 0);[m
[32m+[m[32m        ImGui::RadioButton("Button", &item_type, 1);[m
[32m+[m[32m        ImGui::RadioButton("Checkbox", &item_type, 2);[m
[32m+[m[32m        ImGui::RadioButton("SliderFloat", &item_type, 3);[m
[32m+[m[32m        ImGui::RadioButton("InputText", &item_type, 4);[m
[32m+[m[32m        ImGui::RadioButton("ColorEdit4", &item_type, 5);[m
[32m+[m[32m        ImGui::RadioButton("MenuItem", &item_type, 6);[m
[32m+[m[32m        ImGui::RadioButton("TreeNode (w/ double-click)", &item_type, 7);[m
[32m+[m[32m        ImGui::RadioButton("ListBox", &item_type, 8);[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        bool ret = false;[m
[32m+[m[32m        if (item_type == 0) { ImGui::Text("ITEM: Text"); }                                              // Testing text items with no identifier/interaction[m
[32m+[m[32m        if (item_type == 1) { ret = ImGui::Button("ITEM: Button"); }                                    // Testing button[m
[32m+[m[32m        if (item_type == 2) { ret = ImGui::Checkbox("ITEM: Checkbox", &b); }                            // Testing checkbox[m
[32m+[m[32m        if (item_type == 3) { ret = ImGui::SliderFloat("ITEM: SliderFloat", &col4f[0], 0.0f, 1.0f); }   // Testing basic item[m
[32m+[m[32m        if (item_type == 4) { ret = ImGui::InputText("ITEM: InputText", &str[0], IM_ARRAYSIZE(str)); }  // Testing input text (which handles tabbing)[m
[32m+[m[32m        if (item_type == 5) { ret = ImGui::ColorEdit4("ITEM: ColorEdit4", col4f); }                     // Testing multi-component items (IsItemXXX flags are reported merged)[m
[32m+[m[32m        if (item_type == 6) { ret = ImGui::MenuItem("ITEM: MenuItem"); }                                // Testing menu item (they use ImGuiButtonFlags_PressedOnRelease button policy)[m
[32m+[m[32m        if (item_type == 7) { ret = ImGui::TreeNodeEx("ITEM: TreeNode w/ ImGuiTreeNodeFlags_OpenOnDoubleClick", ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_NoTreePushOnOpen); } // Testing tree node with ImGuiButtonFlags_PressedOnDoubleClick button policy.[m
[32m+[m[32m        if (item_type == 8) { const char* items[] = { "Apple", "Banana", "Cherry", "Kiwi" }; static int current = 1; ret = ImGui::ListBox("ITEM: ListBox", &current, items, IM_ARRAYSIZE(items), IM_ARRAYSIZE(items)); }[m
[32m+[m[32m        ImGui::BulletText([m
[32m+[m[32m            "Return value = %d\n"[m
[32m+[m[32m            "IsItemFocused() = %d\n"[m
[32m+[m[32m            "IsItemHovered() = %d\n"[m
[32m+[m[32m            "IsItemHovered(_AllowWhenBlockedByPopup) = %d\n"[m
[32m+[m[32m            "IsItemHovered(_AllowWhenBlockedByActiveItem) = %d\n"[m
[32m+[m[32m            "IsItemHovered(_AllowWhenOverlapped) = %d\n"[m
[32m+[m[32m            "IsItemHovered(_RectOnly) = %d\n"[m
[32m+[m[32m            "IsItemActive() = %d\n"[m
[32m+[m[32m            "IsItemEdited() = %d\n"[m
[32m+[m[32m            "IsItemActivated() = %d\n"[m
[32m+[m[32m            "IsItemDeactivated() = %d\n"[m
[32m+[m[32m            "IsItemDeactivatedAfterEdit() = %d\n"[m
[32m+[m[32m            "IsItemVisible() = %d\n"[m
[32m+[m[32m            "IsItemClicked() = %d\n"[m
[32m+[m[32m            "GetItemRectMin() = (%.1f, %.1f)\n"[m
[32m+[m[32m            "GetItemRectMax() = (%.1f, %.1f)\n"[m
[32m+[m[32m            "GetItemRectSize() = (%.1f, %.1f)",[m
[32m+[m[32m            ret,[m
[32m+[m[32m            ImGui::IsItemFocused(),[m
[32m+[m[32m            ImGui::IsItemHovered(),[m
[32m+[m[32m            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup),[m
[32m+[m[32m            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),[m
[32m+[m[32m            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenOverlapped),[m
[32m+[m[32m            ImGui::IsItemHovered(ImGuiHoveredFlags_RectOnly),[m
[32m+[m[32m            ImGui::IsItemActive(),[m
[32m+[m[32m            ImGui::IsItemEdited(),[m
[32m+[m[32m            ImGui::IsItemActivated(),[m
[32m+[m[32m            ImGui::IsItemDeactivated(),[m
[32m+[m[32m            ImGui::IsItemDeactivatedAfterEdit(),[m
[32m+[m[32m            ImGui::IsItemVisible(),[m
[32m+[m[32m            ImGui::IsItemClicked(),[m
[32m+[m[32m            ImGui::GetItemRectMin().x, ImGui::GetItemRectMin().y,[m
[32m+[m[32m            ImGui::GetItemRectMax().x, ImGui::GetItemRectMax().y,[m
[32m+[m[32m            ImGui::GetItemRectSize().x, ImGui::GetItemRectSize().y[m
[32m+[m[32m        );[m
[32m+[m
[32m+[m[32m        static bool embed_all_inside_a_child_window = false;[m
[32m+[m[32m        ImGui::Checkbox("Embed everything inside a child window (for additional testing)", &embed_all_inside_a_child_window);[m
[32m+[m[32m        if (embed_all_inside_a_child_window)[m
[32m+[m[32m            ImGui::BeginChild("outer_child", ImVec2(0, ImGui::GetFontSize() * 20), true);[m
[32m+[m
[32m+[m[32m        // Testing IsWindowFocused() function with its various flags. Note that the flags can be combined.[m
[32m+[m[32m        ImGui::BulletText([m
[32m+[m[32m            "IsWindowFocused() = %d\n"[m
[32m+[m[32m            "IsWindowFocused(_ChildWindows) = %d\n"[m
[32m+[m[32m            "IsWindowFocused(_ChildWindows|_RootWindow) = %d\n"[m
[32m+[m[32m            "IsWindowFocused(_RootWindow) = %d\n"[m
[32m+[m[32m            "IsWindowFocused(_AnyWindow) = %d\n",[m
[32m+[m[32m            ImGui::IsWindowFocused(),[m
[32m+[m[32m            ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows),[m
[32m+[m[32m            ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows | ImGuiFocusedFlags_RootWindow),[m
[32m+[m[32m            ImGui::IsWindowFocused(ImGuiFocusedFlags_RootWindow),[m
[32m+[m[32m            ImGui::IsWindowFocused(ImGuiFocusedFlags_AnyWindow));[m
[32m+[m
[32m+[m[32m        // Testing IsWindowHovered() function with its various flags. Note that the flags can be combined.[m
[32m+[m[32m        ImGui::BulletText([m
[32m+[m[32m            "IsWindowHovered() = %d\n"[m
[32m+[m[32m            "IsWindowHovered(_AllowWhenBlockedByPopup) = %d\n"[m
[32m+[m[32m            "IsWindowHovered(_AllowWhenBlockedByActiveItem) = %d\n"[m
[32m+[m[32m            "IsWindowHovered(_ChildWindows) = %d\n"[m
[32m+[m[32m            "IsWindowHovered(_ChildWindows|_RootWindow) = %d\n"[m
[32m+[m[32m            "IsWindowHovered(_ChildWindows|_AllowWhenBlockedByPopup) = %d\n"[m
[32m+[m[32m            "IsWindowHovered(_RootWindow) = %d\n"[m
[32m+[m[32m            "IsWindowHovered(_AnyWindow) = %d\n",[m
[32m+[m[32m            ImGui::IsWindowHovered(),[m
[32m+[m[32m            ImGui::IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup),[m
[32m+[m[32m            ImGui::IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),[m
[32m+[m[32m            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows),[m
[32m+[m[32m            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_RootWindow),[m
[32m+[m[32m            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_AllowWhenBlockedByPopup),[m
[32m+[m[32m            ImGui::IsWindowHovered(ImGuiHoveredFlags_RootWindow),[m
[32m+[m[32m            ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow));[m
[32m+[m
[32m+[m[32m        ImGui::BeginChild("child", ImVec2(0, 50), true);[m
[32m+[m[32m        ImGui::Text("This is another child window for testing the _ChildWindows flag.");[m
[32m+[m[32m        ImGui::EndChild();[m
[32m+[m[32m        if (embed_all_inside_a_child_window)[m
[32m+[m[32m            ImGui::EndChild();[m
[32m+[m
[32m+[m[32m        // Calling IsItemHovered() after begin returns the hovered status of the title bar.[m
[32m+[m[32m        // This is useful in particular if you want to create a context menu (with BeginPopupContextItem) associated to the title bar of a window.[m
[32m+[m[32m        static bool test_window = false;[m
[32m+[m[32m        ImGui::Checkbox("Hovered/Active tests after Begin() for title bar testing", &test_window);[m
[32m+[m[32m        if (test_window)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::Begin("Title bar Hovered/Active tests", &test_window);[m
[32m+[m[32m            if (ImGui::BeginPopupContextItem()) // <-- This is using IsItemHovered()[m
[32m+[m[32m            {[m
[32m+[m[32m                if (ImGui::MenuItem("Close")) { test_window = false; }[m
[32m+[m[32m                ImGui::EndPopup();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::Text([m
[32m+[m[32m                "IsItemHovered() after begin = %d (== is title bar hovered)\n"[m
[32m+[m[32m                "IsItemActive() after begin = %d (== is window being clicked/moved)\n",[m
[32m+[m[32m                ImGui::IsItemHovered(), ImGui::IsItemActive());[m
[32m+[m[32m            ImGui::End();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void ShowDemoWindowLayout()[m
[32m+[m[32m{[m
[32m+[m[32m    if (!ImGui::CollapsingHeader("Layout"))[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Child windows"))[m
[32m+[m[32m    {[m
[32m+[m[32m        HelpMarker("Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window.");[m
[32m+[m[32m        static bool disable_mouse_wheel = false;[m
[32m+[m[32m        static bool disable_menu = false;[m
[32m+[m[32m        ImGui::Checkbox("Disable Mouse Wheel", &disable_mouse_wheel);[m
[32m+[m[32m        ImGui::Checkbox("Disable Menu", &disable_menu);[m
[32m+[m
[32m+[m[32m        static int line = 50;[m
[32m+[m[32m        bool goto_line = ImGui::Button("Goto");[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m[32m        ImGui::SetNextItemWidth(100);[m
[32m+[m[32m        goto_line |= ImGui::InputInt("##Line", &line, 0, 0, ImGuiInputTextFlags_EnterReturnsTrue);[m
[32m+[m
[32m+[m[32m        // Child 1: no border, enable horizontal scrollbar[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGuiWindowFlags window_flags = ImGuiWindowFlags_HorizontalScrollbar | (disable_mouse_wheel ? ImGuiWindowFlags_NoScrollWithMouse : 0);[m
[32m+[m[32m            ImGui::BeginChild("Child1", ImVec2(ImGui::GetWindowContentRegionWidth() * 0.5f, 260), false, window_flags);[m
[32m+[m[32m            for (int i = 0; i < 100; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                ImGui::Text("%04d: scrollable region", i);[m
[32m+[m[32m                if (goto_line && line == i)[m
[32m+[m[32m                    ImGui::SetScrollHereY();[m
[32m+[m[32m            }[m
[32m+[m[32m            if (goto_line && line >= 100)[m
[32m+[m[32m                ImGui::SetScrollHereY();[m
[32m+[m[32m            ImGui::EndChild();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m
[32m+[m[32m        // Child 2: rounded border[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGuiWindowFlags window_flags = (disable_mouse_wheel ? ImGuiWindowFlags_NoScrollWithMouse : 0) | (disable_menu ? 0 : ImGuiWindowFlags_MenuBar);[m
[32m+[m[32m            ImGui::PushStyleVar(ImGuiStyleVar_ChildRounding, 5.0f);[m
[32m+[m[32m            ImGui::BeginChild("Child2", ImVec2(0, 260), true, window_flags);[m
[32m+[m[32m            if (!disable_menu && ImGui::BeginMenuBar())[m
[32m+[m[32m            {[m
[32m+[m[32m                if (ImGui::BeginMenu("Menu"))[m
[32m+[m[32m                {[m
[32m+[m[32m                    ShowExampleMenuFile();[m
[32m+[m[32m                    ImGui::EndMenu();[m
[32m+[m[32m                }[m
[32m+[m[32m                ImGui::EndMenuBar();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::Columns(2);[m
[32m+[m[32m            for (int i = 0; i < 100; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                char buf[32];[m
[32m+[m[32m                sprintf(buf, "%03d", i);[m
[32m+[m[32m                ImGui::Button(buf, ImVec2(-1.0f, 0.0f));[m
[32m+[m[32m                ImGui::NextColumn();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::EndChild();[m
[32m+[m[32m            ImGui::PopStyleVar();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m
[32m+[m[32m        // Demonstrate a few extra things[m
[32m+[m[32m        // - Changing ImGuiCol_ChildBg (which is transparent black in default styles)[m
[32m+[m[32m        // - Using SetCursorPos() to position the child window (because the child window is an item from the POV of the parent window)[m
[32m+[m[32m        //   You can also call SetNextWindowPos() to position the child window. The parent window will effectively layout from this position.[m
[32m+[m[32m        // - Using ImGui::GetItemRectMin/Max() to query the "item" state (because the child window is an item from the POV of the parent window)[m
[32m+[m[32m        //   See "Widgets" -> "Querying Status (Active/Focused/Hovered etc.)" section for more details about this.[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::SetCursorPosX(50);[m
[32m+[m[32m            ImGui::PushStyleColor(ImGuiCol_ChildBg, IM_COL32(255, 0, 0, 100));[m
[32m+[m[32m            ImGui::BeginChild("blah", ImVec2(200, 100), true, ImGuiWindowFlags_None);[m
[32m+[m[32m            for (int n = 0; n < 50; n++)[m
[32m+[m[32m                ImGui::Text("Some test %d", n);[m
[32m+[m[32m            ImGui::EndChild();[m
[32m+[m[32m            ImVec2 child_rect_min = ImGui::GetItemRectMin();[m
[32m+[m[32m            ImVec2 child_rect_max = ImGui::GetItemRectMax();[m
[32m+[m[32m            ImGui::PopStyleColor();[m
[32m+[m[32m            ImGui::Text("Rect of child window is: (%.0f,%.0f) (%.0f,%.0f)", child_rect_min.x, child_rect_min.y, child_rect_max.x, child_rect_max.y);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Widgets Width"))[m
[32m+[m[32m    {[m
[32m+[m[32m        // Use SetNextItemWidth() to set the width of a single upcoming item.[m
[32m+[m[32m        // Use PushItemWidth()/PopItemWidth() to set the width of a group of items.[m
[32m+[m[32m        static float f = 0.0f;[m
[32m+[m[32m        ImGui::Text("SetNextItemWidth/PushItemWidth(100)");[m
[32m+[m[32m        ImGui::SameLine(); HelpMarker("Fixed width.");[m
[32m+[m[32m        ImGui::SetNextItemWidth(100);[m
[32m+[m[32m        ImGui::DragFloat("float##1", &f);[m
[32m+[m
[32m+[m[32m        ImGui::Text("SetNextItemWidth/PushItemWidth(GetWindowWidth() * 0.5f)");[m
[32m+[m[32m        ImGui::SameLine(); HelpMarker("Half of window width.");[m
[32m+[m[32m        ImGui::SetNextItemWidth(ImGui::GetWindowWidth() * 0.5f);[m
[32m+[m[32m        ImGui::DragFloat("float##2", &f);[m
[32m+[m
[32m+[m[32m        ImGui::Text("SetNextItemWidth/PushItemWidth(GetContentRegionAvail().x * 0.5f)");[m
[32m+[m[32m        ImGui::SameLine(); HelpMarker("Half of available width.\n(~ right-cursor_pos)\n(works within a column set)");[m
[32m+[m[32m        ImGui::SetNextItemWidth(ImGui::GetContentRegionAvail().x * 0.5f);[m
[32m+[m[32m        ImGui::DragFloat("float##3", &f);[m
[32m+[m
[32m+[m[32m        ImGui::Text("SetNextItemWidth/PushItemWidth(-100)");[m
[32m+[m[32m        ImGui::SameLine(); HelpMarker("Align to right edge minus 100");[m
[32m+[m[32m        ImGui::SetNextItemWidth(-100);[m
[32m+[m[32m        ImGui::DragFloat("float##4", &f);[m
[32m+[m
[32m+[m[32m        // Demonstrate using PushItemWidth to surround three items. Calling SetNextItemWidth() before each of them would have the same effect.[m
[32m+[m[32m        ImGui::Text("SetNextItemWidth/PushItemWidth(-1)");[m
[32m+[m[32m        ImGui::SameLine(); HelpMarker("Align to right edge");[m
[32m+[m[32m        ImGui::PushItemWidth(-1);[m
[32m+[m[32m        ImGui::DragFloat("float##5a", &f);[m
[32m+[m[32m        ImGui::DragFloat("float##5b", &f);[m
[32m+[m[32m        ImGui::DragFloat("float##5c", &f);[m
[32m+[m[32m        ImGui::PopItemWidth();[m
[32m+[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Basic Horizontal Layout"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::TextWrapped("(Use ImGui::SameLine() to keep adding items to the right of the preceding item)");[m
[32m+[m
[32m+[m[32m        // Text[m
[32m+[m[32m        ImGui::Text("Two items: Hello"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::TextColored(ImVec4(1,1,0,1), "Sailor");[m
[32m+[m
[32m+[m[32m        // Adjust spacing[m
[32m+[m[32m        ImGui::Text("More spacing: Hello"); ImGui::SameLine(0, 20);[m
[32m+[m[32m        ImGui::TextColored(ImVec4(1,1,0,1), "Sailor");[m
[32m+[m
[32m+[m[32m        // Button[m
[32m+[m[32m        ImGui::AlignTextToFramePadding();[m
[32m+[m[32m        ImGui::Text("Normal buttons"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Button("Banana"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Button("Apple"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Button("Corniflower");[m
[32m+[m
[32m+[m[32m        // Button[m
[32m+[m[32m        ImGui::Text("Small buttons"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::SmallButton("Like this one"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Text("can fit within a text block.");[m
[32m+[m
[32m+[m[32m        // Aligned to arbitrary position. Easy/cheap column.[m
[32m+[m[32m        ImGui::Text("Aligned");[m
[32m+[m[32m        ImGui::SameLine(150); ImGui::Text("x=150");[m
[32m+[m[32m        ImGui::SameLine(300); ImGui::Text("x=300");[m
[32m+[m[32m        ImGui::Text("Aligned");[m
[32m+[m[32m        ImGui::SameLine(150); ImGui::SmallButton("x=150");[m
[32m+[m[32m        ImGui::SameLine(300); ImGui::SmallButton("x=300");[m
[32m+[m
[32m+[m[32m        // Checkbox[m
[32m+[m[32m        static bool c1 = false, c2 = false, c3 = false, c4 = false;[m
[32m+[m[32m        ImGui::Checkbox("My", &c1); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Checkbox("Tailor", &c2); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Checkbox("Is", &c3); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Checkbox("Rich", &c4);[m
[32m+[m
[32m+[m[32m        // Various[m
[32m+[m[32m        static float f0 = 1.0f, f1 = 2.0f, f2 = 3.0f;[m
[32m+[m[32m        ImGui::PushItemWidth(80);[m
[32m+[m[32m        const char* items[] = { "AAAA", "BBBB", "CCCC", "DDDD" };[m
[32m+[m[32m        static int item = -1;[m
[32m+[m[32m        ImGui::Combo("Combo", &item, items, IM_ARRAYSIZE(items)); ImGui::SameLine();[m
[32m+[m[32m        ImGui::SliderFloat("X", &f0, 0.0f, 5.0f); ImGui::SameLine();[m
[32m+[m[32m        ImGui::SliderFloat("Y", &f1, 0.0f, 5.0f); ImGui::SameLine();[m
[32m+[m[32m        ImGui::SliderFloat("Z", &f2, 0.0f, 5.0f);[m
[32m+[m[32m        ImGui::PopItemWidth();[m
[32m+[m
[32m+[m[32m        ImGui::PushItemWidth(80);[m
[32m+[m[32m        ImGui::Text("Lists:");[m
[32m+[m[32m        static int selection[4] = { 0, 1, 2, 3 };[m
[32m+[m[32m        for (int i = 0; i < 4; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (i > 0) ImGui::SameLine();[m
[32m+[m[32m            ImGui::PushID(i);[m
[32m+[m[32m            ImGui::ListBox("", &selection[i], items, IM_ARRAYSIZE(items));[m
[32m+[m[32m            ImGui::PopID();[m
[32m+[m[32m            //if (ImGui::IsItemHovered()) ImGui::SetTooltip("ListBox %d hovered", i);[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::PopItemWidth();[m
[32m+[m
[32m+[m[32m        // Dummy[m
[32m+[m[32m        ImVec2 button_sz(40, 40);[m
[32m+[m[32m        ImGui::Button("A", button_sz); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Dummy(button_sz); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Button("B", button_sz);[m
[32m+[m
[32m+[m[32m        // Manually wrapping (we should eventually provide this as an automatic layout feature, but for now you can do it manually)[m
[32m+[m[32m        ImGui::Text("Manually wrapping:");[m
[32m+[m[32m        ImGuiStyle& style = ImGui::GetStyle();[m
[32m+[m[32m        int buttons_count = 20;[m
[32m+[m[32m        float window_visible_x2 = ImGui::GetWindowPos().x + ImGui::GetWindowContentRegionMax().x;[m
[32m+[m[32m        for (int n = 0; n < buttons_count; n++)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::PushID(n);[m
[32m+[m[32m            ImGui::Button("Box", button_sz);[m
[32m+[m[32m            float last_button_x2 = ImGui::GetItemRectMax().x;[m
[32m+[m[32m            float next_button_x2 = last_button_x2 + style.ItemSpacing.x + button_sz.x; // Expected position if next button was on same line[m
[32m+[m[32m            if (n + 1 < buttons_count && next_button_x2 < window_visible_x2)[m
[32m+[m[32m                ImGui::SameLine();[m
[32m+[m[32m            ImGui::PopID();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Tabs"))[m
[32m+[m[32m    {[m
[32m+[m[32m        if (ImGui::TreeNode("Basic"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None;[m
[32m+[m[32m            if (ImGui::BeginTabBar("MyTabBar", tab_bar_flags))[m
[32m+[m[32m            {[m
[32m+[m[32m                if (ImGui::BeginTabItem("Avocado"))[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImGui::Text("This is the Avocado tab!\nblah blah blah blah blah");[m
[32m+[m[32m                    ImGui::EndTabItem();[m
[32m+[m[32m                }[m
[32m+[m[32m                if (ImGui::BeginTabItem("Broccoli"))[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImGui::Text("This is the Broccoli tab!\nblah blah blah blah blah");[m
[32m+[m[32m                    ImGui::EndTabItem();[m
[32m+[m[32m                }[m
[32m+[m[32m                if (ImGui::BeginTabItem("Cucumber"))[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImGui::Text("This is the Cucumber tab!\nblah blah blah blah blah");[m
[32m+[m[32m                    ImGui::EndTabItem();[m
[32m+[m[32m                }[m
[32m+[m[32m                ImGui::EndTabBar();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::Separator();[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::TreeNode("Advanced & Close Button"))[m
[32m+[m[32m        {[m
[32m+[m[32m            // Expose a couple of the available flags. In most cases you may just call BeginTabBar() with no flags (0).[m
[32m+[m[32m            static ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_Reorderable;[m
[32m+[m[32m            ImGui::CheckboxFlags("ImGuiTabBarFlags_Reorderable", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_Reorderable);[m
[32m+[m[32m            ImGui::CheckboxFlags("ImGuiTabBarFlags_AutoSelectNewTabs", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_AutoSelectNewTabs);[m
[32m+[m[32m            ImGui::CheckboxFlags("ImGuiTabBarFlags_TabListPopupButton", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_TabListPopupButton);[m
[32m+[m[32m            ImGui::CheckboxFlags("ImGuiTabBarFlags_NoCloseWithMiddleMouseButton", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_NoCloseWithMiddleMouseButton);[m
[32m+[m[32m            if ((tab_bar_flags & ImGuiTabBarFlags_FittingPolicyMask_) == 0)[m
[32m+[m[32m                tab_bar_flags |= ImGuiTabBarFlags_FittingPolicyDefault_;[m
[32m+[m[32m            if (ImGui::CheckboxFlags("ImGuiTabBarFlags_FittingPolicyResizeDown", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_FittingPolicyResizeDown))[m
[32m+[m[32m                tab_bar_flags &= ~(ImGuiTabBarFlags_FittingPolicyMask_ ^ ImGuiTabBarFlags_FittingPolicyResizeDown);[m
[32m+[m[32m            if (ImGui::CheckboxFlags("ImGuiTabBarFlags_FittingPolicyScroll", (unsigned int*)&tab_bar_flags, ImGuiTabBarFlags_FittingPolicyScroll))[m
[32m+[m[32m                tab_bar_flags &= ~(ImGuiTabBarFlags_FittingPolicyMask_ ^ ImGuiTabBarFlags_FittingPolicyScroll);[m
[32m+[m
[32m+[m[32m            // Tab Bar[m
[32m+[m[32m            const char* names[4] = { "Artichoke", "Beetroot", "Celery", "Daikon" };[m
[32m+[m[32m            static bool opened[4] = { true, true, true, true }; // Persistent user state[m
[32m+[m[32m            for (int n = 0; n < IM_ARRAYSIZE(opened); n++)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (n > 0) { ImGui::SameLine(); }[m
[32m+[m[32m                ImGui::Checkbox(names[n], &opened[n]);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Passing a bool* to BeginTabItem() is similar to passing one to Begin(): the underlying bool will be set to false when the tab is closed.[m
[32m+[m[32m            if (ImGui::BeginTabBar("MyTabBar", tab_bar_flags))[m
[32m+[m[32m            {[m
[32m+[m[32m                for (int n = 0; n < IM_ARRAYSIZE(opened); n++)[m
[32m+[m[32m                    if (opened[n] && ImGui::BeginTabItem(names[n], &opened[n]))[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ImGui::Text("This is the %s tab!", names[n]);[m
[32m+[m[32m                        if (n & 1)[m
[32m+[m[32m                            ImGui::Text("I am an odd tab.");[m
[32m+[m[32m                        ImGui::EndTabItem();[m
[32m+[m[32m                    }[m
[32m+[m[32m                ImGui::EndTabBar();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::Separator();[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Groups"))[m
[32m+[m[32m    {[m
[32m+[m[32m        HelpMarker("Using ImGui::BeginGroup()/EndGroup() to layout items. BeginGroup() basically locks the horizontal position. EndGroup() bundles the whole group so that you can use functions such as IsItemHovered() on it.");[m
[32m+[m[32m        ImGui::BeginGroup();[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::BeginGroup();[m
[32m+[m[32m            ImGui::Button("AAA");[m
[32m+[m[32m            ImGui::SameLine();[m
[32m+[m[32m            ImGui::Button("BBB");[m
[32m+[m[32m            ImGui::SameLine();[m
[32m+[m[32m            ImGui::BeginGroup();[m
[32m+[m[32m            ImGui::Button("CCC");[m
[32m+[m[32m            ImGui::Button("DDD");[m
[32m+[m[32m            ImGui::EndGroup();[m
[32m+[m[32m            ImGui::SameLine();[m
[32m+[m[32m            ImGui::Button("EEE");[m
[32m+[m[32m            ImGui::EndGroup();[m
[32m+[m[32m            if (ImGui::IsItemHovered())[m
[32m+[m[32m                ImGui::SetTooltip("First group hovered");[m
[32m+[m[32m        }[m
[32m+[m[32m        // Capture the group size and create widgets using the same size[m
[32m+[m[32m        ImVec2 size = ImGui::GetItemRectSize();[m
[32m+[m[32m        const float values[5] = { 0.5f, 0.20f, 0.80f, 0.60f, 0.25f };[m
[32m+[m[32m        ImGui::PlotHistogram("##values", values, IM_ARRAYSIZE(values), 0, NULL, 0.0f, 1.0f, size);[m
[32m+[m
[32m+[m[32m        ImGui::Button("ACTION", ImVec2((size.x - ImGui::GetStyle().ItemSpacing.x)*0.5f, size.y));[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m[32m        ImGui::Button("REACTION", ImVec2((size.x - ImGui::GetStyle().ItemSpacing.x)*0.5f, size.y));[m
[32m+[m[32m        ImGui::EndGroup();[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m
[32m+[m[32m        ImGui::Button("LEVERAGE\nBUZZWORD", size);[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m
[32m+[m[32m        if (ImGui::ListBoxHeader("List", size))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::Selectable("Selected", true);[m
[32m+[m[32m            ImGui::Selectable("Not Selected", false);[m
[32m+[m[32m            ImGui::ListBoxFooter();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Text Baseline Alignment"))[m
[32m+[m[32m    {[m
[32m+[m[32m        HelpMarker("This is testing the vertical alignment that gets applied on text to keep it aligned with widgets. Lines only composed of text or \"small\" widgets fit in less vertical spaces than lines with normal widgets.");[m
[32m+[m
[32m+[m[32m        ImGui::Text("One\nTwo\nThree"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Text("Hello\nWorld"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Text("Banana");[m
[32m+[m
[32m+[m[32m        ImGui::Text("Banana"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Text("Hello\nWorld"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Text("One\nTwo\nThree");[m
[32m+[m
[32m+[m[32m        ImGui::Button("HOP##1"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Text("Banana"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Text("Hello\nWorld"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Text("Banana");[m
[32m+[m
[32m+[m[32m        ImGui::Button("HOP##2"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Text("Hello\nWorld"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Text("Banana");[m
[32m+[m
[32m+[m[32m        ImGui::Button("TEST##1"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Text("TEST"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::SmallButton("TEST##2");[m
[32m+[m
[32m+[m[32m        ImGui::AlignTextToFramePadding(); // If your line starts with text, call this to align it to upcoming widgets.[m
[32m+[m[32m        ImGui::Text("Text aligned to Widget"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Button("Widget##1"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Text("Widget"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::SmallButton("Widget##2"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::Button("Widget##3");[m
[32m+[m
[32m+[m[32m        // Tree[m
[32m+[m[32m        const float spacing = ImGui::GetStyle().ItemInnerSpacing.x;[m
[32m+[m[32m        ImGui::Button("Button##1");[m
[32m+[m[32m        ImGui::SameLine(0.0f, spacing);[m
[32m+[m[32m        if (ImGui::TreeNode("Node##1")) { for (int i = 0; i < 6; i++) ImGui::BulletText("Item %d..", i); ImGui::TreePop(); }    // Dummy tree data[m
[32m+[m
[32m+[m[32m        ImGui::AlignTextToFramePadding();         // Vertically align text node a bit lower so it'll be vertically centered with upcoming widget. Otherwise you can use SmallButton (smaller fit).[m
[32m+[m[32m        bool node_open = ImGui::TreeNode("Node##2");  // Common mistake to avoid: if we want to SameLine after TreeNode we need to do it before we add child content.[m
[32m+[m[32m        ImGui::SameLine(0.0f, spacing); ImGui::Button("Button##2");[m
[32m+[m[32m        if (node_open) { for (int i = 0; i < 6; i++) ImGui::BulletText("Item %d..", i); ImGui::TreePop(); }   // Dummy tree data[m
[32m+[m
[32m+[m[32m        // Bullet[m
[32m+[m[32m        ImGui::Button("Button##3");[m
[32m+[m[32m        ImGui::SameLine(0.0f, spacing);[m
[32m+[m[32m        ImGui::BulletText("Bullet text");[m
[32m+[m
[32m+[m[32m        ImGui::AlignTextToFramePadding();[m
[32m+[m[32m        ImGui::BulletText("Node");[m
[32m+[m[32m        ImGui::SameLine(0.0f, spacing); ImGui::Button("Button##4");[m
[32m+[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Scrolling"))[m
[32m+[m[32m    {[m
[32m+[m[32m        HelpMarker("Use SetScrollHereY() or SetScrollFromPosY() to scroll to a given position.");[m
[32m+[m
[32m+[m[32m        static bool track = true;[m
[32m+[m[32m        static int track_line = 50, scroll_to_px = 200;[m
[32m+[m[32m        ImGui::Checkbox("Track", &track);[m
[32m+[m[32m        ImGui::PushItemWidth(100);[m
[32m+[m[32m        ImGui::SameLine(130); track |= ImGui::DragInt("##line", &track_line, 0.25f, 0, 99, "Line = %d");[m
[32m+[m[32m        bool scroll_to = ImGui::Button("Scroll To Pos");[m
[32m+[m[32m        ImGui::SameLine(130); scroll_to |= ImGui::DragInt("##pos_y", &scroll_to_px, 1.00f, 0, 9999, "Y = %d px");[m
[32m+[m[32m        ImGui::PopItemWidth();[m
[32m+[m[32m        if (scroll_to) track = false;[m
[32m+[m
[32m+[m[32m        for (int i = 0; i < 5; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (i > 0) ImGui::SameLine();[m
[32m+[m[32m            ImGui::BeginGroup();[m
[32m+[m[32m            ImGui::Text("%s", i == 0 ? "Top" : i == 1 ? "25%" : i == 2 ? "Center" : i == 3 ? "75%" : "Bottom");[m
[32m+[m[32m            ImGui::BeginChild(ImGui::GetID((void*)(intptr_t)i), ImVec2(ImGui::GetWindowWidth() * 0.17f, 200.0f), true);[m
[32m+[m[32m            if (scroll_to)[m
[32m+[m[32m                ImGui::SetScrollFromPosY(ImGui::GetCursorStartPos().y + scroll_to_px, i * 0.25f);[m
[32m+[m[32m            for (int line = 0; line < 100; line++)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (track && line == track_line)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImGui::TextColored(ImVec4(1,1,0,1), "Line %d", line);[m
[32m+[m[32m                    ImGui::SetScrollHereY(i * 0.25f); // 0.0f:top, 0.5f:center, 1.0f:bottom[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImGui::Text("Line %d", line);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            float scroll_y = ImGui::GetScrollY(), scroll_max_y = ImGui::GetScrollMaxY();[m
[32m+[m[32m            ImGui::EndChild();[m
[32m+[m[32m            ImGui::Text("%.0f/%0.f", scroll_y, scroll_max_y);[m
[32m+[m[32m            ImGui::EndGroup();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Horizontal Scrolling"))[m
[32m+[m[32m    {[m
[32m+[m[32m        HelpMarker("Horizontal scrolling for a window has to be enabled explicitly via the ImGuiWindowFlags_HorizontalScrollbar flag.\n\nYou may want to explicitly specify content width by calling SetNextWindowContentWidth() before Begin().");[m
[32m+[m[32m        static int lines = 7;[m
[32m+[m[32m        ImGui::SliderInt("Lines", &lines, 1, 15);[m
[32m+[m[32m        ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 3.0f);[m
[32m+[m[32m        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2.0f, 1.0f));[m
[32m+[m[32m        ImGui::BeginChild("scrolling", ImVec2(0, ImGui::GetFrameHeightWithSpacing() * 7 + 30), true, ImGuiWindowFlags_HorizontalScrollbar);[m
[32m+[m[32m        for (int line = 0; line < lines; line++)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Display random stuff (for the sake of this trivial demo we are using basic Button+SameLine. If you want to create your own time line for a real application you may be better off[m
[32m+[m[32m            // manipulating the cursor position yourself, aka using SetCursorPos/SetCursorScreenPos to position the widgets yourself. You may also want to use the lower-level ImDrawList API)[m
[32m+[m[32m            int num_buttons = 10 + ((line & 1) ? line * 9 : line * 3);[m
[32m+[m[32m            for (int n = 0; n < num_buttons; n++)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (n > 0) ImGui::SameLine();[m
[32m+[m[32m                ImGui::PushID(n + line * 1000);[m
[32m+[m[32m                char num_buf[16];[m
[32m+[m[32m                sprintf(num_buf, "%d", n);[m
[32m+[m[32m                const char* label = (!(n%15)) ? "FizzBuzz" : (!(n%3)) ? "Fizz" : (!(n%5)) ? "Buzz" : num_buf;[m
[32m+[m[32m                float hue = n*0.05f;[m
[32m+[m[32m                ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4)ImColor::HSV(hue, 0.6f, 0.6f));[m
[32m+[m[32m                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4)ImColor::HSV(hue, 0.7f, 0.7f));[m
[32m+[m[32m                ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4)ImColor::HSV(hue, 0.8f, 0.8f));[m
[32m+[m[32m                ImGui::Button(label, ImVec2(40.0f + sinf((float)(line + n)) * 20.0f, 0.0f));[m
[32m+[m[32m                ImGui::PopStyleColor(3);[m
[32m+[m[32m                ImGui::PopID();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        float scroll_x = ImGui::GetScrollX();[m
[32m+[m[32m        float scroll_max_x = ImGui::GetScrollMaxX();[m
[32m+[m[32m        ImGui::EndChild();[m
[32m+[m[32m        ImGui::PopStyleVar(2);[m
[32m+[m[32m        float scroll_x_delta = 0.0f;[m
[32m+[m[32m        ImGui::SmallButton("<<"); if (ImGui::IsItemActive()) { scroll_x_delta = -ImGui::GetIO().DeltaTime * 1000.0f; } ImGui::SameLine();[m
[32m+[m[32m        ImGui::Text("Scroll from code"); ImGui::SameLine();[m
[32m+[m[32m        ImGui::SmallButton(">>"); if (ImGui::IsItemActive()) { scroll_x_delta = +ImGui::GetIO().DeltaTime * 1000.0f; } ImGui::SameLine();[m
[32m+[m[32m        ImGui::Text("%.0f/%.0f", scroll_x, scroll_max_x);[m
[32m+[m[32m        if (scroll_x_delta != 0.0f)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::BeginChild("scrolling"); // Demonstrate a trick: you can use Begin to set yourself in the context of another window (here we are already out of your child window)[m
[32m+[m[32m            ImGui::SetScrollX(ImGui::GetScrollX() + scroll_x_delta);[m
[32m+[m[32m            ImGui::EndChild();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Clipping"))[m
[32m+[m[32m    {[m
[32m+[m[32m        static ImVec2 size(100, 100), offset(50, 20);[m
[32m+[m[32m        ImGui::TextWrapped("On a per-widget basis we are occasionally clipping text CPU-side if it won't fit in its frame. Otherwise we are doing coarser clipping + passing a scissor rectangle to the renderer. The system is designed to try minimizing both execution and CPU/GPU rendering cost.");[m
[32m+[m[32m        ImGui::DragFloat2("size", (float*)&size, 0.5f, 1.0f, 200.0f, "%.0f");[m
[32m+[m[32m        ImGui::TextWrapped("(Click and drag)");[m
[32m+[m[32m        ImVec2 pos = ImGui::GetCursorScreenPos();[m
[32m+[m[32m        ImVec4 clip_rect(pos.x, pos.y, pos.x + size.x, pos.y + size.y);[m
[32m+[m[32m        ImGui::InvisibleButton("##dummy", size);[m
[32m+[m[32m        if (ImGui::IsItemActive() && ImGui::IsMouseDragging()) { offset.x += ImGui::GetIO().MouseDelta.x; offset.y += ImGui::GetIO().MouseDelta.y; }[m
[32m+[m[32m        ImGui::GetWindowDrawList()->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), IM_COL32(90, 90, 120, 255));[m
[32m+[m[32m        ImGui::GetWindowDrawList()->AddText(ImGui::GetFont(), ImGui::GetFontSize()*2.0f, ImVec2(pos.x + offset.x, pos.y + offset.y), IM_COL32(255, 255, 255, 255), "Line 1 hello\nLine 2 clip me!", NULL, 0.0f, &clip_rect);[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void ShowDemoWindowPopups()[m
[32m+[m[32m{[m
[32m+[m[32m    if (!ImGui::CollapsingHeader("Popups & Modal windows"))[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // The properties of popups windows are:[m
[32m+[m[32m    // - They block normal mouse hovering detection outside them. (*)[m
[32m+[m[32m    // - Unless modal, they can be closed by clicking anywhere outside them, or by pressing ESCAPE.[m
[32m+[m[32m    // - Their visibility state (~bool) is held internally by imgui instead of being held by the programmer as we are used to with regular Begin() calls.[m
[32m+[m[32m    //   User can manipulate the visibility state by calling OpenPopup().[m
[32m+[m[32m    // (*) One can use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup) to bypass it and detect hovering even when normally blocked by a popup.[m
[32m+[m[32m    // Those three properties are connected. The library needs to hold their visibility state because it can close popups at any time.[m
[32m+[m
[32m+[m[32m    // Typical use for regular windows:[m
[32m+[m[32m    //   bool my_tool_is_active = false; if (ImGui::Button("Open")) my_tool_is_active = true; [...] if (my_tool_is_active) Begin("My Tool", &my_tool_is_active) { [...] } End();[m
[32m+[m[32m    // Typical use for popups:[m
[32m+[m[32m    //   if (ImGui::Button("Open")) ImGui::OpenPopup("MyPopup"); if (ImGui::BeginPopup("MyPopup") { [...] EndPopup(); }[m
[32m+[m
[32m+[m[32m    // With popups we have to go through a library call (here OpenPopup) to manipulate the visibility state.[m
[32m+[m[32m    // This may be a bit confusing at first but it should quickly make sense. Follow on the examples below.[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Popups"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::TextWrapped("When a popup is active, it inhibits interacting with windows that are behind the popup. Clicking outside the popup closes it.");[m
[32m+[m
[32m+[m[32m        static int selected_fish = -1;[m
[32m+[m[32m        const char* names[] = { "Bream", "Haddock", "Mackerel", "Pollock", "Tilefish" };[m
[32m+[m[32m        static bool toggles[] = { true, false, false, false, false };[m
[32m+[m
[32m+[m[32m        // Simple selection popup[m
[32m+[m[32m        // (If you want to show the current selection inside the Button itself, you may want to build a string using the "###" operator to preserve a constant ID with a variable label)[m
[32m+[m[32m        if (ImGui::Button("Select.."))[m
[32m+[m[32m            ImGui::OpenPopup("my_select_popup");[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m[32m        ImGui::TextUnformatted(selected_fish == -1 ? "<None>" : names[selected_fish]);[m
[32m+[m[32m        if (ImGui::BeginPopup("my_select_popup"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::Text("Aquarium");[m
[32m+[m[32m            ImGui::Separator();[m
[32m+[m[32m            for (int i = 0; i < IM_ARRAYSIZE(names); i++)[m
[32m+[m[32m                if (ImGui::Selectable(names[i]))[m
[32m+[m[32m                    selected_fish = i;[m
[32m+[m[32m            ImGui::EndPopup();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Showing a menu with toggles[m
[32m+[m[32m        if (ImGui::Button("Toggle.."))[m
[32m+[m[32m            ImGui::OpenPopup("my_toggle_popup");[m
[32m+[m[32m        if (ImGui::BeginPopup("my_toggle_popup"))[m
[32m+[m[32m        {[m
[32m+[m[32m            for (int i = 0; i < IM_ARRAYSIZE(names); i++)[m
[32m+[m[32m                ImGui::MenuItem(names[i], "", &toggles[i]);[m
[32m+[m[32m            if (ImGui::BeginMenu("Sub-menu"))[m
[32m+[m[32m            {[m
[32m+[m[32m                ImGui::MenuItem("Click me");[m
[32m+[m[32m                ImGui::EndMenu();[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            ImGui::Separator();[m
[32m+[m[32m            ImGui::Text("Tooltip here");[m
[32m+[m[32m            if (ImGui::IsItemHovered())[m
[32m+[m[32m                ImGui::SetTooltip("I am a tooltip over a popup");[m
[32m+[m
[32m+[m[32m            if (ImGui::Button("Stacked Popup"))[m
[32m+[m[32m                ImGui::OpenPopup("another popup");[m
[32m+[m[32m            if (ImGui::BeginPopup("another popup"))[m
[32m+[m[32m            {[m
[32m+[m[32m                for (int i = 0; i < IM_ARRAYSIZE(names); i++)[m
[32m+[m[32m                    ImGui::MenuItem(names[i], "", &toggles[i]);[m
[32m+[m[32m                if (ImGui::BeginMenu("Sub-menu"))[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImGui::MenuItem("Click me");[m
[32m+[m[32m                    if (ImGui::Button("Stacked Popup"))[m
[32m+[m[32m                        ImGui::OpenPopup("another popup");[m
[32m+[m[32m                    if (ImGui::BeginPopup("another popup"))[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ImGui::Text("I am the last one here.");[m
[32m+[m[32m                        ImGui::EndPopup();[m
[32m+[m[32m                    }[m
[32m+[m[32m                    ImGui::EndMenu();[m
[32m+[m[32m                }[m
[32m+[m[32m                ImGui::EndPopup();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::EndPopup();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Call the more complete ShowExampleMenuFile which we use in various places of this demo[m
[32m+[m[32m        if (ImGui::Button("File Menu.."))[m
[32m+[m[32m            ImGui::OpenPopup("my_file_popup");[m
[32m+[m[32m        if (ImGui::BeginPopup("my_file_popup"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ShowExampleMenuFile();[m
[32m+[m[32m            ImGui::EndPopup();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Context menus"))[m
[32m+[m[32m    {[m
[32m+[m[32m        // BeginPopupContextItem() is a helper to provide common/simple popup behavior of essentially doing:[m
[32m+[m[32m        //    if (IsItemHovered() && IsMouseReleased(0))[m
[32m+[m[32m        //       OpenPopup(id);[m
[32m+[m[32m        //    return BeginPopup(id);[m
[32m+[m[32m        // For more advanced uses you may want to replicate and cuztomize this code. This the comments inside BeginPopupContextItem() implementation.[m
[32m+[m[32m        static float value = 0.5f;[m
[32m+[m[32m        ImGui::Text("Value = %.3f (<-- right-click here)", value);[m
[32m+[m[32m        if (ImGui::BeginPopupContextItem("item context menu"))[m
[32m+[m[32m        {[m
[32m+[m[32m            if (ImGui::Selectable("Set to zero")) value = 0.0f;[m
[32m+[m[32m            if (ImGui::Selectable("Set to PI")) value = 3.1415f;[m
[32m+[m[32m            ImGui::SetNextItemWidth(-1);[m
[32m+[m[32m            ImGui::DragFloat("##Value", &value, 0.1f, 0.0f, 0.0f);[m
[32m+[m[32m            ImGui::EndPopup();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // We can also use OpenPopupOnItemClick() which is the same as BeginPopupContextItem() but without the Begin call.[m
[32m+[m[32m        // So here we will make it that clicking on the text field with the right mouse button (1) will toggle the visibility of the popup above.[m
[32m+[m[32m        ImGui::Text("(You can also right-click me to open the same popup as above.)");[m
[32m+[m[32m        ImGui::OpenPopupOnItemClick("item context menu", 1);[m
[32m+[m
[32m+[m[32m        // When used after an item that has an ID (here the Button), we can skip providing an ID to BeginPopupContextItem().[m
[32m+[m[32m        // BeginPopupContextItem() will use the last item ID as the popup ID.[m
[32m+[m[32m        // In addition here, we want to include your editable label inside the button label. We use the ### operator to override the ID (read FAQ about ID for details)[m
[32m+[m[32m        static char name[32] = "Label1";[m
[32m+[m[32m        char buf[64]; sprintf(buf, "Button: %s###Button", name); // ### operator override ID ignoring the preceding label[m
[32m+[m[32m        ImGui::Button(buf);[m
[32m+[m[32m        if (ImGui::BeginPopupContextItem())[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::Text("Edit name:");[m
[32m+[m[32m            ImGui::InputText("##edit", name, IM_ARRAYSIZE(name));[m
[32m+[m[32m            if (ImGui::Button("Close"))[m
[32m+[m[32m                ImGui::CloseCurrentPopup();[m
[32m+[m[32m            ImGui::EndPopup();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::SameLine(); ImGui::Text("(<-- right-click here)");[m
[32m+[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Modals"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::TextWrapped("Modal windows are like popups but the user cannot close them by clicking outside the window.");[m
[32m+[m
[32m+[m[32m        if (ImGui::Button("Delete.."))[m
[32m+[m[32m            ImGui::OpenPopup("Delete?");[m
[32m+[m
[32m+[m[32m        if (ImGui::BeginPopupModal("Delete?", NULL, ImGuiWindowFlags_AlwaysAutoResize))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::Text("All those beautiful files will be deleted.\nThis operation cannot be undone!\n\n");[m
[32m+[m[32m            ImGui::Separator();[m
[32m+[m
[32m+[m[32m            //static int dummy_i = 0;[m
[32m+[m[32m            //ImGui::Combo("Combo", &dummy_i, "Delete\0Delete harder\0");[m
[32m+[m
[32m+[m[32m            static bool dont_ask_me_next_time = false;[m
[32m+[m[32m            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));[m
[32m+[m[32m            ImGui::Checkbox("Don't ask me next time", &dont_ask_me_next_time);[m
[32m+[m[32m            ImGui::PopStyleVar();[m
[32m+[m
[32m+[m[32m            if (ImGui::Button("OK", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }[m
[32m+[m[32m            ImGui::SetItemDefaultFocus();[m
[32m+[m[32m            ImGui::SameLine();[m
[32m+[m[32m            if (ImGui::Button("Cancel", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }[m
[32m+[m[32m            ImGui::EndPopup();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::Button("Stacked modals.."))[m
[32m+[m[32m            ImGui::OpenPopup("Stacked 1");[m
[32m+[m[32m        if (ImGui::BeginPopupModal("Stacked 1", NULL, ImGuiWindowFlags_MenuBar))[m
[32m+[m[32m        {[m
[32m+[m[32m            if (ImGui::BeginMenuBar())[m
[32m+[m[32m            {[m
[32m+[m[32m                if (ImGui::BeginMenu("File"))[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (ImGui::MenuItem("Dummy menu item")) {}[m
[32m+[m[32m                    ImGui::EndMenu();[m
[32m+[m[32m                }[m
[32m+[m[32m                ImGui::EndMenuBar();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::Text("Hello from Stacked The First\nUsing style.Colors[ImGuiCol_ModalWindowDimBg] behind it.");[m
[32m+[m
[32m+[m[32m            // Testing behavior of widgets stacking their own regular popups over the modal.[m
[32m+[m[32m            static int item = 1;[m
[32m+[m[32m            static float color[4] = { 0.4f,0.7f,0.0f,0.5f };[m
[32m+[m[32m            ImGui::Combo("Combo", &item, "aaaa\0bbbb\0cccc\0dddd\0eeee\0\0");[m
[32m+[m[32m            ImGui::ColorEdit4("color", color);[m
[32m+[m
[32m+[m[32m            if (ImGui::Button("Add another modal.."))[m
[32m+[m[32m                ImGui::OpenPopup("Stacked 2");[m
[32m+[m
[32m+[m[32m            // Also demonstrate passing a bool* to BeginPopupModal(), this will create a regular close button which will close the popup.[m
[32m+[m[32m            // Note that the visibility state of popups is owned by imgui, so the input value of the bool actually doesn't matter here.[m
[32m+[m[32m            bool dummy_open = true;[m
[32m+[m[32m            if (ImGui::BeginPopupModal("Stacked 2", &dummy_open))[m
[32m+[m[32m            {[m
[32m+[m[32m                ImGui::Text("Hello from Stacked The Second!");[m
[32m+[m[32m                if (ImGui::Button("Close"))[m
[32m+[m[32m                    ImGui::CloseCurrentPopup();[m
[32m+[m[32m                ImGui::EndPopup();[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            if (ImGui::Button("Close"))[m
[32m+[m[32m                ImGui::CloseCurrentPopup();[m
[32m+[m[32m            ImGui::EndPopup();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Menus inside a regular window"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::TextWrapped("Below we are testing adding menu items to a regular window. It's rather unusual but should work!");[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        // NB: As a quirk in this very specific example, we want to differentiate the parent of this menu from the parent of the various popup menus above.[m
[32m+[m[32m        // To do so we are encloding the items in a PushID()/PopID() block to make them two different menusets. If we don't, opening any popup above and hovering our menu here[m
[32m+[m[32m        // would open it. This is because once a menu is active, we allow to switch to a sibling menu by just hovering on it, which is the desired behavior for regular menus.[m
[32m+[m[32m        ImGui::PushID("foo");[m
[32m+[m[32m        ImGui::MenuItem("Menu item", "CTRL+M");[m
[32m+[m[32m        if (ImGui::BeginMenu("Menu inside a regular window"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ShowExampleMenuFile();[m
[32m+[m[32m            ImGui::EndMenu();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::PopID();[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void ShowDemoWindowColumns()[m
[32m+[m[32m{[m
[32m+[m[32m    if (!ImGui::CollapsingHeader("Columns"))[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGui::PushID("Columns");[m
[32m+[m
[32m+[m[32m    static bool disable_indent = false;[m
[32m+[m[32m    ImGui::Checkbox("Disable tree indentation", &disable_indent);[m
[32m+[m[32m    ImGui::SameLine();[m
[32m+[m[32m    HelpMarker("Disable the indenting of tree nodes so demo columns can use the full window width.");[m
[32m+[m[32m    if (disable_indent)[m
[32m+[m[32m        ImGui::PushStyleVar(ImGuiStyleVar_IndentSpacing, 0.0f);[m
[32m+[m
[32m+[m[32m    // Basic columns[m
[32m+[m[32m    if (ImGui::TreeNode("Basic"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::Text("Without border:");[m
[32m+[m[32m        ImGui::Columns(3, "mycolumns3", false);  // 3-ways, no border[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        for (int n = 0; n < 14; n++)[m
[32m+[m[32m        {[m
[32m+[m[32m            char label[32];[m
[32m+[m[32m            sprintf(label, "Item %d", n);[m
[32m+[m[32m            if (ImGui::Selectable(label)) {}[m
[32m+[m[32m            //if (ImGui::Button(label, ImVec2(-1,0))) {}[m
[32m+[m[32m            ImGui::NextColumn();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::Columns(1);[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m
[32m+[m[32m        ImGui::Text("With border:");[m
[32m+[m[32m        ImGui::Columns(4, "mycolumns"); // 4-ways, with border[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        ImGui::Text("ID"); ImGui::NextColumn();[m
[32m+[m[32m        ImGui::Text("Name"); ImGui::NextColumn();[m
[32m+[m[32m        ImGui::Text("Path"); ImGui::NextColumn();[m
[32m+[m[32m        ImGui::Text("Hovered"); ImGui::NextColumn();[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        const char* names[3] = { "One", "Two", "Three" };[m
[32m+[m[32m        const char* paths[3] = { "/path/one", "/path/two", "/path/three" };[m
[32m+[m[32m        static int selected = -1;[m
[32m+[m[32m        for (int i = 0; i < 3; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            char label[32];[m
[32m+[m[32m            sprintf(label, "%04d", i);[m
[32m+[m[32m            if (ImGui::Selectable(label, selected == i, ImGuiSelectableFlags_SpanAllColumns))[m
[32m+[m[32m                selected = i;[m
[32m+[m[32m            bool hovered = ImGui::IsItemHovered();[m
[32m+[m[32m            ImGui::NextColumn();[m
[32m+[m[32m            ImGui::Text(names[i]); ImGui::NextColumn();[m
[32m+[m[32m            ImGui::Text(paths[i]); ImGui::NextColumn();[m
[32m+[m[32m            ImGui::Text("%d", hovered); ImGui::NextColumn();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::Columns(1);[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Create multiple items in a same cell before switching to next column[m
[32m+[m[32m    if (ImGui::TreeNode("Mixed items"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::Columns(3, "mixed");[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m
[32m+[m[32m        ImGui::Text("Hello");[m
[32m+[m[32m        ImGui::Button("Banana");[m
[32m+[m[32m        ImGui::NextColumn();[m
[32m+[m
[32m+[m[32m        ImGui::Text("ImGui");[m
[32m+[m[32m        ImGui::Button("Apple");[m
[32m+[m[32m        static float foo = 1.0f;[m
[32m+[m[32m        ImGui::InputFloat("red", &foo, 0.05f, 0, "%.3f");[m
[32m+[m[32m        ImGui::Text("An extra line here.");[m
[32m+[m[32m        ImGui::NextColumn();[m
[32m+[m
[32m+[m[32m        ImGui::Text("Sailor");[m
[32m+[m[32m        ImGui::Button("Corniflower");[m
[32m+[m[32m        static float bar = 1.0f;[m
[32m+[m[32m        ImGui::InputFloat("blue", &bar, 0.05f, 0, "%.3f");[m
[32m+[m[32m        ImGui::NextColumn();[m
[32m+[m
[32m+[m[32m        if (ImGui::CollapsingHeader("Category A")) { ImGui::Text("Blah blah blah"); } ImGui::NextColumn();[m
[32m+[m[32m        if (ImGui::CollapsingHeader("Category B")) { ImGui::Text("Blah blah blah"); } ImGui::NextColumn();[m
[32m+[m[32m        if (ImGui::CollapsingHeader("Category C")) { ImGui::Text("Blah blah blah"); } ImGui::NextColumn();[m
[32m+[m[32m        ImGui::Columns(1);[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Word wrapping[m
[32m+[m[32m    if (ImGui::TreeNode("Word-wrapping"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::Columns(2, "word-wrapping");[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        ImGui::TextWrapped("The quick brown fox jumps over the lazy dog.");[m
[32m+[m[32m        ImGui::TextWrapped("Hello Left");[m
[32m+[m[32m        ImGui::NextColumn();[m
[32m+[m[32m        ImGui::TextWrapped("The quick brown fox jumps over the lazy dog.");[m
[32m+[m[32m        ImGui::TextWrapped("Hello Right");[m
[32m+[m[32m        ImGui::Columns(1);[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Borders"))[m
[32m+[m[32m    {[m
[32m+[m[32m        // NB: Future columns API should allow automatic horizontal borders.[m
[32m+[m[32m        static bool h_borders = true;[m
[32m+[m[32m        static bool v_borders = true;[m
[32m+[m[32m        ImGui::Checkbox("horizontal", &h_borders);[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m[32m        ImGui::Checkbox("vertical", &v_borders);[m
[32m+[m[32m        ImGui::Columns(4, NULL, v_borders);[m
[32m+[m[32m        for (int i = 0; i < 4*3; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (h_borders && ImGui::GetColumnIndex() == 0)[m
[32m+[m[32m                ImGui::Separator();[m
[32m+[m[32m            ImGui::Text("%c%c%c", 'a'+i, 'a'+i, 'a'+i);[m
[32m+[m[32m            ImGui::Text("Width %.2f", ImGui::GetColumnWidth());[m
[32m+[m[32m            ImGui::Text("Offset %.2f", ImGui::GetColumnOffset());[m
[32m+[m[32m            ImGui::Text("Long text that is likely to clip");[m
[32m+[m[32m            ImGui::Button("Button", ImVec2(-1.0f, 0.0f));[m
[32m+[m[32m            ImGui::NextColumn();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::Columns(1);[m
[32m+[m[32m        if (h_borders)[m
[32m+[m[32m            ImGui::Separator();[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Scrolling columns[m
[32m+[m[32m    /*[m
[32m+[m[32m    if (ImGui::TreeNode("Vertical Scrolling"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::BeginChild("##header", ImVec2(0, ImGui::GetTextLineHeightWithSpacing()+ImGui::GetStyle().ItemSpacing.y));[m
[32m+[m[32m        ImGui::Columns(3);[m
[32m+[m[32m        ImGui::Text("ID"); ImGui::NextColumn();[m
[32m+[m[32m        ImGui::Text("Name"); ImGui::NextColumn();[m
[32m+[m[32m        ImGui::Text("Path"); ImGui::NextColumn();[m
[32m+[m[32m        ImGui::Columns(1);[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        ImGui::EndChild();[m
[32m+[m[32m        ImGui::BeginChild("##scrollingregion", ImVec2(0, 60));[m
[32m+[m[32m        ImGui::Columns(3);[m
[32m+[m[32m        for (int i = 0; i < 10; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::Text("%04d", i); ImGui::NextColumn();[m
[32m+[m[32m            ImGui::Text("Foobar"); ImGui::NextColumn();[m
[32m+[m[32m            ImGui::Text("/path/foobar/%04d/", i); ImGui::NextColumn();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::Columns(1);[m
[32m+[m[32m        ImGui::EndChild();[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m[32m    */[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Horizontal Scrolling"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::SetNextWindowContentSize(ImVec2(1500.0f, 0.0f));[m
[32m+[m[32m        ImGui::BeginChild("##ScrollingRegion", ImVec2(0, ImGui::GetFontSize() * 20), false, ImGuiWindowFlags_HorizontalScrollbar);[m
[32m+[m[32m        ImGui::Columns(10);[m
[32m+[m[32m        int ITEMS_COUNT = 2000;[m
[32m+[m[32m        ImGuiListClipper clipper(ITEMS_COUNT);  // Also demonstrate using the clipper for large list[m
[32m+[m[32m        while (clipper.Step())[m
[32m+[m[32m        {[m
[32m+[m[32m            for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)[m
[32m+[m[32m                for (int j = 0; j < 10; j++)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImGui::Text("Line %d Column %d...", i, j);[m
[32m+[m[32m                    ImGui::NextColumn();[m
[32m+[m[32m                }[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::Columns(1);[m
[32m+[m[32m        ImGui::EndChild();[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::TreeNode("Tree"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::Columns(2, "tree", true);[m
[32m+[m[32m        for (int x = 0; x < 3; x++)[m
[32m+[m[32m        {[m
[32m+[m[32m            bool open1 = ImGui::TreeNode((void*)(intptr_t)x, "Node%d", x);[m
[32m+[m[32m            ImGui::NextColumn();[m
[32m+[m[32m            ImGui::Text("Node contents");[m
[32m+[m[32m            ImGui::NextColumn();[m
[32m+[m[32m            if (open1)[m
[32m+[m[32m            {[m
[32m+[m[32m                for (int y = 0; y < 5; y++)[m
[32m+[m[32m                {[m
[32m+[m[32m                    bool open2 = ImGui::TreeNode((void*)(intptr_t)y, "Node%d.%d", x, y);[m
[32m+[m[32m                    ImGui::NextColumn();[m
[32m+[m[32m                    ImGui::Text("Node contents");[m
[32m+[m[32m                    if (open2)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ImGui::Text("Even more contents");[m
[32m+[m[32m                        if (ImGui::TreeNode("Tree in column"))[m
[32m+[m[32m                        {[m
[32m+[m[32m                            ImGui::Text("The quick brown fox jumps over the lazy dog");[m
[32m+[m[32m                            ImGui::TreePop();[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    ImGui::NextColumn();[m
[32m+[m[32m                    if (open2)[m
[32m+[m[32m                        ImGui::TreePop();[m
[32m+[m[32m                }[m
[32m+[m[32m                ImGui::TreePop();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::Columns(1);[m
[32m+[m[32m        ImGui::TreePop();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (disable_indent)[m
[32m+[m[32m        ImGui::PopStyleVar();[m
[32m+[m[32m    ImGui::PopID();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void ShowDemoWindowMisc()[m
[32m+[m[32m{[m
[32m+[m[32m    if (ImGui::CollapsingHeader("Filtering"))[m
[32m+[m[32m    {[m
[32m+[m[32m        static ImGuiTextFilter filter;[m
[32m+[m[32m        ImGui::Text("Filter usage:\n"[m
[32m+[m[32m                    "  \"\"         display all lines\n"[m
[32m+[m[32m                    "  \"xxx\"      display lines containing \"xxx\"\n"[m
[32m+[m[32m                    "  \"xxx,yyy\"  display lines containing \"xxx\" or \"yyy\"\n"[m
[32m+[m[32m                    "  \"-xxx\"     hide lines containing \"xxx\"");[m
[32m+[m[32m        filter.Draw();[m
[32m+[m[32m        const char* lines[] = { "aaa1.c", "bbb1.c", "ccc1.c", "aaa2.cpp", "bbb2.cpp", "ccc2.cpp", "abc.h", "hello, world" };[m
[32m+[m[32m        for (int i = 0; i < IM_ARRAYSIZE(lines); i++)[m
[32m+[m[32m            if (filter.PassFilter(lines[i]))[m
[32m+[m[32m                ImGui::BulletText("%s", lines[i]);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (ImGui::CollapsingHeader("Inputs, Navigation & Focus"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiIO& io = ImGui::GetIO();[m
[32m+[m
[32m+[m[32m        ImGui::Text("WantCaptureMouse: %d", io.WantCaptureMouse);[m
[32m+[m[32m        ImGui::Text("WantCaptureKeyboard: %d", io.WantCaptureKeyboard);[m
[32m+[m[32m        ImGui::Text("WantTextInput: %d", io.WantTextInput);[m
[32m+[m[32m        ImGui::Text("WantSetMousePos: %d", io.WantSetMousePos);[m
[32m+[m[32m        ImGui::Text("NavActive: %d, NavVisible: %d", io.NavActive, io.NavVisible);[m
[32m+[m
[32m+[m[32m        if (ImGui::TreeNode("Keyboard, Mouse & Navigation State"))[m
[32m+[m[32m        {[m
[32m+[m[32m            if (ImGui::IsMousePosValid())[m
[32m+[m[32m                ImGui::Text("Mouse pos: (%g, %g)", io.MousePos.x, io.MousePos.y);[m
[32m+[m[32m            else[m
[32m+[m[32m                ImGui::Text("Mouse pos: <INVALID>");[m
[32m+[m[32m            ImGui::Text("Mouse delta: (%g, %g)", io.MouseDelta.x, io.MouseDelta.y);[m
[32m+[m[32m            ImGui::Text("Mouse down:");     for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (io.MouseDownDuration[i] >= 0.0f)   { ImGui::SameLine(); ImGui::Text("b%d (%.02f secs)", i, io.MouseDownDuration[i]); }[m
[32m+[m[32m            ImGui::Text("Mouse clicked:");  for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseClicked(i))          { ImGui::SameLine(); ImGui::Text("b%d", i); }[m
[32m+[m[32m            ImGui::Text("Mouse dbl-clicked:"); for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseDoubleClicked(i)) { ImGui::SameLine(); ImGui::Text("b%d", i); }[m
[32m+[m[32m            ImGui::Text("Mouse released:"); for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseReleased(i))         { ImGui::SameLine(); ImGui::Text("b%d", i); }[m
[32m+[m[32m            ImGui::Text("Mouse wheel: %.1f", io.MouseWheel);[m
[32m+[m
[32m+[m[32m            ImGui::Text("Keys down:");      for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (io.KeysDownDuration[i] >= 0.0f)     { ImGui::SameLine(); ImGui::Text("%d (0x%X) (%.02f secs)", i, i, io.KeysDownDuration[i]); }[m
[32m+[m[32m            ImGui::Text("Keys pressed:");   for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (ImGui::IsKeyPressed(i))             { ImGui::SameLine(); ImGui::Text("%d (0x%X)", i, i); }[m
[32m+[m[32m            ImGui::Text("Keys release:");   for (int i = 0; i < IM_ARRAYSIZE(io.KeysDown); i++) if (ImGui::IsKeyReleased(i))            { ImGui::SameLine(); ImGui::Text("%d (0x%X)", i, i); }[m
[32m+[m[32m            ImGui::Text("Keys mods: %s%s%s%s", io.KeyCtrl ? "CTRL " : "", io.KeyShift ? "SHIFT " : "", io.KeyAlt ? "ALT " : "", io.KeySuper ? "SUPER " : "");[m
[32m+[m[32m            ImGui::Text("Chars queue:");    for (int i = 0; i < io.InputQueueCharacters.Size; i++) { ImWchar c = io.InputQueueCharacters[i]; ImGui::SameLine();  ImGui::Text("\'%c\' (0x%04X)", (c > ' ' && c <= 255) ? (char)c : '?', c); } // FIXME: We should convert 'c' to UTF-8 here but the functions are not public.[m
[32m+[m
[32m+[m[32m            ImGui::Text("NavInputs down:"); for (int i = 0; i < IM_ARRAYSIZE(io.NavInputs); i++) if (io.NavInputs[i] > 0.0f)                    { ImGui::SameLine(); ImGui::Text("[%d] %.2f", i, io.NavInputs[i]); }[m
[32m+[m[32m            ImGui::Text("NavInputs pressed:"); for (int i = 0; i < IM_ARRAYSIZE(io.NavInputs); i++) if (io.NavInputsDownDuration[i] == 0.0f)    { ImGui::SameLine(); ImGui::Text("[%d]", i); }[m
[32m+[m[32m            ImGui::Text("NavInputs duration:"); for (int i = 0; i < IM_ARRAYSIZE(io.NavInputs); i++) if (io.NavInputsDownDuration[i] >= 0.0f)   { ImGui::SameLine(); ImGui::Text("[%d] %.2f", i, io.NavInputsDownDuration[i]); }[m
[32m+[m
[32m+[m[32m            ImGui::Button("Hovering me sets the\nkeyboard capture flag");[m
[32m+[m[32m            if (ImGui::IsItemHovered())[m
[32m+[m[32m                ImGui::CaptureKeyboardFromApp(true);[m
[32m+[m[32m            ImGui::SameLine();[m
[32m+[m[32m            ImGui::Button("Holding me clears the\nthe keyboard capture flag");[m
[32m+[m[32m            if (ImGui::IsItemActive())[m
[32m+[m[32m                ImGui::CaptureKeyboardFromApp(false);[m
[32m+[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::TreeNode("Tabbing"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::Text("Use TAB/SHIFT+TAB to cycle through keyboard editable fields.");[m
[32m+[m[32m            static char buf[32] = "dummy";[m
[32m+[m[32m            ImGui::InputText("1", buf, IM_ARRAYSIZE(buf));[m
[32m+[m[32m            ImGui::InputText("2", buf, IM_ARRAYSIZE(buf));[m
[32m+[m[32m            ImGui::InputText("3", buf, IM_ARRAYSIZE(buf));[m
[32m+[m[32m            ImGui::PushAllowKeyboardFocus(false);[m
[32m+[m[32m            ImGui::InputText("4 (tab skip)", buf, IM_ARRAYSIZE(buf));[m
[32m+[m[32m            //ImGui::SameLine(); HelpMarker("Use ImGui::PushAllowKeyboardFocus(bool)\nto disable tabbing through certain widgets.");[m
[32m+[m[32m            ImGui::PopAllowKeyboardFocus();[m
[32m+[m[32m            ImGui::InputText("5", buf, IM_ARRAYSIZE(buf));[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::TreeNode("Focus from code"))[m
[32m+[m[32m        {[m
[32m+[m[32m            bool focus_1 = ImGui::Button("Focus on 1"); ImGui::SameLine();[m
[32m+[m[32m            bool focus_2 = ImGui::Button("Focus on 2"); ImGui::SameLine();[m
[32m+[m[32m            bool focus_3 = ImGui::Button("Focus on 3");[m
[32m+[m[32m            int has_focus = 0;[m
[32m+[m[32m            static char buf[128] = "click on a button to set focus";[m
[32m+[m
[32m+[m[32m            if (focus_1) ImGui::SetKeyboardFocusHere();[m
[32m+[m[32m            ImGui::InputText("1", buf, IM_ARRAYSIZE(buf));[m
[32m+[m[32m            if (ImGui::IsItemActive()) has_focus = 1;[m
[32m+[m
[32m+[m[32m            if (focus_2) ImGui::SetKeyboardFocusHere();[m
[32m+[m[32m            ImGui::InputText("2", buf, IM_ARRAYSIZE(buf));[m
[32m+[m[32m            if (ImGui::IsItemActive()) has_focus = 2;[m
[32m+[m
[32m+[m[32m            ImGui::PushAllowKeyboardFocus(false);[m
[32m+[m[32m            if (focus_3) ImGui::SetKeyboardFocusHere();[m
[32m+[m[32m            ImGui::InputText("3 (tab skip)", buf, IM_ARRAYSIZE(buf));[m
[32m+[m[32m            if (ImGui::IsItemActive()) has_focus = 3;[m
[32m+[m[32m            ImGui::PopAllowKeyboardFocus();[m
[32m+[m
[32m+[m[32m            if (has_focus)[m
[32m+[m[32m                ImGui::Text("Item with focus: %d", has_focus);[m
[32m+[m[32m            else[m
[32m+[m[32m                ImGui::Text("Item with focus: <none>");[m
[32m+[m
[32m+[m[32m            // Use >= 0 parameter to SetKeyboardFocusHere() to focus an upcoming item[m
[32m+[m[32m            static float f3[3] = { 0.0f, 0.0f, 0.0f };[m
[32m+[m[32m            int focus_ahead = -1;[m
[32m+[m[32m            if (ImGui::Button("Focus on X")) { focus_ahead = 0; } ImGui::SameLine();[m
[32m+[m[32m            if (ImGui::Button("Focus on Y")) { focus_ahead = 1; } ImGui::SameLine();[m
[32m+[m[32m            if (ImGui::Button("Focus on Z")) { focus_ahead = 2; }[m
[32m+[m[32m            if (focus_ahead != -1) ImGui::SetKeyboardFocusHere(focus_ahead);[m
[32m+[m[32m            ImGui::SliderFloat3("Float3", &f3[0], 0.0f, 1.0f);[m
[32m+[m
[32m+[m[32m            ImGui::TextWrapped("NB: Cursor & selection are preserved when refocusing last used item in code.");[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::TreeNode("Dragging"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::TextWrapped("You can use ImGui::GetMouseDragDelta(0) to query for the dragged amount on any widget.");[m
[32m+[m[32m            for (int button = 0; button < 3; button++)[m
[32m+[m[32m                ImGui::Text("IsMouseDragging(%d):\n  w/ default threshold: %d,\n  w/ zero threshold: %d\n  w/ large threshold: %d",[m
[32m+[m[32m                    button, ImGui::IsMouseDragging(button), ImGui::IsMouseDragging(button, 0.0f), ImGui::IsMouseDragging(button, 20.0f));[m
[32m+[m
[32m+[m[32m            ImGui::Button("Drag Me");[m
[32m+[m[32m            if (ImGui::IsItemActive())[m
[32m+[m[32m                ImGui::GetForegroundDrawList()->AddLine(io.MouseClickedPos[0], io.MousePos, ImGui::GetColorU32(ImGuiCol_Button), 4.0f); // Draw a line between the button and the mouse cursor[m
[32m+[m
[32m+[m[32m            // Drag operations gets "unlocked" when the mouse has moved past a certain threshold (the default threshold is stored in io.MouseDragThreshold)[m
[32m+[m[32m            // You can request a lower or higher threshold using the second parameter of IsMouseDragging() and GetMouseDragDelta()[m
[32m+[m[32m            ImVec2 value_raw = ImGui::GetMouseDragDelta(0, 0.0f);[m
[32m+[m[32m            ImVec2 value_with_lock_threshold = ImGui::GetMouseDragDelta(0);[m
[32m+[m[32m            ImVec2 mouse_delta = io.MouseDelta;[m
[32m+[m[32m            ImGui::Text("GetMouseDragDelta(0):\n  w/ default threshold: (%.1f, %.1f),\n  w/ zero threshold: (%.1f, %.1f)\nMouseDelta: (%.1f, %.1f)", value_with_lock_threshold.x, value_with_lock_threshold.y, value_raw.x, value_raw.y, mouse_delta.x, mouse_delta.y);[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::TreeNode("Mouse cursors"))[m
[32m+[m[32m        {[m
[32m+[m[32m            const char* mouse_cursors_names[] = { "Arrow", "TextInput", "Move", "ResizeNS", "ResizeEW", "ResizeNESW", "ResizeNWSE", "Hand" };[m
[32m+[m[32m            IM_ASSERT(IM_ARRAYSIZE(mouse_cursors_names) == ImGuiMouseCursor_COUNT);[m
[32m+[m
[32m+[m[32m            ImGui::Text("Current mouse cursor = %d: %s", ImGui::GetMouseCursor(), mouse_cursors_names[ImGui::GetMouseCursor()]);[m
[32m+[m[32m            ImGui::Text("Hover to see mouse cursors:");[m
[32m+[m[32m            ImGui::SameLine(); HelpMarker("Your application can render a different mouse cursor based on what ImGui::GetMouseCursor() returns. If software cursor rendering (io.MouseDrawCursor) is set ImGui will draw the right cursor for you, otherwise your backend needs to handle it.");[m
[32m+[m[32m            for (int i = 0; i < ImGuiMouseCursor_COUNT; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                char label[32];[m
[32m+[m[32m                sprintf(label, "Mouse cursor %d: %s", i, mouse_cursors_names[i]);[m
[32m+[m[32m                ImGui::Bullet(); ImGui::Selectable(label, false);[m
[32m+[m[32m                if (ImGui::IsItemHovered() || ImGui::IsItemFocused())[m
[32m+[m[32m                    ImGui::SetMouseCursor(i);[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::TreePop();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] About Window / ShowAboutWindow()[m
[32m+[m[32m// Access from ImGui Demo -> Help -> About[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mvoid ImGui::ShowAboutWindow(bool* p_open)[m
[32m+[m[32m{[m
[32m+[m[32m    if (!ImGui::Begin("About Dear ImGui", p_open, ImGuiWindowFlags_AlwaysAutoResize))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::End();[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    ImGui::Text("Dear ImGui %s", ImGui::GetVersion());[m
[32m+[m[32m    ImGui::Separator();[m
[32m+[m[32m    ImGui::Text("By Omar Cornut and all dear imgui contributors.");[m
[32m+[m[32m    ImGui::Text("Dear ImGui is licensed under the MIT License, see LICENSE for more information.");[m
[32m+[m
[32m+[m[32m    static bool show_config_info = false;[m
[32m+[m[32m    ImGui::Checkbox("Config/Build Information", &show_config_info);[m
[32m+[m[32m    if (show_config_info)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m        ImGuiStyle& style = ImGui::GetStyle();[m
[32m+[m
[32m+[m[32m        bool copy_to_clipboard = ImGui::Button("Copy to clipboard");[m
[32m+[m[32m        ImGui::BeginChildFrame(ImGui::GetID("cfginfos"), ImVec2(0, ImGui::GetTextLineHeightWithSpacing() * 18), ImGuiWindowFlags_NoMove);[m
[32m+[m[32m        if (copy_to_clipboard)[m
[32m+[m[32m            ImGui::LogToClipboard();[m
[32m+[m
[32m+[m[32m        ImGui::Text("Dear ImGui %s (%d)", IMGUI_VERSION, IMGUI_VERSION_NUM);[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        ImGui::Text("sizeof(size_t): %d, sizeof(ImDrawIdx): %d, sizeof(ImDrawVert): %d", (int)sizeof(size_t), (int)sizeof(ImDrawIdx), (int)sizeof(ImDrawVert));[m
[32m+[m[32m        ImGui::Text("define: __cplusplus=%d", (int)__cplusplus);[m
[32m+[m[32m#ifdef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32m        ImGui::Text("define: IMGUI_DISABLE_OBSOLETE_FUNCTIONS");[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS[m
[32m+[m[32m        ImGui::Text("define: IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS");[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS[m
[32m+[m[32m        ImGui::Text("define: IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS");[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef IMGUI_DISABLE_WIN32_FUNCTIONS[m
[32m+[m[32m        ImGui::Text("define: IMGUI_DISABLE_WIN32_FUNCTIONS");[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS[m
[32m+[m[32m        ImGui::Text("define: IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS");[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef IMGUI_DISABLE_MATH_FUNCTIONS[m
[32m+[m[32m        ImGui::Text("define: IMGUI_DISABLE_MATH_FUNCTIONS");[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef IMGUI_DISABLE_DEFAULT_ALLOCATORS[m
[32m+[m[32m        ImGui::Text("define: IMGUI_DISABLE_DEFAULT_ALLOCATORS");[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef IMGUI_USE_BGRA_PACKED_COLOR[m
[32m+[m[32m        ImGui::Text("define: IMGUI_USE_BGRA_PACKED_COLOR");[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef _WIN32[m
[32m+[m[32m        ImGui::Text("define: _WIN32");[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef _WIN64[m
[32m+[m[32m        ImGui::Text("define: _WIN64");[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef __linux__[m
[32m+[m[32m        ImGui::Text("define: __linux__");[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef __APPLE__[m
[32m+[m[32m        ImGui::Text("define: __APPLE__");[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef _MSC_VER[m
[32m+[m[32m        ImGui::Text("define: _MSC_VER=%d", _MSC_VER);[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef __MINGW32__[m
[32m+[m[32m        ImGui::Text("define: __MINGW32__");[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef __MINGW64__[m
[32m+[m[32m        ImGui::Text("define: __MINGW64__");[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef __GNUC__[m
[32m+[m[32m        ImGui::Text("define: __GNUC__=%d", (int)__GNUC__);[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef __clang_version__[m
[32m+[m[32m        ImGui::Text("define: __clang_version__=%s", __clang_version__);[m
[32m+[m[32m#endif[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        ImGui::Text("io.BackendPlatformName: %s", io.BackendPlatformName ? io.BackendPlatformName : "NULL");[m
[32m+[m[32m        ImGui::Text("io.BackendRendererName: %s", io.BackendRendererName ? io.BackendRendererName : "NULL");[m
[32m+[m[32m        ImGui::Text("io.ConfigFlags: 0x%08X", io.ConfigFlags);[m
[32m+[m[32m        if (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard)        ImGui::Text(" NavEnableKeyboard");[m
[32m+[m[32m        if (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad)         ImGui::Text(" NavEnableGamepad");[m
[32m+[m[32m        if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos)     ImGui::Text(" NavEnableSetMousePos");[m
[32m+[m[32m        if (io.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard)     ImGui::Text(" NavNoCaptureKeyboard");[m
[32m+[m[32m        if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)                  ImGui::Text(" NoMouse");[m
[32m+[m[32m        if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)      ImGui::Text(" NoMouseCursorChange");[m
[32m+[m[32m        if (io.MouseDrawCursor)                                         ImGui::Text("io.MouseDrawCursor");[m
[32m+[m[32m        if (io.ConfigMacOSXBehaviors)                                   ImGui::Text("io.ConfigMacOSXBehaviors");[m
[32m+[m[32m        if (io.ConfigInputTextCursorBlink)                              ImGui::Text("io.ConfigInputTextCursorBlink");[m
[32m+[m[32m        if (io.ConfigWindowsResizeFromEdges)                            ImGui::Text("io.ConfigWindowsResizeFromEdges");[m
[32m+[m[32m        if (io.ConfigWindowsMoveFromTitleBarOnly)                       ImGui::Text("io.ConfigWindowsMoveFromTitleBarOnly");[m
[32m+[m[32m        ImGui::Text("io.BackendFlags: 0x%08X", io.BackendFlags);[m
[32m+[m[32m        if (io.BackendFlags & ImGuiBackendFlags_HasGamepad)             ImGui::Text(" HasGamepad");[m
[32m+[m[32m        if (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors)        ImGui::Text(" HasMouseCursors");[m
[32m+[m[32m        if (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos)         ImGui::Text(" HasSetMousePos");[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        ImGui::Text("io.Fonts: %d fonts, Flags: 0x%08X, TexSize: %d,%d", io.Fonts->Fonts.Size, io.Fonts->Flags, io.Fonts->TexWidth, io.Fonts->TexHeight);[m
[32m+[m[32m        ImGui::Text("io.DisplaySize: %.2f,%.2f", io.DisplaySize.x, io.DisplaySize.y);[m
[32m+[m[32m        ImGui::Text("io.DisplayFramebufferScale: %.2f,%.2f", io.DisplayFramebufferScale.x, io.DisplayFramebufferScale.y);[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        ImGui::Text("style.WindowPadding: %.2f,%.2f", style.WindowPadding.x, style.WindowPadding.y);[m
[32m+[m[32m        ImGui::Text("style.WindowBorderSize: %.2f", style.WindowBorderSize);[m
[32m+[m[32m        ImGui::Text("style.FramePadding: %.2f,%.2f", style.FramePadding.x, style.FramePadding.y);[m
[32m+[m[32m        ImGui::Text("style.FrameRounding: %.2f", style.FrameRounding);[m
[32m+[m[32m        ImGui::Text("style.FrameBorderSize: %.2f", style.FrameBorderSize);[m
[32m+[m[32m        ImGui::Text("style.ItemSpacing: %.2f,%.2f", style.ItemSpacing.x, style.ItemSpacing.y);[m
[32m+[m[32m        ImGui::Text("style.ItemInnerSpacing: %.2f,%.2f", style.ItemInnerSpacing.x, style.ItemInnerSpacing.y);[m
[32m+[m
[32m+[m[32m        if (copy_to_clipboard)[m
[32m+[m[32m            ImGui::LogFinish();[m
[32m+[m[32m        ImGui::EndChildFrame();[m
[32m+[m[32m    }[m
[32m+[m[32m    ImGui::End();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Style Editor / ShowStyleEditor()[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Demo helper function to select among default colors. See ShowStyleEditor() for more advanced options.[m
[32m+[m[32m// Here we use the simplified Combo() api that packs items into a single literal string. Useful for quick combo boxes where the choices are known locally.[m
[32m+[m[32mbool ImGui::ShowStyleSelector(const char* label)[m
[32m+[m[32m{[m
[32m+[m[32m    static int style_idx = -1;[m
[32m+[m[32m    if (ImGui::Combo(label, &style_idx, "Classic\0Dark\0Light\0"))[m
[32m+[m[32m    {[m
[32m+[m[32m        switch (style_idx)[m
[32m+[m[32m        {[m
[32m+[m[32m        case 0: ImGui::StyleColorsClassic(); break;[m
[32m+[m[32m        case 1: ImGui::StyleColorsDark(); break;[m
[32m+[m[32m        case 2: ImGui::StyleColorsLight(); break;[m
[32m+[m[32m        }[m
[32m+[m[32m        return true;[m
[32m+[m[32m    }[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Demo helper function to select among loaded fonts.[m
[32m+[m[32m// Here we use the regular BeginCombo()/EndCombo() api which is more the more flexible one.[m
[32m+[m[32mvoid ImGui::ShowFontSelector(const char* label)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m    ImFont* font_current = ImGui::GetFont();[m
[32m+[m[32m    if (ImGui::BeginCombo(label, font_current->GetDebugName()))[m
[32m+[m[32m    {[m
[32m+[m[32m        for (int n = 0; n < io.Fonts->Fonts.Size; n++)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImFont* font = io.Fonts->Fonts[n];[m
[32m+[m[32m            ImGui::PushID((void*)font);[m
[32m+[m[32m            if (ImGui::Selectable(font->GetDebugName(), font == font_current))[m
[32m+[m[32m                io.FontDefault = font;[m
[32m+[m[32m            ImGui::PopID();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::EndCombo();[m
[32m+[m[32m    }[m
[32m+[m[32m    ImGui::SameLine();[m
[32m+[m[32m    HelpMarker([m
[32m+[m[32m        "- Load additional fonts with io.Fonts->AddFontFromFileTTF().\n"[m
[32m+[m[32m        "- The font atlas is built when calling io.Fonts->GetTexDataAsXXXX() or io.Fonts->Build().\n"[m
[32m+[m[32m        "- Read FAQ and documentation in misc/fonts/ for more details.\n"[m
[32m+[m[32m        "- If you need to add/remove fonts at runtime (e.g. for DPI change), do it before calling NewFrame().");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::ShowStyleEditor(ImGuiStyle* ref)[m
[32m+[m[32m{[m
[32m+[m[32m    // You can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it compares to an internally stored reference)[m
[32m+[m[32m    ImGuiStyle& style = ImGui::GetStyle();[m
[32m+[m[32m    static ImGuiStyle ref_saved_style;[m
[32m+[m
[32m+[m[32m    // Default to using internal storage as reference[m
[32m+[m[32m    static bool init = true;[m
[32m+[m[32m    if (init && ref == NULL)[m
[32m+[m[32m        ref_saved_style = style;[m
[32m+[m[32m    init = false;[m
[32m+[m[32m    if (ref == NULL)[m
[32m+[m[32m        ref = &ref_saved_style;[m
[32m+[m
[32m+[m[32m    ImGui::PushItemWidth(ImGui::GetWindowWidth() * 0.50f);[m
[32m+[m
[32m+[m[32m    if (ImGui::ShowStyleSelector("Colors##Selector"))[m
[32m+[m[32m        ref_saved_style = style;[m
[32m+[m[32m    ImGui::ShowFontSelector("Fonts##Selector");[m
[32m+[m
[32m+[m[32m    // Simplified Settings[m
[32m+[m[32m    if (ImGui::SliderFloat("FrameRounding", &style.FrameRounding, 0.0f, 12.0f, "%.0f"))[m
[32m+[m[32m        style.GrabRounding = style.FrameRounding; // Make GrabRounding always the same value as FrameRounding[m
[32m+[m[32m    { bool window_border = (style.WindowBorderSize > 0.0f); if (ImGui::Checkbox("WindowBorder", &window_border)) style.WindowBorderSize = window_border ? 1.0f : 0.0f; }[m
[32m+[m[32m    ImGui::SameLine();[m
[32m+[m[32m    { bool frame_border = (style.FrameBorderSize > 0.0f); if (ImGui::Checkbox("FrameBorder", &frame_border)) style.FrameBorderSize = frame_border ? 1.0f : 0.0f; }[m
[32m+[m[32m    ImGui::SameLine();[m
[32m+[m[32m    { bool popup_border = (style.PopupBorderSize > 0.0f); if (ImGui::Checkbox("PopupBorder", &popup_border)) style.PopupBorderSize = popup_border ? 1.0f : 0.0f; }[m
[32m+[m
[32m+[m[32m    // Save/Revert button[m
[32m+[m[32m    if (ImGui::Button("Save Ref"))[m
[32m+[m[32m        *ref = ref_saved_style = style;[m
[32m+[m[32m    ImGui::SameLine();[m
[32m+[m[32m    if (ImGui::Button("Revert Ref"))[m
[32m+[m[32m        style = *ref;[m
[32m+[m[32m    ImGui::SameLine();[m
[32m+[m[32m    HelpMarker("Save/Revert in local non-persistent storage. Default Colors definition are not affected. Use \"Export Colors\" below to save them somewhere.");[m
[32m+[m
[32m+[m[32m    ImGui::Separator();[m
[32m+[m
[32m+[m[32m    if (ImGui::BeginTabBar("##tabs", ImGuiTabBarFlags_None))[m
[32m+[m[32m    {[m
[32m+[m[32m        if (ImGui::BeginTabItem("Sizes"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::Text("Main");[m
[32m+[m[32m            ImGui::SliderFloat2("WindowPadding", (float*)&style.WindowPadding, 0.0f, 20.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat2("FramePadding", (float*)&style.FramePadding, 0.0f, 20.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat2("ItemSpacing", (float*)&style.ItemSpacing, 0.0f, 20.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat2("ItemInnerSpacing", (float*)&style.ItemInnerSpacing, 0.0f, 20.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat2("TouchExtraPadding", (float*)&style.TouchExtraPadding, 0.0f, 10.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat("IndentSpacing", &style.IndentSpacing, 0.0f, 30.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat("ScrollbarSize", &style.ScrollbarSize, 1.0f, 20.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat("GrabMinSize", &style.GrabMinSize, 1.0f, 20.0f, "%.0f");[m
[32m+[m[32m            ImGui::Text("Borders");[m
[32m+[m[32m            ImGui::SliderFloat("WindowBorderSize", &style.WindowBorderSize, 0.0f, 1.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat("ChildBorderSize", &style.ChildBorderSize, 0.0f, 1.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat("PopupBorderSize", &style.PopupBorderSize, 0.0f, 1.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat("FrameBorderSize", &style.FrameBorderSize, 0.0f, 1.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat("TabBorderSize", &style.TabBorderSize, 0.0f, 1.0f, "%.0f");[m
[32m+[m[32m            ImGui::Text("Rounding");[m
[32m+[m[32m            ImGui::SliderFloat("WindowRounding", &style.WindowRounding, 0.0f, 12.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat("ChildRounding", &style.ChildRounding, 0.0f, 12.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat("FrameRounding", &style.FrameRounding, 0.0f, 12.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat("PopupRounding", &style.PopupRounding, 0.0f, 12.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat("ScrollbarRounding", &style.ScrollbarRounding, 0.0f, 12.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat("GrabRounding", &style.GrabRounding, 0.0f, 12.0f, "%.0f");[m
[32m+[m[32m            ImGui::SliderFloat("TabRounding", &style.TabRounding, 0.0f, 12.0f, "%.0f");[m
[32m+[m[32m            ImGui::Text("Alignment");[m
[32m+[m[32m            ImGui::SliderFloat2("WindowTitleAlign", (float*)&style.WindowTitleAlign, 0.0f, 1.0f, "%.2f");[m
[32m+[m[32m            ImGui::SliderFloat2("ButtonTextAlign", (float*)&style.ButtonTextAlign, 0.0f, 1.0f, "%.2f"); ImGui::SameLine(); HelpMarker("Alignment applies when a button is larger than its text content.");[m
[32m+[m[32m            ImGui::SliderFloat2("SelectableTextAlign", (float*)&style.SelectableTextAlign, 0.0f, 1.0f, "%.2f"); ImGui::SameLine(); HelpMarker("Alignment applies when a selectable is larger than its text content.");[m
[32m+[m[32m            ImGui::Text("Safe Area Padding"); ImGui::SameLine(); HelpMarker("Adjust if you cannot see the edges of your screen (e.g. on a TV where scaling has not been configured).");[m
[32m+[m[32m            ImGui::SliderFloat2("DisplaySafeAreaPadding", (float*)&style.DisplaySafeAreaPadding, 0.0f, 30.0f, "%.0f");[m
[32m+[m[32m            ImGui::EndTabItem();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::BeginTabItem("Colors"))[m
[32m+[m[32m        {[m
[32m+[m[32m            static int output_dest = 0;[m
[32m+[m[32m            static bool output_only_modified = true;[m
[32m+[m[32m            if (ImGui::Button("Export Unsaved"))[m
[32m+[m[32m            {[m
[32m+[m[32m                if (output_dest == 0)[m
[32m+[m[32m                    ImGui::LogToClipboard();[m
[32m+[m[32m                else[m
[32m+[m[32m                    ImGui::LogToTTY();[m
[32m+[m[32m                ImGui::LogText("ImVec4* colors = ImGui::GetStyle().Colors;" IM_NEWLINE);[m
[32m+[m[32m                for (int i = 0; i < ImGuiCol_COUNT; i++)[m
[32m+[m[32m                {[m
[32m+[m[32m                    const ImVec4& col = style.Colors[i];[m
[32m+[m[32m                    const char* name = ImGui::GetStyleColorName(i);[m
[32m+[m[32m                    if (!output_only_modified || memcmp(&col, &ref->Colors[i], sizeof(ImVec4)) != 0)[m
[32m+[m[32m                        ImGui::LogText("colors[ImGuiCol_%s]%*s= ImVec4(%.2ff, %.2ff, %.2ff, %.2ff);" IM_NEWLINE, name, 23 - (int)strlen(name), "", col.x, col.y, col.z, col.w);[m
[32m+[m[32m                }[m
[32m+[m[32m                ImGui::LogFinish();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::SameLine(); ImGui::SetNextItemWidth(120); ImGui::Combo("##output_type", &output_dest, "To Clipboard\0To TTY\0");[m
[32m+[m[32m            ImGui::SameLine(); ImGui::Checkbox("Only Modified Colors", &output_only_modified);[m
[32m+[m
[32m+[m[32m            static ImGuiTextFilter filter;[m
[32m+[m[32m            filter.Draw("Filter colors", ImGui::GetFontSize() * 16);[m
[32m+[m
[32m+[m[32m            static ImGuiColorEditFlags alpha_flags = 0;[m
[32m+[m[32m            ImGui::RadioButton("Opaque", &alpha_flags, 0); ImGui::SameLine();[m
[32m+[m[32m            ImGui::RadioButton("Alpha", &alpha_flags, ImGuiColorEditFlags_AlphaPreview); ImGui::SameLine();[m
[32m+[m[32m            ImGui::RadioButton("Both", &alpha_flags, ImGuiColorEditFlags_AlphaPreviewHalf); ImGui::SameLine();[m
[32m+[m[32m            HelpMarker("In the color list:\nLeft-click on colored square to open color picker,\nRight-click to open edit options menu.");[m
[32m+[m
[32m+[m[32m            ImGui::BeginChild("##colors", ImVec2(0, 0), true, ImGuiWindowFlags_AlwaysVerticalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar | ImGuiWindowFlags_NavFlattened);[m
[32m+[m[32m            ImGui::PushItemWidth(-160);[m
[32m+[m[32m            for (int i = 0; i < ImGuiCol_COUNT; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                const char* name = ImGui::GetStyleColorName(i);[m
[32m+[m[32m                if (!filter.PassFilter(name))[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                ImGui::PushID(i);[m
[32m+[m[32m                ImGui::ColorEdit4("##color", (float*)&style.Colors[i], ImGuiColorEditFlags_AlphaBar | alpha_flags);[m
[32m+[m[32m                if (memcmp(&style.Colors[i], &ref->Colors[i], sizeof(ImVec4)) != 0)[m
[32m+[m[32m                {[m
[32m+[m[32m                    // Tips: in a real user application, you may want to merge and use an icon font into the main font, so instead of "Save"/"Revert" you'd use icons.[m
[32m+[m[32m                    // Read the FAQ and misc/fonts/README.txt about using icon fonts. It's really easy and super convenient![m
[32m+[m[32m                    ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Save")) ref->Colors[i] = style.Colors[i];[m
[32m+[m[32m                    ImGui::SameLine(0.0f, style.ItemInnerSpacing.x); if (ImGui::Button("Revert")) style.Colors[i] = ref->Colors[i];[m
[32m+[m[32m                }[m
[32m+[m[32m                ImGui::SameLine(0.0f, style.ItemInnerSpacing.x);[m
[32m+[m[32m                ImGui::TextUnformatted(name);[m
[32m+[m[32m                ImGui::PopID();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::PopItemWidth();[m
[32m+[m[32m            ImGui::EndChild();[m
[32m+[m
[32m+[m[32m            ImGui::EndTabItem();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::BeginTabItem("Fonts"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m            ImFontAtlas* atlas = io.Fonts;[m
[32m+[m[32m            HelpMarker("Read FAQ and misc/fonts/README.txt for details on font loading.");[m
[32m+[m[32m            ImGui::PushItemWidth(120);[m
[32m+[m[32m            for (int i = 0; i < atlas->Fonts.Size; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                ImFont* font = atlas->Fonts[i];[m
[32m+[m[32m                ImGui::PushID(font);[m
[32m+[m[32m                bool font_details_opened = ImGui::TreeNode(font, "Font %d: \"%s\"\n%.2f px, %d glyphs, %d file(s)", i, font->ConfigData ? font->ConfigData[0].Name : "", font->FontSize, font->Glyphs.Size, font->ConfigDataCount);[m
[32m+[m[32m                ImGui::SameLine(); if (ImGui::SmallButton("Set as default")) { io.FontDefault = font; }[m
[32m+[m[32m                if (font_details_opened)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImGui::PushFont(font);[m
[32m+[m[32m                    ImGui::Text("The quick brown fox jumps over the lazy dog");[m
[32m+[m[32m                    ImGui::PopFont();[m
[32m+[m[32m                    ImGui::DragFloat("Font scale", &font->Scale, 0.005f, 0.3f, 2.0f, "%.1f");   // Scale only this font[m
[32m+[m[32m                    ImGui::SameLine(); HelpMarker("Note than the default embedded font is NOT meant to be scaled.\n\nFont are currently rendered into bitmaps at a given size at the time of building the atlas. You may oversample them to get some flexibility with scaling. You can also render at multiple sizes and select which one to use at runtime.\n\n(Glimmer of hope: the atlas system should hopefully be rewritten in the future to make scaling more natural and automatic.)");[m
[32m+[m[32m                    ImGui::InputFloat("Font offset", &font->DisplayOffset.y, 1, 1, "%.0f");[m
[32m+[m[32m                    ImGui::Text("Ascent: %f, Descent: %f, Height: %f", font->Ascent, font->Descent, font->Ascent - font->Descent);[m
[32m+[m[32m                    ImGui::Text("Fallback character: '%c' (%d)", font->FallbackChar, font->FallbackChar);[m
[32m+[m[32m                    const float surface_sqrt = sqrtf((float)font->MetricsTotalSurface);[m
[32m+[m[32m                    ImGui::Text("Texture surface: %d pixels (approx) ~ %dx%d", font->MetricsTotalSurface, (int)surface_sqrt, (int)surface_sqrt);[m
[32m+[m[32m                    for (int config_i = 0; config_i < font->ConfigDataCount; config_i++)[m
[32m+[m[32m                        if (const ImFontConfig* cfg = &font->ConfigData[config_i])[m
[32m+[m[32m                            ImGui::BulletText("Input %d: \'%s\', Oversample: (%d,%d), PixelSnapH: %d", config_i, cfg->Name, cfg->OversampleH, cfg->OversampleV, cfg->PixelSnapH);[m
[32m+[m[32m                    if (ImGui::TreeNode("Glyphs", "Glyphs (%d)", font->Glyphs.Size))[m
[32m+[m[32m                    {[m
[32m+[m[32m                        // Display all glyphs of the fonts in separate pages of 256 characters[m
[32m+[m[32m                        for (int base = 0; base < 0x10000; base += 256)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            int count = 0;[m
[32m+[m[32m                            for (int n = 0; n < 256; n++)[m
[32m+[m[32m                                count += font->FindGlyphNoFallback((ImWchar)(base + n)) ? 1 : 0;[m
[32m+[m[32m                            if (count > 0 && ImGui::TreeNode((void*)(intptr_t)base, "U+%04X..U+%04X (%d %s)", base, base + 255, count, count > 1 ? "glyphs" : "glyph"))[m
[32m+[m[32m                            {[m
[32m+[m[32m                                float cell_size = font->FontSize * 1;[m
[32m+[m[32m                                float cell_spacing = style.ItemSpacing.y;[m
[32m+[m[32m                                ImVec2 base_pos = ImGui::GetCursorScreenPos();[m
[32m+[m[32m                                ImDrawList* draw_list = ImGui::GetWindowDrawList();[m
[32m+[m[32m                                for (int n = 0; n < 256; n++)[m
[32m+[m[32m                                {[m
[32m+[m[32m                                    ImVec2 cell_p1(base_pos.x + (n % 16) * (cell_size + cell_spacing), base_pos.y + (n / 16) * (cell_size + cell_spacing));[m
[32m+[m[32m                                    ImVec2 cell_p2(cell_p1.x + cell_size, cell_p1.y + cell_size);[m
[32m+[m[32m                                    const ImFontGlyph* glyph = font->FindGlyphNoFallback((ImWchar)(base + n));[m
[32m+[m[32m                                    draw_list->AddRect(cell_p1, cell_p2, glyph ? IM_COL32(255, 255, 255, 100) : IM_COL32(255, 255, 255, 50));[m
[32m+[m[32m                                    if (glyph)[m
[32m+[m[32m                                        font->RenderChar(draw_list, cell_size, cell_p1, ImGui::GetColorU32(ImGuiCol_Text), (ImWchar)(base + n)); // We use ImFont::RenderChar as a shortcut because we don't have UTF-8 conversion functions available to generate a string.[m
[32m+[m[32m                                    if (glyph && ImGui::IsMouseHoveringRect(cell_p1, cell_p2))[m
[32m+[m[32m                                    {[m
[32m+[m[32m                                        ImGui::BeginTooltip();[m
[32m+[m[32m                                        ImGui::Text("Codepoint: U+%04X", base + n);[m
[32m+[m[32m                                        ImGui::Separator();[m
[32m+[m[32m                                        ImGui::Text("AdvanceX: %.1f", glyph->AdvanceX);[m
[32m+[m[32m                                        ImGui::Text("Pos: (%.2f,%.2f)->(%.2f,%.2f)", glyph->X0, glyph->Y0, glyph->X1, glyph->Y1);[m
[32m+[m[32m                                        ImGui::Text("UV: (%.3f,%.3f)->(%.3f,%.3f)", glyph->U0, glyph->V0, glyph->U1, glyph->V1);[m
[32m+[m[32m                                        ImGui::EndTooltip();[m
[32m+[m[32m                                    }[m
[32m+[m[32m                                }[m
[32m+[m[32m                                ImGui::Dummy(ImVec2((cell_size + cell_spacing) * 16, (cell_size + cell_spacing) * 16));[m
[32m+[m[32m                                ImGui::TreePop();[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        ImGui::TreePop();[m
[32m+[m[32m                    }[m
[32m+[m[32m                    ImGui::TreePop();[m
[32m+[m[32m                }[m
[32m+[m[32m                ImGui::PopID();[m
[32m+[m[32m            }[m
[32m+[m[32m            if (ImGui::TreeNode("Atlas texture", "Atlas texture (%dx%d pixels)", atlas->TexWidth, atlas->TexHeight))[m
[32m+[m[32m            {[m
[32m+[m[32m                ImVec4 tint_col = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);[m
[32m+[m[32m                ImVec4 border_col = ImVec4(1.0f, 1.0f, 1.0f, 0.5f);[m
[32m+[m[32m                ImGui::Image(atlas->TexID, ImVec2((float)atlas->TexWidth, (float)atlas->TexHeight), ImVec2(0, 0), ImVec2(1, 1), tint_col, border_col);[m
[32m+[m[32m                ImGui::TreePop();[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            static float window_scale = 1.0f;[m
[32m+[m[32m            if (ImGui::DragFloat("this window scale", &window_scale, 0.005f, 0.3f, 2.0f, "%.2f"))   // scale only this window[m
[32m+[m[32m                ImGui::SetWindowFontScale(window_scale);[m
[32m+[m[32m            ImGui::DragFloat("global scale", &io.FontGlobalScale, 0.005f, 0.3f, 2.0f, "%.2f");      // scale everything[m
[32m+[m[32m            ImGui::PopItemWidth();[m
[32m+[m
[32m+[m[32m            ImGui::EndTabItem();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::BeginTabItem("Rendering"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::Checkbox("Anti-aliased lines", &style.AntiAliasedLines); ImGui::SameLine(); HelpMarker("When disabling anti-aliasing lines, you'll probably want to disable borders in your style as well.");[m
[32m+[m[32m            ImGui::Checkbox("Anti-aliased fill", &style.AntiAliasedFill);[m
[32m+[m[32m            ImGui::PushItemWidth(100);[m
[32m+[m[32m            ImGui::DragFloat("Curve Tessellation Tolerance", &style.CurveTessellationTol, 0.02f, 0.10f, FLT_MAX, "%.2f", 2.0f);[m
[32m+[m[32m            if (style.CurveTessellationTol < 0.10f) style.CurveTessellationTol = 0.10f;[m
[32m+[m[32m            ImGui::DragFloat("Global Alpha", &style.Alpha, 0.005f, 0.20f, 1.0f, "%.2f"); // Not exposing zero here so user doesn't "lose" the UI (zero alpha clips all widgets). But application code could have a toggle to switch between zero and non-zero.[m
[32m+[m[32m            ImGui::PopItemWidth();[m
[32m+[m
[32m+[m[32m            ImGui::EndTabItem();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        ImGui::EndTabBar();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    ImGui::PopItemWidth();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Demonstrate creating a "main" fullscreen menu bar and populating it.[m
[32m+[m[32m// Note the difference between BeginMainMenuBar() and BeginMenuBar():[m
[32m+[m[32m// - BeginMenuBar() = menu-bar inside current window we Begin()-ed into (the window needs the ImGuiWindowFlags_MenuBar flag)[m
[32m+[m[32m// - BeginMainMenuBar() = helper to create menu-bar-sized window at the top of the main viewport + call BeginMenuBar() into it.[m
[32m+[m[32mstatic void ShowExampleAppMainMenuBar()[m
[32m+[m[32m{[m
[32m+[m[32m    if (ImGui::BeginMainMenuBar())[m
[32m+[m[32m    {[m
[32m+[m[32m        if (ImGui::BeginMenu("File"))[m
[32m+[m[32m        {[m
[32m+[m[32m            ShowExampleMenuFile();[m
[32m+[m[32m            ImGui::EndMenu();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (ImGui::BeginMenu("Edit"))[m
[32m+[m[32m        {[m
[32m+[m[32m            if (ImGui::MenuItem("Undo", "CTRL+Z")) {}[m
[32m+[m[32m            if (ImGui::MenuItem("Redo", "CTRL+Y", false, false)) {}  // Disabled item[m
[32m+[m[32m            ImGui::Separator();[m
[32m+[m[32m            if (ImGui::MenuItem("Cut", "CTRL+X")) {}[m
[32m+[m[32m            if (ImGui::MenuItem("Copy", "CTRL+C")) {}[m
[32m+[m[32m            if (ImGui::MenuItem("Paste", "CTRL+V")) {}[m
[32m+[m[32m            ImGui::EndMenu();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::EndMainMenuBar();[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Note that shortcuts are currently provided for display only (future version will add flags to BeginMenu to process shortcuts)[m
[32m+[m[32mstatic void ShowExampleMenuFile()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGui::MenuItem("(dummy menu)", NULL, false, false);[m
[32m+[m[32m    if (ImGui::MenuItem("New")) {}[m
[32m+[m[32m    if (ImGui::MenuItem("Open", "Ctrl+O")) {}[m
[32m+[m[32m    if (ImGui::BeginMenu("Open Recent"))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::MenuItem("fish_hat.c");[m
[32m+[m[32m        ImGui::MenuItem("fish_hat.inl");[m
[32m+[m[32m        ImGui::MenuItem("fish_hat.h");[m
[32m+[m[32m        if (ImGui::BeginMenu("More.."))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::MenuItem("Hello");[m
[32m+[m[32m            ImGui::MenuItem("Sailor");[m
[32m+[m[32m            if (ImGui::BeginMenu("Recurse.."))[m
[32m+[m[32m            {[m
[32m+[m[32m                ShowExampleMenuFile();[m
[32m+[m[32m                ImGui::EndMenu();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::EndMenu();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::EndMenu();[m
[32m+[m[32m    }[m
[32m+[m[32m    if (ImGui::MenuItem("Save", "Ctrl+S")) {}[m
[32m+[m[32m    if (ImGui::MenuItem("Save As..")) {}[m
[32m+[m[32m    ImGui::Separator();[m
[32m+[m[32m    if (ImGui::BeginMenu("Options"))[m
[32m+[m[32m    {[m
[32m+[m[32m        static bool enabled = true;[m
[32m+[m[32m        ImGui::MenuItem("Enabled", "", &enabled);[m
[32m+[m[32m        ImGui::BeginChild("child", ImVec2(0, 60), true);[m
[32m+[m[32m        for (int i = 0; i < 10; i++)[m
[32m+[m[32m            ImGui::Text("Scrolling Text %d", i);[m
[32m+[m[32m        ImGui::EndChild();[m
[32m+[m[32m        static float f = 0.5f;[m
[32m+[m[32m        static int n = 0;[m
[32m+[m[32m        static bool b = true;[m
[32m+[m[32m        ImGui::SliderFloat("Value", &f, 0.0f, 1.0f);[m
[32m+[m[32m        ImGui::InputFloat("Input", &f, 0.1f);[m
[32m+[m[32m        ImGui::Combo("Combo", &n, "Yes\0No\0Maybe\0\0");[m
[32m+[m[32m        ImGui::Checkbox("Check", &b);[m
[32m+[m[32m        ImGui::EndMenu();[m
[32m+[m[32m    }[m
[32m+[m[32m    if (ImGui::BeginMenu("Colors"))[m
[32m+[m[32m    {[m
[32m+[m[32m        float sz = ImGui::GetTextLineHeight();[m
[32m+[m[32m        for (int i = 0; i < ImGuiCol_COUNT; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            const char* name = ImGui::GetStyleColorName((ImGuiCol)i);[m
[32m+[m[32m            ImVec2 p = ImGui::GetCursorScreenPos();[m
[32m+[m[32m            ImGui::GetWindowDrawList()->AddRectFilled(p, ImVec2(p.x+sz, p.y+sz), ImGui::GetColorU32((ImGuiCol)i));[m
[32m+[m[32m            ImGui::Dummy(ImVec2(sz, sz));[m
[32m+[m[32m            ImGui::SameLine();[m
[32m+[m[32m            ImGui::MenuItem(name);[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::EndMenu();[m
[32m+[m[32m    }[m
[32m+[m[32m    if (ImGui::BeginMenu("Disabled", false)) // Disabled[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(0);[m
[32m+[m[32m    }[m
[32m+[m[32m    if (ImGui::MenuItem("Checked", NULL, true)) {}[m
[32m+[m[32m    if (ImGui::MenuItem("Quit", "Alt+F4")) {}[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Example App: Debug Console / ShowExampleAppConsole()[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Demonstrate creating a simple console window, with scrolling, filtering, completion and history.[m
[32m+[m[32m// For the console example, here we are using a more C++ like approach of declaring a class to hold the data and the functions.[m
[32m+[m[32mstruct ExampleAppConsole[m
[32m+[m[32m{[m
[32m+[m[32m    char                  InputBuf[256];[m
[32m+[m[32m    ImVector<char*>       Items;[m
[32m+[m[32m    ImVector<const char*> Commands;[m
[32m+[m[32m    ImVector<char*>       History;[m
[32m+[m[32m    int                   HistoryPos;    // -1: new line, 0..History.Size-1 browsing history.[m
[32m+[m[32m    ImGuiTextFilter       Filter;[m
[32m+[m[32m    bool                  AutoScroll;[m
[32m+[m[32m    bool                  ScrollToBottom;[m
[32m+[m
[32m+[m[32m    ExampleAppConsole()[m
[32m+[m[32m    {[m
[32m+[m[32m        ClearLog();[m
[32m+[m[32m        memset(InputBuf, 0, sizeof(InputBuf));[m
[32m+[m[32m        HistoryPos = -1;[m
[32m+[m[32m        Commands.push_back("HELP");[m
[32m+[m[32m        Commands.push_back("HISTORY");[m
[32m+[m[32m        Commands.push_back("CLEAR");[m
[32m+[m[32m        Commands.push_back("CLASSIFY");  // "classify" is only here to provide an example of "C"+[tab] completing to "CL" and displaying matches.[m
[32m+[m[32m        AutoScroll = true;[m
[32m+[m[32m        ScrollToBottom = true;[m
[32m+[m[32m        AddLog("Welcome to Dear ImGui!");[m
[32m+[m[32m    }[m
[32m+[m[32m    ~ExampleAppConsole()[m
[32m+[m[32m    {[m
[32m+[m[32m        ClearLog();[m
[32m+[m[32m        for (int i = 0; i < History.Size; i++)[m
[32m+[m[32m            free(History[i]);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Portable helpers[m
[32m+[m[32m    static int   Stricmp(const char* str1, const char* str2)         { int d; while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; } return d; }[m
[32m+[m[32m    static int   Strnicmp(const char* str1, const char* str2, int n) { int d = 0; while (n > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; n--; } return d; }[m
[32m+[m[32m    static char* Strdup(const char *str)                             { size_t len = strlen(str) + 1; void* buf = malloc(len); IM_ASSERT(buf); return (char*)memcpy(buf, (const void*)str, len); }[m
[32m+[m[32m    static void  Strtrim(char* str)                                  { char* str_end = str + strlen(str); while (str_end > str && str_end[-1] == ' ') str_end--; *str_end = 0; }[m
[32m+[m
[32m+[m[32m    void    ClearLog()[m
[32m+[m[32m    {[m
[32m+[m[32m        for (int i = 0; i < Items.Size; i++)[m
[32m+[m[32m            free(Items[i]);[m
[32m+[m[32m        Items.clear();[m
[32m+[m[32m        ScrollToBottom = true;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    void    AddLog(const char* fmt, ...) IM_FMTARGS(2)[m
[32m+[m[32m    {[m
[32m+[m[32m        // FIXME-OPT[m
[32m+[m[32m        char buf[1024];[m
[32m+[m[32m        va_list args;[m
[32m+[m[32m        va_start(args, fmt);[m
[32m+[m[32m        vsnprintf(buf, IM_ARRAYSIZE(buf), fmt, args);[m
[32m+[m[32m        buf[IM_ARRAYSIZE(buf)-1] = 0;[m
[32m+[m[32m        va_end(args);[m
[32m+[m[32m        Items.push_back(Strdup(buf));[m
[32m+[m[32m        if (AutoScroll)[m
[32m+[m[32m            ScrollToBottom = true;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    void    Draw(const char* title, bool* p_open)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::SetNextWindowSize(ImVec2(520,600), ImGuiCond_FirstUseEver);[m
[32m+[m[32m        if (!ImGui::Begin(title, p_open))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::End();[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // As a specific feature guaranteed by the library, after calling Begin() the last Item represent the title bar. So e.g. IsItemHovered() will return true when hovering the title bar.[m
[32m+[m[32m        // Here we create a context menu only available from the title bar.[m
[32m+[m[32m        if (ImGui::BeginPopupContextItem())[m
[32m+[m[32m        {[m
[32m+[m[32m            if (ImGui::MenuItem("Close Console"))[m
[32m+[m[32m                *p_open = false;[m
[32m+[m[32m            ImGui::EndPopup();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        ImGui::TextWrapped("This example implements a console with basic coloring, completion and history. A more elaborate implementation may want to store entries along with extra data such as timestamp, emitter, etc.");[m
[32m+[m[32m        ImGui::TextWrapped("Enter 'HELP' for help, press TAB to use text completion.");[m
[32m+[m
[32m+[m[32m        // TODO: display items starting from the bottom[m
[32m+[m
[32m+[m[32m        if (ImGui::SmallButton("Add Dummy Text"))  { AddLog("%d some text", Items.Size); AddLog("some more text"); AddLog("display very important message here!"); } ImGui::SameLine();[m
[32m+[m[32m        if (ImGui::SmallButton("Add Dummy Error")) { AddLog("[error] something went wrong"); } ImGui::SameLine();[m
[32m+[m[32m        if (ImGui::SmallButton("Clear")) { ClearLog(); } ImGui::SameLine();[m
[32m+[m[32m        bool copy_to_clipboard = ImGui::SmallButton("Copy"); ImGui::SameLine();[m
[32m+[m[32m        if (ImGui::SmallButton("Scroll to bottom")) ScrollToBottom = true;[m
[32m+[m[32m        //static float t = 0.0f; if (ImGui::GetTime() - t > 0.02f) { t = ImGui::GetTime(); AddLog("Spam %f", t); }[m
[32m+[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m
[32m+[m[32m        // Options menu[m
[32m+[m[32m        if (ImGui::BeginPopup("Options"))[m
[32m+[m[32m        {[m
[32m+[m[32m            if (ImGui::Checkbox("Auto-scroll", &AutoScroll))[m
[32m+[m[32m                if (AutoScroll)[m
[32m+[m[32m                    ScrollToBottom = true;[m
[32m+[m[32m            ImGui::EndPopup();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Options, Filter[m
[32m+[m[32m        if (ImGui::Button("Options"))[m
[32m+[m[32m            ImGui::OpenPopup("Options");[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m[32m        Filter.Draw("Filter (\"incl,-excl\") (\"error\")", 180);[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m
[32m+[m[32m        const float footer_height_to_reserve = ImGui::GetStyle().ItemSpacing.y + ImGui::GetFrameHeightWithSpacing(); // 1 separator, 1 input text[m
[32m+[m[32m        ImGui::BeginChild("ScrollingRegion", ImVec2(0, -footer_height_to_reserve), false, ImGuiWindowFlags_HorizontalScrollbar); // Leave room for 1 separator + 1 InputText[m
[32m+[m[32m        if (ImGui::BeginPopupContextWindow())[m
[32m+[m[32m        {[m
[32m+[m[32m            if (ImGui::Selectable("Clear")) ClearLog();[m
[32m+[m[32m            ImGui::EndPopup();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Display every line as a separate entry so we can change their color or add custom widgets. If you only want raw text you can use ImGui::TextUnformatted(log.begin(), log.end());[m
[32m+[m[32m        // NB- if you have thousands of entries this approach may be too inefficient and may require user-side clipping to only process visible items.[m
[32m+[m[32m        // You can seek and display only the lines that are visible using the ImGuiListClipper helper, if your elements are evenly spaced and you have cheap random access to the elements.[m
[32m+[m[32m        // To use the clipper we could replace the 'for (int i = 0; i < Items.Size; i++)' loop with:[m
[32m+[m[32m        //     ImGuiListClipper clipper(Items.Size);[m
[32m+[m[32m        //     while (clipper.Step())[m
[32m+[m[32m        //         for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)[m
[32m+[m[32m        // However, note that you can not use this code as is if a filter is active because it breaks the 'cheap random-access' property. We would need random-access on the post-filtered list.[m
[32m+[m[32m        // A typical application wanting coarse clipping and filtering may want to pre-compute an array of indices that passed the filtering test, recomputing this array when user changes the filter,[m
[32m+[m[32m        // and appending newly elements as they are inserted. This is left as a task to the user until we can manage to improve this example code![m
[32m+[m[32m        // If your items are of variable size you may want to implement code similar to what ImGuiListClipper does. Or split your data into fixed height items to allow random-seeking into your list.[m
[32m+[m[32m        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(4,1)); // Tighten spacing[m
[32m+[m[32m        if (copy_to_clipboard)[m
[32m+[m[32m            ImGui::LogToClipboard();[m
[32m+[m[32m        for (int i = 0; i < Items.Size; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            const char* item = Items[i];[m
[32m+[m[32m            if (!Filter.PassFilter(item))[m
[32m+[m[32m                continue;[m
[32m+[m
[32m+[m[32m            // Normally you would store more information in your item (e.g. make Items[] an array of structure, store color/type etc.)[m
[32m+[m[32m            bool pop_color = false;[m
[32m+[m[32m            if (strstr(item, "[error]"))            { ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.4f, 0.4f, 1.0f)); pop_color = true; }[m
[32m+[m[32m            else if (strncmp(item, "# ", 2) == 0)   { ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.8f, 0.6f, 1.0f)); pop_color = true; }[m
[32m+[m[32m            ImGui::TextUnformatted(item);[m
[32m+[m[32m            if (pop_color)[m
[32m+[m[32m                ImGui::PopStyleColor();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (copy_to_clipboard)[m
[32m+[m[32m            ImGui::LogFinish();[m
[32m+[m[32m        if (ScrollToBottom)[m
[32m+[m[32m            ImGui::SetScrollHereY(1.0f);[m
[32m+[m[32m        ScrollToBottom = false;[m
[32m+[m[32m        ImGui::PopStyleVar();[m
[32m+[m[32m        ImGui::EndChild();[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m
[32m+[m[32m        // Command-line[m
[32m+[m[32m        bool reclaim_focus = false;[m
[32m+[m[32m        if (ImGui::InputText("Input", InputBuf, IM_ARRAYSIZE(InputBuf), ImGuiInputTextFlags_EnterReturnsTrue|ImGuiInputTextFlags_CallbackCompletion|ImGuiInputTextFlags_CallbackHistory, &TextEditCallbackStub, (void*)this))[m
[32m+[m[32m        {[m
[32m+[m[32m            char* s = InputBuf;[m
[32m+[m[32m            Strtrim(s);[m
[32m+[m[32m            if (s[0])[m
[32m+[m[32m                ExecCommand(s);[m
[32m+[m[32m            strcpy(s, "");[m
[32m+[m[32m            reclaim_focus = true;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Auto-focus on window apparition[m
[32m+[m[32m        ImGui::SetItemDefaultFocus();[m
[32m+[m[32m        if (reclaim_focus)[m
[32m+[m[32m            ImGui::SetKeyboardFocusHere(-1); // Auto focus previous widget[m
[32m+[m
[32m+[m[32m        ImGui::End();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    void    ExecCommand(const char* command_line)[m
[32m+[m[32m    {[m
[32m+[m[32m        AddLog("# %s\n", command_line);[m
[32m+[m
[32m+[m[32m        // Insert into history. First find match and delete it so it can be pushed to the back. This isn't trying to be smart or optimal.[m
[32m+[m[32m        HistoryPos = -1;[m
[32m+[m[32m        for (int i = History.Size-1; i >= 0; i--)[m
[32m+[m[32m            if (Stricmp(History[i], command_line) == 0)[m
[32m+[m[32m            {[m
[32m+[m[32m                free(History[i]);[m
[32m+[m[32m                History.erase(History.begin() + i);[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m        History.push_back(Strdup(command_line));[m
[32m+[m
[32m+[m[32m        // Process command[m
[32m+[m[32m        if (Stricmp(command_line, "CLEAR") == 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            ClearLog();[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (Stricmp(command_line, "HELP") == 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            AddLog("Commands:");[m
[32m+[m[32m            for (int i = 0; i < Commands.Size; i++)[m
[32m+[m[32m                AddLog("- %s", Commands[i]);[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (Stricmp(command_line, "HISTORY") == 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            int first = History.Size - 10;[m
[32m+[m[32m            for (int i = first > 0 ? first : 0; i < History.Size; i++)[m
[32m+[m[32m                AddLog("%3d: %s\n", i, History[i]);[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            AddLog("Unknown command: '%s'\n", command_line);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // On commad input, we scroll to bottom even if AutoScroll==false[m
[32m+[m[32m        ScrollToBottom = true;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    static int TextEditCallbackStub(ImGuiInputTextCallbackData* data) // In C++11 you are better off using lambdas for this sort of forwarding callbacks[m
[32m+[m[32m    {[m
[32m+[m[32m        ExampleAppConsole* console = (ExampleAppConsole*)data->UserData;[m
[32m+[m[32m        return console->TextEditCallback(data);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    int     TextEditCallback(ImGuiInputTextCallbackData* data)[m
[32m+[m[32m    {[m
[32m+[m[32m        //AddLog("cursor: %d, selection: %d-%d", data->CursorPos, data->SelectionStart, data->SelectionEnd);[m
[32m+[m[32m        switch (data->EventFlag)[m
[32m+[m[32m        {[m
[32m+[m[32m        case ImGuiInputTextFlags_CallbackCompletion:[m
[32m+[m[32m            {[m
[32m+[m[32m                // Example of TEXT COMPLETION[m
[32m+[m
[32m+[m[32m                // Locate beginning of current word[m
[32m+[m[32m                const char* word_end = data->Buf + data->CursorPos;[m
[32m+[m[32m                const char* word_start = word_end;[m
[32m+[m[32m                while (word_start > data->Buf)[m
[32m+[m[32m                {[m
[32m+[m[32m                    const char c = word_start[-1];[m
[32m+[m[32m                    if (c == ' ' || c == '\t' || c == ',' || c == ';')[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    word_start--;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                // Build a list of candidates[m
[32m+[m[32m                ImVector<const char*> candidates;[m
[32m+[m[32m                for (int i = 0; i < Commands.Size; i++)[m
[32m+[m[32m                    if (Strnicmp(Commands[i], word_start, (int)(word_end-word_start)) == 0)[m
[32m+[m[32m                        candidates.push_back(Commands[i]);[m
[32m+[m
[32m+[m[32m                if (candidates.Size == 0)[m
[32m+[m[32m                {[m
[32m+[m[32m                    // No match[m
[32m+[m[32m                    AddLog("No match for \"%.*s\"!\n", (int)(word_end-word_start), word_start);[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (candidates.Size == 1)[m
[32m+[m[32m                {[m
[32m+[m[32m                    // Single match. Delete the beginning of the word and replace it entirely so we've got nice casing[m
[32m+[m[32m                    data->DeleteChars((int)(word_start-data->Buf), (int)(word_end-word_start));[m
[32m+[m[32m                    data->InsertChars(data->CursorPos, candidates[0]);[m
[32m+[m[32m                    data->InsertChars(data->CursorPos, " ");[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    // Multiple matches. Complete as much as we can, so inputing "C" will complete to "CL" and display "CLEAR" and "CLASSIFY"[m
[32m+[m[32m                    int match_len = (int)(word_end - word_start);[m
[32m+[m[32m                    for (;;)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        int c = 0;[m
[32m+[m[32m                        bool all_candidates_matches = true;[m
[32m+[m[32m                        for (int i = 0; i < candidates.Size && all_candidates_matches; i++)[m
[32m+[m[32m                            if (i == 0)[m
[32m+[m[32m                                c = toupper(candidates[i][match_len]);[m
[32m+[m[32m                            else if (c == 0 || c != toupper(candidates[i][match_len]))[m
[32m+[m[32m                                all_candidates_matches = false;[m
[32m+[m[32m                        if (!all_candidates_matches)[m
[32m+[m[32m                            break;[m
[32m+[m[32m                        match_len++;[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    if (match_len > 0)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        data->DeleteChars((int)(word_start - data->Buf), (int)(word_end-word_start));[m
[32m+[m[32m                        data->InsertChars(data->CursorPos, candidates[0], candidates[0] + match_len);[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    // List matches[m
[32m+[m[32m                    AddLog("Possible matches:\n");[m
[32m+[m[32m                    for (int i = 0; i < candidates.Size; i++)[m
[32m+[m[32m                        AddLog("- %s\n", candidates[i]);[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m        case ImGuiInputTextFlags_CallbackHistory:[m
[32m+[m[32m            {[m
[32m+[m[32m                // Example of HISTORY[m
[32m+[m[32m                const int prev_history_pos = HistoryPos;[m
[32m+[m[32m                if (data->EventKey == ImGuiKey_UpArrow)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (HistoryPos == -1)[m
[32m+[m[32m                        HistoryPos = History.Size - 1;[m
[32m+[m[32m                    else if (HistoryPos > 0)[m
[32m+[m[32m                        HistoryPos--;[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (data->EventKey == ImGuiKey_DownArrow)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (HistoryPos != -1)[m
[32m+[m[32m                        if (++HistoryPos >= History.Size)[m
[32m+[m[32m                            HistoryPos = -1;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                // A better implementation would preserve the data on the current input line along with cursor position.[m
[32m+[m[32m                if (prev_history_pos != HistoryPos)[m
[32m+[m[32m                {[m
[32m+[m[32m                    const char* history_str = (HistoryPos >= 0) ? History[HistoryPos] : "";[m
[32m+[m[32m                    data->DeleteChars(0, data->BufTextLen);[m
[32m+[m[32m                    data->InsertChars(0, history_str);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return 0;[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstatic void ShowExampleAppConsole(bool* p_open)[m
[32m+[m[32m{[m
[32m+[m[32m    static ExampleAppConsole console;[m
[32m+[m[32m    console.Draw("Example: Console", p_open);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Example App: Debug Log / ShowExampleAppLog()[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Usage:[m
[32m+[m[32m//  static ExampleAppLog my_log;[m
[32m+[m[32m//  my_log.AddLog("Hello %d world\n", 123);[m
[32m+[m[32m//  my_log.Draw("title");[m
[32m+[m[32mstruct ExampleAppLog[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiTextBuffer     Buf;[m
[32m+[m[32m    ImGuiTextFilter     Filter;[m
[32m+[m[32m    ImVector<int>       LineOffsets;        // Index to lines offset. We maintain this with AddLog() calls, allowing us to have a random access on lines[m
[32m+[m[32m    bool                AutoScroll;[m
[32m+[m[32m    bool                ScrollToBottom;[m
[32m+[m
[32m+[m[32m    ExampleAppLog()[m
[32m+[m[32m    {[m
[32m+[m[32m        AutoScroll = true;[m
[32m+[m[32m        ScrollToBottom = false;[m
[32m+[m[32m        Clear();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    void    Clear()[m
[32m+[m[32m    {[m
[32m+[m[32m        Buf.clear();[m
[32m+[m[32m        LineOffsets.clear();[m
[32m+[m[32m        LineOffsets.push_back(0);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    void    AddLog(const char* fmt, ...) IM_FMTARGS(2)[m
[32m+[m[32m    {[m
[32m+[m[32m        int old_size = Buf.size();[m
[32m+[m[32m        va_list args;[m
[32m+[m[32m        va_start(args, fmt);[m
[32m+[m[32m        Buf.appendfv(fmt, args);[m
[32m+[m[32m        va_end(args);[m
[32m+[m[32m        for (int new_size = Buf.size(); old_size < new_size; old_size++)[m
[32m+[m[32m            if (Buf[old_size] == '\n')[m
[32m+[m[32m                LineOffsets.push_back(old_size + 1);[m
[32m+[m[32m        if (AutoScroll)[m
[32m+[m[32m            ScrollToBottom = true;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    void    Draw(const char* title, bool* p_open = NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (!ImGui::Begin(title, p_open))[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::End();[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Options menu[m
[32m+[m[32m        if (ImGui::BeginPopup("Options"))[m
[32m+[m[32m        {[m
[32m+[m[32m            if (ImGui::Checkbox("Auto-scroll", &AutoScroll))[m
[32m+[m[32m                if (AutoScroll)[m
[32m+[m[32m                    ScrollToBottom = true;[m
[32m+[m[32m            ImGui::EndPopup();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Main window[m
[32m+[m[32m        if (ImGui::Button("Options"))[m
[32m+[m[32m            ImGui::OpenPopup("Options");[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m[32m        bool clear = ImGui::Button("Clear");[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m[32m        bool copy = ImGui::Button("Copy");[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m[32m        Filter.Draw("Filter", -100.0f);[m
[32m+[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        ImGui::BeginChild("scrolling", ImVec2(0,0), false, ImGuiWindowFlags_HorizontalScrollbar);[m
[32m+[m
[32m+[m[32m        if (clear)[m
[32m+[m[32m            Clear();[m
[32m+[m[32m        if (copy)[m
[32m+[m[32m            ImGui::LogToClipboard();[m
[32m+[m
[32m+[m[32m        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));[m
[32m+[m[32m        const char* buf = Buf.begin();[m
[32m+[m[32m        const char* buf_end = Buf.end();[m
[32m+[m[32m        if (Filter.IsActive())[m
[32m+[m[32m        {[m
[32m+[m[32m            // In this example we don't use the clipper when Filter is enabled.[m
[32m+[m[32m            // This is because we don't have a random access on the result on our filter.[m
[32m+[m[32m            // A real application processing logs with ten of thousands of entries may want to store the result of search/filter.[m
[32m+[m[32m            // especially if the filtering function is not trivial (e.g. reg-exp).[m
[32m+[m[32m            for (int line_no = 0; line_no < LineOffsets.Size; line_no++)[m
[32m+[m[32m            {[m
[32m+[m[32m                const char* line_start = buf + LineOffsets[line_no];[m
[32m+[m[32m                const char* line_end = (line_no + 1 < LineOffsets.Size) ? (buf + LineOffsets[line_no + 1] - 1) : buf_end;[m
[32m+[m[32m                if (Filter.PassFilter(line_start, line_end))[m
[32m+[m[32m                    ImGui::TextUnformatted(line_start, line_end);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            // The simplest and easy way to display the entire buffer:[m
[32m+[m[32m            //   ImGui::TextUnformatted(buf_begin, buf_end);[m
[32m+[m[32m            // And it'll just work. TextUnformatted() has specialization for large blob of text and will fast-forward to skip non-visible lines.[m
[32m+[m[32m            // Here we instead demonstrate using the clipper to only process lines that are within the visible area.[m
[32m+[m[32m            // If you have tens of thousands of items and their processing cost is non-negligible, coarse clipping them on your side is recommended.[m
[32m+[m[32m            // Using ImGuiListClipper requires A) random access into your data, and B) items all being the  same height,[m
[32m+[m[32m            // both of which we can handle since we an array pointing to the beginning of each line of text.[m
[32m+[m[32m            // When using the filter (in the block of code above) we don't have random access into the data to display anymore, which is why we don't use the clipper.[m
[32m+[m[32m            // Storing or skimming through the search result would make it possible (and would be recommended if you want to search through tens of thousands of entries)[m
[32m+[m[32m            ImGuiListClipper clipper;[m
[32m+[m[32m            clipper.Begin(LineOffsets.Size);[m
[32m+[m[32m            while (clipper.Step())[m
[32m+[m[32m            {[m
[32m+[m[32m                for (int line_no = clipper.DisplayStart; line_no < clipper.DisplayEnd; line_no++)[m
[32m+[m[32m                {[m
[32m+[m[32m                    const char* line_start = buf + LineOffsets[line_no];[m
[32m+[m[32m                    const char* line_end = (line_no + 1 < LineOffsets.Size) ? (buf + LineOffsets[line_no + 1] - 1) : buf_end;[m
[32m+[m[32m                    ImGui::TextUnformatted(line_start, line_end);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            clipper.End();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::PopStyleVar();[m
[32m+[m
[32m+[m[32m        if (ScrollToBottom)[m
[32m+[m[32m            ImGui::SetScrollHereY(1.0f);[m
[32m+[m[32m        ScrollToBottom = false;[m
[32m+[m[32m        ImGui::EndChild();[m
[32m+[m[32m        ImGui::End();[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Demonstrate creating a simple log window with basic filtering.[m
[32m+[m[32mstatic void ShowExampleAppLog(bool* p_open)[m
[32m+[m[32m{[m
[32m+[m[32m    static ExampleAppLog log;[m
[32m+[m
[32m+[m[32m    // For the demo: add a debug button _BEFORE_ the normal log window contents[m
[32m+[m[32m    // We take advantage of a rarely used feature: multiple calls to Begin()/End() are appending to the _same_ window.[m
[32m+[m[32m    // Most of the contents of the window will be added by the log.Draw() call.[m
[32m+[m[32m    ImGui::SetNextWindowSize(ImVec2(500, 400), ImGuiCond_FirstUseEver);[m
[32m+[m[32m    ImGui::Begin("Example: Log", p_open);[m
[32m+[m[32m    if (ImGui::SmallButton("[Debug] Add 5 entries"))[m
[32m+[m[32m    {[m
[32m+[m[32m        static int counter = 0;[m
[32m+[m[32m        for (int n = 0; n < 5; n++)[m
[32m+[m[32m        {[m
[32m+[m[32m            const char* categories[3] = { "info", "warn", "error" };[m
[32m+[m[32m            const char* words[] = { "Bumfuzzled", "Cattywampus", "Snickersnee", "Abibliophobia", "Absquatulate", "Nincompoop", "Pauciloquent" };[m
[32m+[m[32m            log.AddLog("[%05d] [%s] Hello, current time is %.1f, here's a word: '%s'\n",[m
[32m+[m[32m                ImGui::GetFrameCount(), categories[counter % IM_ARRAYSIZE(categories)], ImGui::GetTime(), words[counter % IM_ARRAYSIZE(words)]);[m
[32m+[m[32m            counter++;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    ImGui::End();[m
[32m+[m
[32m+[m[32m    // Actually call in the regular Log helper (which will Begin() into the same window as we just did)[m
[32m+[m[32m    log.Draw("Example: Log", p_open);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Demonstrate create a window with multiple child windows.[m
[32m+[m[32mstatic void ShowExampleAppLayout(bool* p_open)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGui::SetNextWindowSize(ImVec2(500, 440), ImGuiCond_FirstUseEver);[m
[32m+[m[32m    if (ImGui::Begin("Example: Simple layout", p_open, ImGuiWindowFlags_MenuBar))[m
[32m+[m[32m    {[m
[32m+[m[32m        if (ImGui::BeginMenuBar())[m
[32m+[m[32m        {[m
[32m+[m[32m            if (ImGui::BeginMenu("File"))[m
[32m+[m[32m            {[m
[32m+[m[32m                if (ImGui::MenuItem("Close")) *p_open = false;[m
[32m+[m[32m                ImGui::EndMenu();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::EndMenuBar();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // left[m
[32m+[m[32m        static int selected = 0;[m
[32m+[m[32m        ImGui::BeginChild("left pane", ImVec2(150, 0), true);[m
[32m+[m[32m        for (int i = 0; i < 100; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            char label[128];[m
[32m+[m[32m            sprintf(label, "MyObject %d", i);[m
[32m+[m[32m            if (ImGui::Selectable(label, selected == i))[m
[32m+[m[32m                selected = i;[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::EndChild();[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m
[32m+[m[32m        // right[m
[32m+[m[32m        ImGui::BeginGroup();[m
[32m+[m[32m            ImGui::BeginChild("item view", ImVec2(0, -ImGui::GetFrameHeightWithSpacing())); // Leave room for 1 line below us[m
[32m+[m[32m                ImGui::Text("MyObject: %d", selected);[m
[32m+[m[32m                ImGui::Separator();[m
[32m+[m[32m                if (ImGui::BeginTabBar("##Tabs", ImGuiTabBarFlags_None))[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (ImGui::BeginTabItem("Description"))[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ImGui::TextWrapped("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ");[m
[32m+[m[32m                        ImGui::EndTabItem();[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (ImGui::BeginTabItem("Details"))[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ImGui::Text("ID: 0123456789");[m
[32m+[m[32m                        ImGui::EndTabItem();[m
[32m+[m[32m                    }[m
[32m+[m[32m                    ImGui::EndTabBar();[m
[32m+[m[32m                }[m
[32m+[m[32m            ImGui::EndChild();[m
[32m+[m[32m            if (ImGui::Button("Revert")) {}[m
[32m+[m[32m            ImGui::SameLine();[m
[32m+[m[32m            if (ImGui::Button("Save")) {}[m
[32m+[m[32m        ImGui::EndGroup();[m
[32m+[m[32m    }[m
[32m+[m[32m    ImGui::End();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Demonstrate create a simple property editor.[m
[32m+[m[32mstatic void ShowExampleAppPropertyEditor(bool* p_open)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGui::SetNextWindowSize(ImVec2(430,450), ImGuiCond_FirstUseEver);[m
[32m+[m[32m    if (!ImGui::Begin("Example: Property editor", p_open))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::End();[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    HelpMarker("This example shows how you may implement a property editor using two columns.\nAll objects/fields data are dummies here.\nRemember that in many simple cases, you can use ImGui::SameLine(xxx) to position\nyour cursor horizontally instead of using the Columns() API.");[m
[32m+[m
[32m+[m[32m    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2,2));[m
[32m+[m[32m    ImGui::Columns(2);[m
[32m+[m[32m    ImGui::Separator();[m
[32m+[m
[32m+[m[32m    struct funcs[m
[32m+[m[32m    {[m
[32m+[m[32m        static void ShowDummyObject(const char* prefix, int uid)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGui::PushID(uid);                      // Use object uid as identifier. Most commonly you could also use the object pointer as a base ID.[m
[32m+[m[32m            ImGui::AlignTextToFramePadding();  // Text and Tree nodes are less high than regular widgets, here we add vertical spacing to make the tree lines equal high.[m
[32m+[m[32m            bool node_open = ImGui::TreeNode("Object", "%s_%u", prefix, uid);[m
[32m+[m[32m            ImGui::NextColumn();[m
[32m+[m[32m            ImGui::AlignTextToFramePadding();[m
[32m+[m[32m            ImGui::Text("my sailor is rich");[m
[32m+[m[32m            ImGui::NextColumn();[m
[32m+[m[32m            if (node_open)[m
[32m+[m[32m            {[m
[32m+[m[32m                static float dummy_members[8] = { 0.0f,0.0f,1.0f,3.1416f,100.0f,999.0f };[m
[32m+[m[32m                for (int i = 0; i < 8; i++)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImGui::PushID(i); // Use field index as identifier.[m
[32m+[m[32m                    if (i < 2)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        ShowDummyObject("Child", 424242);[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else[m
[32m+[m[32m                    {[m
[32m+[m[32m                        // Here we use a TreeNode to highlight on hover (we could use e.g. Selectable as well)[m
[32m+[m[32m                        ImGui::AlignTextToFramePadding();[m
[32m+[m[32m                        ImGui::TreeNodeEx("Field", ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_Bullet, "Field_%d", i);[m
[32m+[m[32m                        ImGui::NextColumn();[m
[32m+[m[32m                        ImGui::SetNextItemWidth(-1);[m
[32m+[m[32m                        if (i >= 5)[m
[32m+[m[32m                            ImGui::InputFloat("##value", &dummy_members[i], 1.0f);[m
[32m+[m[32m                        else[m
[32m+[m[32m                            ImGui::DragFloat("##value", &dummy_members[i], 0.01f);[m
[32m+[m[32m                        ImGui::NextColumn();[m
[32m+[m[32m                    }[m
[32m+[m[32m                    ImGui::PopID();[m
[32m+[m[32m                }[m
[32m+[m[32m                ImGui::TreePop();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGui::PopID();[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    // Iterate dummy objects with dummy members (all the same data)[m
[32m+[m[32m    for (int obj_i = 0; obj_i < 3; obj_i++)[m
[32m+[m[32m        funcs::ShowDummyObject("Object", obj_i);[m
[32m+[m
[32m+[m[32m    ImGui::Columns(1);[m
[32m+[m[32m    ImGui::Separator();[m
[32m+[m[32m    ImGui::PopStyleVar();[m
[32m+[m[32m    ImGui::End();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Example App: Long Text / ShowExampleAppLongText()[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Demonstrate/test rendering huge amount of text, and the incidence of clipping.[m
[32m+[m[32mstatic void ShowExampleAppLongText(bool* p_open)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGui::SetNextWindowSize(ImVec2(520,600), ImGuiCond_FirstUseEver);[m
[32m+[m[32m    if (!ImGui::Begin("Example: Long text display", p_open))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::End();[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    static int test_type = 0;[m
[32m+[m[32m    static ImGuiTextBuffer log;[m
[32m+[m[32m    static int lines = 0;[m
[32m+[m[32m    ImGui::Text("Printing unusually long amount of text.");[m
[32m+[m[32m    ImGui::Combo("Test type", &test_type, "Single call to TextUnformatted()\0Multiple calls to Text(), clipped manually\0Multiple calls to Text(), not clipped (slow)\0");[m
[32m+[m[32m    ImGui::Text("Buffer contents: %d lines, %d bytes", lines, log.size());[m
[32m+[m[32m    if (ImGui::Button("Clear")) { log.clear(); lines = 0; }[m
[32m+[m[32m    ImGui::SameLine();[m
[32m+[m[32m    if (ImGui::Button("Add 1000 lines"))[m
[32m+[m[32m    {[m
[32m+[m[32m        for (int i = 0; i < 1000; i++)[m
[32m+[m[32m            log.appendf("%i The quick brown fox jumps over the lazy dog\n", lines+i);[m
[32m+[m[32m        lines += 1000;[m
[32m+[m[32m    }[m
[32m+[m[32m    ImGui::BeginChild("Log");[m
[32m+[m[32m    switch (test_type)[m
[32m+[m[32m    {[m
[32m+[m[32m    case 0:[m
[32m+[m[32m        // Single call to TextUnformatted() with a big buffer[m
[32m+[m[32m        ImGui::TextUnformatted(log.begin(), log.end());[m
[32m+[m[32m        break;[m
[32m+[m[32m    case 1:[m
[32m+[m[32m        {[m
[32m+[m[32m            // Multiple calls to Text(), manually coarsely clipped - demonstrate how to use the ImGuiListClipper helper.[m
[32m+[m[32m            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));[m
[32m+[m[32m            ImGuiListClipper clipper(lines);[m
[32m+[m[32m            while (clipper.Step())[m
[32m+[m[32m                for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)[m
[32m+[m[32m                    ImGui::Text("%i The quick brown fox jumps over the lazy dog", i);[m
[32m+[m[32m            ImGui::PopStyleVar();[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m    case 2:[m
[32m+[m[32m        // Multiple calls to Text(), not clipped (slow)[m
[32m+[m[32m        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));[m
[32m+[m[32m        for (int i = 0; i < lines; i++)[m
[32m+[m[32m            ImGui::Text("%i The quick brown fox jumps over the lazy dog", i);[m
[32m+[m[32m        ImGui::PopStyleVar();[m
[32m+[m[32m        break;[m
[32m+[m[32m    }[m
[32m+[m[32m    ImGui::EndChild();[m
[32m+[m[32m    ImGui::End();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Demonstrate creating a window which gets auto-resized according to its content.[m
[32m+[m[32mstatic void ShowExampleAppAutoResize(bool* p_open)[m
[32m+[m[32m{[m
[32m+[m[32m    if (!ImGui::Begin("Example: Auto-resizing window", p_open, ImGuiWindowFlags_AlwaysAutoResize))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::End();[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    static int lines = 10;[m
[32m+[m[32m    ImGui::Text("Window will resize every-frame to the size of its content.\nNote that you probably don't want to query the window size to\noutput your content because that would create a feedback loop.");[m
[32m+[m[32m    ImGui::SliderInt("Number of lines", &lines, 1, 20);[m
[32m+[m[32m    for (int i = 0; i < lines; i++)[m
[32m+[m[32m        ImGui::Text("%*sThis is line %d", i * 4, "", i); // Pad with space to extend size horizontally[m
[32m+[m[32m    ImGui::End();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Demonstrate creating a window with custom resize constraints.[m
[32m+[m[32mstatic void ShowExampleAppConstrainedResize(bool* p_open)[m
[32m+[m[32m{[m
[32m+[m[32m    struct CustomConstraints // Helper functions to demonstrate programmatic constraints[m
[32m+[m[32m    {[m
[32m+[m[32m        static void Square(ImGuiSizeCallbackData* data) { data->DesiredSize = ImVec2(IM_MAX(data->DesiredSize.x, data->DesiredSize.y), IM_MAX(data->DesiredSize.x, data->DesiredSize.y)); }[m
[32m+[m[32m        static void Step(ImGuiSizeCallbackData* data)   { float step = (float)(int)(intptr_t)data->UserData; data->DesiredSize = ImVec2((int)(data->DesiredSize.x / step + 0.5f) * step, (int)(data->DesiredSize.y / step + 0.5f) * step); }[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    static bool auto_resize = false;[m
[32m+[m[32m    static int type = 0;[m
[32m+[m[32m    static int display_lines = 10;[m
[32m+[m[32m    if (type == 0) ImGui::SetNextWindowSizeConstraints(ImVec2(-1, 0),    ImVec2(-1, FLT_MAX));      // Vertical only[m
[32m+[m[32m    if (type == 1) ImGui::SetNextWindowSizeConstraints(ImVec2(0, -1),    ImVec2(FLT_MAX, -1));      // Horizontal only[m
[32m+[m[32m    if (type == 2) ImGui::SetNextWindowSizeConstraints(ImVec2(100, 100), ImVec2(FLT_MAX, FLT_MAX)); // Width > 100, Height > 100[m
[32m+[m[32m    if (type == 3) ImGui::SetNextWindowSizeConstraints(ImVec2(400, -1),  ImVec2(500, -1));          // Width 400-500[m
[32m+[m[32m    if (type == 4) ImGui::SetNextWindowSizeConstraints(ImVec2(-1, 400),  ImVec2(-1, 500));          // Height 400-500[m
[32m+[m[32m    if (type == 5) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Square);                     // Always Square[m
[32m+[m[32m    if (type == 6) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Step, (void*)(intptr_t)100); // Fixed Step[m
[32m+[m
[32m+[m[32m    ImGuiWindowFlags flags = auto_resize ? ImGuiWindowFlags_AlwaysAutoResize : 0;[m
[32m+[m[32m    if (ImGui::Begin("Example: Constrained Resize", p_open, flags))[m
[32m+[m[32m    {[m
[32m+[m[32m        const char* desc[] =[m
[32m+[m[32m        {[m
[32m+[m[32m            "Resize vertical only",[m
[32m+[m[32m            "Resize horizontal only",[m
[32m+[m[32m            "Width > 100, Height > 100",[m
[32m+[m[32m            "Width 400-500",[m
[32m+[m[32m            "Height 400-500",[m
[32m+[m[32m            "Custom: Always Square",[m
[32m+[m[32m            "Custom: Fixed Steps (100)",[m
[32m+[m[32m        };[m
[32m+[m[32m        if (ImGui::Button("200x200")) { ImGui::SetWindowSize(ImVec2(200, 200)); } ImGui::SameLine();[m
[32m+[m[32m        if (ImGui::Button("500x500")) { ImGui::SetWindowSize(ImVec2(500, 500)); } ImGui::SameLine();[m
[32m+[m[32m        if (ImGui::Button("800x200")) { ImGui::SetWindowSize(ImVec2(800, 200)); }[m
[32m+[m[32m        ImGui::SetNextItemWidth(200);[m
[32m+[m[32m        ImGui::Combo("Constraint", &type, desc, IM_ARRAYSIZE(desc));[m
[32m+[m[32m        ImGui::SetNextItemWidth(200);[m
[32m+[m[32m        ImGui::DragInt("Lines", &display_lines, 0.2f, 1, 100);[m
[32m+[m[32m        ImGui::Checkbox("Auto-resize", &auto_resize);[m
[32m+[m[32m        for (int i = 0; i < display_lines; i++)[m
[32m+[m[32m            ImGui::Text("%*sHello, sailor! Making this line long enough for the example.", i * 4, "");[m
[32m+[m[32m    }[m
[32m+[m[32m    ImGui::End();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Example App: Simple Overlay / ShowExampleAppSimpleOverlay()[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Demonstrate creating a simple static window with no decoration + a context-menu to choose which corner of the screen to use.[m
[32m+[m[32mstatic void ShowExampleAppSimpleOverlay(bool* p_open)[m
[32m+[m[32m{[m
[32m+[m[32m    const float DISTANCE = 10.0f;[m
[32m+[m[32m    static int corner = 0;[m
[32m+[m[32m    ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m    if (corner != -1)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImVec2 window_pos = ImVec2((corner & 1) ? io.DisplaySize.x - DISTANCE : DISTANCE, (corner & 2) ? io.DisplaySize.y - DISTANCE : DISTANCE);[m
[32m+[m[32m        ImVec2 window_pos_pivot = ImVec2((corner & 1) ? 1.0f : 0.0f, (corner & 2) ? 1.0f : 0.0f);[m
[32m+[m[32m        ImGui::SetNextWindowPos(window_pos, ImGuiCond_Always, window_pos_pivot);[m
[32m+[m[32m    }[m
[32m+[m[32m    ImGui::SetNextWindowBgAlpha(0.35f); // Transparent background[m
[32m+[m[32m    if (ImGui::Begin("Example: Simple overlay", p_open, (corner != -1 ? ImGuiWindowFlags_NoMove : 0) | ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::Text("Simple overlay\n" "in the corner of the screen.\n" "(right-click to change position)");[m
[32m+[m[32m        ImGui::Separator();[m
[32m+[m[32m        if (ImGui::IsMousePosValid())[m
[32m+[m[32m            ImGui::Text("Mouse Position: (%.1f,%.1f)", io.MousePos.x, io.MousePos.y);[m
[32m+[m[32m        else[m
[32m+[m[32m            ImGui::Text("Mouse Position: <invalid>");[m
[32m+[m[32m        if (ImGui::BeginPopupContextWindow())[m
[32m+[m[32m        {[m
[32m+[m[32m            if (ImGui::MenuItem("Custom",       NULL, corner == -1)) corner = -1;[m
[32m+[m[32m            if (ImGui::MenuItem("Top-left",     NULL, corner == 0)) corner = 0;[m
[32m+[m[32m            if (ImGui::MenuItem("Top-right",    NULL, corner == 1)) corner = 1;[m
[32m+[m[32m            if (ImGui::MenuItem("Bottom-left",  NULL, corner == 2)) corner = 2;[m
[32m+[m[32m            if (ImGui::MenuItem("Bottom-right", NULL, corner == 3)) corner = 3;[m
[32m+[m[32m            if (p_open && ImGui::MenuItem("Close")) *p_open = false;[m
[32m+[m[32m            ImGui::EndPopup();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    ImGui::End();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Example App: Manipulating Window Titles / ShowExampleAppWindowTitles()[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Demonstrate using "##" and "###" in identifiers to manipulate ID generation.[m
[32m+[m[32m// This apply to all regular items as well. Read FAQ section "How can I have multiple widgets with the same label? Can I have widget without a label? (Yes). A primer on the purpose of labels/IDs." for details.[m
[32m+[m[32mstatic void ShowExampleAppWindowTitles(bool*)[m
[32m+[m[32m{[m
[32m+[m[32m    // By default, Windows are uniquely identified by their title.[m
[32m+[m[32m    // You can use the "##" and "###" markers to manipulate the display/ID.[m
[32m+[m
[32m+[m[32m    // Using "##" to display same title but have unique identifier.[m
[32m+[m[32m    ImGui::SetNextWindowPos(ImVec2(100, 100), ImGuiCond_FirstUseEver);[m
[32m+[m[32m    ImGui::Begin("Same title as another window##1");[m
[32m+[m[32m    ImGui::Text("This is window 1.\nMy title is the same as window 2, but my identifier is unique.");[m
[32m+[m[32m    ImGui::End();[m
[32m+[m
[32m+[m[32m    ImGui::SetNextWindowPos(ImVec2(100, 200), ImGuiCond_FirstUseEver);[m
[32m+[m[32m    ImGui::Begin("Same title as another window##2");[m
[32m+[m[32m    ImGui::Text("This is window 2.\nMy title is the same as window 1, but my identifier is unique.");[m
[32m+[m[32m    ImGui::End();[m
[32m+[m
[32m+[m[32m    // Using "###" to display a changing title but keep a static identifier "AnimatedTitle"[m
[32m+[m[32m    char buf[128];[m
[32m+[m[32m    sprintf(buf, "Animated title %c %d###AnimatedTitle", "|/-\\"[(int)(ImGui::GetTime() / 0.25f) & 3], ImGui::GetFrameCount());[m
[32m+[m[32m    ImGui::SetNextWindowPos(ImVec2(100, 300), ImGuiCond_FirstUseEver);[m
[32m+[m[32m    ImGui::Begin(buf);[m
[32m+[m[32m    ImGui::Text("This window has a changing title.");[m
[32m+[m[32m    ImGui::End();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Demonstrate using the low-level ImDrawList to draw custom shapes.[m
[32m+[m[32mstatic void ShowExampleAppCustomRendering(bool* p_open)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGui::SetNextWindowSize(ImVec2(350, 560), ImGuiCond_FirstUseEver);[m
[32m+[m[32m    if (!ImGui::Begin("Example: Custom rendering", p_open))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::End();[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Tip: If you do a lot of custom rendering, you probably want to use your own geometrical types and benefit of overloaded operators, etc.[m
[32m+[m[32m    // Define IM_VEC2_CLASS_EXTRA in imconfig.h to create implicit conversions between your types and ImVec2/ImVec4.[m
[32m+[m[32m    // ImGui defines overloaded operators but they are internal to imgui.cpp and not exposed outside (to avoid messing with your types)[m
[32m+[m[32m    // In this example we are not using the maths operators![m
[32m+[m[32m    ImDrawList* draw_list = ImGui::GetWindowDrawList();[m
[32m+[m
[32m+[m[32m    if (ImGui::BeginTabBar("##TabBar"))[m
[32m+[m[32m    {[m
[32m+[m[32m        // Primitives[m
[32m+[m[32m        if (ImGui::BeginTabItem("Primitives"))[m
[32m+[m[32m        {[m
[32m+[m[32m            static float sz = 36.0f;[m
[32m+[m[32m            static float thickness = 3.0f;[m
[32m+[m[32m            static ImVec4 colf = ImVec4(1.0f, 1.0f, 0.4f, 1.0f);[m
[32m+[m[32m            ImGui::DragFloat("Size", &sz, 0.2f, 2.0f, 72.0f, "%.0f");[m
[32m+[m[32m            ImGui::DragFloat("Thickness", &thickness, 0.05f, 1.0f, 8.0f, "%.02f");[m
[32m+[m[32m            ImGui::ColorEdit4("Color", &colf.x);[m
[32m+[m[32m            const ImVec2 p = ImGui::GetCursorScreenPos();[m
[32m+[m[32m            const ImU32 col = ImColor(colf);[m
[32m+[m[32m            float x = p.x + 4.0f, y = p.y + 4.0f;[m
[32m+[m[32m            float spacing = 10.0f;[m
[32m+[m[32m            ImDrawCornerFlags corners_none = 0;[m
[32m+[m[32m            ImDrawCornerFlags corners_all = ImDrawCornerFlags_All;[m
[32m+[m[32m            ImDrawCornerFlags corners_tl_br = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotRight;[m
[32m+[m[32m            for (int n = 0; n < 2; n++)[m
[32m+[m[32m            {[m
[32m+[m[32m                // First line uses a thickness of 1.0f, second line uses the configurable thickness[m
[32m+[m[32m                float th = (n == 0) ? 1.0f : thickness;[m
[32m+[m[32m                draw_list->AddCircle(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, col, 6, th);                x += sz + spacing;  // Hexagon[m
[32m+[m[32m                draw_list->AddCircle(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, col, 20, th);               x += sz + spacing;  // Circle[m
[32m+[m[32m                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 0.0f,  corners_none, th);     x += sz + spacing;  // Square[m
[32m+[m[32m                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 10.0f, corners_all, th);      x += sz + spacing;  // Square with all rounded corners[m
[32m+[m[32m                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 10.0f, corners_tl_br, th);    x += sz + spacing;  // Square with two rounded corners[m
[32m+[m[32m                draw_list->AddTriangle(ImVec2(x+sz*0.5f,y), ImVec2(x+sz, y+sz-0.5f), ImVec2(x, y+sz-0.5f), col, th);      x += sz + spacing;      // Triangle[m
[32m+[m[32m                draw_list->AddTriangle(ImVec2(x+sz*0.2f,y), ImVec2(x, y+sz-0.5f), ImVec2(x+sz*0.4f, y+sz-0.5f), col, th); x += sz*0.4f + spacing; // Thin triangle[m
[32m+[m[32m                draw_list->AddLine(ImVec2(x, y), ImVec2(x + sz, y), col, th);                               x += sz + spacing;  // Horizontal line (note: drawing a filled rectangle will be faster!)[m
[32m+[m[32m                draw_list->AddLine(ImVec2(x, y), ImVec2(x, y + sz), col, th);                               x += spacing;       // Vertical line (note: drawing a filled rectangle will be faster!)[m
[32m+[m[32m                draw_list->AddLine(ImVec2(x, y), ImVec2(x + sz, y + sz), col, th);                          x += sz + spacing;  // Diagonal line[m
[32m+[m[32m                draw_list->AddBezierCurve(ImVec2(x, y), ImVec2(x + sz*1.3f, y + sz*0.3f), ImVec2(x + sz - sz*1.3f, y + sz - sz*0.3f), ImVec2(x + sz, y + sz), col, th);[m
[32m+[m[32m                x = p.x + 4;[m
[32m+[m[32m                y += sz + spacing;[m
[32m+[m[32m            }[m
[32m+[m[32m            draw_list->AddCircleFilled(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, col, 6);              x += sz + spacing;  // Hexagon[m
[32m+[m[32m            draw_list->AddCircleFilled(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, col, 32);             x += sz + spacing;  // Circle[m
[32m+[m[32m            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col);                        x += sz + spacing;  // Square[m
[32m+[m[32m            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 10.0f);                 x += sz + spacing;  // Square with all rounded corners[m
[32m+[m[32m            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 10.0f, corners_tl_br);  x += sz + spacing;  // Square with two rounded corners[m
[32m+[m[32m            draw_list->AddTriangleFilled(ImVec2(x+sz*0.5f,y), ImVec2(x+sz, y+sz-0.5f), ImVec2(x, y+sz-0.5f), col);      x += sz + spacing;      // Triangle[m
[32m+[m[32m            draw_list->AddTriangleFilled(ImVec2(x+sz*0.2f,y), ImVec2(x, y+sz-0.5f), ImVec2(x+sz*0.4f, y+sz-0.5f), col); x += sz*0.4f + spacing; // Thin triangle[m
[32m+[m[32m            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + thickness), col);                 x += sz + spacing;  // Horizontal line (faster than AddLine, but only handle integer thickness)[m
[32m+[m[32m            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + thickness, y + sz), col);                 x += spacing*2.0f;  // Vertical line (faster than AddLine, but only handle integer thickness)[m
[32m+[m[32m            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + 1, y + 1), col);                          x += sz;            // Pixel (faster than AddLine)[m
[32m+[m[32m            draw_list->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x + sz, y + sz), IM_COL32(0, 0, 0, 255), IM_COL32(255, 0, 0, 255), IM_COL32(255, 255, 0, 255), IM_COL32(0, 255, 0, 255));[m
[32m+[m[32m            ImGui::Dummy(ImVec2((sz + spacing) * 9.8f, (sz + spacing) * 3));[m
[32m+[m[32m            ImGui::EndTabItem();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::BeginTabItem("Canvas"))[m
[32m+[m[32m        {[m
[32m+[m[32m            static ImVector<ImVec2> points;[m
[32m+[m[32m            static bool adding_line = false;[m
[32m+[m[32m            if (ImGui::Button("Clear")) points.clear();[m
[32m+[m[32m            if (points.Size >= 2) { ImGui::SameLine(); if (ImGui::Button("Undo")) { points.pop_back(); points.pop_back(); } }[m
[32m+[m[32m            ImGui::Text("Left-click and drag to add lines,\nRight-click to undo");[m
[32m+[m
[32m+[m[32m            // Here we are using InvisibleButton() as a convenience to 1) advance the cursor and 2) allows us to use IsItemHovered()[m
[32m+[m[32m            // But you can also draw directly and poll mouse/keyboard by yourself. You can manipulate the cursor using GetCursorPos() and SetCursorPos().[m
[32m+[m[32m            // If you only use the ImDrawList API, you can notify the owner window of its extends by using SetCursorPos(max).[m
[32m+[m[32m            ImVec2 canvas_pos = ImGui::GetCursorScreenPos();            // ImDrawList API uses screen coordinates![m
[32m+[m[32m            ImVec2 canvas_size = ImGui::GetContentRegionAvail();        // Resize canvas to what's available[m
[32m+[m[32m            if (canvas_size.x < 50.0f) canvas_size.x = 50.0f;[m
[32m+[m[32m            if (canvas_size.y < 50.0f) canvas_size.y = 50.0f;[m
[32m+[m[32m            draw_list->AddRectFilledMultiColor(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), IM_COL32(50, 50, 50, 255), IM_COL32(50, 50, 60, 255), IM_COL32(60, 60, 70, 255), IM_COL32(50, 50, 60, 255));[m
[32m+[m[32m            draw_list->AddRect(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), IM_COL32(255, 255, 255, 255));[m
[32m+[m
[32m+[m[32m            bool adding_preview = false;[m
[32m+[m[32m            ImGui::InvisibleButton("canvas", canvas_size);[m
[32m+[m[32m            ImVec2 mouse_pos_in_canvas = ImVec2(ImGui::GetIO().MousePos.x - canvas_pos.x, ImGui::GetIO().MousePos.y - canvas_pos.y);[m
[32m+[m[32m            if (adding_line)[m
[32m+[m[32m            {[m
[32m+[m[32m                adding_preview = true;[m
[32m+[m[32m                points.push_back(mouse_pos_in_canvas);[m
[32m+[m[32m                if (!ImGui::IsMouseDown(0))[m
[32m+[m[32m                    adding_line = adding_preview = false;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (ImGui::IsItemHovered())[m
[32m+[m[32m            {[m
[32m+[m[32m                if (!adding_line && ImGui::IsMouseClicked(0))[m
[32m+[m[32m                {[m
[32m+[m[32m                    points.push_back(mouse_pos_in_canvas);[m
[32m+[m[32m                    adding_line = true;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (ImGui::IsMouseClicked(1) && !points.empty())[m
[32m+[m[32m                {[m
[32m+[m[32m                    adding_line = adding_preview = false;[m
[32m+[m[32m                    points.pop_back();[m
[32m+[m[32m                    points.pop_back();[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            draw_list->PushClipRect(canvas_pos, ImVec2(canvas_pos.x + canvas_size.x, canvas_pos.y + canvas_size.y), true);      // clip lines within the canvas (if we resize it, etc.)[m
[32m+[m[32m            for (int i = 0; i < points.Size - 1; i += 2)[m
[32m+[m[32m                draw_list->AddLine(ImVec2(canvas_pos.x + points[i].x, canvas_pos.y + points[i].y), ImVec2(canvas_pos.x + points[i + 1].x, canvas_pos.y + points[i + 1].y), IM_COL32(255, 255, 0, 255), 2.0f);[m
[32m+[m[32m            draw_list->PopClipRect();[m
[32m+[m[32m            if (adding_preview)[m
[32m+[m[32m                points.pop_back();[m
[32m+[m[32m            ImGui::EndTabItem();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (ImGui::BeginTabItem("BG/FG draw lists"))[m
[32m+[m[32m        {[m
[32m+[m[32m            static bool draw_bg = true;[m
[32m+[m[32m            static bool draw_fg = true;[m
[32m+[m[32m            ImGui::Checkbox("Draw in Background draw list", &draw_bg);[m
[32m+[m[32m            ImGui::Checkbox("Draw in Foreground draw list", &draw_fg);[m
[32m+[m[32m            ImVec2 window_pos = ImGui::GetWindowPos();[m
[32m+[m[32m            ImVec2 window_size = ImGui::GetWindowSize();[m
[32m+[m[32m            ImVec2 window_center = ImVec2(window_pos.x + window_size.x * 0.5f, window_pos.y + window_size.y * 0.5f);[m
[32m+[m[32m            if (draw_bg)[m
[32m+[m[32m                ImGui::GetBackgroundDrawList()->AddCircle(window_center, window_size.x * 0.6f, IM_COL32(255, 0, 0, 200), 32, 10+4);[m
[32m+[m[32m            if (draw_fg)[m
[32m+[m[32m                ImGui::GetForegroundDrawList()->AddCircle(window_center, window_size.y * 0.6f, IM_COL32(0, 255, 0, 200), 32, 10);[m
[32m+[m[32m            ImGui::EndTabItem();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        ImGui::EndTabBar();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    ImGui::End();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Simplified structure to mimic a Document model[m
[32m+[m[32mstruct MyDocument[m
[32m+[m[32m{[m
[32m+[m[32m    const char* Name;           // Document title[m
[32m+[m[32m    bool        Open;           // Set when the document is open (in this demo, we keep an array of all available documents to simplify the demo)[m
[32m+[m[32m    bool        OpenPrev;       // Copy of Open from last update.[m
[32m+[m[32m    bool        Dirty;          // Set when the document has been modified[m
[32m+[m[32m    bool        WantClose;      // Set when the document[m
[32m+[m[32m    ImVec4      Color;          // An arbitrary variable associated to the document[m
[32m+[m
[32m+[m[32m    MyDocument(const char* name, bool open = true, const ImVec4& color = ImVec4(1.0f,1.0f,1.0f,1.0f))[m
[32m+[m[32m    {[m
[32m+[m[32m        Name = name;[m
[32m+[m[32m        Open = OpenPrev = open;[m
[32m+[m[32m        Dirty = false;[m
[32m+[m[32m        WantClose = false;[m
[32m+[m[32m        Color = color;[m
[32m+[m[32m    }[m
[32m+[m[32m    void DoOpen()       { Open = true; }[m
[32m+[m[32m    void DoQueueClose() { WantClose = true; }[m
[32m+[m[32m    void DoForceClose() { Open = false; Dirty = false; }[m
[32m+[m[32m    void DoSave()       { Dirty = false; }[m
[32m+[m
[32m+[m[32m    // Display dummy contents for the Document[m
[32m+[m[32m    static void DisplayContents(MyDocument* doc)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::PushID(doc);[m
[32m+[m[32m        ImGui::Text("Document \"%s\"", doc->Name);[m
[32m+[m[32m        ImGui::PushStyleColor(ImGuiCol_Text, doc->Color);[m
[32m+[m[32m        ImGui::TextWrapped("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.");[m
[32m+[m[32m        ImGui::PopStyleColor();[m
[32m+[m[32m        if (ImGui::Button("Modify", ImVec2(100, 0)))[m
[32m+[m[32m            doc->Dirty = true;[m
[32m+[m[32m        ImGui::SameLine();[m
[32m+[m[32m        if (ImGui::Button("Save", ImVec2(100, 0)))[m
[32m+[m[32m            doc->DoSave();[m
[32m+[m[32m        ImGui::ColorEdit3("color", &doc->Color.x);  // Useful to test drag and drop and hold-dragged-to-open-tab behavior.[m
[32m+[m[32m        ImGui::PopID();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Display context menu for the Document[m
[32m+[m[32m    static void DisplayContextMenu(MyDocument* doc)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (!ImGui::BeginPopupContextItem())[m
[32m+[m[32m            return;[m
[32m+[m
[32m+[m[32m        char buf[256];[m
[32m+[m[32m        sprintf(buf, "Save %s", doc->Name);[m
[32m+[m[32m        if (ImGui::MenuItem(buf, "CTRL+S", false, doc->Open))[m
[32m+[m[32m            doc->DoSave();[m
[32m+[m[32m        if (ImGui::MenuItem("Close", "CTRL+W", false, doc->Open))[m
[32m+[m[32m            doc->DoQueueClose();[m
[32m+[m[32m        ImGui::EndPopup();[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstruct ExampleAppDocuments[m
[32m+[m[32m{[m
[32m+[m[32m    ImVector<MyDocument> Documents;[m
[32m+[m
[32m+[m[32m    ExampleAppDocuments()[m
[32m+[m[32m    {[m
[32m+[m[32m        Documents.push_back(MyDocument("Lettuce",             true,  ImVec4(0.4f, 0.8f, 0.4f, 1.0f)));[m
[32m+[m[32m        Documents.push_back(MyDocument("Eggplant",            true,  ImVec4(0.8f, 0.5f, 1.0f, 1.0f)));[m
[32m+[m[32m        Documents.push_back(MyDocument("Carrot",              true,  ImVec4(1.0f, 0.8f, 0.5f, 1.0f)));[m
[32m+[m[32m        Documents.push_back(MyDocument("Tomato",              false, ImVec4(1.0f, 0.3f, 0.4f, 1.0f)));[m
[32m+[m[32m        Documents.push_back(MyDocument("A Rather Long Title", false));[m
[32m+[m[32m        Documents.push_back(MyDocument("Some Document",       false));[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// [Optional] Notify the system of Tabs/Windows closure that happened outside the regular tab interface.[m
[32m+[m[32m// If a tab has been closed programmatically (aka closed from another source such as the Checkbox() in the demo, as opposed[m
[32m+[m[32m// to clicking on the regular tab closing button) and stops being submitted, it will take a frame for the tab bar to notice its absence.[m
[32m+[m[32m// During this frame there will be a gap in the tab bar, and if the tab that has disappeared was the selected one, the tab bar[m
[32m+[m[32m// will report no selected tab during the frame. This will effectively give the impression of a flicker for one frame.[m
[32m+[m[32m// We call SetTabItemClosed() to manually notify the Tab Bar or Docking system of removed tabs to avoid this glitch.[m
[32m+[m[32m// Note that this completely optional, and only affect tab bars with the ImGuiTabBarFlags_Reorderable flag.[m
[32m+[m[32mstatic void NotifyOfDocumentsClosedElsewhere(ExampleAppDocuments& app)[m
[32m+[m[32m{[m
[32m+[m[32m    for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)[m
[32m+[m[32m    {[m
[32m+[m[32m        MyDocument* doc = &app.Documents[doc_n];[m
[32m+[m[32m        if (!doc->Open && doc->OpenPrev)[m
[32m+[m[32m            ImGui::SetTabItemClosed(doc->Name);[m
[32m+[m[32m        doc->OpenPrev = doc->Open;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ShowExampleAppDocuments(bool* p_open)[m
[32m+[m[32m{[m
[32m+[m[32m    static ExampleAppDocuments app;[m
[32m+[m
[32m+[m[32m    // Options[m
[32m+[m[32m    static bool opt_reorderable = true;[m
[32m+[m[32m    static ImGuiTabBarFlags opt_fitting_flags = ImGuiTabBarFlags_FittingPolicyDefault_;[m
[32m+[m
[32m+[m[32m    if (!ImGui::Begin("Example: Documents", p_open, ImGuiWindowFlags_MenuBar))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGui::End();[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Menu[m
[32m+[m[32m    if (ImGui::BeginMenuBar())[m
[32m+[m[32m    {[m
[32m+[m[32m        if (ImGui::BeginMenu("File"))[m
[32m+[m[32m        {[m
[32m+[m[32m            int open_count = 0;[m
[32m+[m[32m            for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)[m
[32m+[m[32m                open_count += app.Documents[doc_n].Open ? 1 : 0;[m
[32m+[m
[32m+[m[32m            if (ImGui::BeginMenu("Open", open_count < app.Documents.Size))[m
[32m+[m[32m            {[m
[32m+[m[32m                for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)[m
[32m+[m[32m                {[m
[32m+[m[32m                    MyDocument* doc = &app.Documents[doc_n];[m
[32m+[m[32m                    if (!doc->Open)[m
[32m+[m[32m                        if (ImGui::MenuItem(doc->Name))[m
[32m+[m[32m                            doc->DoOpen();[m
[32m+[m[32m                }[m
[32m+[m[32m                ImGui::EndMenu();[m
[32m+[m[32m            }[m
[32m+[m[32m            if (ImGui::MenuItem("Close All Documents", NULL, false, open_count > 0))[m
[32m+[m[32m                for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)[m
[32m+[m[32m                    app.Documents[doc_n].DoQueueClose();[m
[32m+[m[32m            if (ImGui::MenuItem("Exit", "Alt+F4")) {}[m
[32m+[m[32m            ImGui::EndMenu();[m
[32m+[m[32m        }[m
[32m+[m[32m        ImGui::EndMenuBar();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // [Debug] List documents with one checkbox for each[m
[32m+[m[32m    for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)[m
[32m+[m[32m    {[m
[32m+[m[32m        MyDocument* doc = &app.Documents[doc_n];[m
[32m+[m[32m        if (doc_n > 0)[m
[32m+[m[32m            ImGui::SameLine();[m
[32m+[m[32m        ImGui::PushID(doc);[m
[32m+[m[32m        if (ImGui::Checkbox(doc->Name, &doc->Open))[m
[32m+[m[32m            if (!doc->Open)[m
[32m+[m[32m                doc->DoForceClose();[m
[32m+[m[32m        ImGui::PopID();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    ImGui::Separator();[m
[32m+[m
[32m+[m[32m    // Submit Tab Bar and Tabs[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiTabBarFlags tab_bar_flags = (opt_fitting_flags) | (opt_reorderable ? ImGuiTabBarFlags_Reorderable : 0);[m
[32m+[m[32m        if (ImGui::BeginTabBar("##tabs", tab_bar_flags))[m
[32m+[m[32m        {[m
[32m+[m[32m            if (opt_reorderable)[m
[32m+[m[32m                NotifyOfDocumentsClosedElsewhere(app);[m
[32m+[m
[32m+[m[32m            // [DEBUG] Stress tests[m
[32m+[m[32m            //if ((ImGui::GetFrameCount() % 30) == 0) docs[1].Open ^= 1;            // [DEBUG] Automatically show/hide a tab. Test various interactions e.g. dragging with this on.[m
[32m+[m[32m            //if (ImGui::GetIO().KeyCtrl) ImGui::SetTabItemSelected(docs[1].Name);  // [DEBUG] Test SetTabItemSelected(), probably not very useful as-is anyway..[m
[32m+[m
[32m+[m[32m            // Submit Tabs[m
[32m+[m[32m            for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)[m
[32m+[m[32m            {[m
[32m+[m[32m                MyDocument* doc = &app.Documents[doc_n];[m
[32m+[m[32m                if (!doc->Open)[m
[32m+[m[32m                    continue;[m
[32m+[m
[32m+[m[32m                ImGuiTabItemFlags tab_flags = (doc->Dirty ? ImGuiTabItemFlags_UnsavedDocument : 0);[m
[32m+[m[32m                bool visible = ImGui::BeginTabItem(doc->Name, &doc->Open, tab_flags);[m
[32m+[m
[32m+[m[32m                // Cancel attempt to close when unsaved add to save queue so we can display a popup.[m
[32m+[m[32m                if (!doc->Open && doc->Dirty)[m
[32m+[m[32m                {[m
[32m+[m[32m                    doc->Open = true;[m
[32m+[m[32m                    doc->DoQueueClose();[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                MyDocument::DisplayContextMenu(doc);[m
[32m+[m[32m                if (visible)[m
[32m+[m[32m                {[m
[32m+[m[32m                    MyDocument::DisplayContents(doc);[m
[32m+[m[32m                    ImGui::EndTabItem();[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            ImGui::EndTabBar();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Update closing queue[m
[32m+[m[32m    static ImVector<MyDocument*> close_queue;[m
[32m+[m[32m    if (close_queue.empty())[m
[32m+[m[32m    {[m
[32m+[m[32m        // Close queue is locked once we started a popup[m
[32m+[m[32m        for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)[m
[32m+[m[32m        {[m
[32m+[m[32m            MyDocument* doc = &app.Documents[doc_n];[m
[32m+[m[32m            if (doc->WantClose)[m
[32m+[m[32m            {[m
[32m+[m[32m                doc->WantClose = false;[m
[32m+[m[32m                close_queue.push_back(doc);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Display closing confirmation UI[m
[32m+[m[32m    if (!close_queue.empty())[m
[32m+[m[32m    {[m
[32m+[m[32m        int close_queue_unsaved_documents = 0;[m
[32m+[m[32m        for (int n = 0; n < close_queue.Size; n++)[m
[32m+[m[32m            if (close_queue[n]->Dirty)[m
[32m+[m[32m                close_queue_unsaved_documents++;[m
[32m+[m
[32m+[m[32m        if (close_queue_unsaved_documents == 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Close documents when all are unsaved[m
[32m+[m[32m            for (int n = 0; n < close_queue.Size; n++)[m
[32m+[m[32m                close_queue[n]->DoForceClose();[m
[32m+[m[32m            close_queue.clear();[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            if (!ImGui::IsPopupOpen("Save?"))[m
[32m+[m[32m                ImGui::OpenPopup("Save?");[m
[32m+[m[32m            if (ImGui::BeginPopupModal("Save?"))[m
[32m+[m[32m            {[m
[32m+[m[32m                ImGui::Text("Save change to the following items?");[m
[32m+[m[32m                ImGui::SetNextItemWidth(-1.0f);[m
[32m+[m[32m                if (ImGui::ListBoxHeader("##", close_queue_unsaved_documents, 6))[m
[32m+[m[32m                {[m
[32m+[m[32m                    for (int n = 0; n < close_queue.Size; n++)[m
[32m+[m[32m                        if (close_queue[n]->Dirty)[m
[32m+[m[32m                            ImGui::Text("%s", close_queue[n]->Name);[m
[32m+[m[32m                    ImGui::ListBoxFooter();[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (ImGui::Button("Yes", ImVec2(80, 0)))[m
[32m+[m[32m                {[m
[32m+[m[32m                    for (int n = 0; n < close_queue.Size; n++)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        if (close_queue[n]->Dirty)[m
[32m+[m[32m                            close_queue[n]->DoSave();[m
[32m+[m[32m                        close_queue[n]->DoForceClose();[m
[32m+[m[32m                    }[m
[32m+[m[32m                    close_queue.clear();[m
[32m+[m[32m                    ImGui::CloseCurrentPopup();[m
[32m+[m[32m                }[m
[32m+[m[32m                ImGui::SameLine();[m
[32m+[m[32m                if (ImGui::Button("No", ImVec2(80, 0)))[m
[32m+[m[32m                {[m
[32m+[m[32m                    for (int n = 0; n < close_queue.Size; n++)[m
[32m+[m[32m                        close_queue[n]->DoForceClose();[m
[32m+[m[32m                    close_queue.clear();[m
[32m+[m[32m                    ImGui::CloseCurrentPopup();[m
[32m+[m[32m                }[m
[32m+[m[32m                ImGui::SameLine();[m
[32m+[m[32m                if (ImGui::Button("Cancel", ImVec2(80, 0)))[m
[32m+[m[32m                {[m
[32m+[m[32m                    close_queue.clear();[m
[32m+[m[32m                    ImGui::CloseCurrentPopup();[m
[32m+[m[32m                }[m
[32m+[m[32m                ImGui::EndPopup();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    ImGui::End();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// End of Demo code[m
[32m+[m[32m#else[m
[32m+[m
[32m+[m[32mvoid ImGui::ShowAboutWindow(bool*) {}[m
[32m+[m[32mvoid ImGui::ShowDemoWindow(bool*) {}[m
[32m+[m[32mvoid ImGui::ShowUserGuide() {}[m
[32m+[m[32mvoid ImGui::ShowStyleEditor(ImGuiStyle*) {}[m
[32m+[m
[32m+[m[32m#endif[m
[1mdiff --git a/vendor/source/ImGui/imgui_draw.cpp b/vendor/source/ImGui/imgui_draw.cpp[m
[1mnew file mode 100644[m
[1mindex 0000000..63d99a2[m
[1m--- /dev/null[m
[1m+++ b/vendor/source/ImGui/imgui_draw.cpp[m
[36m@@ -0,0 +1,3306 @@[m
[32m+[m[32m// dear imgui, v1.70[m
[32m+[m[32m// (drawing and font code)[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m
[32m+[m[32mIndex of this file:[m
[32m+[m
[32m+[m[32m// [SECTION] STB libraries implementation[m
[32m+[m[32m// [SECTION] Style functions[m
[32m+[m[32m// [SECTION] ImDrawList[m
[32m+[m[32m// [SECTION] ImDrawData[m
[32m+[m[32m// [SECTION] Helpers ShadeVertsXXX functions[m
[32m+[m[32m// [SECTION] ImFontConfig[m
[32m+[m[32m// [SECTION] ImFontAtlas[m
[32m+[m[32m// [SECTION] ImFontAtlas glyph ranges helpers[m
[32m+[m[32m// [SECTION] ImFontGlyphRangesBuilder[m
[32m+[m[32m// [SECTION] ImFont[m
[32m+[m[32m// [SECTION] Internal Render Helpers[m
[32m+[m[32m// [SECTION] Decompression code[m
[32m+[m[32m// [SECTION] Default font data (ProggyClean.ttf)[m
[32m+[m
[32m+[m[32m*/[m
[32m+[m
[32m+[m[32m#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)[m
[32m+[m[32m#define _CRT_SECURE_NO_WARNINGS[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#include "imgui.h"[m
[32m+[m[32m#ifndef IMGUI_DEFINE_MATH_OPERATORS[m
[32m+[m[32m#define IMGUI_DEFINE_MATH_OPERATORS[m
[32m+[m[32m#endif[m
[32m+[m[32m#include "imgui_internal.h"[m
[32m+[m
[32m+[m[32m#include <stdio.h>      // vsnprintf, sscanf, printf[m
[32m+[m[32m#if !defined(alloca)[m
[32m+[m[32m#if defined(__GLIBC__) || defined(__sun) || defined(__CYGWIN__) || defined(__APPLE__)[m
[32m+[m[32m#include <alloca.h>     // alloca (glibc uses <alloca.h>. Note that Cygwin may have _WIN32 defined, so the order matters here)[m
[32m+[m[32m#elif defined(_WIN32)[m
[32m+[m[32m#include <malloc.h>     // alloca[m
[32m+[m[32m#if !defined(alloca)[m
[32m+[m[32m#define alloca _alloca  // for clang with MS Codegen[m
[32m+[m[32m#endif[m
[32m+[m[32m#else[m
[32m+[m[32m#include <stdlib.h>     // alloca[m
[32m+[m[32m#endif[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Visual Studio warnings[m
[32m+[m[32m#ifdef _MSC_VER[m
[32m+[m[32m#pragma warning (disable: 4505) // unreferenced local function has been removed (stb stuff)[m
[32m+[m[32m#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Clang/GCC warnings with -Weverything[m
[32m+[m[32m#ifdef __clang__[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants ok.[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wglobal-constructors"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference is.[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //[m
[32m+[m[32m#if __has_warning("-Wzero-as-null-pointer-constant")[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning : zero as null pointer constant              // some standard header variations use #define NULL 0[m
[32m+[m[32m#endif[m
[32m+[m[32m#if __has_warning("-Wcomma")[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wcomma"                  // warning : possible misuse of comma operator here             //[m
[32m+[m[32m#endif[m
[32m+[m[32m#if __has_warning("-Wreserved-id-macro")[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wreserved-id-macro"      // warning : macro name is a reserved identifier                //[m
[32m+[m[32m#endif[m
[32m+[m[32m#if __has_warning("-Wdouble-promotion")[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wdouble-promotion"       // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.[m
[32m+[m[32m#endif[m
[32m+[m[32m#elif defined(__GNUC__)[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wstack-protector"          // warning: stack protector not protecting local variables: variable length buffer[m
[32m+[m[32m#if __GNUC__ >= 8[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wclass-memaccess"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead[m
[32m+[m[32m#endif[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] STB libraries implementation[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Compile time options:[m
[32m+[m[32m//#define IMGUI_STB_NAMESPACE           ImStb[m
[32m+[m[32m//#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"[m
[32m+[m[32m//#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"[m
[32m+[m[32m//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION[m
[32m+[m[32m//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION[m
[32m+[m
[32m+[m[32m#ifdef IMGUI_STB_NAMESPACE[m
[32m+[m[32mnamespace IMGUI_STB_NAMESPACE[m
[32m+[m[32m{[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef _MSC_VER[m
[32m+[m[32m#pragma warning (push)[m
[32m+[m[32m#pragma warning (disable: 4456)                             // declaration of 'xx' hides previous local declaration[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef __clang__[m
[32m+[m[32m#pragma clang diagnostic push[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wunused-function"[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wmissing-prototypes"[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wimplicit-fallthrough"[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wcast-qual"              // warning : cast from 'const xxxx *' to 'xxx *' drops const qualifier //[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef __GNUC__[m
[32m+[m[32m#pragma GCC diagnostic push[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wtype-limits"              // warning: comparison is always true due to limited range of data type [-Wtype-limits][m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wcast-qual"                // warning: cast from type 'const xxxx *' to type 'xxxx *' casts away qualifiers[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifndef STB_RECT_PACK_IMPLEMENTATION                        // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)[m
[32m+[m[32m#ifndef IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION[m
[32m+[m[32m#define STBRP_STATIC[m
[32m+[m[32m#define STBRP_ASSERT(x)     IM_ASSERT(x)[m
[32m+[m[32m#define STBRP_SORT          ImQsort[m
[32m+[m[32m#define STB_RECT_PACK_IMPLEMENTATION[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef IMGUI_STB_RECT_PACK_FILENAME[m
[32m+[m[32m#include IMGUI_STB_RECT_PACK_FILENAME[m
[32m+[m[32m#else[m
[32m+[m[32m#include "imstb_rectpack.h"[m
[32m+[m[32m#endif[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifndef STB_TRUETYPE_IMPLEMENTATION                         // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)[m
[32m+[m[32m#ifndef IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION[m
[32m+[m[32m#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))[m
[32m+[m[32m#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))[m
[32m+[m[32m#define STBTT_assert(x)     IM_ASSERT(x)[m
[32m+[m[32m#define STBTT_fmod(x,y)     ImFmod(x,y)[m
[32m+[m[32m#define STBTT_sqrt(x)       ImSqrt(x)[m
[32m+[m[32m#define STBTT_pow(x,y)      ImPow(x,y)[m
[32m+[m[32m#define STBTT_fabs(x)       ImFabs(x)[m
[32m+[m[32m#define STBTT_ifloor(x)     ((int)ImFloorStd(x))[m
[32m+[m[32m#define STBTT_iceil(x)      ((int)ImCeil(x))[m
[32m+[m[32m#define STBTT_STATIC[m
[32m+[m[32m#define STB_TRUETYPE_IMPLEMENTATION[m
[32m+[m[32m#else[m
[32m+[m[32m#define STBTT_DEF extern[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef IMGUI_STB_TRUETYPE_FILENAME[m
[32m+[m[32m#include IMGUI_STB_TRUETYPE_FILENAME[m
[32m+[m[32m#else[m
[32m+[m[32m#include "imstb_truetype.h"[m
[32m+[m[32m#endif[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef __GNUC__[m
[32m+[m[32m#pragma GCC diagnostic pop[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef __clang__[m
[32m+[m[32m#pragma clang diagnostic pop[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef _MSC_VER[m
[32m+[m[32m#pragma warning (pop)[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef IMGUI_STB_NAMESPACE[m
[32m+[m[32m} // namespace ImStb[m
[32m+[m[32musing namespace IMGUI_STB_NAMESPACE;[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Style functions[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mvoid ImGui::StyleColorsDark(ImGuiStyle* dst)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();[m
[32m+[m[32m    ImVec4* colors = style->Colors;[m
[32m+[m
[32m+[m[32m    colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);[m
[32m+[m[32m    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);[m
[32m+[m[32m    colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);[m
[32m+[m[32m    colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);[m
[32m+[m[32m    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);[m
[32m+[m[32m    colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);[m
[32m+[m[32m    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);[m
[32m+[m[32m    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);[m
[32m+[m[32m    colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);[m
[32m+[m[32m    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);[m
[32m+[m[32m    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);[m
[32m+[m[32m    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);[m
[32m+[m[32m    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);[m
[32m+[m[32m    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];[m
[32m+[m[32m    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);[m
[32m+[m[32m    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.25f);[m
[32m+[m[32m    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);[m
[32m+[m[32m    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);[m
[32m+[m[32m    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);[m
[32m+[m[32m    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];[m
[32m+[m[32m    colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);[m
[32m+[m[32m    colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);[m
[32m+[m[32m    colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);[m
[32m+[m[32m    colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);[m
[32m+[m[32m    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);[m
[32m+[m[32m    colors[ImGuiCol_NavHighlight]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);[m
[32m+[m[32m    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);[m
[32m+[m[32m    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::StyleColorsClassic(ImGuiStyle* dst)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();[m
[32m+[m[32m    ImVec4* colors = style->Colors;[m
[32m+[m
[32m+[m[32m    colors[ImGuiCol_Text]                   = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_WindowBg]               = ImVec4(0.00f, 0.00f, 0.00f, 0.70f);[m
[32m+[m[32m    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);[m
[32m+[m[32m    colors[ImGuiCol_PopupBg]                = ImVec4(0.11f, 0.11f, 0.14f, 0.92f);[m
[32m+[m[32m    colors[ImGuiCol_Border]                 = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);[m
[32m+[m[32m    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);[m
[32m+[m[32m    colors[ImGuiCol_FrameBg]                = ImVec4(0.43f, 0.43f, 0.43f, 0.39f);[m
[32m+[m[32m    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.47f, 0.47f, 0.69f, 0.40f);[m
[32m+[m[32m    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.42f, 0.41f, 0.64f, 0.69f);[m
[32m+[m[32m    colors[ImGuiCol_TitleBg]                = ImVec4(0.27f, 0.27f, 0.54f, 0.83f);[m
[32m+[m[32m    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.32f, 0.32f, 0.63f, 0.87f);[m
[32m+[m[32m    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.40f, 0.40f, 0.80f, 0.20f);[m
[32m+[m[32m    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.40f, 0.40f, 0.55f, 0.80f);[m
[32m+[m[32m    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.20f, 0.25f, 0.30f, 0.60f);[m
[32m+[m[32m    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.40f, 0.40f, 0.80f, 0.30f);[m
[32m+[m[32m    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.40f, 0.40f, 0.80f, 0.40f);[m
[32m+[m[32m    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);[m
[32m+[m[32m    colors[ImGuiCol_CheckMark]              = ImVec4(0.90f, 0.90f, 0.90f, 0.50f);[m
[32m+[m[32m    colors[ImGuiCol_SliderGrab]             = ImVec4(1.00f, 1.00f, 1.00f, 0.30f);[m
[32m+[m[32m    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);[m
[32m+[m[32m    colors[ImGuiCol_Button]                 = ImVec4(0.35f, 0.40f, 0.61f, 0.62f);[m
[32m+[m[32m    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.40f, 0.48f, 0.71f, 0.79f);[m
[32m+[m[32m    colors[ImGuiCol_ButtonActive]           = ImVec4(0.46f, 0.54f, 0.80f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_Header]                 = ImVec4(0.40f, 0.40f, 0.90f, 0.45f);[m
[32m+[m[32m    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.45f, 0.45f, 0.90f, 0.80f);[m
[32m+[m[32m    colors[ImGuiCol_HeaderActive]           = ImVec4(0.53f, 0.53f, 0.87f, 0.80f);[m
[32m+[m[32m    colors[ImGuiCol_Separator]              = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.60f, 0.60f, 0.70f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.70f, 0.70f, 0.90f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_ResizeGrip]             = ImVec4(1.00f, 1.00f, 1.00f, 0.16f);[m
[32m+[m[32m    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.78f, 0.82f, 1.00f, 0.60f);[m
[32m+[m[32m    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.78f, 0.82f, 1.00f, 0.90f);[m
[32m+[m[32m    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);[m
[32m+[m[32m    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];[m
[32m+[m[32m    colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);[m
[32m+[m[32m    colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);[m
[32m+[m[32m    colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);[m
[32m+[m[32m    colors[ImGuiCol_PlotLines]              = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.00f, 0.00f, 1.00f, 0.35f);[m
[32m+[m[32m    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);[m
[32m+[m[32m    colors[ImGuiCol_NavHighlight]           = colors[ImGuiCol_HeaderHovered];[m
[32m+[m[32m    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);[m
[32m+[m[32m    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);[m
[32m+[m[32m    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Those light colors are better suited with a thicker font than the default one + FrameBorder[m
[32m+[m[32mvoid ImGui::StyleColorsLight(ImGuiStyle* dst)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();[m
[32m+[m[32m    ImVec4* colors = style->Colors;[m
[32m+[m
[32m+[m[32m    colors[ImGuiCol_Text]                   = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_WindowBg]               = ImVec4(0.94f, 0.94f, 0.94f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);[m
[32m+[m[32m    colors[ImGuiCol_PopupBg]                = ImVec4(1.00f, 1.00f, 1.00f, 0.98f);[m
[32m+[m[32m    colors[ImGuiCol_Border]                 = ImVec4(0.00f, 0.00f, 0.00f, 0.30f);[m
[32m+[m[32m    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);[m
[32m+[m[32m    colors[ImGuiCol_FrameBg]                = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);[m
[32m+[m[32m    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);[m
[32m+[m[32m    colors[ImGuiCol_TitleBg]                = ImVec4(0.96f, 0.96f, 0.96f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.82f, 0.82f, 0.82f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(1.00f, 1.00f, 1.00f, 0.51f);[m
[32m+[m[32m    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.86f, 0.86f, 0.86f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.98f, 0.98f, 0.98f, 0.53f);[m
[32m+[m[32m    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.69f, 0.69f, 0.69f, 0.80f);[m
[32m+[m[32m    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.49f, 0.49f, 0.49f, 0.80f);[m
[32m+[m[32m    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.49f, 0.49f, 0.49f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_SliderGrab]             = ImVec4(0.26f, 0.59f, 0.98f, 0.78f);[m
[32m+[m[32m    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.46f, 0.54f, 0.80f, 0.60f);[m
[32m+[m[32m    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);[m
[32m+[m[32m    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);[m
[32m+[m[32m    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);[m
[32m+[m[32m    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_Separator]              = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.14f, 0.44f, 0.80f, 0.78f);[m
[32m+[m[32m    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.14f, 0.44f, 0.80f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.80f, 0.80f, 0.80f, 0.56f);[m
[32m+[m[32m    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);[m
[32m+[m[32m    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);[m
[32m+[m[32m    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.90f);[m
[32m+[m[32m    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];[m
[32m+[m[32m    colors[ImGuiCol_TabActive]              = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);[m
[32m+[m[32m    colors[ImGuiCol_TabUnfocused]           = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);[m
[32m+[m[32m    colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(colors[ImGuiCol_TabActive],    colors[ImGuiCol_TitleBg], 0.40f);[m
[32m+[m[32m    colors[ImGuiCol_PlotLines]              = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.45f, 0.00f, 1.00f);[m
[32m+[m[32m    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);[m
[32m+[m[32m    colors[ImGuiCol_DragDropTarget]         = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);[m
[32m+[m[32m    colors[ImGuiCol_NavHighlight]           = colors[ImGuiCol_HeaderHovered];[m
[32m+[m[32m    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(0.70f, 0.70f, 0.70f, 0.70f);[m
[32m+[m[32m    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.20f, 0.20f, 0.20f, 0.20f);[m
[32m+[m[32m    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// ImDrawList[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mImDrawListSharedData::ImDrawListSharedData()[m
[32m+[m[32m{[m
[32m+[m[32m    Font = NULL;[m
[32m+[m[32m    FontSize = 0.0f;[m
[32m+[m[32m    CurveTessellationTol = 0.0f;[m
[32m+[m[32m    ClipRectFullscreen = ImVec4(-8192.0f, -8192.0f, +8192.0f, +8192.0f);[m
[32m+[m
[32m+[m[32m    // Const data[m
[32m+[m[32m    for (int i = 0; i < IM_ARRAYSIZE(CircleVtx12); i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(CircleVtx12);[m
[32m+[m[32m        CircleVtx12[i] = ImVec2(ImCos(a), ImSin(a));[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::Clear()[m
[32m+[m[32m{[m
[32m+[m[32m    CmdBuffer.resize(0);[m
[32m+[m[32m    IdxBuffer.resize(0);[m
[32m+[m[32m    VtxBuffer.resize(0);[m
[32m+[m[32m    Flags = ImDrawListFlags_AntiAliasedLines | ImDrawListFlags_AntiAliasedFill;[m
[32m+[m[32m    _VtxCurrentIdx = 0;[m
[32m+[m[32m    _VtxWritePtr = NULL;[m
[32m+[m[32m    _IdxWritePtr = NULL;[m
[32m+[m[32m    _ClipRectStack.resize(0);[m
[32m+[m[32m    _TextureIdStack.resize(0);[m
[32m+[m[32m    _Path.resize(0);[m
[32m+[m[32m    _ChannelsCurrent = 0;[m
[32m+[m[32m    _ChannelsCount = 1;[m
[32m+[m[32m    // NB: Do not clear channels so our allocations are re-used after the first frame.[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::ClearFreeMemory()[m
[32m+[m[32m{[m
[32m+[m[32m    CmdBuffer.clear();[m
[32m+[m[32m    IdxBuffer.clear();[m
[32m+[m[32m    VtxBuffer.clear();[m
[32m+[m[32m    _VtxCurrentIdx = 0;[m
[32m+[m[32m    _VtxWritePtr = NULL;[m
[32m+[m[32m    _IdxWritePtr = NULL;[m
[32m+[m[32m    _ClipRectStack.clear();[m
[32m+[m[32m    _TextureIdStack.clear();[m
[32m+[m[32m    _Path.clear();[m
[32m+[m[32m    _ChannelsCurrent = 0;[m
[32m+[m[32m    _ChannelsCount = 1;[m
[32m+[m[32m    for (int i = 0; i < _Channels.Size; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (i == 0) memset(&_Channels[0], 0, sizeof(_Channels[0]));  // channel 0 is a copy of CmdBuffer/IdxBuffer, don't destruct again[m
[32m+[m[32m        _Channels[i].CmdBuffer.clear();[m
[32m+[m[32m        _Channels[i].IdxBuffer.clear();[m
[32m+[m[32m    }[m
[32m+[m[32m    _Channels.clear();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImDrawList* ImDrawList::CloneOutput() const[m
[32m+[m[32m{[m
[32m+[m[32m    ImDrawList* dst = IM_NEW(ImDrawList(NULL));[m
[32m+[m[32m    dst->CmdBuffer = CmdBuffer;[m
[32m+[m[32m    dst->IdxBuffer = IdxBuffer;[m
[32m+[m[32m    dst->VtxBuffer = VtxBuffer;[m
[32m+[m[32m    dst->Flags = Flags;[m
[32m+[m[32m    return dst;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Using macros because C++ is a terrible language, we want guaranteed inline, no code in header, and no overhead in Debug builds[m
[32m+[m[32m#define GetCurrentClipRect()    (_ClipRectStack.Size ? _ClipRectStack.Data[_ClipRectStack.Size-1]  : _Data->ClipRectFullscreen)[m
[32m+[m[32m#define GetCurrentTextureId()   (_TextureIdStack.Size ? _TextureIdStack.Data[_TextureIdStack.Size-1] : (ImTextureID)NULL)[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddDrawCmd()[m
[32m+[m[32m{[m
[32m+[m[32m    ImDrawCmd draw_cmd;[m
[32m+[m[32m    draw_cmd.ClipRect = GetCurrentClipRect();[m
[32m+[m[32m    draw_cmd.TextureId = GetCurrentTextureId();[m
[32m+[m
[32m+[m[32m    IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);[m
[32m+[m[32m    CmdBuffer.push_back(draw_cmd);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddCallback(ImDrawCallback callback, void* callback_data)[m
[32m+[m[32m{[m
[32m+[m[32m    ImDrawCmd* current_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;[m
[32m+[m[32m    if (!current_cmd || current_cmd->ElemCount != 0 || current_cmd->UserCallback != NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        AddDrawCmd();[m
[32m+[m[32m        current_cmd = &CmdBuffer.back();[m
[32m+[m[32m    }[m
[32m+[m[32m    current_cmd->UserCallback = callback;[m
[32m+[m[32m    current_cmd->UserCallbackData = callback_data;[m
[32m+[m
[32m+[m[32m    AddDrawCmd(); // Force a new command after us (see comment below)[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Our scheme may appears a bit unusual, basically we want the most-common calls AddLine AddRect etc. to not have to perform any check so we always have a command ready in the stack.[m
[32m+[m[32m// The cost of figuring out if a new command has to be added or if we can merge is paid in those Update** functions only.[m
[32m+[m[32mvoid ImDrawList::UpdateClipRect()[m
[32m+[m[32m{[m
[32m+[m[32m    // If current command is used with different settings we need to add a new command[m
[32m+[m[32m    const ImVec4 curr_clip_rect = GetCurrentClipRect();[m
[32m+[m[32m    ImDrawCmd* curr_cmd = CmdBuffer.Size > 0 ? &CmdBuffer.Data[CmdBuffer.Size-1] : NULL;[m
[32m+[m[32m    if (!curr_cmd || (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) != 0) || curr_cmd->UserCallback != NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        AddDrawCmd();[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Try to merge with previous command if it matches, else use current command[m
[32m+[m[32m    ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;[m
[32m+[m[32m    if (curr_cmd->ElemCount == 0 && prev_cmd && memcmp(&prev_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) == 0 && prev_cmd->TextureId == GetCurrentTextureId() && prev_cmd->UserCallback == NULL)[m
[32m+[m[32m        CmdBuffer.pop_back();[m
[32m+[m[32m    else[m
[32m+[m[32m        curr_cmd->ClipRect = curr_clip_rect;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::UpdateTextureID()[m
[32m+[m[32m{[m
[32m+[m[32m    // If current command is used with different settings we need to add a new command[m
[32m+[m[32m    const ImTextureID curr_texture_id = GetCurrentTextureId();[m
[32m+[m[32m    ImDrawCmd* curr_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;[m
[32m+[m[32m    if (!curr_cmd || (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != curr_texture_id) || curr_cmd->UserCallback != NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        AddDrawCmd();[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Try to merge with previous command if it matches, else use current command[m
[32m+[m[32m    ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;[m
[32m+[m[32m    if (curr_cmd->ElemCount == 0 && prev_cmd && prev_cmd->TextureId == curr_texture_id && memcmp(&prev_cmd->ClipRect, &GetCurrentClipRect(), sizeof(ImVec4)) == 0 && prev_cmd->UserCallback == NULL)[m
[32m+[m[32m        CmdBuffer.pop_back();[m
[32m+[m[32m    else[m
[32m+[m[32m        curr_cmd->TextureId = curr_texture_id;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#undef GetCurrentClipRect[m
[32m+[m[32m#undef GetCurrentTextureId[m
[32m+[m
[32m+[m[32m// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)[m
[32m+[m[32mvoid ImDrawList::PushClipRect(ImVec2 cr_min, ImVec2 cr_max, bool intersect_with_current_clip_rect)[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);[m
[32m+[m[32m    if (intersect_with_current_clip_rect && _ClipRectStack.Size)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImVec4 current = _ClipRectStack.Data[_ClipRectStack.Size-1];[m
[32m+[m[32m        if (cr.x < current.x) cr.x = current.x;[m
[32m+[m[32m        if (cr.y < current.y) cr.y = current.y;[m
[32m+[m[32m        if (cr.z > current.z) cr.z = current.z;[m
[32m+[m[32m        if (cr.w > current.w) cr.w = current.w;[m
[32m+[m[32m    }[m
[32m+[m[32m    cr.z = ImMax(cr.x, cr.z);[m
[32m+[m[32m    cr.w = ImMax(cr.y, cr.w);[m
[32m+[m
[32m+[m[32m    _ClipRectStack.push_back(cr);[m
[32m+[m[32m    UpdateClipRect();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::PushClipRectFullScreen()[m
[32m+[m[32m{[m
[32m+[m[32m    PushClipRect(ImVec2(_Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y), ImVec2(_Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::PopClipRect()[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(_ClipRectStack.Size > 0);[m
[32m+[m[32m    _ClipRectStack.pop_back();[m
[32m+[m[32m    UpdateClipRect();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::PushTextureID(ImTextureID texture_id)[m
[32m+[m[32m{[m
[32m+[m[32m    _TextureIdStack.push_back(texture_id);[m
[32m+[m[32m    UpdateTextureID();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::PopTextureID()[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(_TextureIdStack.Size > 0);[m
[32m+[m[32m    _TextureIdStack.pop_back();[m
[32m+[m[32m    UpdateTextureID();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::ChannelsSplit(int channels_count)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(_ChannelsCurrent == 0 && _ChannelsCount == 1);[m
[32m+[m[32m    int old_channels_count = _Channels.Size;[m
[32m+[m[32m    if (old_channels_count < channels_count)[m
[32m+[m[32m        _Channels.resize(channels_count);[m
[32m+[m[32m    _ChannelsCount = channels_count;[m
[32m+[m
[32m+[m[32m    // _Channels[] (24/32 bytes each) hold storage that we'll swap with this->_CmdBuffer/_IdxBuffer[m
[32m+[m[32m    // The content of _Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.[m
[32m+[m[32m    // When we switch to the next channel, we'll copy _CmdBuffer/_IdxBuffer into _Channels[0] and then _Channels[1] into _CmdBuffer/_IdxBuffer[m
[32m+[m[32m    memset(&_Channels[0], 0, sizeof(ImDrawChannel));[m
[32m+[m[32m    for (int i = 1; i < channels_count; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (i >= old_channels_count)[m
[32m+[m[32m        {[m
[32m+[m[32m            IM_PLACEMENT_NEW(&_Channels[i]) ImDrawChannel();[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            _Channels[i].CmdBuffer.resize(0);[m
[32m+[m[32m            _Channels[i].IdxBuffer.resize(0);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (_Channels[i].CmdBuffer.Size == 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImDrawCmd draw_cmd;[m
[32m+[m[32m            draw_cmd.ClipRect = _ClipRectStack.back();[m
[32m+[m[32m            draw_cmd.TextureId = _TextureIdStack.back();[m
[32m+[m[32m            _Channels[i].CmdBuffer.push_back(draw_cmd);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::ChannelsMerge()[m
[32m+[m[32m{[m
[32m+[m[32m    // Note that we never use or rely on channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.[m
[32m+[m[32m    if (_ChannelsCount <= 1)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ChannelsSetCurrent(0);[m
[32m+[m[32m    if (CmdBuffer.Size && CmdBuffer.back().ElemCount == 0)[m
[32m+[m[32m        CmdBuffer.pop_back();[m
[32m+[m
[32m+[m[32m    int new_cmd_buffer_count = 0, new_idx_buffer_count = 0;[m
[32m+[m[32m    for (int i = 1; i < _ChannelsCount; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImDrawChannel& ch = _Channels[i];[m
[32m+[m[32m        if (ch.CmdBuffer.Size && ch.CmdBuffer.back().ElemCount == 0)[m
[32m+[m[32m            ch.CmdBuffer.pop_back();[m
[32m+[m[32m        new_cmd_buffer_count += ch.CmdBuffer.Size;[m
[32m+[m[32m        new_idx_buffer_count += ch.IdxBuffer.Size;[m
[32m+[m[32m    }[m
[32m+[m[32m    CmdBuffer.resize(CmdBuffer.Size + new_cmd_buffer_count);[m
[32m+[m[32m    IdxBuffer.resize(IdxBuffer.Size + new_idx_buffer_count);[m
[32m+[m
[32m+[m[32m    ImDrawCmd* cmd_write = CmdBuffer.Data + CmdBuffer.Size - new_cmd_buffer_count;[m
[32m+[m[32m    _IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size - new_idx_buffer_count;[m
[32m+[m[32m    for (int i = 1; i < _ChannelsCount; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImDrawChannel& ch = _Channels[i];[m
[32m+[m[32m        if (int sz = ch.CmdBuffer.Size) { memcpy(cmd_write, ch.CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }[m
[32m+[m[32m        if (int sz = ch.IdxBuffer.Size) { memcpy(_IdxWritePtr, ch.IdxBuffer.Data, sz * sizeof(ImDrawIdx)); _IdxWritePtr += sz; }[m
[32m+[m[32m    }[m
[32m+[m[32m    UpdateClipRect(); // We call this instead of AddDrawCmd(), so that empty channels won't produce an extra draw call.[m
[32m+[m[32m    _ChannelsCount = 1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::ChannelsSetCurrent(int idx)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(idx < _ChannelsCount);[m
[32m+[m[32m    if (_ChannelsCurrent == idx) return;[m
[32m+[m[32m    memcpy(&_Channels.Data[_ChannelsCurrent].CmdBuffer, &CmdBuffer, sizeof(CmdBuffer)); // copy 12 bytes, four times[m
[32m+[m[32m    memcpy(&_Channels.Data[_ChannelsCurrent].IdxBuffer, &IdxBuffer, sizeof(IdxBuffer));[m
[32m+[m[32m    _ChannelsCurrent = idx;[m
[32m+[m[32m    memcpy(&CmdBuffer, &_Channels.Data[_ChannelsCurrent].CmdBuffer, sizeof(CmdBuffer));[m
[32m+[m[32m    memcpy(&IdxBuffer, &_Channels.Data[_ChannelsCurrent].IdxBuffer, sizeof(IdxBuffer));[m
[32m+[m[32m    _IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// NB: this can be called with negative count for removing primitives (as long as the result does not underflow)[m
[32m+[m[32mvoid ImDrawList::PrimReserve(int idx_count, int vtx_count)[m
[32m+[m[32m{[m
[32m+[m[32m    ImDrawCmd& draw_cmd = CmdBuffer.Data[CmdBuffer.Size-1];[m
[32m+[m[32m    draw_cmd.ElemCount += idx_count;[m
[32m+[m
[32m+[m[32m    int vtx_buffer_old_size = VtxBuffer.Size;[m
[32m+[m[32m    VtxBuffer.resize(vtx_buffer_old_size + vtx_count);[m
[32m+[m[32m    _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;[m
[32m+[m
[32m+[m[32m    int idx_buffer_old_size = IdxBuffer.Size;[m
[32m+[m[32m    IdxBuffer.resize(idx_buffer_old_size + idx_count);[m
[32m+[m[32m    _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Fully unrolled with inline call to keep our debug builds decently fast.[m
[32m+[m[32mvoid ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);[m
[32m+[m[32m    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;[m
[32m+[m[32m    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);[m
[32m+[m[32m    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);[m
[32m+[m[32m    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;[m
[32m+[m[32m    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;[m
[32m+[m[32m    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;[m
[32m+[m[32m    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;[m
[32m+[m[32m    _VtxWritePtr += 4;[m
[32m+[m[32m    _VtxCurrentIdx += 4;[m
[32m+[m[32m    _IdxWritePtr += 6;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);[m
[32m+[m[32m    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;[m
[32m+[m[32m    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);[m
[32m+[m[32m    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);[m
[32m+[m[32m    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;[m
[32m+[m[32m    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;[m
[32m+[m[32m    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;[m
[32m+[m[32m    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;[m
[32m+[m[32m    _VtxWritePtr += 4;[m
[32m+[m[32m    _VtxCurrentIdx += 4;[m
[32m+[m[32m    _IdxWritePtr += 6;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)[m
[32m+[m[32m{[m
[32m+[m[32m    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;[m
[32m+[m[32m    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);[m
[32m+[m[32m    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);[m
[32m+[m[32m    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;[m
[32m+[m[32m    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;[m
[32m+[m[32m    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;[m
[32m+[m[32m    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;[m
[32m+[m[32m    _VtxWritePtr += 4;[m
[32m+[m[32m    _VtxCurrentIdx += 4;[m
[32m+[m[32m    _IdxWritePtr += 6;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// On AddPolyline() and AddConvexPolyFilled() we intentionally avoid using ImVec2 and superflous function calls to optimize debug/non-inlined builds.[m
[32m+[m[32m// Those macros expects l-values.[m
[32m+[m[32m#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = 1.0f / ImSqrt(d2); VX *= inv_len; VY *= inv_len; } }[m
[32m+[m[32m#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 < 0.5f) d2 = 0.5f; float inv_lensq = 1.0f / d2; VX *= inv_lensq; VY *= inv_lensq; }[m
[32m+[m
[32m+[m[32m// TODO: Thickness anti-aliased lines cap are missing their AA fringe.[m
[32m+[m[32m// We avoid using the ImVec2 math operators here to reduce cost to a minimum for debug/non-inlined builds.[m
[32m+[m[32mvoid ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness)[m
[32m+[m[32m{[m
[32m+[m[32m    if (points_count < 2)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    const ImVec2 uv = _Data->TexUvWhitePixel;[m
[32m+[m
[32m+[m[32m    int count = points_count;[m
[32m+[m[32m    if (!closed)[m
[32m+[m[32m        count = points_count-1;[m
[32m+[m
[32m+[m[32m    const bool thick_line = thickness > 1.0f;[m
[32m+[m[32m    if (Flags & ImDrawListFlags_AntiAliasedLines)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Anti-aliased stroke[m
[32m+[m[32m        const float AA_SIZE = 1.0f;[m
[32m+[m[32m        const ImU32 col_trans = col & ~IM_COL32_A_MASK;[m
[32m+[m
[32m+[m[32m        const int idx_count = thick_line ? count*18 : count*12;[m
[32m+[m[32m        const int vtx_count = thick_line ? points_count*4 : points_count*3;[m
[32m+[m[32m        PrimReserve(idx_count, vtx_count);[m
[32m+[m
[32m+[m[32m        // Temporary buffer[m
[32m+[m[32m        ImVec2* temp_normals = (ImVec2*)alloca(points_count * (thick_line ? 5 : 3) * sizeof(ImVec2)); //-V630[m
[32m+[m[32m        ImVec2* temp_points = temp_normals + points_count;[m
[32m+[m
[32m+[m[32m        for (int i1 = 0; i1 < count; i1++)[m
[32m+[m[32m        {[m
[32m+[m[32m            const int i2 = (i1+1) == points_count ? 0 : i1+1;[m
[32m+[m[32m            float dx = points[i2].x - points[i1].x;[m
[32m+[m[32m            float dy = points[i2].y - points[i1].y;[m
[32m+[m[32m            IM_NORMALIZE2F_OVER_ZERO(dx, dy);[m
[32m+[m[32m            temp_normals[i1].x = dy;[m
[32m+[m[32m            temp_normals[i1].y = -dx;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!closed)[m
[32m+[m[32m            temp_normals[points_count-1] = temp_normals[points_count-2];[m
[32m+[m
[32m+[m[32m        if (!thick_line)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (!closed)[m
[32m+[m[32m            {[m
[32m+[m[32m                temp_points[0] = points[0] + temp_normals[0] * AA_SIZE;[m
[32m+[m[32m                temp_points[1] = points[0] - temp_normals[0] * AA_SIZE;[m
[32m+[m[32m                temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * AA_SIZE;[m
[32m+[m[32m                temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * AA_SIZE;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.[m
[32m+[m[32m            unsigned int idx1 = _VtxCurrentIdx;[m
[32m+[m[32m            for (int i1 = 0; i1 < count; i1++)[m
[32m+[m[32m            {[m
[32m+[m[32m                const int i2 = (i1+1) == points_count ? 0 : i1+1;[m
[32m+[m[32m                unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+3;[m
[32m+[m
[32m+[m[32m                // Average normals[m
[32m+[m[32m                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;[m
[32m+[m[32m                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;[m
[32m+[m[32m                IM_FIXNORMAL2F(dm_x, dm_y)[m
[32m+[m[32m                dm_x *= AA_SIZE;[m
[32m+[m[32m                dm_y *= AA_SIZE;[m
[32m+[m
[32m+[m[32m                // Add temporary vertexes[m
[32m+[m[32m                ImVec2* out_vtx = &temp_points[i2*2];[m
[32m+[m[32m                out_vtx[0].x = points[i2].x + dm_x;[m
[32m+[m[32m                out_vtx[0].y = points[i2].y + dm_y;[m
[32m+[m[32m                out_vtx[1].x = points[i2].x - dm_x;[m
[32m+[m[32m                out_vtx[1].y = points[i2].y - dm_y;[m
[32m+[m
[32m+[m[32m                // Add indexes[m
[32m+[m[32m                _IdxWritePtr[0] = (ImDrawIdx)(idx2+0); _IdxWritePtr[1] = (ImDrawIdx)(idx1+0); _IdxWritePtr[2] = (ImDrawIdx)(idx1+2);[m
[32m+[m[32m                _IdxWritePtr[3] = (ImDrawIdx)(idx1+2); _IdxWritePtr[4] = (ImDrawIdx)(idx2+2); _IdxWritePtr[5] = (ImDrawIdx)(idx2+0);[m
[32m+[m[32m                _IdxWritePtr[6] = (ImDrawIdx)(idx2+1); _IdxWritePtr[7] = (ImDrawIdx)(idx1+1); _IdxWritePtr[8] = (ImDrawIdx)(idx1+0);[m
[32m+[m[32m                _IdxWritePtr[9] = (ImDrawIdx)(idx1+0); _IdxWritePtr[10]= (ImDrawIdx)(idx2+0); _IdxWritePtr[11]= (ImDrawIdx)(idx2+1);[m
[32m+[m[32m                _IdxWritePtr += 12;[m
[32m+[m
[32m+[m[32m                idx1 = idx2;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Add vertexes[m
[32m+[m[32m            for (int i = 0; i < points_count; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                _VtxWritePtr[0].pos = points[i];          _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;[m
[32m+[m[32m                _VtxWritePtr[1].pos = temp_points[i*2+0]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;[m
[32m+[m[32m                _VtxWritePtr[2].pos = temp_points[i*2+1]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col_trans;[m
[32m+[m[32m                _VtxWritePtr += 3;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;[m
[32m+[m[32m            if (!closed)[m
[32m+[m[32m            {[m
[32m+[m[32m                temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);[m
[32m+[m[32m                temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);[m
[32m+[m[32m                temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);[m
[32m+[m[32m                temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);[m
[32m+[m[32m                temp_points[(points_count-1)*4+0] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);[m
[32m+[m[32m                temp_points[(points_count-1)*4+1] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness);[m
[32m+[m[32m                temp_points[(points_count-1)*4+2] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness);[m
[32m+[m[32m                temp_points[(points_count-1)*4+3] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.[m
[32m+[m[32m            unsigned int idx1 = _VtxCurrentIdx;[m
[32m+[m[32m            for (int i1 = 0; i1 < count; i1++)[m
[32m+[m[32m            {[m
[32m+[m[32m                const int i2 = (i1+1) == points_count ? 0 : i1+1;[m
[32m+[m[32m                unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+4;[m
[32m+[m
[32m+[m[32m                // Average normals[m
[32m+[m[32m                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;[m
[32m+[m[32m                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;[m
[32m+[m[32m                IM_FIXNORMAL2F(dm_x, dm_y);[m
[32m+[m[32m                float dm_out_x = dm_x * (half_inner_thickness + AA_SIZE);[m
[32m+[m[32m                float dm_out_y = dm_y * (half_inner_thickness + AA_SIZE);[m
[32m+[m[32m                float dm_in_x = dm_x * half_inner_thickness;[m
[32m+[m[32m                float dm_in_y = dm_y * half_inner_thickness;[m
[32m+[m
[32m+[m[32m                // Add temporary vertexes[m
[32m+[m[32m                ImVec2* out_vtx = &temp_points[i2*4];[m
[32m+[m[32m                out_vtx[0].x = points[i2].x + dm_out_x;[m
[32m+[m[32m                out_vtx[0].y = points[i2].y + dm_out_y;[m
[32m+[m[32m                out_vtx[1].x = points[i2].x + dm_in_x;[m
[32m+[m[32m                out_vtx[1].y = points[i2].y + dm_in_y;[m
[32m+[m[32m                out_vtx[2].x = points[i2].x - dm_in_x;[m
[32m+[m[32m                out_vtx[2].y = points[i2].y - dm_in_y;[m
[32m+[m[32m                out_vtx[3].x = points[i2].x - dm_out_x;[m
[32m+[m[32m                out_vtx[3].y = points[i2].y - dm_out_y;[m
[32m+[m
[32m+[m[32m                // Add indexes[m
[32m+[m[32m                _IdxWritePtr[0]  = (ImDrawIdx)(idx2+1); _IdxWritePtr[1]  = (ImDrawIdx)(idx1+1); _IdxWritePtr[2]  = (ImDrawIdx)(idx1+2);[m
[32m+[m[32m                _IdxWritePtr[3]  = (ImDrawIdx)(idx1+2); _IdxWritePtr[4]  = (ImDrawIdx)(idx2+2); _IdxWritePtr[5]  = (ImDrawIdx)(idx2+1);[m
[32m+[m[32m                _IdxWritePtr[6]  = (ImDrawIdx)(idx2+1); _IdxWritePtr[7]  = (ImDrawIdx)(idx1+1); _IdxWritePtr[8]  = (ImDrawIdx)(idx1+0);[m
[32m+[m[32m                _IdxWritePtr[9]  = (ImDrawIdx)(idx1+0); _IdxWritePtr[10] = (ImDrawIdx)(idx2+0); _IdxWritePtr[11] = (ImDrawIdx)(idx2+1);[m
[32m+[m[32m                _IdxWritePtr[12] = (ImDrawIdx)(idx2+2); _IdxWritePtr[13] = (ImDrawIdx)(idx1+2); _IdxWritePtr[14] = (ImDrawIdx)(idx1+3);[m
[32m+[m[32m                _IdxWritePtr[15] = (ImDrawIdx)(idx1+3); _IdxWritePtr[16] = (ImDrawIdx)(idx2+3); _IdxWritePtr[17] = (ImDrawIdx)(idx2+2);[m
[32m+[m[32m                _IdxWritePtr += 18;[m
[32m+[m
[32m+[m[32m                idx1 = idx2;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Add vertexes[m
[32m+[m[32m            for (int i = 0; i < points_count; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                _VtxWritePtr[0].pos = temp_points[i*4+0]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col_trans;[m
[32m+[m[32m                _VtxWritePtr[1].pos = temp_points[i*4+1]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;[m
[32m+[m[32m                _VtxWritePtr[2].pos = temp_points[i*4+2]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;[m
[32m+[m[32m                _VtxWritePtr[3].pos = temp_points[i*4+3]; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col_trans;[m
[32m+[m[32m                _VtxWritePtr += 4;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        _VtxCurrentIdx += (ImDrawIdx)vtx_count;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // Non Anti-aliased Stroke[m
[32m+[m[32m        const int idx_count = count*6;[m
[32m+[m[32m        const int vtx_count = count*4;      // FIXME-OPT: Not sharing edges[m
[32m+[m[32m        PrimReserve(idx_count, vtx_count);[m
[32m+[m
[32m+[m[32m        for (int i1 = 0; i1 < count; i1++)[m
[32m+[m[32m        {[m
[32m+[m[32m            const int i2 = (i1+1) == points_count ? 0 : i1+1;[m
[32m+[m[32m            const ImVec2& p1 = points[i1];[m
[32m+[m[32m            const ImVec2& p2 = points[i2];[m
[32m+[m
[32m+[m[32m            float dx = p2.x - p1.x;[m
[32m+[m[32m            float dy = p2.y - p1.y;[m
[32m+[m[32m            IM_NORMALIZE2F_OVER_ZERO(dx, dy);[m
[32m+[m[32m            dx *= (thickness * 0.5f);[m
[32m+[m[32m            dy *= (thickness * 0.5f);[m
[32m+[m
[32m+[m[32m            _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;[m
[32m+[m[32m            _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;[m
[32m+[m[32m            _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;[m
[32m+[m[32m            _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;[m
[32m+[m[32m            _VtxWritePtr += 4;[m
[32m+[m
[32m+[m[32m            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx+1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx+2);[m
[32m+[m[32m            _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx+2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx+3);[m
[32m+[m[32m            _IdxWritePtr += 6;[m
[32m+[m[32m            _VtxCurrentIdx += 4;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// We intentionally avoid using ImVec2 and its math operators here to reduce cost to a minimum for debug/non-inlined builds.[m
[32m+[m[32mvoid ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col)[m
[32m+[m[32m{[m
[32m+[m[32m    if (points_count < 3)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    const ImVec2 uv = _Data->TexUvWhitePixel;[m
[32m+[m
[32m+[m[32m    if (Flags & ImDrawListFlags_AntiAliasedFill)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Anti-aliased Fill[m
[32m+[m[32m        const float AA_SIZE = 1.0f;[m
[32m+[m[32m        const ImU32 col_trans = col & ~IM_COL32_A_MASK;[m
[32m+[m[32m        const int idx_count = (points_count-2)*3 + points_count*6;[m
[32m+[m[32m        const int vtx_count = (points_count*2);[m
[32m+[m[32m        PrimReserve(idx_count, vtx_count);[m
[32m+[m
[32m+[m[32m        // Add indexes for fill[m
[32m+[m[32m        unsigned int vtx_inner_idx = _VtxCurrentIdx;[m
[32m+[m[32m        unsigned int vtx_outer_idx = _VtxCurrentIdx+1;[m
[32m+[m[32m        for (int i = 2; i < points_count; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx+((i-1)<<1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx+(i<<1));[m
[32m+[m[32m            _IdxWritePtr += 3;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Compute normals[m
[32m+[m[32m        ImVec2* temp_normals = (ImVec2*)alloca(points_count * sizeof(ImVec2)); //-V630[m
[32m+[m[32m        for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)[m
[32m+[m[32m        {[m
[32m+[m[32m            const ImVec2& p0 = points[i0];[m
[32m+[m[32m            const ImVec2& p1 = points[i1];[m
[32m+[m[32m            float dx = p1.x - p0.x;[m
[32m+[m[32m            float dy = p1.y - p0.y;[m
[32m+[m[32m            IM_NORMALIZE2F_OVER_ZERO(dx, dy);[m
[32m+[m[32m            temp_normals[i0].x = dy;[m
[32m+[m[32m            temp_normals[i0].y = -dx;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Average normals[m
[32m+[m[32m            const ImVec2& n0 = temp_normals[i0];[m
[32m+[m[32m            const ImVec2& n1 = temp_normals[i1];[m
[32m+[m[32m            float dm_x = (n0.x + n1.x) * 0.5f;[m
[32m+[m[32m            float dm_y = (n0.y + n1.y) * 0.5f;[m
[32m+[m[32m            IM_FIXNORMAL2F(dm_x, dm_y);[m
[32m+[m[32m            dm_x *= AA_SIZE * 0.5f;[m
[32m+[m[32m            dm_y *= AA_SIZE * 0.5f;[m
[32m+[m
[32m+[m[32m            // Add vertices[m
[32m+[m[32m            _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner[m
[32m+[m[32m            _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer[m
[32m+[m[32m            _VtxWritePtr += 2;[m
[32m+[m
[32m+[m[32m            // Add indexes for fringes[m
[32m+[m[32m            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx+(i1<<1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx+(i0<<1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx+(i0<<1));[m
[32m+[m[32m            _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx+(i0<<1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx+(i1<<1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx+(i1<<1));[m
[32m+[m[32m            _IdxWritePtr += 6;[m
[32m+[m[32m        }[m
[32m+[m[32m        _VtxCurrentIdx += (ImDrawIdx)vtx_count;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // Non Anti-aliased Fill[m
[32m+[m[32m        const int idx_count = (points_count-2)*3;[m
[32m+[m[32m        const int vtx_count = points_count;[m
[32m+[m[32m        PrimReserve(idx_count, vtx_count);[m
[32m+[m[32m        for (int i = 0; i < vtx_count; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;[m
[32m+[m[32m            _VtxWritePtr++;[m
[32m+[m[32m        }[m
[32m+[m[32m        for (int i = 2; i < points_count; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx+i-1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx+i);[m
[32m+[m[32m            _IdxWritePtr += 3;[m
[32m+[m[32m        }[m
[32m+[m[32m        _VtxCurrentIdx += (ImDrawIdx)vtx_count;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12)[m
[32m+[m[32m{[m
[32m+[m[32m    if (radius == 0.0f || a_min_of_12 > a_max_of_12)[m
[32m+[m[32m    {[m
[32m+[m[32m        _Path.push_back(centre);[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    _Path.reserve(_Path.Size + (a_max_of_12 - a_min_of_12 + 1));[m
[32m+[m[32m    for (int a = a_min_of_12; a <= a_max_of_12; a++)[m
[32m+[m[32m    {[m
[32m+[m[32m        const ImVec2& c = _Data->CircleVtx12[a % IM_ARRAYSIZE(_Data->CircleVtx12)];[m
[32m+[m[32m        _Path.push_back(ImVec2(centre.x + c.x * radius, centre.y + c.y * radius));[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments)[m
[32m+[m[32m{[m
[32m+[m[32m    if (radius == 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        _Path.push_back(centre);[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Note that we are adding a point at both a_min and a_max.[m
[32m+[m[32m    // If you are trying to draw a full closed circle you don't want the overlapping points![m
[32m+[m[32m    _Path.reserve(_Path.Size + (num_segments + 1));[m
[32m+[m[32m    for (int i = 0; i <= num_segments; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);[m
[32m+[m[32m        _Path.push_back(ImVec2(centre.x + ImCos(a) * radius, centre.y + ImSin(a) * radius));[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void PathBezierToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)[m
[32m+[m[32m{[m
[32m+[m[32m    float dx = x4 - x1;[m
[32m+[m[32m    float dy = y4 - y1;[m
[32m+[m[32m    float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);[m
[32m+[m[32m    float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);[m
[32m+[m[32m    d2 = (d2 >= 0) ? d2 : -d2;[m
[32m+[m[32m    d3 = (d3 >= 0) ? d3 : -d3;[m
[32m+[m[32m    if ((d2+d3) * (d2+d3) < tess_tol * (dx*dx + dy*dy))[m
[32m+[m[32m    {[m
[32m+[m[32m        path->push_back(ImVec2(x4, y4));[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (level < 10)[m
[32m+[m[32m    {[m
[32m+[m[32m        float x12 = (x1+x2)*0.5f,       y12 = (y1+y2)*0.5f;[m
[32m+[m[32m        float x23 = (x2+x3)*0.5f,       y23 = (y2+y3)*0.5f;[m
[32m+[m[32m        float x34 = (x3+x4)*0.5f,       y34 = (y3+y4)*0.5f;[m
[32m+[m[32m        float x123 = (x12+x23)*0.5f,    y123 = (y12+y23)*0.5f;[m
[32m+[m[32m        float x234 = (x23+x34)*0.5f,    y234 = (y23+y34)*0.5f;[m
[32m+[m[32m        float x1234 = (x123+x234)*0.5f, y1234 = (y123+y234)*0.5f;[m
[32m+[m
[32m+[m[32m        PathBezierToCasteljau(path, x1,y1,        x12,y12,    x123,y123,  x1234,y1234, tess_tol, level+1);[m
[32m+[m[32m        PathBezierToCasteljau(path, x1234,y1234,  x234,y234,  x34,y34,    x4,y4,       tess_tol, level+1);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2 p1 = _Path.back();[m
[32m+[m[32m    if (num_segments == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Auto-tessellated[m
[32m+[m[32m        PathBezierToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        float t_step = 1.0f / (float)num_segments;[m
[32m+[m[32m        for (int i_step = 1; i_step <= num_segments; i_step++)[m
[32m+[m[32m        {[m
[32m+[m[32m            float t = t_step * i_step;[m
[32m+[m[32m            float u = 1.0f - t;[m
[32m+[m[32m            float w1 = u*u*u;[m
[32m+[m[32m            float w2 = 3*u*u*t;[m
[32m+[m[32m            float w3 = 3*u*t*t;[m
[32m+[m[32m            float w4 = t*t*t;[m
[32m+[m[32m            _Path.push_back(ImVec2(w1*p1.x + w2*p2.x + w3*p3.x + w4*p4.x, w1*p1.y + w2*p2.y + w3*p3.y + w4*p4.y));[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, int rounding_corners)[m
[32m+[m[32m{[m
[32m+[m[32m    rounding = ImMin(rounding, ImFabs(b.x - a.x) * ( ((rounding_corners & ImDrawCornerFlags_Top)  == ImDrawCornerFlags_Top)  || ((rounding_corners & ImDrawCornerFlags_Bot)   == ImDrawCornerFlags_Bot)   ? 0.5f : 1.0f ) - 1.0f);[m
[32m+[m[32m    rounding = ImMin(rounding, ImFabs(b.y - a.y) * ( ((rounding_corners & ImDrawCornerFlags_Left) == ImDrawCornerFlags_Left) || ((rounding_corners & ImDrawCornerFlags_Right) == ImDrawCornerFlags_Right) ? 0.5f : 1.0f ) - 1.0f);[m
[32m+[m
[32m+[m[32m    if (rounding <= 0.0f || rounding_corners == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        PathLineTo(a);[m
[32m+[m[32m        PathLineTo(ImVec2(b.x, a.y));[m
[32m+[m[32m        PathLineTo(b);[m
[32m+[m[32m        PathLineTo(ImVec2(a.x, b.y));[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        const float rounding_tl = (rounding_corners & ImDrawCornerFlags_TopLeft) ? rounding : 0.0f;[m
[32m+[m[32m        const float rounding_tr = (rounding_corners & ImDrawCornerFlags_TopRight) ? rounding : 0.0f;[m
[32m+[m[32m        const float rounding_br = (rounding_corners & ImDrawCornerFlags_BotRight) ? rounding : 0.0f;[m
[32m+[m[32m        const float rounding_bl = (rounding_corners & ImDrawCornerFlags_BotLeft) ? rounding : 0.0f;[m
[32m+[m[32m        PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);[m
[32m+[m[32m        PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);[m
[32m+[m[32m        PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);[m
[32m+[m[32m        PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)[m
[32m+[m[32m{[m
[32m+[m[32m    if ((col & IM_COL32_A_MASK) == 0)[m
[32m+[m[32m        return;[m
[32m+[m[32m    PathLineTo(a + ImVec2(0.5f,0.5f));[m
[32m+[m[32m    PathLineTo(b + ImVec2(0.5f,0.5f));[m
[32m+[m[32m    PathStroke(col, false, thickness);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// a: upper-left, b: lower-right. we don't render 1 px sized rectangles properly.[m
[32m+[m[32mvoid ImDrawList::AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags, float thickness)[m
[32m+[m[32m{[m
[32m+[m[32m    if ((col & IM_COL32_A_MASK) == 0)[m
[32m+[m[32m        return;[m
[32m+[m[32m    if (Flags & ImDrawListFlags_AntiAliasedLines)[m
[32m+[m[32m        PathRect(a + ImVec2(0.5f,0.5f), b - ImVec2(0.50f,0.50f), rounding, rounding_corners_flags);[m
[32m+[m[32m    else[m
[32m+[m[32m        PathRect(a + ImVec2(0.5f,0.5f), b - ImVec2(0.49f,0.49f), rounding, rounding_corners_flags); // Better looking lower-right corner and rounded non-AA shapes.[m
[32m+[m[32m    PathStroke(col, true, thickness);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags)[m
[32m+[m[32m{[m
[32m+[m[32m    if ((col & IM_COL32_A_MASK) == 0)[m
[32m+[m[32m        return;[m
[32m+[m[32m    if (rounding > 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        PathRect(a, b, rounding, rounding_corners_flags);[m
[32m+[m[32m        PathFillConvex(col);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        PrimReserve(6, 4);[m
[32m+[m[32m        PrimRect(a, b, col);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddRectFilledMultiColor(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)[m
[32m+[m[32m{[m
[32m+[m[32m    if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    const ImVec2 uv = _Data->TexUvWhitePixel;[m
[32m+[m[32m    PrimReserve(6, 4);[m
[32m+[m[32m    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+1)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2));[m
[32m+[m[32m    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+3));[m
[32m+[m[32m    PrimWriteVtx(a, uv, col_upr_left);[m
[32m+[m[32m    PrimWriteVtx(ImVec2(c.x, a.y), uv, col_upr_right);[m
[32m+[m[32m    PrimWriteVtx(c, uv, col_bot_right);[m
[32m+[m[32m    PrimWriteVtx(ImVec2(a.x, c.y), uv, col_bot_left);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness)[m
[32m+[m[32m{[m
[32m+[m[32m    if ((col & IM_COL32_A_MASK) == 0)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    PathLineTo(a);[m
[32m+[m[32m    PathLineTo(b);[m
[32m+[m[32m    PathLineTo(c);[m
[32m+[m[32m    PathLineTo(d);[m
[32m+[m[32m    PathStroke(col, true, thickness);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col)[m
[32m+[m[32m{[m
[32m+[m[32m    if ((col & IM_COL32_A_MASK) == 0)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    PathLineTo(a);[m
[32m+[m[32m    PathLineTo(b);[m
[32m+[m[32m    PathLineTo(c);[m
[32m+[m[32m    PathLineTo(d);[m
[32m+[m[32m    PathFillConvex(col);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness)[m
[32m+[m[32m{[m
[32m+[m[32m    if ((col & IM_COL32_A_MASK) == 0)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    PathLineTo(a);[m
[32m+[m[32m    PathLineTo(b);[m
[32m+[m[32m    PathLineTo(c);[m
[32m+[m[32m    PathStroke(col, true, thickness);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)[m
[32m+[m[32m{[m
[32m+[m[32m    if ((col & IM_COL32_A_MASK) == 0)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    PathLineTo(a);[m
[32m+[m[32m    PathLineTo(b);[m
[32m+[m[32m    PathLineTo(c);[m
[32m+[m[32m    PathFillConvex(col);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments, float thickness)[m
[32m+[m[32m{[m
[32m+[m[32m    if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // Because we are filling a closed shape we remove 1 from the count of segments/points[m
[32m+[m[32m    const float a_max = IM_PI*2.0f * ((float)num_segments - 1.0f) / (float)num_segments;[m
[32m+[m[32m    PathArcTo(centre, radius-0.5f, 0.0f, a_max, num_segments - 1);[m
[32m+[m[32m    PathStroke(col, true, thickness);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments)[m
[32m+[m[32m{[m
[32m+[m[32m    if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // Because we are filling a closed shape we remove 1 from the count of segments/points[m
[32m+[m[32m    const float a_max = IM_PI*2.0f * ((float)num_segments - 1.0f) / (float)num_segments;[m
[32m+[m[32m    PathArcTo(centre, radius, 0.0f, a_max, num_segments - 1);[m
[32m+[m[32m    PathFillConvex(col);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments)[m
[32m+[m[32m{[m
[32m+[m[32m    if ((col & IM_COL32_A_MASK) == 0)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    PathLineTo(pos0);[m
[32m+[m[32m    PathBezierCurveTo(cp0, cp1, pos1, num_segments);[m
[32m+[m[32m    PathStroke(col, false, thickness);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)[m
[32m+[m[32m{[m
[32m+[m[32m    if ((col & IM_COL32_A_MASK) == 0)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    if (text_end == NULL)[m
[32m+[m[32m        text_end = text_begin + strlen(text_begin);[m
[32m+[m[32m    if (text_begin == text_end)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // Pull default font/size from the shared ImDrawListSharedData instance[m
[32m+[m[32m    if (font == NULL)[m
[32m+[m[32m        font = _Data->Font;[m
[32m+[m[32m    if (font_size == 0.0f)[m
[32m+[m[32m        font_size = _Data->FontSize;[m
[32m+[m
[32m+[m[32m    IM_ASSERT(font->ContainerAtlas->TexID == _TextureIdStack.back());  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.[m
[32m+[m
[32m+[m[32m    ImVec4 clip_rect = _ClipRectStack.back();[m
[32m+[m[32m    if (cpu_fine_clip_rect)[m
[32m+[m[32m    {[m
[32m+[m[32m        clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);[m
[32m+[m[32m        clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);[m
[32m+[m[32m        clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);[m
[32m+[m[32m        clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);[m
[32m+[m[32m    }[m
[32m+[m[32m    font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)[m
[32m+[m[32m{[m
[32m+[m[32m    AddText(NULL, 0.0f, pos, col, text_begin, text_end);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col)[m
[32m+[m[32m{[m
[32m+[m[32m    if ((col & IM_COL32_A_MASK) == 0)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();[m
[32m+[m[32m    if (push_texture_id)[m
[32m+[m[32m        PushTextureID(user_texture_id);[m
[32m+[m
[32m+[m[32m    PrimReserve(6, 4);[m
[32m+[m[32m    PrimRectUV(a, b, uv_a, uv_b, col);[m
[32m+[m
[32m+[m[32m    if (push_texture_id)[m
[32m+[m[32m        PopTextureID();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)[m
[32m+[m[32m{[m
[32m+[m[32m    if ((col & IM_COL32_A_MASK) == 0)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();[m
[32m+[m[32m    if (push_texture_id)[m
[32m+[m[32m        PushTextureID(user_texture_id);[m
[32m+[m
[32m+[m[32m    PrimReserve(6, 4);[m
[32m+[m[32m    PrimQuadUV(a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);[m
[32m+[m
[32m+[m[32m    if (push_texture_id)[m
[32m+[m[32m        PopTextureID();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImDrawList::AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners)[m
[32m+[m[32m{[m
[32m+[m[32m    if ((col & IM_COL32_A_MASK) == 0)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    if (rounding <= 0.0f || (rounding_corners & ImDrawCornerFlags_All) == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        AddImage(user_texture_id, a, b, uv_a, uv_b, col);[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();[m
[32m+[m[32m    if (push_texture_id)[m
[32m+[m[32m        PushTextureID(user_texture_id);[m
[32m+[m
[32m+[m[32m    int vert_start_idx = VtxBuffer.Size;[m
[32m+[m[32m    PathRect(a, b, rounding, rounding_corners);[m
[32m+[m[32m    PathFillConvex(col);[m
[32m+[m[32m    int vert_end_idx = VtxBuffer.Size;[m
[32m+[m[32m    ImGui::ShadeVertsLinearUV(this, vert_start_idx, vert_end_idx, a, b, uv_a, uv_b, true);[m
[32m+[m
[32m+[m[32m    if (push_texture_id)[m
[32m+[m[32m        PopTextureID();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] ImDrawData[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering![m
[32m+[m[32mvoid ImDrawData::DeIndexAllBuffers()[m
[32m+[m[32m{[m
[32m+[m[32m    ImVector<ImDrawVert> new_vtx_buffer;[m
[32m+[m[32m    TotalVtxCount = TotalIdxCount = 0;[m
[32m+[m[32m    for (int i = 0; i < CmdListsCount; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImDrawList* cmd_list = CmdLists[i];[m
[32m+[m[32m        if (cmd_list->IdxBuffer.empty())[m
[32m+[m[32m            continue;[m
[32m+[m[32m        new_vtx_buffer.resize(cmd_list->IdxBuffer.Size);[m
[32m+[m[32m        for (int j = 0; j < cmd_list->IdxBuffer.Size; j++)[m
[32m+[m[32m            new_vtx_buffer[j] = cmd_list->VtxBuffer[cmd_list->IdxBuffer[j]];[m
[32m+[m[32m        cmd_list->VtxBuffer.swap(new_vtx_buffer);[m
[32m+[m[32m        cmd_list->IdxBuffer.resize(0);[m
[32m+[m[32m        TotalVtxCount += cmd_list->VtxBuffer.Size;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Helper to scale the ClipRect field of each ImDrawCmd.[m
[32m+[m[32m// Use if your final output buffer is at a different scale than draw_data->DisplaySize,[m
[32m+[m[32m// or if there is a difference between your window resolution and framebuffer resolution.[m
[32m+[m[32mvoid ImDrawData::ScaleClipRects(const ImVec2& fb_scale)[m
[32m+[m[32m{[m
[32m+[m[32m    for (int i = 0; i < CmdListsCount; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImDrawList* cmd_list = CmdLists[i];[m
[32m+[m[32m        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImDrawCmd* cmd = &cmd_list->CmdBuffer[cmd_i];[m
[32m+[m[32m            cmd->ClipRect = ImVec4(cmd->ClipRect.x * fb_scale.x, cmd->ClipRect.y * fb_scale.y, cmd->ClipRect.z * fb_scale.x, cmd->ClipRect.w * fb_scale.y);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Helpers ShadeVertsXXX functions[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Generic linear color gradient, write to RGB fields, leave A untouched.[m
[32m+[m[32mvoid ImGui::ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1)[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2 gradient_extent = gradient_p1 - gradient_p0;[m
[32m+[m[32m    float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);[m
[32m+[m[32m    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;[m
[32m+[m[32m    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;[m
[32m+[m[32m    for (ImDrawVert* vert = vert_start; vert < vert_end; vert++)[m
[32m+[m[32m    {[m
[32m+[m[32m        float d = ImDot(vert->pos - gradient_p0, gradient_extent);[m
[32m+[m[32m        float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);[m
[32m+[m[32m        int r = ImLerp((int)(col0 >> IM_COL32_R_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_R_SHIFT) & 0xFF, t);[m
[32m+[m[32m        int g = ImLerp((int)(col0 >> IM_COL32_G_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_G_SHIFT) & 0xFF, t);[m
[32m+[m[32m        int b = ImLerp((int)(col0 >> IM_COL32_B_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_B_SHIFT) & 0xFF, t);[m
[32m+[m[32m        vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Distribute UV over (a, b) rectangle[m
[32m+[m[32mvoid ImGui::ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp)[m
[32m+[m[32m{[m
[32m+[m[32m    const ImVec2 size = b - a;[m
[32m+[m[32m    const ImVec2 uv_size = uv_b - uv_a;[m
[32m+[m[32m    const ImVec2 scale = ImVec2([m
[32m+[m[32m        size.x != 0.0f ? (uv_size.x / size.x) : 0.0f,[m
[32m+[m[32m        size.y != 0.0f ? (uv_size.y / size.y) : 0.0f);[m
[32m+[m
[32m+[m[32m    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;[m
[32m+[m[32m    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;[m
[32m+[m[32m    if (clamp)[m
[32m+[m[32m    {[m
[32m+[m[32m        const ImVec2 min = ImMin(uv_a, uv_b);[m
[32m+[m[32m        const ImVec2 max = ImMax(uv_a, uv_b);[m
[32m+[m[32m        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)[m
[32m+[m[32m            vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)[m
[32m+[m[32m            vertex->uv = uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] ImFontConfig[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mImFontConfig::ImFontConfig()[m
[32m+[m[32m{[m
[32m+[m[32m    FontData = NULL;[m
[32m+[m[32m    FontDataSize = 0;[m
[32m+[m[32m    FontDataOwnedByAtlas = true;[m
[32m+[m[32m    FontNo = 0;[m
[32m+[m[32m    SizePixels = 0.0f;[m
[32m+[m[32m    OversampleH = 3; // FIXME: 2 may be a better default?[m
[32m+[m[32m    OversampleV = 1;[m
[32m+[m[32m    PixelSnapH = false;[m
[32m+[m[32m    GlyphExtraSpacing = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    GlyphOffset = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    GlyphRanges = NULL;[m
[32m+[m[32m    GlyphMinAdvanceX = 0.0f;[m
[32m+[m[32m    GlyphMaxAdvanceX = FLT_MAX;[m
[32m+[m[32m    MergeMode = false;[m
[32m+[m[32m    RasterizerFlags = 0x00;[m
[32m+[m[32m    RasterizerMultiply = 1.0f;[m
[32m+[m[32m    memset(Name, 0, sizeof(Name));[m
[32m+[m[32m    DstFont = NULL;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] ImFontAtlas[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// A work of art lies ahead! (. = white layer, X = black layer, others are blank)[m
[32m+[m[32m// The white texels on the top left are the ones we'll use everywhere in ImGui to render filled shapes.[m
[32m+[m[32mconst int FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF = 108;[m
[32m+[m[32mconst int FONT_ATLAS_DEFAULT_TEX_DATA_H      = 27;[m
[32m+[m[32mconst unsigned int FONT_ATLAS_DEFAULT_TEX_DATA_ID = 0x80000000;[m
[32m+[m[32mstatic const char FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * FONT_ATLAS_DEFAULT_TEX_DATA_H + 1] =[m
[32m+[m[32m{[m
[32m+[m[32m    "..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX-     XX          "[m
[32m+[m[32m    "..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X-    X..X         "[m
[32m+[m[32m    "---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X-    X..X         "[m
[32m+[m[32m    "X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X-    X..X         "[m
[32m+[m[32m    "XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X-    X..X         "[m
[32m+[m[32m    "X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X-    X..XXX       "[m
[32m+[m[32m    "X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX-    X..X..XXX    "[m
[32m+[m[32m    "X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      -    X..X..X..XX  "[m
[32m+[m[32m    "X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       -    X..X..X..X.X "[m
[32m+[m[32m    "X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        -XXX X..X..X..X..X"[m
[32m+[m[32m    "X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         -X..XX........X..X"[m
[32m+[m[32m    "X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          -X...X...........X"[m
[32m+[m[32m    "X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           - X..............X"[m
[32m+[m[32m    "X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            -  X.............X"[m
[32m+[m[32m    "X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           -  X.............X"[m
[32m+[m[32m    "X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          -   X............X"[m
[32m+[m[32m    "X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          -   X...........X "[m
[32m+[m[32m    "X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       -------------------------------------    X..........X "[m
[32m+[m[32m    "X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           -    X..........X "[m
[32m+[m[32m    "XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           -     X........X  "[m
[32m+[m[32m    "      X..X          -  X...X  -         X...X         -  X..X           X..X  -           -     X........X  "[m
[32m+[m[32m    "       XX           -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           -     XXXXXXXXXX  "[m
[32m+[m[32m    "------------        -    X    -           X           -X.....................X-           ------------------"[m
[32m+[m[32m    "                    ----------------------------------- X...XXXXXXXXXXXXX...X -                             "[m
[32m+[m[32m    "                                                      -  X..X           X..X  -                             "[m
[32m+[m[32m    "                                                      -   X.X           X.X   -                             "[m
[32m+[m[32m    "                                                      -    XX           XX    -                             "[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstatic const ImVec2 FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ImGuiMouseCursor_COUNT][3] =[m
[32m+[m[32m{[m
[32m+[m[32m    // Pos ........ Size ......... Offset ......[m
[32m+[m[32m    { ImVec2( 0,3), ImVec2(12,19), ImVec2( 0, 0) }, // ImGuiMouseCursor_Arrow[m
[32m+[m[32m    { ImVec2(13,0), ImVec2( 7,16), ImVec2( 1, 8) }, // ImGuiMouseCursor_TextInput[m
[32m+[m[32m    { ImVec2(31,0), ImVec2(23,23), ImVec2(11,11) }, // ImGuiMouseCursor_ResizeAll[m
[32m+[m[32m    { ImVec2(21,0), ImVec2( 9,23), ImVec2( 4,11) }, // ImGuiMouseCursor_ResizeNS[m
[32m+[m[32m    { ImVec2(55,18),ImVec2(23, 9), ImVec2(11, 4) }, // ImGuiMouseCursor_ResizeEW[m
[32m+[m[32m    { ImVec2(73,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNESW[m
[32m+[m[32m    { ImVec2(55,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNWSE[m
[32m+[m[32m    { ImVec2(91,0), ImVec2(17,22), ImVec2( 5, 0) }, // ImGuiMouseCursor_Hand[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mImFontAtlas::ImFontAtlas()[m
[32m+[m[32m{[m
[32m+[m[32m    Locked = false;[m
[32m+[m[32m    Flags = ImFontAtlasFlags_None;[m
[32m+[m[32m    TexID = (ImTextureID)NULL;[m
[32m+[m[32m    TexDesiredWidth = 0;[m
[32m+[m[32m    TexGlyphPadding = 1;[m
[32m+[m
[32m+[m[32m    TexPixelsAlpha8 = NULL;[m
[32m+[m[32m    TexPixelsRGBA32 = NULL;[m
[32m+[m[32m    TexWidth = TexHeight = 0;[m
[32m+[m[32m    TexUvScale = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    TexUvWhitePixel = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)[m
[32m+[m[32m        CustomRectIds[n] = -1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImFontAtlas::~ImFontAtlas()[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");[m
[32m+[m[32m    Clear();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid    ImFontAtlas::ClearInputData()[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");[m
[32m+[m[32m    for (int i = 0; i < ConfigData.Size; i++)[m
[32m+[m[32m        if (ConfigData[i].FontData && ConfigData[i].FontDataOwnedByAtlas)[m
[32m+[m[32m        {[m
[32m+[m[32m            IM_FREE(ConfigData[i].FontData);[m
[32m+[m[32m            ConfigData[i].FontData = NULL;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m    // When clearing this we lose access to the font name and other information used to build the font.[m
[32m+[m[32m    for (int i = 0; i < Fonts.Size; i++)[m
[32m+[m[32m        if (Fonts[i]->ConfigData >= ConfigData.Data && Fonts[i]->ConfigData < ConfigData.Data + ConfigData.Size)[m
[32m+[m[32m        {[m
[32m+[m[32m            Fonts[i]->ConfigData = NULL;[m
[32m+[m[32m            Fonts[i]->ConfigDataCount = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m    ConfigData.clear();[m
[32m+[m[32m    CustomRects.clear();[m
[32m+[m[32m    for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)[m
[32m+[m[32m        CustomRectIds[n] = -1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid    ImFontAtlas::ClearTexData()[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");[m
[32m+[m[32m    if (TexPixelsAlpha8)[m
[32m+[m[32m        IM_FREE(TexPixelsAlpha8);[m
[32m+[m[32m    if (TexPixelsRGBA32)[m
[32m+[m[32m        IM_FREE(TexPixelsRGBA32);[m
[32m+[m[32m    TexPixelsAlpha8 = NULL;[m
[32m+[m[32m    TexPixelsRGBA32 = NULL;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid    ImFontAtlas::ClearFonts()[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");[m
[32m+[m[32m    for (int i = 0; i < Fonts.Size; i++)[m
[32m+[m[32m        IM_DELETE(Fonts[i]);[m
[32m+[m[32m    Fonts.clear();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid    ImFontAtlas::Clear()[m
[32m+[m[32m{[m
[32m+[m[32m    ClearInputData();[m
[32m+[m[32m    ClearTexData();[m
[32m+[m[32m    ClearFonts();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)[m
[32m+[m[32m{[m
[32m+[m[32m    // Build atlas on demand[m
[32m+[m[32m    if (TexPixelsAlpha8 == NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (ConfigData.empty())[m
[32m+[m[32m            AddFontDefault();[m
[32m+[m[32m        Build();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    *out_pixels = TexPixelsAlpha8;[m
[32m+[m[32m    if (out_width) *out_width = TexWidth;[m
[32m+[m[32m    if (out_height) *out_height = TexHeight;[m
[32m+[m[32m    if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)[m
[32m+[m[32m{[m
[32m+[m[32m    // Convert to RGBA32 format on demand[m
[32m+[m[32m    // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp[m
[32m+[m[32m    if (!TexPixelsRGBA32)[m
[32m+[m[32m    {[m
[32m+[m[32m        unsigned char* pixels = NULL;[m
[32m+[m[32m        GetTexDataAsAlpha8(&pixels, NULL, NULL);[m
[32m+[m[32m        if (pixels)[m
[32m+[m[32m        {[m
[32m+[m[32m            TexPixelsRGBA32 = (unsigned int*)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);[m
[32m+[m[32m            const unsigned char* src = pixels;[m
[32m+[m[32m            unsigned int* dst = TexPixelsRGBA32;[m
[32m+[m[32m            for (int n = TexWidth * TexHeight; n > 0; n--)[m
[32m+[m[32m                *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    *out_pixels = (unsigned char*)TexPixelsRGBA32;[m
[32m+[m[32m    if (out_width) *out_width = TexWidth;[m
[32m+[m[32m    if (out_height) *out_height = TexHeight;[m
[32m+[m[32m    if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");[m
[32m+[m[32m    IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);[m
[32m+[m[32m    IM_ASSERT(font_cfg->SizePixels > 0.0f);[m
[32m+[m
[32m+[m[32m    // Create new font[m
[32m+[m[32m    if (!font_cfg->MergeMode)[m
[32m+[m[32m        Fonts.push_back(IM_NEW(ImFont));[m
[32m+[m[32m    else[m
[32m+[m[32m        IM_ASSERT(!Fonts.empty() && "Cannot use MergeMode for the first font"); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.[m
[32m+[m
[32m+[m[32m    ConfigData.push_back(*font_cfg);[m
[32m+[m[32m    ImFontConfig& new_font_cfg = ConfigData.back();[m
[32m+[m[32m    if (new_font_cfg.DstFont == NULL)[m
[32m+[m[32m        new_font_cfg.DstFont = Fonts.back();[m
[32m+[m[32m    if (!new_font_cfg.FontDataOwnedByAtlas)[m
[32m+[m[32m    {[m
[32m+[m[32m        new_font_cfg.FontData = IM_ALLOC(new_font_cfg.FontDataSize);[m
[32m+[m[32m        new_font_cfg.FontDataOwnedByAtlas = true;[m
[32m+[m[32m        memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Invalidate texture[m
[32m+[m[32m    ClearTexData();[m
[32m+[m[32m    return new_font_cfg.DstFont;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Default font TTF is compressed with stb_compress then base85 encoded (see misc/fonts/binary_to_compressed_c.cpp for encoder)[m
[32m+[m[32mstatic unsigned int stb_decompress_length(const unsigned char *input);[m
[32m+[m[32mstatic unsigned int stb_decompress(unsigned char *output, const unsigned char *input, unsigned int length);[m
[32m+[m[32mstatic const char*  GetDefaultCompressedFontDataTTFBase85();[m
[32m+[m[32mstatic unsigned int Decode85Byte(char c)                                    { return c >= '\\' ? c-36 : c-35; }[m
[32m+[m[32mstatic void         Decode85(const unsigned char* src, unsigned char* dst)[m
[32m+[m[32m{[m
[32m+[m[32m    while (*src)[m
[32m+[m[32m    {[m
[32m+[m[32m        unsigned int tmp = Decode85Byte(src[0]) + 85*(Decode85Byte(src[1]) + 85*(Decode85Byte(src[2]) + 85*(Decode85Byte(src[3]) + 85*Decode85Byte(src[4]))));[m
[32m+[m[32m        dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.[m
[32m+[m[32m        src += 5;[m
[32m+[m[32m        dst += 4;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Load embedded ProggyClean.ttf at size 13, disable oversampling[m
[32m+[m[32mImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)[m
[32m+[m[32m{[m
[32m+[m[32m    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();[m
[32m+[m[32m    if (!font_cfg_template)[m
[32m+[m[32m    {[m
[32m+[m[32m        font_cfg.OversampleH = font_cfg.OversampleV = 1;[m
[32m+[m[32m        font_cfg.PixelSnapH = true;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (font_cfg.SizePixels <= 0.0f)[m
[32m+[m[32m        font_cfg.SizePixels = 13.0f * 1.0f;[m
[32m+[m[32m    if (font_cfg.Name[0] == '\0')[m
[32m+[m[32m        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);[m
[32m+[m
[32m+[m[32m    const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();[m
[32m+[m[32m    const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();[m
[32m+[m[32m    ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);[m
[32m+[m[32m    font->DisplayOffset.y = 1.0f;[m
[32m+[m[32m    return font;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");[m
[32m+[m[32m    size_t data_size = 0;[m
[32m+[m[32m    void* data = ImFileLoadToMemory(filename, "rb", &data_size, 0);[m
[32m+[m[32m    if (!data)[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(0); // Could not load file.[m
[32m+[m[32m        return NULL;[m
[32m+[m[32m    }[m
[32m+[m[32m    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();[m
[32m+[m[32m    if (font_cfg.Name[0] == '\0')[m
[32m+[m[32m    {[m
[32m+[m[32m        // Store a short copy of filename into into the font name for convenience[m
[32m+[m[32m        const char* p;[m
[32m+[m[32m        for (p = filename + strlen(filename); p > filename && p[-1] != '/' && p[-1] != '\\'; p--) {}[m
[32m+[m[32m        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "%s, %.0fpx", p, size_pixels);[m
[32m+[m[32m    }[m
[32m+[m[32m    return AddFontFromMemoryTTF(data, (int)data_size, size_pixels, &font_cfg, glyph_ranges);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// NB: Transfer ownership of 'ttf_data' to ImFontAtlas, unless font_cfg_template->FontDataOwnedByAtlas == false. Owned TTF buffer will be deleted after Build().[m
[32m+[m[32mImFont* ImFontAtlas::AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");[m
[32m+[m[32m    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();[m
[32m+[m[32m    IM_ASSERT(font_cfg.FontData == NULL);[m
[32m+[m[32m    font_cfg.FontData = ttf_data;[m
[32m+[m[32m    font_cfg.FontDataSize = ttf_size;[m
[32m+[m[32m    font_cfg.SizePixels = size_pixels;[m
[32m+[m[32m    if (glyph_ranges)[m
[32m+[m[32m        font_cfg.GlyphRanges = glyph_ranges;[m
[32m+[m[32m    return AddFont(&font_cfg);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)[m
[32m+[m[32m{[m
[32m+[m[32m    const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);[m
[32m+[m[32m    unsigned char* buf_decompressed_data = (unsigned char *)IM_ALLOC(buf_decompressed_size);[m
[32m+[m[32m    stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);[m
[32m+[m
[32m+[m[32m    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();[m
[32m+[m[32m    IM_ASSERT(font_cfg.FontData == NULL);[m
[32m+[m[32m    font_cfg.FontDataOwnedByAtlas = true;[m
[32m+[m[32m    return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)[m
[32m+[m[32m{[m
[32m+[m[32m    int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;[m
[32m+[m[32m    void* compressed_ttf = IM_ALLOC((size_t)compressed_ttf_size);[m
[32m+[m[32m    Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);[m
[32m+[m[32m    ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);[m
[32m+[m[32m    IM_FREE(compressed_ttf);[m
[32m+[m[32m    return font;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImFontAtlas::AddCustomRectRegular(unsigned int id, int width, int height)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(id >= 0x10000);[m
[32m+[m[32m    IM_ASSERT(width > 0 && width <= 0xFFFF);[m
[32m+[m[32m    IM_ASSERT(height > 0 && height <= 0xFFFF);[m
[32m+[m[32m    CustomRect r;[m
[32m+[m[32m    r.ID = id;[m
[32m+[m[32m    r.Width = (unsigned short)width;[m
[32m+[m[32m    r.Height = (unsigned short)height;[m
[32m+[m[32m    CustomRects.push_back(r);[m
[32m+[m[32m    return CustomRects.Size - 1; // Return index[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImFontAtlas::AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(font != NULL);[m
[32m+[m[32m    IM_ASSERT(width > 0 && width <= 0xFFFF);[m
[32m+[m[32m    IM_ASSERT(height > 0 && height <= 0xFFFF);[m
[32m+[m[32m    CustomRect r;[m
[32m+[m[32m    r.ID = id;[m
[32m+[m[32m    r.Width = (unsigned short)width;[m
[32m+[m[32m    r.Height = (unsigned short)height;[m
[32m+[m[32m    r.GlyphAdvanceX = advance_x;[m
[32m+[m[32m    r.GlyphOffset = offset;[m
[32m+[m[32m    r.Font = font;[m
[32m+[m[32m    CustomRects.push_back(r);[m
[32m+[m[32m    return CustomRects.Size - 1; // Return index[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImFontAtlas::CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(TexWidth > 0 && TexHeight > 0);   // Font atlas needs to be built before we can calculate UV coordinates[m
[32m+[m[32m    IM_ASSERT(rect->IsPacked());                // Make sure the rectangle has been packed[m
[32m+[m[32m    *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);[m
[32m+[m[32m    *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImFontAtlas::GetMouseCursorTexData(ImGuiMouseCursor cursor_type, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2])[m
[32m+[m[32m{[m
[32m+[m[32m    if (cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT)[m
[32m+[m[32m        return false;[m
[32m+[m[32m    if (Flags & ImFontAtlasFlags_NoMouseCursors)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    IM_ASSERT(CustomRectIds[0] != -1);[m
[32m+[m[32m    ImFontAtlas::CustomRect& r = CustomRects[CustomRectIds[0]];[m
[32m+[m[32m    IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);[m
[32m+[m[32m    ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r.X, (float)r.Y);[m
[32m+[m[32m    ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];[m
[32m+[m[32m    *out_size = size;[m
[32m+[m[32m    *out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2];[m
[32m+[m[32m    out_uv_border[0] = (pos) * TexUvScale;[m
[32m+[m[32m    out_uv_border[1] = (pos + size) * TexUvScale;[m
[32m+[m[32m    pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;[m
[32m+[m[32m    out_uv_fill[0] = (pos) * TexUvScale;[m
[32m+[m[32m    out_uv_fill[1] = (pos + size) * TexUvScale;[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool    ImFontAtlas::Build()[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");[m
[32m+[m[32m    return ImFontAtlasBuildWithStbTruetype(this);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid    ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_brighten_factor)[m
[32m+[m[32m{[m
[32m+[m[32m    for (unsigned int i = 0; i < 256; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        unsigned int value = (unsigned int)(i * in_brighten_factor);[m
[32m+[m[32m        out_table[i] = value > 255 ? 255 : (value & 0xFF);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid    ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride)[m
[32m+[m[32m{[m
[32m+[m[32m    unsigned char* data = pixels + x + y * stride;[m
[32m+[m[32m    for (int j = h; j > 0; j--, data += stride)[m
[32m+[m[32m        for (int i = 0; i < w; i++)[m
[32m+[m[32m            data[i] = table[data[i]];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Temporary data for one source font (multiple source fonts can be merged into one destination ImFont)[m
[32m+[m[32m// (C++03 doesn't allow instancing ImVector<> with function-local types so we declare the type here.)[m
[32m+[m[32mstruct ImFontBuildSrcData[m
[32m+[m[32m{[m
[32m+[m[32m    stbtt_fontinfo      FontInfo;[m
[32m+[m[32m    stbtt_pack_range    PackRange;          // Hold the list of codepoints to pack (essentially points to Codepoints.Data)[m
[32m+[m[32m    stbrp_rect*         Rects;              // Rectangle to pack. We first fill in their size and the packer will give us their position.[m
[32m+[m[32m    stbtt_packedchar*   PackedChars;        // Output glyphs[m
[32m+[m[32m    const ImWchar*      SrcRanges;          // Ranges as requested by user (user is allowed to request too much, e.g. 0x0020..0xFFFF)[m
[32m+[m[32m    int                 DstIndex;           // Index into atlas->Fonts[] and dst_tmp_array[][m
[32m+[m[32m    int                 GlyphsHighest;      // Highest requested codepoint[m
[32m+[m[32m    int                 GlyphsCount;        // Glyph count (excluding missing glyphs and glyphs already set by an earlier source font)[m
[32m+[m[32m    ImBoolVector        GlyphsSet;          // Glyph bit map (random access, 1-bit per codepoint. This will be a maximum of 8KB)[m
[32m+[m[32m    ImVector<int>       GlyphsList;         // Glyph codepoints list (flattened version of GlyphsMap)[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Temporary data for one destination ImFont* (multiple source fonts can be merged into one destination ImFont)[m
[32m+[m[32mstruct ImFontBuildDstData[m
[32m+[m[32m{[m
[32m+[m[32m    int                 SrcCount;           // Number of source fonts targeting this destination font.[m
[32m+[m[32m    int                 GlyphsHighest;[m
[32m+[m[32m    int                 GlyphsCount;[m
[32m+[m[32m    ImBoolVector        GlyphsSet;          // This is used to resolve collision when multiple sources are merged into a same destination font.[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstatic void UnpackBoolVectorToFlatIndexList(const ImBoolVector* in, ImVector<int>* out)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));[m
[32m+[m[32m    const int* it_begin = in->Storage.begin();[m
[32m+[m[32m    const int* it_end = in->Storage.end();[m
[32m+[m[32m    for (const int* it = it_begin; it < it_end; it++)[m
[32m+[m[32m        if (int entries_32 = *it)[m
[32m+[m[32m            for (int bit_n = 0; bit_n < 32; bit_n++)[m
[32m+[m[32m                if (entries_32 & (1 << bit_n))[m
[32m+[m[32m                    out->push_back((int)((it - it_begin) << 5) + bit_n);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool    ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(atlas->ConfigData.Size > 0);[m
[32m+[m
[32m+[m[32m    ImFontAtlasBuildRegisterDefaultCustomRects(atlas);[m
[32m+[m
[32m+[m[32m    // Clear atlas[m
[32m+[m[32m    atlas->TexID = (ImTextureID)NULL;[m
[32m+[m[32m    atlas->TexWidth = atlas->TexHeight = 0;[m
[32m+[m[32m    atlas->TexUvScale = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    atlas->ClearTexData();[m
[32m+[m
[32m+[m[32m    // Temporary storage for building[m
[32m+[m[32m    ImVector<ImFontBuildSrcData> src_tmp_array;[m
[32m+[m[32m    ImVector<ImFontBuildDstData> dst_tmp_array;[m
[32m+[m[32m    src_tmp_array.resize(atlas->ConfigData.Size);[m
[32m+[m[32m    dst_tmp_array.resize(atlas->Fonts.Size);[m
[32m+[m[32m    memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());[m
[32m+[m[32m    memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());[m
[32m+[m
[32m+[m[32m    // 1. Initialize font loading structure, check font data validity[m
[32m+[m[32m    for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];[m
[32m+[m[32m        ImFontConfig& cfg = atlas->ConfigData[src_i];[m
[32m+[m[32m        IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));[m
[32m+[m
[32m+[m[32m        // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)[m
[32m+[m[32m        src_tmp.DstIndex = -1;[m
[32m+[m[32m        for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)[m
[32m+[m[32m            if (cfg.DstFont == atlas->Fonts[output_i])[m
[32m+[m[32m                src_tmp.DstIndex = output_i;[m
[32m+[m[32m        IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts[] array?[m
[32m+[m[32m        if (src_tmp.DstIndex == -1)[m
[32m+[m[32m            return false;[m
[32m+[m
[32m+[m[32m        // Initialize helper structure for font loading and verify that the TTF/OTF data is correct[m
[32m+[m[32m        const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);[m
[32m+[m[32m        IM_ASSERT(font_offset >= 0 && "FontData is incorrect, or FontNo cannot be found.");[m
[32m+[m[32m        if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))[m
[32m+[m[32m            return false;[m
[32m+[m
[32m+[m[32m        // Measure highest codepoints[m
[32m+[m[32m        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];[m
[32m+[m[32m        src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();[m
[32m+[m[32m        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)[m
[32m+[m[32m            src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);[m
[32m+[m[32m        dst_tmp.SrcCount++;[m
[32m+[m[32m        dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.[m
[32m+[m[32m    int total_glyphs_count = 0;[m
[32m+[m[32m    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];[m
[32m+[m[32m        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];[m
[32m+[m[32m        src_tmp.GlyphsSet.Resize(src_tmp.GlyphsHighest + 1);[m
[32m+[m[32m        if (dst_tmp.GlyphsSet.Storage.empty())[m
[32m+[m[32m            dst_tmp.GlyphsSet.Resize(dst_tmp.GlyphsHighest + 1);[m
[32m+[m
[32m+[m[32m        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)[m
[32m+[m[32m            for (int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (dst_tmp.GlyphsSet.GetBit(codepoint))    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint))    // It is actually in the font?[m
[32m+[m[32m                    continue;[m
[32m+[m
[32m+[m[32m                // Add to avail set/counters[m
[32m+[m[32m                src_tmp.GlyphsCount++;[m
[32m+[m[32m                dst_tmp.GlyphsCount++;[m
[32m+[m[32m                src_tmp.GlyphsSet.SetBit(codepoint, true);[m
[32m+[m[32m                dst_tmp.GlyphsSet.SetBit(codepoint, true);[m
[32m+[m[32m                total_glyphs_count++;[m
[32m+[m[32m            }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)[m
[32m+[m[32m    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];[m
[32m+[m[32m        src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);[m
[32m+[m[32m        UnpackBoolVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList);[m
[32m+[m[32m        src_tmp.GlyphsSet.Clear();[m
[32m+[m[32m        IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);[m
[32m+[m[32m    }[m
[32m+[m[32m    for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)[m
[32m+[m[32m        dst_tmp_array[dst_i].GlyphsSet.Clear();[m
[32m+[m[32m    dst_tmp_array.clear();[m
[32m+[m
[32m+[m[32m    // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)[m
[32m+[m[32m    // (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)[m
[32m+[m[32m    ImVector<stbrp_rect> buf_rects;[m
[32m+[m[32m    ImVector<stbtt_packedchar> buf_packedchars;[m
[32m+[m[32m    buf_rects.resize(total_glyphs_count);[m
[32m+[m[32m    buf_packedchars.resize(total_glyphs_count);[m
[32m+[m[32m    memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());[m
[32m+[m[32m    memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());[m
[32m+[m
[32m+[m[32m    // 4. Gather glyphs sizes so we can pack them in our virtual canvas.[m
[32m+[m[32m    int total_surface = 0;[m
[32m+[m[32m    int buf_rects_out_n = 0;[m
[32m+[m[32m    int buf_packedchars_out_n = 0;[m
[32m+[m[32m    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];[m
[32m+[m[32m        if (src_tmp.GlyphsCount == 0)[m
[32m+[m[32m            continue;[m
[32m+[m
[32m+[m[32m        src_tmp.Rects = &buf_rects[buf_rects_out_n];[m
[32m+[m[32m        src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];[m
[32m+[m[32m        buf_rects_out_n += src_tmp.GlyphsCount;[m
[32m+[m[32m        buf_packedchars_out_n += src_tmp.GlyphsCount;[m
[32m+[m
[32m+[m[32m        // Convert our ranges in the format stb_truetype wants[m
[32m+[m[32m        ImFontConfig& cfg = atlas->ConfigData[src_i];[m
[32m+[m[32m        src_tmp.PackRange.font_size = cfg.SizePixels;[m
[32m+[m[32m        src_tmp.PackRange.first_unicode_codepoint_in_range = 0;[m
[32m+[m[32m        src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;[m
[32m+[m[32m        src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;[m
[32m+[m[32m        src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;[m
[32m+[m[32m        src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;[m
[32m+[m[32m        src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;[m
[32m+[m
[32m+[m[32m        // Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)[m
[32m+[m[32m        const float scale = (cfg.SizePixels > 0) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels);[m
[32m+[m[32m        const int padding = atlas->TexGlyphPadding;[m
[32m+[m[32m        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            int x0, y0, x1, y1;[m
[32m+[m[32m            const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);[m
[32m+[m[32m            IM_ASSERT(glyph_index_in_font != 0);[m
[32m+[m[32m            stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);[m
[32m+[m[32m            src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + padding + cfg.OversampleH - 1);[m
[32m+[m[32m            src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + padding + cfg.OversampleV - 1);[m
[32m+[m[32m            total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // We need a width for the skyline algorithm, any width![m
[32m+[m[32m    // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.[m
[32m+[m[32m    // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.[m
[32m+[m[32m    const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;[m
[32m+[m[32m    atlas->TexHeight = 0;[m
[32m+[m[32m    if (atlas->TexDesiredWidth > 0)[m
[32m+[m[32m        atlas->TexWidth = atlas->TexDesiredWidth;[m
[32m+[m[32m    else[m
[32m+[m[32m        atlas->TexWidth = (surface_sqrt >= 4096*0.7f) ? 4096 : (surface_sqrt >= 2048*0.7f) ? 2048 : (surface_sqrt >= 1024*0.7f) ? 1024 : 512;[m
[32m+[m
[32m+[m[32m    // 5. Start packing[m
[32m+[m[32m    // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).[m
[32m+[m[32m    const int TEX_HEIGHT_MAX = 1024 * 32;[m
[32m+[m[32m    stbtt_pack_context spc = {};[m
[32m+[m[32m    stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, atlas->TexGlyphPadding, NULL);[m
[32m+[m[32m    ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);[m
[32m+[m
[32m+[m[32m    // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.[m
[32m+[m[32m    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];[m
[32m+[m[32m        if (src_tmp.GlyphsCount == 0)[m
[32m+[m[32m            continue;[m
[32m+[m
[32m+[m[32m        stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);[m
[32m+[m
[32m+[m[32m        // Extend texture height and mark missing glyphs as non-packed so we won't render them.[m
[32m+[m[32m        // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)[m
[32m+[m[32m        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)[m
[32m+[m[32m            if (src_tmp.Rects[glyph_i].was_packed)[m
[32m+[m[32m                atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // 7. Allocate texture[m
[32m+[m[32m    atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);[m
[32m+[m[32m    atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);[m
[32m+[m[32m    atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);[m
[32m+[m[32m    memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);[m
[32m+[m[32m    spc.pixels = atlas->TexPixelsAlpha8;[m
[32m+[m[32m    spc.height = atlas->TexHeight;[m
[32m+[m
[32m+[m[32m    // 8. Render/rasterize font characters into the texture[m
[32m+[m[32m    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImFontConfig& cfg = atlas->ConfigData[src_i];[m
[32m+[m[32m        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];[m
[32m+[m[32m        if (src_tmp.GlyphsCount == 0)[m
[32m+[m[32m            continue;[m
[32m+[m
[32m+[m[32m        stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);[m
[32m+[m
[32m+[m[32m        // Apply multiply operator[m
[32m+[m[32m        if (cfg.RasterizerMultiply != 1.0f)[m
[32m+[m[32m        {[m
[32m+[m[32m            unsigned char multiply_table[256];[m
[32m+[m[32m            ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);[m
[32m+[m[32m            stbrp_rect* r = &src_tmp.Rects[0];[m
[32m+[m[32m            for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)[m
[32m+[m[32m                if (r->was_packed)[m
[32m+[m[32m                    ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);[m
[32m+[m[32m        }[m
[32m+[m[32m        src_tmp.Rects = NULL;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // End packing[m
[32m+[m[32m    stbtt_PackEnd(&spc);[m
[32m+[m[32m    buf_rects.clear();[m
[32m+[m
[32m+[m[32m    // 9. Setup ImFont and glyphs for runtime[m
[32m+[m[32m    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];[m
[32m+[m[32m        if (src_tmp.GlyphsCount == 0)[m
[32m+[m[32m            continue;[m
[32m+[m
[32m+[m[32m        ImFontConfig& cfg = atlas->ConfigData[src_i];[m
[32m+[m[32m        ImFont* dst_font = cfg.DstFont; // We can have multiple input fonts writing into a same destination font (when using MergeMode=true)[m
[32m+[m
[32m+[m[32m        const float font_scale = stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels);[m
[32m+[m[32m        int unscaled_ascent, unscaled_descent, unscaled_line_gap;[m
[32m+[m[32m        stbtt_GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);[m
[32m+[m
[32m+[m[32m        const float ascent = ImFloor(unscaled_ascent * font_scale + ((unscaled_ascent > 0.0f) ? +1 : -1));[m
[32m+[m[32m        const float descent = ImFloor(unscaled_descent * font_scale + ((unscaled_descent > 0.0f) ? +1 : -1));[m
[32m+[m[32m        ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);[m
[32m+[m[32m        const float font_off_x = cfg.GlyphOffset.x;[m
[32m+[m[32m        const float font_off_y = cfg.GlyphOffset.y + (float)(int)(dst_font->Ascent + 0.5f);[m
[32m+[m
[32m+[m[32m        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            const int codepoint = src_tmp.GlyphsList[glyph_i];[m
[32m+[m[32m            const stbtt_packedchar& pc = src_tmp.PackedChars[glyph_i];[m
[32m+[m
[32m+[m[32m            const float char_advance_x_org = pc.xadvance;[m
[32m+[m[32m            const float char_advance_x_mod = ImClamp(char_advance_x_org, cfg.GlyphMinAdvanceX, cfg.GlyphMaxAdvanceX);[m
[32m+[m[32m            float char_off_x = font_off_x;[m
[32m+[m[32m            if (char_advance_x_org != char_advance_x_mod)[m
[32m+[m[32m                char_off_x += cfg.PixelSnapH ? (float)(int)((char_advance_x_mod - char_advance_x_org) * 0.5f) : (char_advance_x_mod - char_advance_x_org) * 0.5f;[m
[32m+[m
[32m+[m[32m            // Register glyph[m
[32m+[m[32m            stbtt_aligned_quad q;[m
[32m+[m[32m            float dummy_x = 0.0f, dummy_y = 0.0f;[m
[32m+[m[32m            stbtt_GetPackedQuad(src_tmp.PackedChars, atlas->TexWidth, atlas->TexHeight, glyph_i, &dummy_x, &dummy_y, &q, 0);[m
[32m+[m[32m            dst_font->AddGlyph((ImWchar)codepoint, q.x0 + char_off_x, q.y0 + font_off_y, q.x1 + char_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, char_advance_x_mod);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Cleanup temporary (ImVector doesn't honor destructor)[m
[32m+[m[32m    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)[m
[32m+[m[32m        src_tmp_array[src_i].~ImFontBuildSrcData();[m
[32m+[m
[32m+[m[32m    ImFontAtlasBuildFinish(atlas);[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImFontAtlasBuildRegisterDefaultCustomRects(ImFontAtlas* atlas)[m
[32m+[m[32m{[m
[32m+[m[32m    if (atlas->CustomRectIds[0] >= 0)[m
[32m+[m[32m        return;[m
[32m+[m[32m    if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))[m
[32m+[m[32m        atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF*2+1, FONT_ATLAS_DEFAULT_TEX_DATA_H);[m
[32m+[m[32m    else[m
[32m+[m[32m        atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, 2, 2);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent)[m
[32m+[m[32m{[m
[32m+[m[32m    if (!font_config->MergeMode)[m
[32m+[m[32m    {[m
[32m+[m[32m        font->ClearOutputData();[m
[32m+[m[32m        font->FontSize = font_config->SizePixels;[m
[32m+[m[32m        font->ConfigData = font_config;[m
[32m+[m[32m        font->ContainerAtlas = atlas;[m
[32m+[m[32m        font->Ascent = ascent;[m
[32m+[m[32m        font->Descent = descent;[m
[32m+[m[32m    }[m
[32m+[m[32m    font->ConfigDataCount++;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque)[m
[32m+[m[32m{[m
[32m+[m[32m    stbrp_context* pack_context = (stbrp_context*)stbrp_context_opaque;[m
[32m+[m[32m    IM_ASSERT(pack_context != NULL);[m
[32m+[m
[32m+[m[32m    ImVector<ImFontAtlas::CustomRect>& user_rects = atlas->CustomRects;[m
[32m+[m[32m    IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.[m
[32m+[m
[32m+[m[32m    ImVector<stbrp_rect> pack_rects;[m
[32m+[m[32m    pack_rects.resize(user_rects.Size);[m
[32m+[m[32m    memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());[m
[32m+[m[32m    for (int i = 0; i < user_rects.Size; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        pack_rects[i].w = user_rects[i].Width;[m
[32m+[m[32m        pack_rects[i].h = user_rects[i].Height;[m
[32m+[m[32m    }[m
[32m+[m[32m    stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);[m
[32m+[m[32m    for (int i = 0; i < pack_rects.Size; i++)[m
[32m+[m[32m        if (pack_rects[i].was_packed)[m
[32m+[m[32m        {[m
[32m+[m[32m            user_rects[i].X = pack_rects[i].x;[m
[32m+[m[32m            user_rects[i].Y = pack_rects[i].y;[m
[32m+[m[32m            IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);[m
[32m+[m[32m            atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);[m
[32m+[m[32m        }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void ImFontAtlasBuildRenderDefaultTexData(ImFontAtlas* atlas)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(atlas->CustomRectIds[0] >= 0);[m
[32m+[m[32m    IM_ASSERT(atlas->TexPixelsAlpha8 != NULL);[m
[32m+[m[32m    ImFontAtlas::CustomRect& r = atlas->CustomRects[atlas->CustomRectIds[0]];[m
[32m+[m[32m    IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);[m
[32m+[m[32m    IM_ASSERT(r.IsPacked());[m
[32m+[m
[32m+[m[32m    const int w = atlas->TexWidth;[m
[32m+[m[32m    if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))[m
[32m+[m[32m    {[m
[32m+[m[32m        // Render/copy pixels[m
[32m+[m[32m        IM_ASSERT(r.Width == FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * 2 + 1 && r.Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);[m
[32m+[m[32m        for (int y = 0, n = 0; y < FONT_ATLAS_DEFAULT_TEX_DATA_H; y++)[m
[32m+[m[32m            for (int x = 0; x < FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF; x++, n++)[m
[32m+[m[32m            {[m
[32m+[m[32m                const int offset0 = (int)(r.X + x) + (int)(r.Y + y) * w;[m
[32m+[m[32m                const int offset1 = offset0 + FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;[m
[32m+[m[32m                atlas->TexPixelsAlpha8[offset0] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == '.' ? 0xFF : 0x00;[m
[32m+[m[32m                atlas->TexPixelsAlpha8[offset1] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == 'X' ? 0xFF : 0x00;[m
[32m+[m[32m            }[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(r.Width == 2 && r.Height == 2);[m
[32m+[m[32m        const int offset = (int)(r.X) + (int)(r.Y) * w;[m
[32m+[m[32m        atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;[m
[32m+[m[32m    }[m
[32m+[m[32m    atlas->TexUvWhitePixel = ImVec2((r.X + 0.5f) * atlas->TexUvScale.x, (r.Y + 0.5f) * atlas->TexUvScale.y);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImFontAtlasBuildFinish(ImFontAtlas* atlas)[m
[32m+[m[32m{[m
[32m+[m[32m    // Render into our custom data block[m
[32m+[m[32m    ImFontAtlasBuildRenderDefaultTexData(atlas);[m
[32m+[m
[32m+[m[32m    // Register custom rectangle glyphs[m
[32m+[m[32m    for (int i = 0; i < atlas->CustomRects.Size; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        const ImFontAtlas::CustomRect& r = atlas->CustomRects[i];[m
[32m+[m[32m        if (r.Font == NULL || r.ID > 0x10000)[m
[32m+[m[32m            continue;[m
[32m+[m
[32m+[m[32m        IM_ASSERT(r.Font->ContainerAtlas == atlas);[m
[32m+[m[32m        ImVec2 uv0, uv1;[m
[32m+[m[32m        atlas->CalcCustomRectUV(&r, &uv0, &uv1);[m
[32m+[m[32m        r.Font->AddGlyph((ImWchar)r.ID, r.GlyphOffset.x, r.GlyphOffset.y, r.GlyphOffset.x + r.Width, r.GlyphOffset.y + r.Height, uv0.x, uv0.y, uv1.x, uv1.y, r.GlyphAdvanceX);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Build all fonts lookup tables[m
[32m+[m[32m    for (int i = 0; i < atlas->Fonts.Size; i++)[m
[32m+[m[32m        if (atlas->Fonts[i]->DirtyLookupTables)[m
[32m+[m[32m            atlas->Fonts[i]->BuildLookupTable();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Retrieve list of range (2 int per range, values are inclusive)[m
[32m+[m[32mconst ImWchar*   ImFontAtlas::GetGlyphRangesDefault()[m
[32m+[m[32m{[m
[32m+[m[32m    static const ImWchar ranges[] =[m
[32m+[m[32m    {[m
[32m+[m[32m        0x0020, 0x00FF, // Basic Latin + Latin Supplement[m
[32m+[m[32m        0,[m
[32m+[m[32m    };[m
[32m+[m[32m    return &ranges[0];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst ImWchar*  ImFontAtlas::GetGlyphRangesKorean()[m
[32m+[m[32m{[m
[32m+[m[32m    static const ImWchar ranges[] =[m
[32m+[m[32m    {[m
[32m+[m[32m        0x0020, 0x00FF, // Basic Latin + Latin Supplement[m
[32m+[m[32m        0x3131, 0x3163, // Korean alphabets[m
[32m+[m[32m        0xAC00, 0xD79D, // Korean characters[m
[32m+[m[32m        0,[m
[32m+[m[32m    };[m
[32m+[m[32m    return &ranges[0];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst ImWchar*  ImFontAtlas::GetGlyphRangesChineseFull()[m
[32m+[m[32m{[m
[32m+[m[32m    static const ImWchar ranges[] =[m
[32m+[m[32m    {[m
[32m+[m[32m        0x0020, 0x00FF, // Basic Latin + Latin Supplement[m
[32m+[m[32m        0x2000, 0x206F, // General Punctuation[m
[32m+[m[32m        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana[m
[32m+[m[32m        0x31F0, 0x31FF, // Katakana Phonetic Extensions[m
[32m+[m[32m        0xFF00, 0xFFEF, // Half-width characters[m
[32m+[m[32m        0x4e00, 0x9FAF, // CJK Ideograms[m
[32m+[m[32m        0,[m
[32m+[m[32m    };[m
[32m+[m[32m    return &ranges[0];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void UnpackAccumulativeOffsetsIntoRanges(int base_codepoint, const short* accumulative_offsets, int accumulative_offsets_count, ImWchar* out_ranges)[m
[32m+[m[32m{[m
[32m+[m[32m    for (int n = 0; n < accumulative_offsets_count; n++, out_ranges += 2)[m
[32m+[m[32m    {[m
[32m+[m[32m        out_ranges[0] = out_ranges[1] = (ImWchar)(base_codepoint + accumulative_offsets[n]);[m
[32m+[m[32m        base_codepoint += accumulative_offsets[n];[m
[32m+[m[32m    }[m
[32m+[m[32m    out_ranges[0] = 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] ImFontAtlas glyph ranges helpers[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mconst ImWchar*  ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon()[m
[32m+[m[32m{[m
[32m+[m[32m    // Store 2500 regularly used characters for Simplified Chinese.[m
[32m+[m[32m    // Sourced from https://zh.wiktionary.org/wiki/%E9%99%84%E5%BD%95:%E7%8E%B0%E4%BB%A3%E6%B1%89%E8%AF%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E8%A1%A8[m
[32m+[m[32m    // This table covers 97.97% of all characters used during the month in July, 1987.[m
[32m+[m[32m    // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.[m
[32m+[m[32m    // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)[m
[32m+[m[32m    static const short accumulative_offsets_from_0x4E00[] =[m
[32m+[m[32m    {[m
[32m+[m[32m        0,1,2,4,1,1,1,1,2,1,3,2,1,2,2,1,1,1,1,1,5,2,1,2,3,3,3,2,2,4,1,1,1,2,1,5,2,3,1,2,1,2,1,1,2,1,1,2,2,1,4,1,1,1,1,5,10,1,2,19,2,1,2,1,2,1,2,1,2,[m
[32m+[m[32m        1,5,1,6,3,2,1,2,2,1,1,1,4,8,5,1,1,4,1,1,3,1,2,1,5,1,2,1,1,1,10,1,1,5,2,4,6,1,4,2,2,2,12,2,1,1,6,1,1,1,4,1,1,4,6,5,1,4,2,2,4,10,7,1,1,4,2,4,[m
[32m+[m[32m        2,1,4,3,6,10,12,5,7,2,14,2,9,1,1,6,7,10,4,7,13,1,5,4,8,4,1,1,2,28,5,6,1,1,5,2,5,20,2,2,9,8,11,2,9,17,1,8,6,8,27,4,6,9,20,11,27,6,68,2,2,1,1,[m
[32m+[m[32m        1,2,1,2,2,7,6,11,3,3,1,1,3,1,2,1,1,1,1,1,3,1,1,8,3,4,1,5,7,2,1,4,4,8,4,2,1,2,1,1,4,5,6,3,6,2,12,3,1,3,9,2,4,3,4,1,5,3,3,1,3,7,1,5,1,1,1,1,2,[m
[32m+[m[32m        3,4,5,2,3,2,6,1,1,2,1,7,1,7,3,4,5,15,2,2,1,5,3,22,19,2,1,1,1,1,2,5,1,1,1,6,1,1,12,8,2,9,18,22,4,1,1,5,1,16,1,2,7,10,15,1,1,6,2,4,1,2,4,1,6,[m
[32m+[m[32m        1,1,3,2,4,1,6,4,5,1,2,1,1,2,1,10,3,1,3,2,1,9,3,2,5,7,2,19,4,3,6,1,1,1,1,1,4,3,2,1,1,1,2,5,3,1,1,1,2,2,1,1,2,1,1,2,1,3,1,1,1,3,7,1,4,1,1,2,1,[m
[32m+[m[32m        1,2,1,2,4,4,3,8,1,1,1,2,1,3,5,1,3,1,3,4,6,2,2,14,4,6,6,11,9,1,15,3,1,28,5,2,5,5,3,1,3,4,5,4,6,14,3,2,3,5,21,2,7,20,10,1,2,19,2,4,28,28,2,3,[m
[32m+[m[32m        2,1,14,4,1,26,28,42,12,40,3,52,79,5,14,17,3,2,2,11,3,4,6,3,1,8,2,23,4,5,8,10,4,2,7,3,5,1,1,6,3,1,2,2,2,5,28,1,1,7,7,20,5,3,29,3,17,26,1,8,4,[m
[32m+[m[32m        27,3,6,11,23,5,3,4,6,13,24,16,6,5,10,25,35,7,3,2,3,3,14,3,6,2,6,1,4,2,3,8,2,1,1,3,3,3,4,1,1,13,2,2,4,5,2,1,14,14,1,2,2,1,4,5,2,3,1,14,3,12,[m
[32m+[m[32m        3,17,2,16,5,1,2,1,8,9,3,19,4,2,2,4,17,25,21,20,28,75,1,10,29,103,4,1,2,1,1,4,2,4,1,2,3,24,2,2,2,1,1,2,1,3,8,1,1,1,2,1,1,3,1,1,1,6,1,5,3,1,1,[m
[32m+[m[32m        1,3,4,1,1,5,2,1,5,6,13,9,16,1,1,1,1,3,2,3,2,4,5,2,5,2,2,3,7,13,7,2,2,1,1,1,1,2,3,3,2,1,6,4,9,2,1,14,2,14,2,1,18,3,4,14,4,11,41,15,23,15,23,[m
[32m+[m[32m        176,1,3,4,1,1,1,1,5,3,1,2,3,7,3,1,1,2,1,2,4,4,6,2,4,1,9,7,1,10,5,8,16,29,1,1,2,2,3,1,3,5,2,4,5,4,1,1,2,2,3,3,7,1,6,10,1,17,1,44,4,6,2,1,1,6,[m
[32m+[m[32m        5,4,2,10,1,6,9,2,8,1,24,1,2,13,7,8,8,2,1,4,1,3,1,3,3,5,2,5,10,9,4,9,12,2,1,6,1,10,1,1,7,7,4,10,8,3,1,13,4,3,1,6,1,3,5,2,1,2,17,16,5,2,16,6,[m
[32m+[m[32m        1,4,2,1,3,3,6,8,5,11,11,1,3,3,2,4,6,10,9,5,7,4,7,4,7,1,1,4,2,1,3,6,8,7,1,6,11,5,5,3,24,9,4,2,7,13,5,1,8,82,16,61,1,1,1,4,2,2,16,10,3,8,1,1,[m
[32m+[m[32m        6,4,2,1,3,1,1,1,4,3,8,4,2,2,1,1,1,1,1,6,3,5,1,1,4,6,9,2,1,1,1,2,1,7,2,1,6,1,5,4,4,3,1,8,1,3,3,1,3,2,2,2,2,3,1,6,1,2,1,2,1,3,7,1,8,2,1,2,1,5,[m
[32m+[m[32m        2,5,3,5,10,1,2,1,1,3,2,5,11,3,9,3,5,1,1,5,9,1,2,1,5,7,9,9,8,1,3,3,3,6,8,2,3,2,1,1,32,6,1,2,15,9,3,7,13,1,3,10,13,2,14,1,13,10,2,1,3,10,4,15,[m
[32m+[m[32m        2,15,15,10,1,3,9,6,9,32,25,26,47,7,3,2,3,1,6,3,4,3,2,8,5,4,1,9,4,2,2,19,10,6,2,3,8,1,2,2,4,2,1,9,4,4,4,6,4,8,9,2,3,1,1,1,1,3,5,5,1,3,8,4,6,[m
[32m+[m[32m        2,1,4,12,1,5,3,7,13,2,5,8,1,6,1,2,5,14,6,1,5,2,4,8,15,5,1,23,6,62,2,10,1,1,8,1,2,2,10,4,2,2,9,2,1,1,3,2,3,1,5,3,3,2,1,3,8,1,1,1,11,3,1,1,4,[m
[32m+[m[32m        3,7,1,14,1,2,3,12,5,2,5,1,6,7,5,7,14,11,1,3,1,8,9,12,2,1,11,8,4,4,2,6,10,9,13,1,1,3,1,5,1,3,2,4,4,1,18,2,3,14,11,4,29,4,2,7,1,3,13,9,2,2,5,[m
[32m+[m[32m        3,5,20,7,16,8,5,72,34,6,4,22,12,12,28,45,36,9,7,39,9,191,1,1,1,4,11,8,4,9,2,3,22,1,1,1,1,4,17,1,7,7,1,11,31,10,2,4,8,2,3,2,1,4,2,16,4,32,2,[m
[32m+[m[32m        3,19,13,4,9,1,5,2,14,8,1,1,3,6,19,6,5,1,16,6,2,10,8,5,1,2,3,1,5,5,1,11,6,6,1,3,3,2,6,3,8,1,1,4,10,7,5,7,7,5,8,9,2,1,3,4,1,1,3,1,3,3,2,6,16,[m
[32m+[m[32m        1,4,6,3,1,10,6,1,3,15,2,9,2,10,25,13,9,16,6,2,2,10,11,4,3,9,1,2,6,6,5,4,30,40,1,10,7,12,14,33,6,3,6,7,3,1,3,1,11,14,4,9,5,12,11,49,18,51,31,[m
[32m+[m[32m        140,31,2,2,1,5,1,8,1,10,1,4,4,3,24,1,10,1,3,6,6,16,3,4,5,2,1,4,2,57,10,6,22,2,22,3,7,22,6,10,11,36,18,16,33,36,2,5,5,1,1,1,4,10,1,4,13,2,7,[m
[32m+[m[32m        5,2,9,3,4,1,7,43,3,7,3,9,14,7,9,1,11,1,1,3,7,4,18,13,1,14,1,3,6,10,73,2,2,30,6,1,11,18,19,13,22,3,46,42,37,89,7,3,16,34,2,2,3,9,1,7,1,1,1,2,[m
[32m+[m[32m        2,4,10,7,3,10,3,9,5,28,9,2,6,13,7,3,1,3,10,2,7,2,11,3,6,21,54,85,2,1,4,2,2,1,39,3,21,2,2,5,1,1,1,4,1,1,3,4,15,1,3,2,4,4,2,3,8,2,20,1,8,7,13,[m
[32m+[m[32m        4,1,26,6,2,9,34,4,21,52,10,4,4,1,5,12,2,11,1,7,2,30,12,44,2,30,1,1,3,6,16,9,17,39,82,2,2,24,7,1,7,3,16,9,14,44,2,1,2,1,2,3,5,2,4,1,6,7,5,3,[m
[32m+[m[32m        2,6,1,11,5,11,2,1,18,19,8,1,3,24,29,2,1,3,5,2,2,1,13,6,5,1,46,11,3,5,1,1,5,8,2,10,6,12,6,3,7,11,2,4,16,13,2,5,1,1,2,2,5,2,28,5,2,23,10,8,4,[m
[32m+[m[32m        4,22,39,95,38,8,14,9,5,1,13,5,4,3,13,12,11,1,9,1,27,37,2,5,4,4,63,211,95,2,2,2,1,3,5,2,1,1,2,2,1,1,1,3,2,4,1,2,1,1,5,2,2,1,1,2,3,1,3,1,1,1,[m
[32m+[m[32m        3,1,4,2,1,3,6,1,1,3,7,15,5,3,2,5,3,9,11,4,2,22,1,6,3,8,7,1,4,28,4,16,3,3,25,4,4,27,27,1,4,1,2,2,7,1,3,5,2,28,8,2,14,1,8,6,16,25,3,3,3,14,3,[m
[32m+[m[32m        3,1,1,2,1,4,6,3,8,4,1,1,1,2,3,6,10,6,2,3,18,3,2,5,5,4,3,1,5,2,5,4,23,7,6,12,6,4,17,11,9,5,1,1,10,5,12,1,1,11,26,33,7,3,6,1,17,7,1,5,12,1,11,[m
[32m+[m[32m        2,4,1,8,14,17,23,1,2,1,7,8,16,11,9,6,5,2,6,4,16,2,8,14,1,11,8,9,1,1,1,9,25,4,11,19,7,2,15,2,12,8,52,7,5,19,2,16,4,36,8,1,16,8,24,26,4,6,2,9,[m
[32m+[m[32m        5,4,36,3,28,12,25,15,37,27,17,12,59,38,5,32,127,1,2,9,17,14,4,1,2,1,1,8,11,50,4,14,2,19,16,4,17,5,4,5,26,12,45,2,23,45,104,30,12,8,3,10,2,2,[m
[32m+[m[32m        3,3,1,4,20,7,2,9,6,15,2,20,1,3,16,4,11,15,6,134,2,5,59,1,2,2,2,1,9,17,3,26,137,10,211,59,1,2,4,1,4,1,1,1,2,6,2,3,1,1,2,3,2,3,1,3,4,4,2,3,3,[m
[32m+[m[32m        1,4,3,1,7,2,2,3,1,2,1,3,3,3,2,2,3,2,1,3,14,6,1,3,2,9,6,15,27,9,34,145,1,1,2,1,1,1,1,2,1,1,1,1,2,2,2,3,1,2,1,1,1,2,3,5,8,3,5,2,4,1,3,2,2,2,12,[m
[32m+[m[32m        4,1,1,1,10,4,5,1,20,4,16,1,15,9,5,12,2,9,2,5,4,2,26,19,7,1,26,4,30,12,15,42,1,6,8,172,1,1,4,2,1,1,11,2,2,4,2,1,2,1,10,8,1,2,1,4,5,1,2,5,1,8,[m
[32m+[m[32m        4,1,3,4,2,1,6,2,1,3,4,1,2,1,1,1,1,12,5,7,2,4,3,1,1,1,3,3,6,1,2,2,3,3,3,2,1,2,12,14,11,6,6,4,12,2,8,1,7,10,1,35,7,4,13,15,4,3,23,21,28,52,5,[m
[32m+[m[32m        26,5,6,1,7,10,2,7,53,3,2,1,1,1,2,163,532,1,10,11,1,3,3,4,8,2,8,6,2,2,23,22,4,2,2,4,2,1,3,1,3,3,5,9,8,2,1,2,8,1,10,2,12,21,20,15,105,2,3,1,1,[m
[32m+[m[32m        3,2,3,1,1,2,5,1,4,15,11,19,1,1,1,1,5,4,5,1,1,2,5,3,5,12,1,2,5,1,11,1,1,15,9,1,4,5,3,26,8,2,1,3,1,1,15,19,2,12,1,2,5,2,7,2,19,2,20,6,26,7,5,[m
[32m+[m[32m        2,2,7,34,21,13,70,2,128,1,1,2,1,1,2,1,1,3,2,2,2,15,1,4,1,3,4,42,10,6,1,49,85,8,1,2,1,1,4,4,2,3,6,1,5,7,4,3,211,4,1,2,1,2,5,1,2,4,2,2,6,5,6,[m
[32m+[m[32m        10,3,4,48,100,6,2,16,296,5,27,387,2,2,3,7,16,8,5,38,15,39,21,9,10,3,7,59,13,27,21,47,5,21,6[m
[32m+[m[32m    };[m
[32m+[m[32m    static ImWchar base_ranges[] = // not zero-terminated[m
[32m+[m[32m    {[m
[32m+[m[32m        0x0020, 0x00FF, // Basic Latin + Latin Supplement[m
[32m+[m[32m        0x2000, 0x206F, // General Punctuation[m
[32m+[m[32m        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana[m
[32m+[m[32m        0x31F0, 0x31FF, // Katakana Phonetic Extensions[m
[32m+[m[32m        0xFF00, 0xFFEF  // Half-width characters[m
[32m+[m[32m    };[m
[32m+[m[32m    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00) * 2 + 1] = { 0 };[m
[32m+[m[32m    if (!full_ranges[0])[m
[32m+[m[32m    {[m
[32m+[m[32m        memcpy(full_ranges, base_ranges, sizeof(base_ranges));[m
[32m+[m[32m        UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));[m
[32m+[m[32m    }[m
[32m+[m[32m    return &full_ranges[0];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst ImWchar*  ImFontAtlas::GetGlyphRangesJapanese()[m
[32m+[m[32m{[m
[32m+[m[32m    // 1946 common ideograms code points for Japanese[m
[32m+[m[32m    // Sourced from http://theinstructionlimit.com/common-kanji-character-ranges-for-xna-spritefont-rendering[m
[32m+[m[32m    // FIXME: Source a list of the revised 2136 Joyo Kanji list from 2010 and rebuild this.[m
[32m+[m[32m    // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.[m
[32m+[m[32m    // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)[m
[32m+[m[32m    static const short accumulative_offsets_from_0x4E00[] =[m
[32m+[m[32m    {[m
[32m+[m[32m        0,1,2,4,1,1,1,1,2,1,6,2,2,1,8,5,7,11,1,2,10,10,8,2,4,20,2,11,8,2,1,2,1,6,2,1,7,5,3,7,1,1,13,7,9,1,4,6,1,2,1,10,1,1,9,2,2,4,5,6,14,1,1,9,3,18,[m
[32m+[m[32m        5,4,2,2,10,7,1,1,1,3,2,4,3,23,2,10,12,2,14,2,4,13,1,6,10,3,1,7,13,6,4,13,5,2,3,17,2,2,5,7,6,4,1,7,14,16,6,13,9,15,1,1,7,16,4,7,1,19,9,2,7,15,[m
[32m+[m[32m        2,6,5,13,25,4,14,13,11,25,1,1,1,2,1,2,2,3,10,11,3,3,1,1,4,4,2,1,4,9,1,4,3,5,5,2,7,12,11,15,7,16,4,5,16,2,1,1,6,3,3,1,1,2,7,6,6,7,1,4,7,6,1,1,[m
[32m+[m[32m        2,1,12,3,3,9,5,8,1,11,1,2,3,18,20,4,1,3,6,1,7,3,5,5,7,2,2,12,3,1,4,2,3,2,3,11,8,7,4,17,1,9,25,1,1,4,2,2,4,1,2,7,1,1,1,3,1,2,6,16,1,2,1,1,3,12,[m
[32m+[m[32m        20,2,5,20,8,7,6,2,1,1,1,1,6,2,1,2,10,1,1,6,1,3,1,2,1,4,1,12,4,1,3,1,1,1,1,1,10,4,7,5,13,1,15,1,1,30,11,9,1,15,38,14,1,32,17,20,1,9,31,2,21,9,[m
[32m+[m[32m        4,49,22,2,1,13,1,11,45,35,43,55,12,19,83,1,3,2,3,13,2,1,7,3,18,3,13,8,1,8,18,5,3,7,25,24,9,24,40,3,17,24,2,1,6,2,3,16,15,6,7,3,12,1,9,7,3,3,[m
[32m+[m[32m        3,15,21,5,16,4,5,12,11,11,3,6,3,2,31,3,2,1,1,23,6,6,1,4,2,6,5,2,1,1,3,3,22,2,6,2,3,17,3,2,4,5,1,9,5,1,1,6,15,12,3,17,2,14,2,8,1,23,16,4,2,23,[m
[32m+[m[32m        8,15,23,20,12,25,19,47,11,21,65,46,4,3,1,5,6,1,2,5,26,2,1,1,3,11,1,1,1,2,1,2,3,1,1,10,2,3,1,1,1,3,6,3,2,2,6,6,9,2,2,2,6,2,5,10,2,4,1,2,1,2,2,[m
[32m+[m[32m        3,1,1,3,1,2,9,23,9,2,1,1,1,1,5,3,2,1,10,9,6,1,10,2,31,25,3,7,5,40,1,15,6,17,7,27,180,1,3,2,2,1,1,1,6,3,10,7,1,3,6,17,8,6,2,2,1,3,5,5,8,16,14,[m
[32m+[m[32m        15,1,1,4,1,2,1,1,1,3,2,7,5,6,2,5,10,1,4,2,9,1,1,11,6,1,44,1,3,7,9,5,1,3,1,1,10,7,1,10,4,2,7,21,15,7,2,5,1,8,3,4,1,3,1,6,1,4,2,1,4,10,8,1,4,5,[m
[32m+[m[32m        1,5,10,2,7,1,10,1,1,3,4,11,10,29,4,7,3,5,2,3,33,5,2,19,3,1,4,2,6,31,11,1,3,3,3,1,8,10,9,12,11,12,8,3,14,8,6,11,1,4,41,3,1,2,7,13,1,5,6,2,6,12,[m
[32m+[m[32m        12,22,5,9,4,8,9,9,34,6,24,1,1,20,9,9,3,4,1,7,2,2,2,6,2,28,5,3,6,1,4,6,7,4,2,1,4,2,13,6,4,4,3,1,8,8,3,2,1,5,1,2,2,3,1,11,11,7,3,6,10,8,6,16,16,[m
[32m+[m[32m        22,7,12,6,21,5,4,6,6,3,6,1,3,2,1,2,8,29,1,10,1,6,13,6,6,19,31,1,13,4,4,22,17,26,33,10,4,15,12,25,6,67,10,2,3,1,6,10,2,6,2,9,1,9,4,4,1,2,16,2,[m
[32m+[m[32m        5,9,2,3,8,1,8,3,9,4,8,6,4,8,11,3,2,1,1,3,26,1,7,5,1,11,1,5,3,5,2,13,6,39,5,1,5,2,11,6,10,5,1,15,5,3,6,19,21,22,2,4,1,6,1,8,1,4,8,2,4,2,2,9,2,[m
[32m+[m[32m        1,1,1,4,3,6,3,12,7,1,14,2,4,10,2,13,1,17,7,3,2,1,3,2,13,7,14,12,3,1,29,2,8,9,15,14,9,14,1,3,1,6,5,9,11,3,38,43,20,7,7,8,5,15,12,19,15,81,8,7,[m
[32m+[m[32m        1,5,73,13,37,28,8,8,1,15,18,20,165,28,1,6,11,8,4,14,7,15,1,3,3,6,4,1,7,14,1,1,11,30,1,5,1,4,14,1,4,2,7,52,2,6,29,3,1,9,1,21,3,5,1,26,3,11,14,[m
[32m+[m[32m        11,1,17,5,1,2,1,3,2,8,1,2,9,12,1,1,2,3,8,3,24,12,7,7,5,17,3,3,3,1,23,10,4,4,6,3,1,16,17,22,3,10,21,16,16,6,4,10,2,1,1,2,8,8,6,5,3,3,3,39,25,[m
[32m+[m[32m        15,1,1,16,6,7,25,15,6,6,12,1,22,13,1,4,9,5,12,2,9,1,12,28,8,3,5,10,22,60,1,2,40,4,61,63,4,1,13,12,1,4,31,12,1,14,89,5,16,6,29,14,2,5,49,18,18,[m
[32m+[m[32m        5,29,33,47,1,17,1,19,12,2,9,7,39,12,3,7,12,39,3,1,46,4,12,3,8,9,5,31,15,18,3,2,2,66,19,13,17,5,3,46,124,13,57,34,2,5,4,5,8,1,1,1,4,3,1,17,5,[m
[32m+[m[32m        3,5,3,1,8,5,6,3,27,3,26,7,12,7,2,17,3,7,18,78,16,4,36,1,2,1,6,2,1,39,17,7,4,13,4,4,4,1,10,4,2,4,6,3,10,1,19,1,26,2,4,33,2,73,47,7,3,8,2,4,15,[m
[32m+[m[32m        18,1,29,2,41,14,1,21,16,41,7,39,25,13,44,2,2,10,1,13,7,1,7,3,5,20,4,8,2,49,1,10,6,1,6,7,10,7,11,16,3,12,20,4,10,3,1,2,11,2,28,9,2,4,7,2,15,1,[m
[32m+[m[32m        27,1,28,17,4,5,10,7,3,24,10,11,6,26,3,2,7,2,2,49,16,10,16,15,4,5,27,61,30,14,38,22,2,7,5,1,3,12,23,24,17,17,3,3,2,4,1,6,2,7,5,1,1,5,1,1,9,4,[m
[32m+[m[32m        1,3,6,1,8,2,8,4,14,3,5,11,4,1,3,32,1,19,4,1,13,11,5,2,1,8,6,8,1,6,5,13,3,23,11,5,3,16,3,9,10,1,24,3,198,52,4,2,2,5,14,5,4,22,5,20,4,11,6,41,[m
[32m+[m[32m        1,5,2,2,11,5,2,28,35,8,22,3,18,3,10,7,5,3,4,1,5,3,8,9,3,6,2,16,22,4,5,5,3,3,18,23,2,6,23,5,27,8,1,33,2,12,43,16,5,2,3,6,1,20,4,2,9,7,1,11,2,[m
[32m+[m[32m        10,3,14,31,9,3,25,18,20,2,5,5,26,14,1,11,17,12,40,19,9,6,31,83,2,7,9,19,78,12,14,21,76,12,113,79,34,4,1,1,61,18,85,10,2,2,13,31,11,50,6,33,159,[m
[32m+[m[32m        179,6,6,7,4,4,2,4,2,5,8,7,20,32,22,1,3,10,6,7,28,5,10,9,2,77,19,13,2,5,1,4,4,7,4,13,3,9,31,17,3,26,2,6,6,5,4,1,7,11,3,4,2,1,6,2,20,4,1,9,2,6,[m
[32m+[m[32m        3,7,1,1,1,20,2,3,1,6,2,3,6,2,4,8,1,5,13,8,4,11,23,1,10,6,2,1,3,21,2,2,4,24,31,4,10,10,2,5,192,15,4,16,7,9,51,1,2,1,1,5,1,1,2,1,3,5,3,1,3,4,1,[m
[32m+[m[32m        3,1,3,3,9,8,1,2,2,2,4,4,18,12,92,2,10,4,3,14,5,25,16,42,4,14,4,2,21,5,126,30,31,2,1,5,13,3,22,5,6,6,20,12,1,14,12,87,3,19,1,8,2,9,9,3,3,23,2,[m
[32m+[m[32m        3,7,6,3,1,2,3,9,1,3,1,6,3,2,1,3,11,3,1,6,10,3,2,3,1,2,1,5,1,1,11,3,6,4,1,7,2,1,2,5,5,34,4,14,18,4,19,7,5,8,2,6,79,1,5,2,14,8,2,9,2,1,36,28,16,[m
[32m+[m[32m        4,1,1,1,2,12,6,42,39,16,23,7,15,15,3,2,12,7,21,64,6,9,28,8,12,3,3,41,59,24,51,55,57,294,9,9,2,6,2,15,1,2,13,38,90,9,9,9,3,11,7,1,1,1,5,6,3,2,[m
[32m+[m[32m        1,2,2,3,8,1,4,4,1,5,7,1,4,3,20,4,9,1,1,1,5,5,17,1,5,2,6,2,4,1,4,5,7,3,18,11,11,32,7,5,4,7,11,127,8,4,3,3,1,10,1,1,6,21,14,1,16,1,7,1,3,6,9,65,[m
[32m+[m[32m        51,4,3,13,3,10,1,1,12,9,21,110,3,19,24,1,1,10,62,4,1,29,42,78,28,20,18,82,6,3,15,6,84,58,253,15,155,264,15,21,9,14,7,58,40,39,[m
[32m+[m[32m    };[m
[32m+[m[32m    static ImWchar base_ranges[] = // not zero-terminated[m
[32m+[m[32m    {[m
[32m+[m[32m        0x0020, 0x00FF, // Basic Latin + Latin Supplement[m
[32m+[m[32m        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana[m
[32m+[m[32m        0x31F0, 0x31FF, // Katakana Phonetic Extensions[m
[32m+[m[32m        0xFF00, 0xFFEF  // Half-width characters[m
[32m+[m[32m    };[m
[32m+[m[32m    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00)*2 + 1] = { 0 };[m
[32m+[m[32m    if (!full_ranges[0])[m
[32m+[m[32m    {[m
[32m+[m[32m        memcpy(full_ranges, base_ranges, sizeof(base_ranges));[m
[32m+[m[32m        UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));[m
[32m+[m[32m    }[m
[32m+[m[32m    return &full_ranges[0];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst ImWchar*  ImFontAtlas::GetGlyphRangesCyrillic()[m
[32m+[m[32m{[m
[32m+[m[32m    static const ImWchar ranges[] =[m
[32m+[m[32m    {[m
[32m+[m[32m        0x0020, 0x00FF, // Basic Latin + Latin Supplement[m
[32m+[m[32m        0x0400, 0x052F, // Cyrillic + Cyrillic Supplement[m
[32m+[m[32m        0x2DE0, 0x2DFF, // Cyrillic Extended-A[m
[32m+[m[32m        0xA640, 0xA69F, // Cyrillic Extended-B[m
[32m+[m[32m        0,[m
[32m+[m[32m    };[m
[32m+[m[32m    return &ranges[0];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst ImWchar*  ImFontAtlas::GetGlyphRangesThai()[m
[32m+[m[32m{[m
[32m+[m[32m    static const ImWchar ranges[] =[m
[32m+[m[32m    {[m
[32m+[m[32m        0x0020, 0x00FF, // Basic Latin[m
[32m+[m[32m        0x2010, 0x205E, // Punctuations[m
[32m+[m[32m        0x0E00, 0x0E7F, // Thai[m
[32m+[m[32m        0,[m
[32m+[m[32m    };[m
[32m+[m[32m    return &ranges[0];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst ImWchar*  ImFontAtlas::GetGlyphRangesVietnamese()[m
[32m+[m[32m{[m
[32m+[m[32m    static const ImWchar ranges[] =[m
[32m+[m[32m    {[m
[32m+[m[32m        0x0020, 0x00FF, // Basic Latin[m
[32m+[m[32m        0x0102, 0x0103,[m
[32m+[m[32m        0x0110, 0x0111,[m
[32m+[m[32m        0x0128, 0x0129,[m
[32m+[m[32m        0x0168, 0x0169,[m
[32m+[m[32m        0x01A0, 0x01A1,[m
[32m+[m[32m        0x01AF, 0x01B0,[m
[32m+[m[32m        0x1EA0, 0x1EF9,[m
[32m+[m[32m        0,[m
[32m+[m[32m    };[m
[32m+[m[32m    return &ranges[0];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] ImFontGlyphRangesBuilder[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mvoid ImFontGlyphRangesBuilder::AddText(const char* text, const char* text_end)[m
[32m+[m[32m{[m
[32m+[m[32m    while (text_end ? (text < text_end) : *text)[m
[32m+[m[32m    {[m
[32m+[m[32m        unsigned int c = 0;[m
[32m+[m[32m        int c_len = ImTextCharFromUtf8(&c, text, text_end);[m
[32m+[m[32m        text += c_len;[m
[32m+[m[32m        if (c_len == 0)[m
[32m+[m[32m            break;[m
[32m+[m[32m        if (c < 0x10000)[m
[32m+[m[32m            AddChar((ImWchar)c);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImFontGlyphRangesBuilder::AddRanges(const ImWchar* ranges)[m
[32m+[m[32m{[m
[32m+[m[32m    for (; ranges[0]; ranges += 2)[m
[32m+[m[32m        for (ImWchar c = ranges[0]; c <= ranges[1]; c++)[m
[32m+[m[32m            AddChar(c);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImFontGlyphRangesBuilder::BuildRanges(ImVector<ImWchar>* out_ranges)[m
[32m+[m[32m{[m
[32m+[m[32m    for (int n = 0; n < 0x10000; n++)[m
[32m+[m[32m        if (GetBit(n))[m
[32m+[m[32m        {[m
[32m+[m[32m            out_ranges->push_back((ImWchar)n);[m
[32m+[m[32m            while (n < 0x10000 && GetBit(n + 1))[m
[32m+[m[32m                n++;[m
[32m+[m[32m            out_ranges->push_back((ImWchar)n);[m
[32m+[m[32m        }[m
[32m+[m[32m    out_ranges->push_back(0);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] ImFont[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mImFont::ImFont()[m
[32m+[m[32m{[m
[32m+[m[32m    FontSize = 0.0f;[m
[32m+[m[32m    FallbackAdvanceX = 0.0f;[m
[32m+[m[32m    FallbackChar = (ImWchar)'?';[m
[32m+[m[32m    DisplayOffset = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    FallbackGlyph = NULL;[m
[32m+[m[32m    ContainerAtlas = NULL;[m
[32m+[m[32m    ConfigData = NULL;[m
[32m+[m[32m    ConfigDataCount = 0;[m
[32m+[m[32m    DirtyLookupTables = false;[m
[32m+[m[32m    Scale = 1.0f;[m
[32m+[m[32m    Ascent = Descent = 0.0f;[m
[32m+[m[32m    MetricsTotalSurface = 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImFont::~ImFont()[m
[32m+[m[32m{[m
[32m+[m[32m    ClearOutputData();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid    ImFont::ClearOutputData()[m
[32m+[m[32m{[m
[32m+[m[32m    FontSize = 0.0f;[m
[32m+[m[32m    FallbackAdvanceX = 0.0f;[m
[32m+[m[32m    Glyphs.clear();[m
[32m+[m[32m    IndexAdvanceX.clear();[m
[32m+[m[32m    IndexLookup.clear();[m
[32m+[m[32m    FallbackGlyph = NULL;[m
[32m+[m[32m    ContainerAtlas = NULL;[m
[32m+[m[32m    DirtyLookupTables = true;[m
[32m+[m[32m    Ascent = Descent = 0.0f;[m
[32m+[m[32m    MetricsTotalSurface = 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImFont::BuildLookupTable()[m
[32m+[m[32m{[m
[32m+[m[32m    int max_codepoint = 0;[m
[32m+[m[32m    for (int i = 0; i != Glyphs.Size; i++)[m
[32m+[m[32m        max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);[m
[32m+[m
[32m+[m[32m    IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved[m
[32m+[m[32m    IndexAdvanceX.clear();[m
[32m+[m[32m    IndexLookup.clear();[m
[32m+[m[32m    DirtyLookupTables = false;[m
[32m+[m[32m    GrowIndex(max_codepoint + 1);[m
[32m+[m[32m    for (int i = 0; i < Glyphs.Size; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        int codepoint = (int)Glyphs[i].Codepoint;[m
[32m+[m[32m        IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;[m
[32m+[m[32m        IndexLookup[codepoint] = (ImWchar)i;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Create a glyph to handle TAB[m
[32m+[m[32m    // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)[m
[32m+[m[32m    if (FindGlyph((ImWchar)' '))[m
[32m+[m[32m    {[m
[32m+[m[32m        if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times[m
[32m+[m[32m            Glyphs.resize(Glyphs.Size + 1);[m
[32m+[m[32m        ImFontGlyph& tab_glyph = Glyphs.back();[m
[32m+[m[32m        tab_glyph = *FindGlyph((ImWchar)' ');[m
[32m+[m[32m        tab_glyph.Codepoint = '\t';[m
[32m+[m[32m        tab_glyph.AdvanceX *= IM_TABSIZE;[m
[32m+[m[32m        IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;[m
[32m+[m[32m        IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size-1);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    FallbackGlyph = FindGlyphNoFallback(FallbackChar);[m
[32m+[m[32m    FallbackAdvanceX = FallbackGlyph ? FallbackGlyph->AdvanceX : 0.0f;[m
[32m+[m[32m    for (int i = 0; i < max_codepoint + 1; i++)[m
[32m+[m[32m        if (IndexAdvanceX[i] < 0.0f)[m
[32m+[m[32m            IndexAdvanceX[i] = FallbackAdvanceX;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImFont::SetFallbackChar(ImWchar c)[m
[32m+[m[32m{[m
[32m+[m[32m    FallbackChar = c;[m
[32m+[m[32m    BuildLookupTable();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImFont::GrowIndex(int new_size)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);[m
[32m+[m[32m    if (new_size <= IndexLookup.Size)[m
[32m+[m[32m        return;[m
[32m+[m[32m    IndexAdvanceX.resize(new_size, -1.0f);[m
[32m+[m[32m    IndexLookup.resize(new_size, (ImWchar)-1);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// x0/y0/x1/y1 are offset from the character upper-left layout position, in pixels. Therefore x0/y0 are often fairly close to zero.[m
[32m+[m[32m// Not to be mistaken with texture coordinates, which are held by u0/v0/u1/v1 in normalized format (0.0..1.0 on each texture axis).[m
[32m+[m[32mvoid ImFont::AddGlyph(ImWchar codepoint, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)[m
[32m+[m[32m{[m
[32m+[m[32m    Glyphs.resize(Glyphs.Size + 1);[m
[32m+[m[32m    ImFontGlyph& glyph = Glyphs.back();[m
[32m+[m[32m    glyph.Codepoint = (ImWchar)codepoint;[m
[32m+[m[32m    glyph.X0 = x0;[m
[32m+[m[32m    glyph.Y0 = y0;[m
[32m+[m[32m    glyph.X1 = x1;[m
[32m+[m[32m    glyph.Y1 = y1;[m
[32m+[m[32m    glyph.U0 = u0;[m
[32m+[m[32m    glyph.V0 = v0;[m
[32m+[m[32m    glyph.U1 = u1;[m
[32m+[m[32m    glyph.V1 = v1;[m
[32m+[m[32m    glyph.AdvanceX = advance_x + ConfigData->GlyphExtraSpacing.x;  // Bake spacing into AdvanceX[m
[32m+[m
[32m+[m[32m    if (ConfigData->PixelSnapH)[m
[32m+[m[32m        glyph.AdvanceX = (float)(int)(glyph.AdvanceX + 0.5f);[m
[32m+[m
[32m+[m[32m    // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)[m
[32m+[m[32m    DirtyLookupTables = true;[m
[32m+[m[32m    MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + 1.99f) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + 1.99f);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(IndexLookup.Size > 0);    // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.[m
[32m+[m[32m    int index_size = IndexLookup.Size;[m
[32m+[m
[32m+[m[32m    if (dst < index_size && IndexLookup.Data[dst] == (ImWchar)-1 && !overwrite_dst) // 'dst' already exists[m
[32m+[m[32m        return;[m
[32m+[m[32m    if (src >= index_size && dst >= index_size) // both 'dst' and 'src' don't exist -> no-op[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    GrowIndex(dst + 1);[m
[32m+[m[32m    IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (ImWchar)-1;[m
[32m+[m[32m    IndexAdvanceX[dst] = (src < index_size) ? IndexAdvanceX.Data[src] : 1.0f;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst ImFontGlyph* ImFont::FindGlyph(ImWchar c) const[m
[32m+[m[32m{[m
[32m+[m[32m    if (c >= IndexLookup.Size)[m
[32m+[m[32m        return FallbackGlyph;[m
[32m+[m[32m    const ImWchar i = IndexLookup.Data[c];[m
[32m+[m[32m    if (i == (ImWchar)-1)[m
[32m+[m[32m        return FallbackGlyph;[m
[32m+[m[32m    return &Glyphs.Data[i];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst ImFontGlyph* ImFont::FindGlyphNoFallback(ImWchar c) const[m
[32m+[m[32m{[m
[32m+[m[32m    if (c >= IndexLookup.Size)[m
[32m+[m[32m        return NULL;[m
[32m+[m[32m    const ImWchar i = IndexLookup.Data[c];[m
[32m+[m[32m    if (i == (ImWchar)-1)[m
[32m+[m[32m        return NULL;[m
[32m+[m[32m    return &Glyphs.Data[i];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const[m
[32m+[m[32m{[m
[32m+[m[32m    // Simple word-wrapping for English, not full-featured. Please submit failing cases![m
[32m+[m[32m    // FIXME: Much possible improvements (don't cut things like "word !", "word!!!" but cut within "word,,,,", more sensible support for punctuations, support for Unicode punctuations, etc.)[m
[32m+[m
[32m+[m[32m    // For references, possible wrap point marked with ^[m
[32m+[m[32m    //  "aaa bbb, ccc,ddd. eee   fff. ggg!"[m
[32m+[m[32m    //      ^    ^    ^   ^   ^__    ^    ^[m
[32m+[m
[32m+[m[32m    // List of hardcoded separators: .,;!?'"[m
[32m+[m
[32m+[m[32m    // Skip extra blanks after a line returns (that includes not counting them in width computation)[m
[32m+[m[32m    // e.g. "Hello    world" --> "Hello" "World"[m
[32m+[m
[32m+[m[32m    // Cut words that cannot possibly fit within one line.[m
[32m+[m[32m    // e.g.: "The tropical fish" with ~5 characters worth of width --> "The tr" "opical" "fish"[m
[32m+[m
[32m+[m[32m    float line_width = 0.0f;[m
[32m+[m[32m    float word_width = 0.0f;[m
[32m+[m[32m    float blank_width = 0.0f;[m
[32m+[m[32m    wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters[m
[32m+[m
[32m+[m[32m    const char* word_end = text;[m
[32m+[m[32m    const char* prev_word_end = NULL;[m
[32m+[m[32m    bool inside_word = true;[m
[32m+[m
[32m+[m[32m    const char* s = text;[m
[32m+[m[32m    while (s < text_end)[m
[32m+[m[32m    {[m
[32m+[m[32m        unsigned int c = (unsigned int)*s;[m
[32m+[m[32m        const char* next_s;[m
[32m+[m[32m        if (c < 0x80)[m
[32m+[m[32m            next_s = s + 1;[m
[32m+[m[32m        else[m
[32m+[m[32m            next_s = s + ImTextCharFromUtf8(&c, s, text_end);[m
[32m+[m[32m        if (c == 0)[m
[32m+[m[32m            break;[m
[32m+[m
[32m+[m[32m        if (c < 32)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (c == '\n')[m
[32m+[m[32m            {[m
[32m+[m[32m                line_width = word_width = blank_width = 0.0f;[m
[32m+[m[32m                inside_word = true;[m
[32m+[m[32m                s = next_s;[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (c == '\r')[m
[32m+[m[32m            {[m
[32m+[m[32m                s = next_s;[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX);[m
[32m+[m[32m        if (ImCharIsBlankW(c))[m
[32m+[m[32m        {[m
[32m+[m[32m            if (inside_word)[m
[32m+[m[32m            {[m
[32m+[m[32m                line_width += blank_width;[m
[32m+[m[32m                blank_width = 0.0f;[m
[32m+[m[32m                word_end = s;[m
[32m+[m[32m            }[m
[32m+[m[32m            blank_width += char_width;[m
[32m+[m[32m            inside_word = false;[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            word_width += char_width;[m
[32m+[m[32m            if (inside_word)[m
[32m+[m[32m            {[m
[32m+[m[32m                word_end = next_s;[m
[32m+[m[32m            }[m
[32m+[m[32m            else[m
[32m+[m[32m            {[m
[32m+[m[32m                prev_word_end = word_end;[m
[32m+[m[32m                line_width += word_width + blank_width;[m
[32m+[m[32m                word_width = blank_width = 0.0f;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Allow wrapping after punctuation.[m
[32m+[m[32m            inside_word = !(c == '.' || c == ',' || c == ';' || c == '!' || c == '?' || c == '\"');[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // We ignore blank width at the end of the line (they can be skipped)[m
[32m+[m[32m        if (line_width + word_width >= wrap_width)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Words that cannot possibly fit within an entire line will be cut anywhere.[m
[32m+[m[32m            if (word_width < wrap_width)[m
[32m+[m[32m                s = prev_word_end ? prev_word_end : word_end;[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        s = next_s;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return s;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const[m
[32m+[m[32m{[m
[32m+[m[32m    if (!text_end)[m
[32m+[m[32m        text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.[m
[32m+[m
[32m+[m[32m    const float line_height = size;[m
[32m+[m[32m    const float scale = size / FontSize;[m
[32m+[m
[32m+[m[32m    ImVec2 text_size = ImVec2(0,0);[m
[32m+[m[32m    float line_width = 0.0f;[m
[32m+[m
[32m+[m[32m    const bool word_wrap_enabled = (wrap_width > 0.0f);[m
[32m+[m[32m    const char* word_wrap_eol = NULL;[m
[32m+[m
[32m+[m[32m    const char* s = text_begin;[m
[32m+[m[32m    while (s < text_end)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (word_wrap_enabled)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.[m
[32m+[m[32m            if (!word_wrap_eol)[m
[32m+[m[32m            {[m
[32m+[m[32m                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);[m
[32m+[m[32m                if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.[m
[32m+[m[32m                    word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            if (s >= word_wrap_eol)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (text_size.x < line_width)[m
[32m+[m[32m                    text_size.x = line_width;[m
[32m+[m[32m                text_size.y += line_height;[m
[32m+[m[32m                line_width = 0.0f;[m
[32m+[m[32m                word_wrap_eol = NULL;[m
[32m+[m
[32m+[m[32m                // Wrapping skips upcoming blanks[m
[32m+[m[32m                while (s < text_end)[m
[32m+[m[32m                {[m
[32m+[m[32m                    const char c = *s;[m
[32m+[m[32m                    if (ImCharIsBlankA(c)) { s++; } else if (c == '\n') { s++; break; } else { break; }[m
[32m+[m[32m                }[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Decode and advance source[m
[32m+[m[32m        const char* prev_s = s;[m
[32m+[m[32m        unsigned int c = (unsigned int)*s;[m
[32m+[m[32m        if (c < 0x80)[m
[32m+[m[32m        {[m
[32m+[m[32m            s += 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            s += ImTextCharFromUtf8(&c, s, text_end);[m
[32m+[m[32m            if (c == 0) // Malformed UTF-8?[m
[32m+[m[32m                break;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (c < 32)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (c == '\n')[m
[32m+[m[32m            {[m
[32m+[m[32m                text_size.x = ImMax(text_size.x, line_width);[m
[32m+[m[32m                text_size.y += line_height;[m
[32m+[m[32m                line_width = 0.0f;[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (c == '\r')[m
[32m+[m[32m                continue;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX) * scale;[m
[32m+[m[32m        if (line_width + char_width >= max_width)[m
[32m+[m[32m        {[m
[32m+[m[32m            s = prev_s;[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        line_width += char_width;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (text_size.x < line_width)[m
[32m+[m[32m        text_size.x = line_width;[m
[32m+[m
[32m+[m[32m    if (line_width > 0 || text_size.y == 0.0f)[m
[32m+[m[32m        text_size.y += line_height;[m
[32m+[m
[32m+[m[32m    if (remaining)[m
[32m+[m[32m        *remaining = s;[m
[32m+[m
[32m+[m[32m    return text_size;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImFont::RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, ImWchar c) const[m
[32m+[m[32m{[m
[32m+[m[32m    if (c == ' ' || c == '\t' || c == '\n' || c == '\r') // Match behavior of RenderText(), those 4 codepoints are hard-coded.[m
[32m+[m[32m        return;[m
[32m+[m[32m    if (const ImFontGlyph* glyph = FindGlyph(c))[m
[32m+[m[32m    {[m
[32m+[m[32m        float scale = (size >= 0.0f) ? (size / FontSize) : 1.0f;[m
[32m+[m[32m        pos.x = (float)(int)pos.x + DisplayOffset.x;[m
[32m+[m[32m        pos.y = (float)(int)pos.y + DisplayOffset.y;[m
[32m+[m[32m        draw_list->PrimReserve(6, 4);[m
[32m+[m[32m        draw_list->PrimRectUV(ImVec2(pos.x + glyph->X0 * scale, pos.y + glyph->Y0 * scale), ImVec2(pos.x + glyph->X1 * scale, pos.y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImFont::RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip) const[m
[32m+[m[32m{[m
[32m+[m[32m    if (!text_end)[m
[32m+[m[32m        text_end = text_begin + strlen(text_begin); // ImGui functions generally already provides a valid text_end, so this is merely to handle direct calls.[m
[32m+[m
[32m+[m[32m    // Align to be pixel perfect[m
[32m+[m[32m    pos.x = (float)(int)pos.x + DisplayOffset.x;[m
[32m+[m[32m    pos.y = (float)(int)pos.y + DisplayOffset.y;[m
[32m+[m[32m    float x = pos.x;[m
[32m+[m[32m    float y = pos.y;[m
[32m+[m[32m    if (y > clip_rect.w)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    const float scale = size / FontSize;[m
[32m+[m[32m    const float line_height = FontSize * scale;[m
[32m+[m[32m    const bool word_wrap_enabled = (wrap_width > 0.0f);[m
[32m+[m[32m    const char* word_wrap_eol = NULL;[m
[32m+[m
[32m+[m[32m    // Fast-forward to first visible line[m
[32m+[m[32m    const char* s = text_begin;[m
[32m+[m[32m    if (y + line_height < clip_rect.y && !word_wrap_enabled)[m
[32m+[m[32m        while (y + line_height < clip_rect.y && s < text_end)[m
[32m+[m[32m        {[m
[32m+[m[32m            s = (const char*)memchr(s, '\n', text_end - s);[m
[32m+[m[32m            s = s ? s + 1 : text_end;[m
[32m+[m[32m            y += line_height;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m    // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()[m
[32m+[m[32m    // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)[m
[32m+[m[32m    if (text_end - s > 10000 && !word_wrap_enabled)[m
[32m+[m[32m    {[m
[32m+[m[32m        const char* s_end = s;[m
[32m+[m[32m        float y_end = y;[m
[32m+[m[32m        while (y_end < clip_rect.w && s_end < text_end)[m
[32m+[m[32m        {[m
[32m+[m[32m            s_end = (const char*)memchr(s_end, '\n', text_end - s_end);[m
[32m+[m[32m            s_end = s_end ? s_end + 1 : text_end;[m
[32m+[m[32m            y_end += line_height;[m
[32m+[m[32m        }[m
[32m+[m[32m        text_end = s_end;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (s == text_end)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)[m
[32m+[m[32m    const int vtx_count_max = (int)(text_end - s) * 4;[m
[32m+[m[32m    const int idx_count_max = (int)(text_end - s) * 6;[m
[32m+[m[32m    const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;[m
[32m+[m[32m    draw_list->PrimReserve(idx_count_max, vtx_count_max);[m
[32m+[m
[32m+[m[32m    ImDrawVert* vtx_write = draw_list->_VtxWritePtr;[m
[32m+[m[32m    ImDrawIdx* idx_write = draw_list->_IdxWritePtr;[m
[32m+[m[32m    unsigned int vtx_current_idx = draw_list->_VtxCurrentIdx;[m
[32m+[m
[32m+[m[32m    while (s < text_end)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (word_wrap_enabled)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.[m
[32m+[m[32m            if (!word_wrap_eol)[m
[32m+[m[32m            {[m
[32m+[m[32m                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - pos.x));[m
[32m+[m[32m                if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.[m
[32m+[m[32m                    word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            if (s >= word_wrap_eol)[m
[32m+[m[32m            {[m
[32m+[m[32m                x = pos.x;[m
[32m+[m[32m                y += line_height;[m
[32m+[m[32m                word_wrap_eol = NULL;[m
[32m+[m
[32m+[m[32m                // Wrapping skips upcoming blanks[m
[32m+[m[32m                while (s < text_end)[m
[32m+[m[32m                {[m
[32m+[m[32m                    const char c = *s;[m
[32m+[m[32m                    if (ImCharIsBlankA(c)) { s++; } else if (c == '\n') { s++; break; } else { break; }[m
[32m+[m[32m                }[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Decode and advance source[m
[32m+[m[32m        unsigned int c = (unsigned int)*s;[m
[32m+[m[32m        if (c < 0x80)[m
[32m+[m[32m        {[m
[32m+[m[32m            s += 1;[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            s += ImTextCharFromUtf8(&c, s, text_end);[m
[32m+[m[32m            if (c == 0) // Malformed UTF-8?[m
[32m+[m[32m                break;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (c < 32)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (c == '\n')[m
[32m+[m[32m            {[m
[32m+[m[32m                x = pos.x;[m
[32m+[m[32m                y += line_height;[m
[32m+[m[32m                if (y > clip_rect.w)[m
[32m+[m[32m                    break; // break out of main loop[m
[32m+[m[32m                continue;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (c == '\r')[m
[32m+[m[32m                continue;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        float char_width = 0.0f;[m
[32m+[m[32m        if (const ImFontGlyph* glyph = FindGlyph((ImWchar)c))[m
[32m+[m[32m        {[m
[32m+[m[32m            char_width = glyph->AdvanceX * scale;[m
[32m+[m
[32m+[m[32m            // Arbitrarily assume that both space and tabs are empty glyphs as an optimization[m
[32m+[m[32m            if (c != ' ' && c != '\t')[m
[32m+[m[32m            {[m
[32m+[m[32m                // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w[m
[32m+[m[32m                float x1 = x + glyph->X0 * scale;[m
[32m+[m[32m                float x2 = x + glyph->X1 * scale;[m
[32m+[m[32m                float y1 = y + glyph->Y0 * scale;[m
[32m+[m[32m                float y2 = y + glyph->Y1 * scale;[m
[32m+[m[32m                if (x1 <= clip_rect.z && x2 >= clip_rect.x)[m
[32m+[m[32m                {[m
[32m+[m[32m                    // Render a character[m
[32m+[m[32m                    float u1 = glyph->U0;[m
[32m+[m[32m                    float v1 = glyph->V0;[m
[32m+[m[32m                    float u2 = glyph->U1;[m
[32m+[m[32m                    float v2 = glyph->V1;[m
[32m+[m
[32m+[m[32m                    // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.[m
[32m+[m[32m                    if (cpu_fine_clip)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        if (x1 < clip_rect.x)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);[m
[32m+[m[32m                            x1 = clip_rect.x;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (y1 < clip_rect.y)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);[m
[32m+[m[32m                            y1 = clip_rect.y;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (x2 > clip_rect.z)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);[m
[32m+[m[32m                            x2 = clip_rect.z;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (y2 > clip_rect.w)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);[m
[32m+[m[32m                            y2 = clip_rect.w;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (y1 >= y2)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            x += char_width;[m
[32m+[m[32m                            continue;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                    // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:[m
[32m+[m[32m                    {[m
[32m+[m[32m                        idx_write[0] = (ImDrawIdx)(vtx_current_idx); idx_write[1] = (ImDrawIdx)(vtx_current_idx+1); idx_write[2] = (ImDrawIdx)(vtx_current_idx+2);[m
[32m+[m[32m                        idx_write[3] = (ImDrawIdx)(vtx_current_idx); idx_write[4] = (ImDrawIdx)(vtx_current_idx+2); idx_write[5] = (ImDrawIdx)(vtx_current_idx+3);[m
[32m+[m[32m                        vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;[m
[32m+[m[32m                        vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;[m
[32m+[m[32m                        vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;[m
[32m+[m[32m                        vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;[m
[32m+[m[32m                        vtx_write += 4;[m
[32m+[m[32m                        vtx_current_idx += 4;[m
[32m+[m[32m                        idx_write += 6;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        x += char_width;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Give back unused vertices[m
[32m+[m[32m    draw_list->VtxBuffer.resize((int)(vtx_write - draw_list->VtxBuffer.Data));[m
[32m+[m[32m    draw_list->IdxBuffer.resize((int)(idx_write - draw_list->IdxBuffer.Data));[m
[32m+[m[32m    draw_list->CmdBuffer[draw_list->CmdBuffer.Size-1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);[m
[32m+[m[32m    draw_list->_VtxWritePtr = vtx_write;[m
[32m+[m[32m    draw_list->_IdxWritePtr = idx_write;[m
[32m+[m[32m    draw_list->_VtxCurrentIdx = (unsigned int)draw_list->VtxBuffer.Size;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Internal Render Helpers[m
[32m+[m[32m// (progressively moved from imgui.cpp to here when they are redesigned to stop accessing ImGui global state)[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// - RenderMouseCursor()[m
[32m+[m[32m// - RenderArrowPointingAt()[m
[32m+[m[32m// - RenderRectFilledRangeH()[m
[32m+[m[32m// - RenderPixelEllipsis()[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mvoid ImGui::RenderMouseCursor(ImDrawList* draw_list, ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor)[m
[32m+[m[32m{[m
[32m+[m[32m    if (mouse_cursor == ImGuiMouseCursor_None)[m
[32m+[m[32m        return;[m
[32m+[m[32m    IM_ASSERT(mouse_cursor > ImGuiMouseCursor_None && mouse_cursor < ImGuiMouseCursor_COUNT);[m
[32m+[m
[32m+[m[32m    const ImU32 col_shadow = IM_COL32(0, 0, 0, 48);[m
[32m+[m[32m    const ImU32 col_border = IM_COL32(0, 0, 0, 255);          // Black[m
[32m+[m[32m    const ImU32 col_fill   = IM_COL32(255, 255, 255, 255);    // White[m
[32m+[m
[32m+[m[32m    ImFontAtlas* font_atlas = draw_list->_Data->Font->ContainerAtlas;[m
[32m+[m[32m    ImVec2 offset, size, uv[4];[m
[32m+[m[32m    if (font_atlas->GetMouseCursorTexData(mouse_cursor, &offset, &size, &uv[0], &uv[2]))[m
[32m+[m[32m    {[m
[32m+[m[32m        pos -= offset;[m
[32m+[m[32m        const ImTextureID tex_id = font_atlas->TexID;[m
[32m+[m[32m        draw_list->PushTextureID(tex_id);[m
[32m+[m[32m        draw_list->AddImage(tex_id, pos + ImVec2(1,0)*scale, pos + ImVec2(1,0)*scale + size*scale, uv[2], uv[3], col_shadow);[m
[32m+[m[32m        draw_list->AddImage(tex_id, pos + ImVec2(2,0)*scale, pos + ImVec2(2,0)*scale + size*scale, uv[2], uv[3], col_shadow);[m
[32m+[m[32m        draw_list->AddImage(tex_id, pos,                     pos + size*scale,                     uv[2], uv[3], col_border);[m
[32m+[m[32m        draw_list->AddImage(tex_id, pos,                     pos + size*scale,                     uv[0], uv[1], col_fill);[m
[32m+[m[32m        draw_list->PopTextureID();[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Render an arrow. 'pos' is position of the arrow tip. half_sz.x is length from base to tip. half_sz.y is length on each side.[m
[32m+[m[32mvoid ImGui::RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col)[m
[32m+[m[32m{[m
[32m+[m[32m    switch (direction)[m
[32m+[m[32m    {[m
[32m+[m[32m    case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;[m
[32m+[m[32m    case ImGuiDir_Right: draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), pos, col); return;[m
[32m+[m[32m    case ImGuiDir_Up:    draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), pos, col); return;[m
[32m+[m[32m    case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;[m
[32m+[m[32m    case ImGuiDir_None: case ImGuiDir_COUNT: break; // Fix warnings[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic inline float ImAcos01(float x)[m
[32m+[m[32m{[m
[32m+[m[32m    if (x <= 0.0f) return IM_PI * 0.5f;[m
[32m+[m[32m    if (x >= 1.0f) return 0.0f;[m
[32m+[m[32m    return ImAcos(x);[m
[32m+[m[32m    //return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x + 1.5707963267948966f; // Cheap approximation, may be enough for what we do.[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// FIXME: Cleanup and move code to ImDrawList.[m
[32m+[m[32mvoid ImGui::RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding)[m
[32m+[m[32m{[m
[32m+[m[32m    if (x_end_norm == x_start_norm)[m
[32m+[m[32m        return;[m
[32m+[m[32m    if (x_start_norm > x_end_norm)[m
[32m+[m[32m        ImSwap(x_start_norm, x_end_norm);[m
[32m+[m
[32m+[m[32m    ImVec2 p0 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_start_norm), rect.Min.y);[m
[32m+[m[32m    ImVec2 p1 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_end_norm), rect.Max.y);[m
[32m+[m[32m    if (rounding == 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        draw_list->AddRectFilled(p0, p1, col, 0.0f);[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    rounding = ImClamp(ImMin((rect.Max.x - rect.Min.x) * 0.5f, (rect.Max.y - rect.Min.y) * 0.5f) - 1.0f, 0.0f, rounding);[m
[32m+[m[32m    const float inv_rounding = 1.0f / rounding;[m
[32m+[m[32m    const float arc0_b = ImAcos01(1.0f - (p0.x - rect.Min.x) * inv_rounding);[m
[32m+[m[32m    const float arc0_e = ImAcos01(1.0f - (p1.x - rect.Min.x) * inv_rounding);[m
[32m+[m[32m    const float half_pi = IM_PI * 0.5f; // We will == compare to this because we know this is the exact value ImAcos01 can return.[m
[32m+[m[32m    const float x0 = ImMax(p0.x, rect.Min.x + rounding);[m
[32m+[m[32m    if (arc0_b == arc0_e)[m
[32m+[m[32m    {[m
[32m+[m[32m        draw_list->PathLineTo(ImVec2(x0, p1.y));[m
[32m+[m[32m        draw_list->PathLineTo(ImVec2(x0, p0.y));[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (arc0_b == 0.0f && arc0_e == half_pi)[m
[32m+[m[32m    {[m
[32m+[m[32m        draw_list->PathArcToFast(ImVec2(x0, p1.y - rounding), rounding, 3, 6); // BL[m
[32m+[m[32m        draw_list->PathArcToFast(ImVec2(x0, p0.y + rounding), rounding, 6, 9); // TR[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        draw_list->PathArcTo(ImVec2(x0, p1.y - rounding), rounding, IM_PI - arc0_e, IM_PI - arc0_b, 3); // BL[m
[32m+[m[32m        draw_list->PathArcTo(ImVec2(x0, p0.y + rounding), rounding, IM_PI + arc0_b, IM_PI + arc0_e, 3); // TR[m
[32m+[m[32m    }[m
[32m+[m[32m    if (p1.x > rect.Min.x + rounding)[m
[32m+[m[32m    {[m
[32m+[m[32m        const float arc1_b = ImAcos01(1.0f - (rect.Max.x - p1.x) * inv_rounding);[m
[32m+[m[32m        const float arc1_e = ImAcos01(1.0f - (rect.Max.x - p0.x) * inv_rounding);[m
[32m+[m[32m        const float x1 = ImMin(p1.x, rect.Max.x - rounding);[m
[32m+[m[32m        if (arc1_b == arc1_e)[m
[32m+[m[32m        {[m
[32m+[m[32m            draw_list->PathLineTo(ImVec2(x1, p0.y));[m
[32m+[m[32m            draw_list->PathLineTo(ImVec2(x1, p1.y));[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (arc1_b == 0.0f && arc1_e == half_pi)[m
[32m+[m[32m        {[m
[32m+[m[32m            draw_list->PathArcToFast(ImVec2(x1, p0.y + rounding), rounding, 9, 12); // TR[m
[32m+[m[32m            draw_list->PathArcToFast(ImVec2(x1, p1.y - rounding), rounding, 0, 3);  // BR[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            draw_list->PathArcTo(ImVec2(x1, p0.y + rounding), rounding, -arc1_e, -arc1_b, 3); // TR[m
[32m+[m[32m            draw_list->PathArcTo(ImVec2(x1, p1.y - rounding), rounding, +arc1_b, +arc1_e, 3); // BR[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    draw_list->PathFillConvex(col);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// FIXME: Rendering an ellipsis "..." is a surprisingly tricky problem for us... we cannot rely on font glyph having it,[m
[32m+[m[32m// and regular dot are typically too wide. If we render a dot/shape ourselves it comes with the risk that it wouldn't match[m
[32m+[m[32m// the boldness or positioning of what the font uses...[m
[32m+[m[32mvoid ImGui::RenderPixelEllipsis(ImDrawList* draw_list, ImVec2 pos, int count, ImU32 col)[m
[32m+[m[32m{[m
[32m+[m[32m    ImFont* font = draw_list->_Data->Font;[m
[32m+[m[32m    const float font_scale = draw_list->_Data->FontSize / font->FontSize;[m
[32m+[m[32m    pos.y += (float)(int)(font->DisplayOffset.y + font->Ascent * font_scale + 0.5f - 1.0f);[m
[32m+[m[32m    for (int dot_n = 0; dot_n < count; dot_n++)[m
[32m+[m[32m        draw_list->AddRectFilled(ImVec2(pos.x + dot_n * 2.0f, pos.y), ImVec2(pos.x + dot_n * 2.0f + 1.0f, pos.y + 1.0f), col);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Decompression code[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Compressed with stb_compress() then converted to a C array and encoded as base85.[m
[32m+[m[32m// Use the program in misc/fonts/binary_to_compressed_c.cpp to create the array from a TTF file.[m
[32m+[m[32m// The purpose of encoding as base85 instead of "0x00,0x01,..." style is only save on _source code_ size.[m
[32m+[m[32m// Decompression from stb.h (public domain) by Sean Barrett https://github.com/nothings/stb/blob/master/stb.h[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mstatic unsigned int stb_decompress_length(const unsigned char *input)[m
[32m+[m[32m{[m
[32m+[m[32m    return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic unsigned char *stb__barrier_out_e, *stb__barrier_out_b;[m
[32m+[m[32mstatic const unsigned char *stb__barrier_in_b;[m
[32m+[m[32mstatic unsigned char *stb__dout;[m
[32m+[m[32mstatic void stb__match(const unsigned char *data, unsigned int length)[m
[32m+[m[32m{[m
[32m+[m[32m    // INVERSE of memmove... write each byte before copying the next...[m
[32m+[m[32m    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);[m
[32m+[m[32m    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }[m
[32m+[m[32m    if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e+1; return; }[m
[32m+[m[32m    while (length--) *stb__dout++ = *data++;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stb__lit(const unsigned char *data, unsigned int length)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);[m
[32m+[m[32m    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }[m
[32m+[m[32m    if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e+1; return; }[m
[32m+[m[32m    memcpy(stb__dout, data, length);[m
[32m+[m[32m    stb__dout += length;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])[m
[32m+[m[32m#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))[m
[32m+[m[32m#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))[m
[32m+[m
[32m+[m[32mstatic const unsigned char *stb_decompress_token(const unsigned char *i)[m
[32m+[m[32m{[m
[32m+[m[32m    if (*i >= 0x20) { // use fewer if's for cases that expand small[m
[32m+[m[32m        if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;[m
[32m+[m[32m        else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;[m
[32m+[m[32m        else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);[m
[32m+[m[32m    } else { // more ifs for cases that expand large, since overhead is amortized[m
[32m+[m[32m        if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;[m
[32m+[m[32m        else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;[m
[32m+[m[32m        else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);[m
[32m+[m[32m        else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);[m
[32m+[m[32m        else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;[m
[32m+[m[32m        else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;[m
[32m+[m[32m    }[m
[32m+[m[32m    return i;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen)[m
[32m+[m[32m{[m
[32m+[m[32m    const unsigned long ADLER_MOD = 65521;[m
[32m+[m[32m    unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;[m
[32m+[m[32m    unsigned long blocklen, i;[m
[32m+[m
[32m+[m[32m    blocklen = buflen % 5552;[m
[32m+[m[32m    while (buflen) {[m
[32m+[m[32m        for (i=0; i + 7 < blocklen; i += 8) {[m
[32m+[m[32m            s1 += buffer[0], s2 += s1;[m
[32m+[m[32m            s1 += buffer[1], s2 += s1;[m
[32m+[m[32m            s1 += buffer[2], s2 += s1;[m
[32m+[m[32m            s1 += buffer[3], s2 += s1;[m
[32m+[m[32m            s1 += buffer[4], s2 += s1;[m
[32m+[m[32m            s1 += buffer[5], s2 += s1;[m
[32m+[m[32m            s1 += buffer[6], s2 += s1;[m
[32m+[m[32m            s1 += buffer[7], s2 += s1;[m
[32m+[m
[32m+[m[32m            buffer += 8;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        for (; i < blocklen; ++i)[m
[32m+[m[32m            s1 += *buffer++, s2 += s1;[m
[32m+[m
[32m+[m[32m        s1 %= ADLER_MOD, s2 %= ADLER_MOD;[m
[32m+[m[32m        buflen -= blocklen;[m
[32m+[m[32m        blocklen = 5552;[m
[32m+[m[32m    }[m
[32m+[m[32m    return (unsigned int)(s2 << 16) + (unsigned int)s1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic unsigned int stb_decompress(unsigned char *output, const unsigned char *i, unsigned int /*length*/)[m
[32m+[m[32m{[m
[32m+[m[32m    unsigned int olen;[m
[32m+[m[32m    if (stb__in4(0) != 0x57bC0000) return 0;[m
[32m+[m[32m    if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB[m
[32m+[m[32m    olen = stb_decompress_length(i);[m
[32m+[m[32m    stb__barrier_in_b = i;[m
[32m+[m[32m    stb__barrier_out_e = output + olen;[m
[32m+[m[32m    stb__barrier_out_b = output;[m
[32m+[m[32m    i += 16;[m
[32m+[m
[32m+[m[32m    stb__dout = output;[m
[32m+[m[32m    for (;;) {[m
[32m+[m[32m        const unsigned char *old_i = i;[m
[32m+[m[32m        i = stb_decompress_token(i);[m
[32m+[m[32m        if (i == old_i) {[m
[32m+[m[32m            if (*i == 0x05 && i[1] == 0xfa) {[m
[32m+[m[32m                IM_ASSERT(stb__dout == output + olen);[m
[32m+[m[32m                if (stb__dout != output + olen) return 0;[m
[32m+[m[32m                if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))[m
[32m+[m[32m                    return 0;[m
[32m+[m[32m                return olen;[m
[32m+[m[32m            } else {[m
[32m+[m[32m                IM_ASSERT(0); /* NOTREACHED */[m
[32m+[m[32m                return 0;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        IM_ASSERT(stb__dout <= output + olen);[m
[32m+[m[32m        if (stb__dout > output + olen)[m
[32m+[m[32m            return 0;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Default font data (ProggyClean.ttf)[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// ProggyClean.ttf[m
[32m+[m[32m// Copyright (c) 2004, 2005 Tristan Grimmer[m
[32m+[m[32m// MIT license (see License.txt in http://www.upperbounds.net/download/ProggyClean.ttf.zip)[m
[32m+[m[32m// Download and more information at http://upperbounds.net[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// File: 'ProggyClean.ttf' (41208 bytes)[m
[32m+[m[32m// Exported using misc/fonts/binary_to_compressed_c.cpp (with compression + base85 string encoding).[m
[32m+[m[32m// The purpose of encoding as base85 instead of "0x00,0x01,..." style is only save on _source code_ size.[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32mstatic const char proggy_clean_ttf_compressed_data_base85[11980+1] =[m
[32m+[m[32m    "7])#######hV0qs'/###[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb';9Crc6tgXmKVeU2cD4Eo3R/"[m
[32m+[m[32m    "2*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(lf(r/7GrRgwV%MS=C#"[m
[32m+[m[32m    "`8ND>Qo#t'X#(v#Y9w0#1D$CIf;W'#pWUPXOuxXuU(H9M(1<q-UE31#^-V'8IRUo7Qf./L>=Ke$$'5F%)]0^#0X@U.a<r:QLtFsLcL6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uL"[m
[32m+[m[32m    "i@^rMl9t=cWq6##weg>$FBjVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N'[0#7RL_&#w+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`N"[m
[32m+[m[32m    "kfimM2J,W-jXS:)r0wK#@Fge$U>`w'N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%?76%^GMHePW-Z5l'&GiF#$956:rS?dA#fiK:)Yr+`&#0j@'DbG&#^$PG.Ll+DNa<XCMKEV*N)LN/N"[m
[32m+[m[32m    "*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl'&hF;;$<_=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)"[m
[32m+[m[32m    "tm+/Us9pG)XPu`<0s-)WTt(gCRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CX"[m
[32m+[m[32m    "ow0i(?$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQk.a>D[.e;mc."[m
[32m+[m[32m    "x]Ip.PH^'/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ'NQ(3_PLhE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZq]DAbkU*JqkL+nwX@@47`5>w=4h(9.`G"[m
[32m+[m[32m    "CRUxHPeR`5Mjol(dUWxZa(>STrPkrJiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HOIZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).'2($5FNP&EQ(,)"[m
[32m+[m[32m    "U]W]+fh18.vsai00);D3@4ku5P?DP8aJt+;qUM]=+b'8@;mViBKx0DE[-auGl8:PJ&Dj+M6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$UV(?#P6YY#"[m
[32m+[m[32m    "'/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]'/4C#v$U`0#V.[0>xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.kK/HSB==-'Ie/QTtG?-.*^N-4B/ZM"[m
[32m+[m[32m    "_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw'.,MRsqVr.L;aN&#/EgJ)PBc[-f>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`gu"[m
[32m+[m[32m    "Ft(c%=;Am_Qs@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8'=l_f-b49'UOqkLu7-##oDY2L(te+Mch&gLYtJ,MEtJfLh'x'M=$CS-ZZ%P]8bZ>#S?YY#%Q&q'3^Fw&?D)UDNrocM3A76/"[m
[32m+[m[32m    "/oL?#h7gl85[qW/NDOk%16ij;+:1a'iNIdb-ou8.P*w,v5#EI$TWS>Pot-R*H'-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>29sp3dt-52U%VM#q7'DHpg+#Z9%H[K<L"[m
[32m+[m[32m    "%a2E-grWVM3@2=-k22tL]4$##6We'8UJCKE[d_=%wI;'6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#"[m
[32m+[m[32m    "OQFKNX@QI'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c'[0#(s1X&xm$Y%B7*K:eDA323j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682-SjMXJK)("[m
[32m+[m[32m    "h$hxua_K]ul92%'BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDPmL<LYs8i#XwJOYaKPKc1h:'9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuYa%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5h"[m
[32m+[m[32m    "o;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]]u-[=99tts1.qb#q72g1WJO81q+eN'03'eM>&1XxY-caEnO"[m
[32m+[m[32m    "j%2n8)),?ILR5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew'He]h:sI[2LM$[guka3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1]MupW^-"[m
[32m+[m[32m    "sj_$%[HK%'F####QRZJ::Y3EGl4'@%FkiAOg#p[##O`gukTfBHagL<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg*%K8ln(wcf3/'DW-$.lR?n[nCH-"[m
[32m+[m[32m    "eXOONTJlh:.RYF%3'p6sq:UIMA945&^HFS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP'vh1/R&O_J9'um,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56'hl;.s5CUrxjO"[m
[32m+[m[32m    "M7-##.l+Au'A&O:-T72L]P`&=;ctp'XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B*P:Rowwm-`0PKjYDDM'3]d39VZHEl4,.j']Pk-M.h^&:0FACm$maq-&sgw0t7/6(^xtk%"[m
[32m+[m[32m    "LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P'$M<Jnq79VsJW/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_-Sj9,VK3M.*'&0D[Ca]J9gp8,kAW]"[m
[32m+[m[32m    "%(?A%R$f<->Zts'^kn=-^@c4%-pY6qI%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%KYo8fRULNd2.>%m]UK:n%r$'sw]J;5pAoO_#2mO3n,'=H5(et"[m
[32m+[m[32m    "Hg*`+RLgv>=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ':+Q_k+uvOSLiEo(<aD/K<CCc`'Lx>'?;++O'>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRbA#Kjm%upV1g:"[m
[32m+[m[32m    "a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X'e?YLfjM[VO0MbuFp7;>Q&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL("[m
[32m+[m[32m    "$/V,;(kXZejWO`<[5?\?ewY(*9=%wDc;,u<'9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.kLg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI'o8)b<"[m
[32m+[m[32m    "nKnw'Ho8C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE5^V8O(x<<aG/1N$#FX$0V5Y6x'aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM(=/M0:JxG'?"[m
[32m+[m[32m    "7WhH%o'a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?'(<S:68tq*WoDfZu';mM?8X[ma8W%*`-=;D.(nc7/;"[m
[32m+[m[32m    ")g:T1=^J$&BRV(-lTmNB6xqB[@0*o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3M"[m
[32m+[m[32m    "D?@f&1'BW-)Ju<L25gl8uhVm1hL$##*8###'A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmWCMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD'QdWoY-F$BtUwmfe$YqL'8(PWX("[m
[32m+[m[32m    "P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w'KD`LP5IbH;rTV>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO*5NK,((W-i:$,kp'UDAO(G0Sq7MVjJs"[m
[32m+[m[32m    "bIu)'Z,*[>br5fX^:FPAWr-m2KgL<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6'8uTG&#1T5g)uLv:873UpTLgH+#FgpH'_o1780Ph8KmxQJ8#H72L4@768@Tm&Q"[m
[32m+[m[32m    "h4CB/5OvmA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z'<$#4H)6,>e0jT6'N#(q%.O=?2S]u*(m<-"[m
[32m+[m[32m    "V8J'(1)G][68hW$5'q[GC&5j`TE?m'esFGNRM)j,ffZ?-qx8;->g4t*:CIP/[Qap7/9'#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFFcL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5i"[m
[32m+[m[32m    "sZ88+dKQ)W6>J%CL<KE>`.d*(B`-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv'?>-XV1q['-5k'cAZ69e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7"[m
[32m+[m[32m    ".m7jilQ02'0-VWAg<a/''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2'v:^;-DIBW,B4E68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW'b)Tq7VT9q^*^$$.:&N@@"[m
[32m+[m[32m    "$&)WHtPm*5_rO0&e%K&#-30j(E4#'Zb.o/(Tpm$>K'f@[PvFl,hfINTNU6u'0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*"[m
[32m+[m[32m    "hv^BFpQj:K'#SJ,sB-'#](j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&GjUR=1D8QaS3Up&@*9wP?+lo7b?@%'k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u"[m
[32m+[m[32m    "@-W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAKjKjseK</xKT*)B,N9X3]krc12t'pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8cY#YZ?=,`Wdxu/ae&#"[m
[32m+[m[32m    "w6)R89tI#6@s'(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,;^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D###EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#"[m
[32m+[m[32m    "u1p]ovUKW&Y%q]'>$1@-[xfn$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%)$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0"[m
[32m+[m[32m    "d=j.LQf./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c)QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrLW-1pG_&2UdB8"[m
[32m+[m[32m    "6e%B/:=>)N4xeW.*wft-;$'58-ESqr<b?UI(_%@[P46>#U`'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#"[m
[32m+[m[32m    "b0v=Pjer]$gG&JXDf->'StvU7505l9$AFvgYRI^&<^b68?j#q9QX4SM'RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''X.`$#8+1GD"[m
[32m+[m[32m    ":k$YUWsbn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4)'$Ab(Nof%V'8hL&#<NEdtg(n'=S1A(Q1/I&4([%dM`,Iu'1:_hL>SfD07&6D<fp8dHM7/g+"[m
[32m+[m[32m    "tlPN9J*rKaPct&?'uBCem^jn%9_K)<,C5K3s=5g&GmJb*[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m'vi`3?%Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*"[m
[32m+[m[32m    "$3WoJSCLweV[aZ'MQIjO<7;X-X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68LvEA'q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7"[m
[32m+[m[32m    ":d[/;r_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup'D#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr'_wgH)NUIR8a1n#S?Yej'h8^58UbZd+^FKD*T@;6A"[m
[32m+[m[32m    "7aQC[K8d-(v6GI$x:T<&'Gp5Uf>@M.*J:;$-rv29'M]8qMv-tLp,'886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu'QvBT.#=)0ukruV&.)3=(^1`o*Pj4<-<aN((^7('#Z0wK#5GX@7"[m
[32m+[m[32m    "u][`*S^43933A4rl][`*O4CgLEl]v$1Q3AeF37dbXk,.)vj#x'd`;qgbQR%FW,2(?LO=s%Sc68%NP'##Aotl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f'f/&_mt&F)XdF<9t4)Qa.*kT"[m
[32m+[m[32m    "LwQ'(TTB9.xH'>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72LnYl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2'IM%L3I)X((e/dl2&8'<M"[m
[32m+[m[32m    ":^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En'CR.q7E)p'/kle2HM,u;^%OKC-N+Ll%F9CF<Nf'^#t2L,;27W:0O@6##U6W7:$rJfLWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>"[m
[32m+[m[32m    "_>@kXQtMacfD.m-VAb8;IReM3$wf0''hra*so568'Ip&vRs849'MRYSp%:t:h5qSgwpEr$B>Q,;s(C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP'##p#C0c%-Gb%"[m
[32m+[m[32m    "hd+<-j'Ai*x&&HMkT]C'OSl##5RG[JXaHN;d'uA#x._U;.`PU@(Z3dt4r152@:v,'R.Sj'w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%>.G690a:$##<,);?;72#?x9+d;"[m
[32m+[m[32m    "^V'9;jY@;)br#q^YQpx:X#Te$Z^'=-=bGhLf:D6&bNwZ9-ZD#n^9HhLMr5G;']d&6'wYmTFmL<LD)F^%[tC'8;+9E#C$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s'B;K-M6$EB%is00:"[m
[32m+[m[32m    "+A4[7xks.LrNk0&E)wILYF@2L'0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT'<-,v`3;_)I9M^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k11IM1c^j%"[m
[32m+[m[32m    "9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8'je'D7k`e;)2pYwPA'_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^('7fB&Hq-:sf,sNj8xq^>$U4O]GKx'm9)b@p7YsvK3w^YR-"[m
[32m+[m[32m    "CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp^iI9O8KnTj,]H?D*r7'M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnrU(4&8/P+:hLSKj$#U%]49t'I:rgMi'FL@a:0Y-uA[39',(vbma*"[m
[32m+[m[32m    "hU%<-SRF`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>Ti1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*Vj>SsD<U4JHY"[m
[32m+[m[32m    "8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK'-x?'(:siIfL<$pFM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa8wD8=^GlPa8TKI1CjhsCTSLJM'/Wl>-"[m
[32m+[m[32m    "S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n<bhPmUkMw>%t<)'mEVE''n`WnJra$^TKvX5B>;_aSEK',(hwa0:i4G?.Bci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs'6,'85`"[m
[32m+[m[32m    "0?t/'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%OtJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<ROu7cL5l;-[A]%/"[m
[32m+[m[32m    "+fsd;l#SafT/f*W]0=O'$(Tb<[)*@e775R-:Yob%g*>l*:xP?Yb.5)%w_I?7uk5JC+FS(m#i'k.'a0i)9<7b'fs'59hq$*5Uhv##pi^8+hIEBF`nvo`;'l0.^S1<-wUK2/Coh58KKhLj"[m
[32m+[m[32m    "M=SO*rfO`+qC`W-On.=AJ56>>i2@2LH6A:&5q`?9I3@@'04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V"[m
[32m+[m[32m    "?6*C()dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+AurK<m86QIth*#v;-OBqi+L7wDE-Ir8K['m+DDSLwK&/.?-V%U_%3:qKNu$_b*B-kp7NaD'QdWQPK"[m
[32m+[m[32m    "Yq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vmJ80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/'+1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa"[m
[32m+[m[32m    ">gXm8YB`1d@K#n]76-a$U,mF<fX]idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&c$ooQUj]Exd*3ZM@-WGW2%s',B-_M%>%Ul:#/'xoFM9QX-$.QN'>"[m
[32m+[m[32m    "[%$Z$uF6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o'$?X3B</R90;eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*'3E>=-<)Gt*Iw)'QG:`@I"[m
[32m+[m[32m    "wOf7&]1i'S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/6Aj7:'1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0'1<Vc52=u`3^o-n1'g4v58Hj&6_t7$##?M)c<$bgQ_'SY((-xkA#"[m
[32m+[m[32m    "Y(,p'H9rIVY-b,'%bCPF7.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs,eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$"[m
[32m+[m[32m    "MlvAF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo'RS1R84=@paTKt)>=%&1[)*vp'u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u'm0dr9l,<*wMK*Oe=g8lV_KEBFkO'oU]^=[-792#ok,)"[m
[32m+[m[32m    "i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K1<-rGdO'$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw'DJN:)Ss;wGn9A32ijw%FL+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo"[m
[32m+[m[32m    "1*c-(aY168o<`JsSbk-,1N;$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+STRxX'q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W'$P"[m
[32m+[m[32m    "iDDG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7fSkgl6-++D:'A,uq7SvlB$pcpH'q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF6##$l84N1w?AO>'IAO"[m
[32m+[m[32m    "URQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#"[m
[32m+[m[32m    ";u.T%fAr%4tJ8&><1=GHZ_+m9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx=T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>"[m
[32m+[m[32m    "w$)F./^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*A#]-=A#a9OA#"[m
[32m+[m[32m    "d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k'MS.o?.5/sWel/wpEM0%3'/1)K^f1-d>G21&v(35>V`39V7A4=onx4"[m
[32m+[m[32m    "A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#"[m
[32m+[m[32m    "/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`+78#4uI-#"[m
[32m+[m[32m    "m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#"[m
[32m+[m[32m    "TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiCf&0g2'tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP"[m
[32m+[m[32m    "GT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xp"[m
[32m+[m[32m    "O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#lLYI:xvD=#";[m
[32m+[m
[32m+[m[32mstatic const char* GetDefaultCompressedFontDataTTFBase85()[m
[32m+[m[32m{[m
[32m+[m[32m    return proggy_clean_ttf_compressed_data_base85;[m
[32m+[m[32m}[m
[1mdiff --git a/vendor/source/ImGui/imgui_impl_glfw.cpp b/vendor/source/ImGui/imgui_impl_glfw.cpp[m
[1mnew file mode 100644[m
[1mindex 0000000..0ed9f7d[m
[1m--- /dev/null[m
[1m+++ b/vendor/source/ImGui/imgui_impl_glfw.cpp[m
[36m@@ -0,0 +1,330 @@[m
[32m+[m[32m// dear imgui: Platform Binding for GLFW[m
[32m+[m[32m// This needs to be used along with a Renderer (e.g. OpenGL3, Vulkan..)[m
[32m+[m[32m// (Info: GLFW is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan graphics context creation, etc.)[m
[32m+[m[32m// (Requires: GLFW 3.1+)[m
[32m+[m
[32m+[m[32m// Implemented features:[m
[32m+[m[32m//  [X] Platform: Clipboard support.[m
[32m+[m[32m//  [X] Platform: Gamepad support. Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.[m
[32m+[m[32m//  [x] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'. FIXME: 3 cursors types are missing from GLFW.[m
[32m+[m[32m//  [X] Platform: Keyboard arrays indexed using GLFW_KEY_* codes, e.g. ImGui::IsKeyPressed(GLFW_KEY_SPACE).[m
[32m+[m
[32m+[m[32m// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.[m
[32m+[m[32m// If you are new to dear imgui, read examples/README.txt and read the documentation at the top of imgui.cpp.[m
[32m+[m[32m// https://github.com/ocornut/imgui[m
[32m+[m
[32m+[m[32m// CHANGELOG[m
[32m+[m[32m// (minor and older changes stripped away, please see git history for details)[m
[32m+[m[32m//  2019-03-12: Misc: Preserve DisplayFramebufferScale when main window is minimized.[m
[32m+[m[32m//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.[m
[32m+[m[32m//  2018-11-07: Inputs: When installing our GLFW callbacks, we save user's previously installed ones - if any - and chain call them.[m
[32m+[m[32m//  2018-08-01: Inputs: Workaround for Emscripten which doesn't seem to handle focus related calls.[m
[32m+[m[32m//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.[m
[32m+[m[32m//  2018-06-08: Misc: Extracted imgui_impl_glfw.cpp/.h away from the old combined GLFW+OpenGL/Vulkan examples.[m
[32m+[m[32m//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors flag + honor ImGuiConfigFlags_NoMouseCursorChange flag.[m
[32m+[m[32m//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value, passed to glfwSetCursor()).[m
[32m+[m[32m//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.[m
[32m+[m[32m//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.[m
[32m+[m[32m//  2018-01-25: Inputs: Added gamepad support if ImGuiConfigFlags_NavEnableGamepad is set.[m
[32m+[m[32m//  2018-01-25: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when using navigation and ImGuiConfigFlags_NavMoveMouse is set).[m
[32m+[m[32m//  2018-01-20: Inputs: Added Horizontal Mouse Wheel support.[m
[32m+[m[32m//  2018-01-18: Inputs: Added mapping for ImGuiKey_Insert.[m
[32m+[m[32m//  2017-08-25: Inputs: MousePos set to -FLT_MAX,-FLT_MAX when mouse is unavailable/missing (instead of -1,-1).[m
[32m+[m[32m//  2016-10-15: Misc: Added a void* user_data parameter to Clipboard function handlers.[m
[32m+[m
[32m+[m[32m#include "imgui.h"[m
[32m+[m[32m#include "imgui_impl_glfw.h"[m
[32m+[m
[32m+[m[32m// GLFW[m
[32m+[m[32m#include <GLFW/glfw3.h>[m
[32m+[m[32m#ifdef _WIN32[m
[32m+[m[32m#undef APIENTRY[m
[32m+[m[32m#define GLFW_EXPOSE_NATIVE_WIN32[m
[32m+[m[32m#include <GLFW/glfw3native.h>   // for glfwGetWin32Window[m
[32m+[m[32m#endif[m
[32m+[m[32m#define GLFW_HAS_WINDOW_TOPMOST     (GLFW_VERSION_MAJOR * 1000 + GLFW_VERSION_MINOR * 100 >= 3200) // 3.2+ GLFW_FLOATING[m
[32m+[m[32m#define GLFW_HAS_WINDOW_HOVERED     (GLFW_VERSION_MAJOR * 1000 + GLFW_VERSION_MINOR * 100 >= 3300) // 3.3+ GLFW_HOVERED[m
[32m+[m[32m#define GLFW_HAS_WINDOW_ALPHA       (GLFW_VERSION_MAJOR * 1000 + GLFW_VERSION_MINOR * 100 >= 3300) // 3.3+ glfwSetWindowOpacity[m
[32m+[m[32m#define GLFW_HAS_PER_MONITOR_DPI    (GLFW_VERSION_MAJOR * 1000 + GLFW_VERSION_MINOR * 100 >= 3300) // 3.3+ glfwGetMonitorContentScale[m
[32m+[m[32m#define GLFW_HAS_VULKAN             (GLFW_VERSION_MAJOR * 1000 + GLFW_VERSION_MINOR * 100 >= 3200) // 3.2+ glfwCreateWindowSurface[m
[32m+[m
[32m+[m[32m// Data[m
[32m+[m[32menum GlfwClientApi[m
[32m+[m[32m{[m
[32m+[m[32m    GlfwClientApi_Unknown,[m
[32m+[m[32m    GlfwClientApi_OpenGL,[m
[32m+[m[32m    GlfwClientApi_Vulkan[m
[32m+[m[32m};[m
[32m+[m[32mstatic GLFWwindow*          g_Window = NULL;[m
[32m+[m[32mstatic GlfwClientApi        g_ClientApi = GlfwClientApi_Unknown;[m
[32m+[m[32mstatic double               g_Time = 0.0;[m
[32m+[m[32mstatic bool                 g_MouseJustPressed[5] = { false, false, false, false, false };[m
[32m+[m[32mstatic GLFWcursor*          g_MouseCursors[ImGuiMouseCursor_COUNT] = { 0 };[m
[32m+[m
[32m+[m[32m// Chain GLFW callbacks: our callbacks will call the user's previously installed callbacks, if any.[m
[32m+[m[32mstatic GLFWmousebuttonfun   g_PrevUserCallbackMousebutton = NULL;[m
[32m+[m[32mstatic GLFWscrollfun        g_PrevUserCallbackScroll = NULL;[m
[32m+[m[32mstatic GLFWkeyfun           g_PrevUserCallbackKey = NULL;[m
[32m+[m[32mstatic GLFWcharfun          g_PrevUserCallbackChar = NULL;[m
[32m+[m
[32m+[m[32mstatic const char* ImGui_ImplGlfw_GetClipboardText(void* user_data)[m
[32m+[m[32m{[m
[32m+[m[32m    return glfwGetClipboardString((GLFWwindow*)user_data);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void ImGui_ImplGlfw_SetClipboardText(void* user_data, const char* text)[m
[32m+[m[32m{[m
[32m+[m[32m    glfwSetClipboardString((GLFWwindow*)user_data, text);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui_ImplGlfw_MouseButtonCallback(GLFWwindow* window, int button, int action, int mods)[m
[32m+[m[32m{[m
[32m+[m[32m    if (g_PrevUserCallbackMousebutton != NULL)[m
[32m+[m[32m        g_PrevUserCallbackMousebutton(window, button, action, mods);[m
[32m+[m
[32m+[m[32m    if (action == GLFW_PRESS && button >= 0 && button < IM_ARRAYSIZE(g_MouseJustPressed))[m
[32m+[m[32m        g_MouseJustPressed[button] = true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui_ImplGlfw_ScrollCallback(GLFWwindow* window, double xoffset, double yoffset)[m
[32m+[m[32m{[m
[32m+[m[32m    if (g_PrevUserCallbackScroll != NULL)[m
[32m+[m[32m        g_PrevUserCallbackScroll(window, xoffset, yoffset);[m
[32m+[m
[32m+[m[32m    ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m    io.MouseWheelH += (float)xoffset;[m
[32m+[m[32m    io.MouseWheel += (float)yoffset;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui_ImplGlfw_KeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods)[m
[32m+[m[32m{[m
[32m+[m[32m    if (g_PrevUserCallbackKey != NULL)[m
[32m+[m[32m        g_PrevUserCallbackKey(window, key, scancode, action, mods);[m
[32m+[m
[32m+[m[32m    ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m    if (action == GLFW_PRESS)[m
[32m+[m[32m        io.KeysDown[key] = true;[m
[32m+[m[32m    if (action == GLFW_RELEASE)[m
[32m+[m[32m        io.KeysDown[key] = false;[m
[32m+[m
[32m+[m[32m    // Modifiers are not reliable across systems[m
[32m+[m[32m    io.KeyCtrl = io.KeysDown[GLFW_KEY_LEFT_CONTROL] || io.KeysDown[GLFW_KEY_RIGHT_CONTROL];[m
[32m+[m[32m    io.KeyShift = io.KeysDown[GLFW_KEY_LEFT_SHIFT] || io.KeysDown[GLFW_KEY_RIGHT_SHIFT];[m
[32m+[m[32m    io.KeyAlt = io.KeysDown[GLFW_KEY_LEFT_ALT] || io.KeysDown[GLFW_KEY_RIGHT_ALT];[m
[32m+[m[32m    io.KeySuper = io.KeysDown[GLFW_KEY_LEFT_SUPER] || io.KeysDown[GLFW_KEY_RIGHT_SUPER];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui_ImplGlfw_CharCallback(GLFWwindow* window, unsigned int c)[m
[32m+[m[32m{[m
[32m+[m[32m    if (g_PrevUserCallbackChar != NULL)[m
[32m+[m[32m        g_PrevUserCallbackChar(window, c);[m
[32m+[m
[32m+[m[32m    ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m    if (c > 0 && c < 0x10000)[m
[32m+[m[32m        io.AddInputCharacter((unsigned short)c);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic bool ImGui_ImplGlfw_Init(GLFWwindow* window, bool install_callbacks, GlfwClientApi client_api)[m
[32m+[m[32m{[m
[32m+[m[32m    g_Window = window;[m
[32m+[m[32m    g_Time = 0.0;[m
[32m+[m
[32m+[m[32m    // Setup back-end capabilities flags[m
[32m+[m[32m    ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m    io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         // We can honor GetMouseCursor() values (optional)[m
[32m+[m[32m    io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          // We can honor io.WantSetMousePos requests (optional, rarely used)[m
[32m+[m[32m    io.BackendPlatformName = "imgui_impl_glfw";[m
[32m+[m
[32m+[m[32m    // Keyboard mapping. ImGui will use those indices to peek into the io.KeysDown[] array.[m
[32m+[m[32m    io.KeyMap[ImGuiKey_Tab] = GLFW_KEY_TAB;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_LeftArrow] = GLFW_KEY_LEFT;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_RightArrow] = GLFW_KEY_RIGHT;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_UpArrow] = GLFW_KEY_UP;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_DownArrow] = GLFW_KEY_DOWN;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_PageUp] = GLFW_KEY_PAGE_UP;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_PageDown] = GLFW_KEY_PAGE_DOWN;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_Home] = GLFW_KEY_HOME;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_End] = GLFW_KEY_END;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_Insert] = GLFW_KEY_INSERT;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_Delete] = GLFW_KEY_DELETE;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_Backspace] = GLFW_KEY_BACKSPACE;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_Space] = GLFW_KEY_SPACE;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_Enter] = GLFW_KEY_ENTER;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_Escape] = GLFW_KEY_ESCAPE;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_A] = GLFW_KEY_A;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_C] = GLFW_KEY_C;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_V] = GLFW_KEY_V;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_X] = GLFW_KEY_X;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_Y] = GLFW_KEY_Y;[m
[32m+[m[32m    io.KeyMap[ImGuiKey_Z] = GLFW_KEY_Z;[m
[32m+[m
[32m+[m[32m    io.SetClipboardTextFn = ImGui_ImplGlfw_SetClipboardText;[m
[32m+[m[32m    io.GetClipboardTextFn = ImGui_ImplGlfw_GetClipboardText;[m
[32m+[m[32m    io.ClipboardUserData = g_Window;[m
[32m+[m[32m#if defined(_WIN32)[m
[32m+[m[32m    io.ImeWindowHandle = (void*)glfwGetWin32Window(g_Window);[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m    g_MouseCursors[ImGuiMouseCursor_Arrow] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);[m
[32m+[m[32m    g_MouseCursors[ImGuiMouseCursor_TextInput] = glfwCreateStandardCursor(GLFW_IBEAM_CURSOR);[m
[32m+[m[32m    g_MouseCursors[ImGuiMouseCursor_ResizeAll] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);   // FIXME: GLFW doesn't have this.[m
[32m+[m[32m    g_MouseCursors[ImGuiMouseCursor_ResizeNS] = glfwCreateStandardCursor(GLFW_VRESIZE_CURSOR);[m
[32m+[m[32m    g_MouseCursors[ImGuiMouseCursor_ResizeEW] = glfwCreateStandardCursor(GLFW_HRESIZE_CURSOR);[m
[32m+[m[32m    g_MouseCursors[ImGuiMouseCursor_ResizeNESW] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);  // FIXME: GLFW doesn't have this.[m
[32m+[m[32m    g_MouseCursors[ImGuiMouseCursor_ResizeNWSE] = glfwCreateStandardCursor(GLFW_ARROW_CURSOR);  // FIXME: GLFW doesn't have this.[m
[32m+[m[32m    g_MouseCursors[ImGuiMouseCursor_Hand] = glfwCreateStandardCursor(GLFW_HAND_CURSOR);[m
[32m+[m
[32m+[m[32m    // Chain GLFW callbacks: our callbacks will call the user's previously installed callbacks, if any.[m
[32m+[m[32m    g_PrevUserCallbackMousebutton = NULL;[m
[32m+[m[32m    g_PrevUserCallbackScroll = NULL;[m
[32m+[m[32m    g_PrevUserCallbackKey = NULL;[m
[32m+[m[32m    g_PrevUserCallbackChar = NULL;[m
[32m+[m[32m    if (install_callbacks)[m
[32m+[m[32m    {[m
[32m+[m[32m        g_PrevUserCallbackMousebutton = glfwSetMouseButtonCallback(window, ImGui_ImplGlfw_MouseButtonCallback);[m
[32m+[m[32m        g_PrevUserCallbackScroll = glfwSetScrollCallback(window, ImGui_ImplGlfw_ScrollCallback);[m
[32m+[m[32m        g_PrevUserCallbackKey = glfwSetKeyCallback(window, ImGui_ImplGlfw_KeyCallback);[m
[32m+[m[32m        g_PrevUserCallbackChar = glfwSetCharCallback(window, ImGui_ImplGlfw_CharCallback);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    g_ClientApi = client_api;[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui_ImplGlfw_InitForOpenGL(GLFWwindow* window, bool install_callbacks)[m
[32m+[m[32m{[m
[32m+[m[32m    return ImGui_ImplGlfw_Init(window, install_callbacks, GlfwClientApi_OpenGL);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui_ImplGlfw_InitForVulkan(GLFWwindow* window, bool install_callbacks)[m
[32m+[m[32m{[m
[32m+[m[32m    return ImGui_ImplGlfw_Init(window, install_callbacks, GlfwClientApi_Vulkan);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui_ImplGlfw_Shutdown()[m
[32m+[m[32m{[m
[32m+[m[32m    for (ImGuiMouseCursor cursor_n = 0; cursor_n < ImGuiMouseCursor_COUNT; cursor_n++)[m
[32m+[m[32m    {[m
[32m+[m[32m        glfwDestroyCursor(g_MouseCursors[cursor_n]);[m
[32m+[m[32m        g_MouseCursors[cursor_n] = NULL;[m
[32m+[m[32m    }[m
[32m+[m[32m    g_ClientApi = GlfwClientApi_Unknown;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void ImGui_ImplGlfw_UpdateMousePosAndButtons()[m
[32m+[m[32m{[m
[32m+[m[32m    // Update buttons[m
[32m+[m[32m    ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m    for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        // If a mouse press event came, always pass it as "mouse held this frame", so we don't miss click-release events that are shorter than 1 frame.[m
[32m+[m[32m        io.MouseDown[i] = g_MouseJustPressed[i] || glfwGetMouseButton(g_Window, i) != 0;[m
[32m+[m[32m        g_MouseJustPressed[i] = false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Update mouse position[m
[32m+[m[32m    const ImVec2 mouse_pos_backup = io.MousePos;[m
[32m+[m[32m    io.MousePos = ImVec2(-FLT_MAX, -FLT_MAX);[m
[32m+[m[32m#ifdef __EMSCRIPTEN__[m
[32m+[m[32m    const bool focused = true; // Emscripten[m
[32m+[m[32m#else[m
[32m+[m[32m    const bool focused = glfwGetWindowAttrib(g_Window, GLFW_FOCUSED) != 0;[m
[32m+[m[32m#endif[m
[32m+[m[32m    if (focused)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (io.WantSetMousePos)[m
[32m+[m[32m        {[m
[32m+[m[32m            glfwSetCursorPos(g_Window, (double)mouse_pos_backup.x, (double)mouse_pos_backup.y);[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            double mouse_x, mouse_y;[m
[32m+[m[32m            glfwGetCursorPos(g_Window, &mouse_x, &mouse_y);[m
[32m+[m[32m            io.MousePos = ImVec2((float)mouse_x, (float)mouse_y);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void ImGui_ImplGlfw_UpdateMouseCursor()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m    if ((io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange) || glfwGetInputMode(g_Window, GLFW_CURSOR) == GLFW_CURSOR_DISABLED)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();[m
[32m+[m[32m    if (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Hide OS mouse cursor if imgui is drawing it or if it wants no cursor[m
[32m+[m[32m        glfwSetInputMode(g_Window, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // Show OS mouse cursor[m
[32m+[m[32m        // FIXME-PLATFORM: Unfocused windows seems to fail changing the mouse cursor with GLFW 3.2, but 3.3 works here.[m
[32m+[m[32m        glfwSetCursor(g_Window, g_MouseCursors[imgui_cursor] ? g_MouseCursors[imgui_cursor] : g_MouseCursors[ImGuiMouseCursor_Arrow]);[m
[32m+[m[32m        glfwSetInputMode(g_Window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void ImGui_ImplGlfw_UpdateGamepads()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m    memset(io.NavInputs, 0, sizeof(io.NavInputs));[m
[32m+[m[32m    if ((io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) == 0)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // Update gamepad inputs[m
[32m+[m[32m    #define MAP_BUTTON(NAV_NO, BUTTON_NO)       { if (buttons_count > BUTTON_NO && buttons[BUTTON_NO] == GLFW_PRESS) io.NavInputs[NAV_NO] = 1.0f; }[m
[32m+[m[32m    #define MAP_ANALOG(NAV_NO, AXIS_NO, V0, V1) { float v = (axes_count > AXIS_NO) ? axes[AXIS_NO] : V0; v = (v - V0) / (V1 - V0); if (v > 1.0f) v = 1.0f; if (io.NavInputs[NAV_NO] < v) io.NavInputs[NAV_NO] = v; }[m
[32m+[m[32m    int axes_count = 0, buttons_count = 0;[m
[32m+[m[32m    const float* axes = glfwGetJoystickAxes(GLFW_JOYSTICK_1, &axes_count);[m
[32m+[m[32m    const unsigned char* buttons = glfwGetJoystickButtons(GLFW_JOYSTICK_1, &buttons_count);[m
[32m+[m[32m    MAP_BUTTON(ImGuiNavInput_Activate,   0);     // Cross / A[m
[32m+[m[32m    MAP_BUTTON(ImGuiNavInput_Cancel,     1);     // Circle / B[m
[32m+[m[32m    MAP_BUTTON(ImGuiNavInput_Menu,       2);     // Square / X[m
[32m+[m[32m    MAP_BUTTON(ImGuiNavInput_Input,      3);     // Triangle / Y[m
[32m+[m[32m    MAP_BUTTON(ImGuiNavInput_DpadLeft,   13);    // D-Pad Left[m
[32m+[m[32m    MAP_BUTTON(ImGuiNavInput_DpadRight,  11);    // D-Pad Right[m
[32m+[m[32m    MAP_BUTTON(ImGuiNavInput_DpadUp,     10);    // D-Pad Up[m
[32m+[m[32m    MAP_BUTTON(ImGuiNavInput_DpadDown,   12);    // D-Pad Down[m
[32m+[m[32m    MAP_BUTTON(ImGuiNavInput_FocusPrev,  4);     // L1 / LB[m
[32m+[m[32m    MAP_BUTTON(ImGuiNavInput_FocusNext,  5);     // R1 / RB[m
[32m+[m[32m    MAP_BUTTON(ImGuiNavInput_TweakSlow,  4);     // L1 / LB[m
[32m+[m[32m    MAP_BUTTON(ImGuiNavInput_TweakFast,  5);     // R1 / RB[m
[32m+[m[32m    MAP_ANALOG(ImGuiNavInput_LStickLeft, 0,  -0.3f,  -0.9f);[m
[32m+[m[32m    MAP_ANALOG(ImGuiNavInput_LStickRight,0,  +0.3f,  +0.9f);[m
[32m+[m[32m    MAP_ANALOG(ImGuiNavInput_LStickUp,   1,  +0.3f,  +0.9f);[m
[32m+[m[32m    MAP_ANALOG(ImGuiNavInput_LStickDown, 1,  -0.3f,  -0.9f);[m
[32m+[m[32m    #undef MAP_BUTTON[m
[32m+[m[32m    #undef MAP_ANALOG[m
[32m+[m[32m    if (axes_count > 0 && buttons_count > 0)[m
[32m+[m[32m        io.BackendFlags |= ImGuiBackendFlags_HasGamepad;[m
[32m+[m[32m    else[m
[32m+[m[32m        io.BackendFlags &= ~ImGuiBackendFlags_HasGamepad;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui_ImplGlfw_NewFrame()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m    IM_ASSERT(io.Fonts->IsBuilt() && "Font atlas not built! It is generally built by the renderer back-end. Missing call to renderer _NewFrame() function? e.g. ImGui_ImplOpenGL3_NewFrame().");[m
[32m+[m
[32m+[m[32m    // Setup display size (every frame to accommodate for window resizing)[m
[32m+[m[32m    int w, h;[m
[32m+[m[32m    int display_w, display_h;[m
[32m+[m[32m    glfwGetWindowSize(g_Window, &w, &h);[m
[32m+[m[32m    glfwGetFramebufferSize(g_Window, &display_w, &display_h);[m
[32m+[m[32m    io.DisplaySize = ImVec2((float)w, (float)h);[m
[32m+[m[32m    if (w > 0 && h > 0)[m
[32m+[m[32m        io.DisplayFramebufferScale = ImVec2((float)display_w / w, (float)display_h / h);[m
[32m+[m
[32m+[m[32m    // Setup time step[m
[32m+[m[32m    double current_time = glfwGetTime();[m
[32m+[m[32m    io.DeltaTime = g_Time > 0.0 ? (float)(current_time - g_Time) : (float)(1.0f/60.0f);[m
[32m+[m[32m    g_Time = current_time;[m
[32m+[m
[32m+[m[32m    ImGui_ImplGlfw_UpdateMousePosAndButtons();[m
[32m+[m[32m    ImGui_ImplGlfw_UpdateMouseCursor();[m
[32m+[m
[32m+[m[32m    // Update game controllers (if enabled and available)[m
[32m+[m[32m    ImGui_ImplGlfw_UpdateGamepads();[m
[32m+[m[32m}[m
[1mdiff --git a/vendor/source/ImGui/imgui_impl_glfw.h b/vendor/source/ImGui/imgui_impl_glfw.h[m
[1mnew file mode 100644[m
[1mindex 0000000..ccbe840[m
[1m--- /dev/null[m
[1m+++ b/vendor/source/ImGui/imgui_impl_glfw.h[m
[36m@@ -0,0 +1,33 @@[m
[32m+[m[32m// dear imgui: Platform Binding for GLFW[m
[32m+[m[32m// This needs to be used along with a Renderer (e.g. OpenGL3, Vulkan..)[m
[32m+[m[32m// (Info: GLFW is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan graphics context creation, etc.)[m
[32m+[m
[32m+[m[32m// Implemented features:[m
[32m+[m[32m//  [X] Platform: Clipboard support.[m
[32m+[m[32m//  [X] Platform: Gamepad support. Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.[m
[32m+[m[32m//  [x] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'. FIXME: 3 cursors types are missing from GLFW.[m
[32m+[m[32m//  [X] Platform: Keyboard arrays indexed using GLFW_KEY_* codes, e.g. ImGui::IsKeyPressed(GLFW_KEY_SPACE).[m
[32m+[m
[32m+[m[32m// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.[m
[32m+[m[32m// If you are new to dear imgui, read examples/README.txt and read the documentation at the top of imgui.cpp.[m
[32m+[m[32m// https://github.com/ocornut/imgui[m
[32m+[m
[32m+[m[32m// About GLSL version:[m
[32m+[m[32m// The 'glsl_version' initialization parameter defaults to "#version 150" if NULL.[m
[32m+[m[32m// Only override if your GL version doesn't handle this GLSL version. Keep NULL if unsure![m
[32m+[m
[32m+[m[32m#pragma once[m
[32m+[m
[32m+[m[32mstruct GLFWwindow;[m
[32m+[m
[32m+[m[32mIMGUI_IMPL_API bool     ImGui_ImplGlfw_InitForOpenGL(GLFWwindow* window, bool install_callbacks);[m
[32m+[m[32mIMGUI_IMPL_API bool     ImGui_ImplGlfw_InitForVulkan(GLFWwindow* window, bool install_callbacks);[m
[32m+[m[32mIMGUI_IMPL_API void     ImGui_ImplGlfw_Shutdown();[m
[32m+[m[32mIMGUI_IMPL_API void     ImGui_ImplGlfw_NewFrame();[m
[32m+[m
[32m+[m[32m// InitXXX function with 'install_callbacks=true': install GLFW callbacks. They will call user's previously installed callbacks, if any.[m
[32m+[m[32m// InitXXX function with 'install_callbacks=false': do not install GLFW callbacks. You will need to call them yourself from your own GLFW callbacks.[m
[32m+[m[32mIMGUI_IMPL_API void     ImGui_ImplGlfw_MouseButtonCallback(GLFWwindow* window, int button, int action, int mods);[m
[32m+[m[32mIMGUI_IMPL_API void     ImGui_ImplGlfw_ScrollCallback(GLFWwindow* window, double xoffset, double yoffset);[m
[32m+[m[32mIMGUI_IMPL_API void     ImGui_ImplGlfw_KeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods);[m
[32m+[m[32mIMGUI_IMPL_API void     ImGui_ImplGlfw_CharCallback(GLFWwindow* window, unsigned int c);[m
[1mdiff --git a/vendor/source/ImGui/imgui_impl_opengl3.cpp b/vendor/source/ImGui/imgui_impl_opengl3.cpp[m
[1mnew file mode 100644[m
[1mindex 0000000..364b9cc[m
[1m--- /dev/null[m
[1m+++ b/vendor/source/ImGui/imgui_impl_opengl3.cpp[m
[36m@@ -0,0 +1,613 @@[m
[32m+[m[32m// dear imgui: Renderer for modern OpenGL with shaders / programmatic pipeline[m
[32m+[m[32m// - Desktop GL: 3.x 4.x[m
[32m+[m[32m// - Embedded GL: ES 2.0 (WebGL 1.0), ES 3.0 (WebGL 2.0)[m
[32m+[m[32m// This needs to be used along with a Platform Binding (e.g. GLFW, SDL, Win32, custom..)[m
[32m+[m
[32m+[m[32m// Implemented features:[m
[32m+[m[32m//  [X] Renderer: User texture binding. Use 'GLuint' OpenGL texture identifier as void*/ImTextureID. Read the FAQ about ImTextureID in imgui.cpp.[m
[32m+[m
[32m+[m[32m// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.[m
[32m+[m[32m// If you are new to dear imgui, read examples/README.txt and read the documentation at the top of imgui.cpp.[m
[32m+[m[32m// https://github.com/ocornut/imgui[m
[32m+[m
[32m+[m[32m// CHANGELOG[m
[32m+[m[32m// (minor and older changes stripped away, please see git history for details)[m
[32m+[m[32m//  2019-04-30: OpenGL: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.[m
[32m+[m[32m//  2019-03-29: OpenGL: Not calling glBindBuffer more than necessary in the render loop.[m
[32m+[m[32m//  2019-03-15: OpenGL: Added a dummy GL call + comments in ImGui_ImplOpenGL3_Init() to detect uninitialized GL function loaders early.[m
[32m+[m[32m//  2019-03-03: OpenGL: Fix support for ES 2.0 (WebGL 1.0).[m
[32m+[m[32m//  2019-02-20: OpenGL: Fix for OSX not supporting OpenGL 4.5, we don't try to read GL_CLIP_ORIGIN even if defined by the headers/loader.[m
[32m+[m[32m//  2019-02-11: OpenGL: Projecting clipping rectangles correctly using draw_data->FramebufferScale to allow multi-viewports for retina display.[m
[32m+[m[32m//  2019-02-01: OpenGL: Using GLSL 410 shaders for any version over 410 (e.g. 430, 450).[m
[32m+[m[32m//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.[m
[32m+[m[32m//  2018-11-13: OpenGL: Support for GL 4.5's glClipControl(GL_UPPER_LEFT) / GL_CLIP_ORIGIN.[m
[32m+[m[32m//  2018-08-29: OpenGL: Added support for more OpenGL loaders: glew and glad, with comments indicative that any loader can be used.[m
[32m+[m[32m//  2018-08-09: OpenGL: Default to OpenGL ES 3 on iOS and Android. GLSL version default to "#version 300 ES".[m
[32m+[m[32m//  2018-07-30: OpenGL: Support for GLSL 300 ES and 410 core. Fixes for Emscripten compilation.[m
[32m+[m[32m//  2018-07-10: OpenGL: Support for more GLSL versions (based on the GLSL version string). Added error output when shaders fail to compile/link.[m
[32m+[m[32m//  2018-06-08: Misc: Extracted imgui_impl_opengl3.cpp/.h away from the old combined GLFW/SDL+OpenGL3 examples.[m
[32m+[m[32m//  2018-06-08: OpenGL: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.[m
[32m+[m[32m//  2018-05-25: OpenGL: Removed unnecessary backup/restore of GL_ELEMENT_ARRAY_BUFFER_BINDING since this is part of the VAO state.[m
[32m+[m[32m//  2018-05-14: OpenGL: Making the call to glBindSampler() optional so 3.2 context won't fail if the function is a NULL pointer.[m
[32m+[m[32m//  2018-03-06: OpenGL: Added const char* glsl_version parameter to ImGui_ImplOpenGL3_Init() so user can override the GLSL version e.g. "#version 150".[m
[32m+[m[32m//  2018-02-23: OpenGL: Create the VAO in the render function so the setup can more easily be used with multiple shared GL context.[m
[32m+[m[32m//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplSdlGL3_RenderDrawData() in the .h file so you can call it yourself.[m
[32m+[m[32m//  2018-01-07: OpenGL: Changed GLSL shader version from 330 to 150.[m
[32m+[m[32m//  2017-09-01: OpenGL: Save and restore current bound sampler. Save and restore current polygon mode.[m
[32m+[m[32m//  2017-05-01: OpenGL: Fixed save and restore of current blend func state.[m
[32m+[m[32m//  2017-05-01: OpenGL: Fixed save and restore of current GL_ACTIVE_TEXTURE.[m
[32m+[m[32m//  2016-09-05: OpenGL: Fixed save and restore of current scissor rectangle.[m
[32m+[m[32m//  2016-07-29: OpenGL: Explicitly setting GL_UNPACK_ROW_LENGTH to reduce issues because SDL changes it. (#752)[m
[32m+[m
[32m+[m[32m//----------------------------------------[m
[32m+[m[32m// OpenGL    GLSL      GLSL[m
[32m+[m[32m// version   version   string[m
[32m+[m[32m//----------------------------------------[m
[32m+[m[32m//  2.0       110       "#version 110"[m
[32m+[m[32m//  2.1       120       "#version 120"[m
[32m+[m[32m//  3.0       130       "#version 130"[m
[32m+[m[32m//  3.1       140       "#version 140"[m
[32m+[m[32m//  3.2       150       "#version 150"[m
[32m+[m[32m//  3.3       330       "#version 330 core"[m
[32m+[m[32m//  4.0       400       "#version 400 core"[m
[32m+[m[32m//  4.1       410       "#version 410 core"[m
[32m+[m[32m//  4.2       420       "#version 410 core"[m
[32m+[m[32m//  4.3       430       "#version 430 core"[m
[32m+[m[32m//  ES 2.0    100       "#version 100"      = WebGL 1.0[m
[32m+[m[32m//  ES 3.0    300       "#version 300 es"   = WebGL 2.0[m
[32m+[m[32m//----------------------------------------[m
[32m+[m
[32m+[m[32m#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)[m
[32m+[m[32m#define _CRT_SECURE_NO_WARNINGS[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#include "imgui.h"[m
[32m+[m[32m#include "imgui_impl_opengl3.h"[m
[32m+[m[32m#include <stdio.h>[m
[32m+[m[32m#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier[m
[32m+[m[32m#include <stddef.h>     // intptr_t[m
[32m+[m[32m#else[m
[32m+[m[32m#include <stdint.h>     // intptr_t[m
[32m+[m[32m#endif[m
[32m+[m[32m#if defined(__APPLE__)[m
[32m+[m[32m#include "TargetConditionals.h"[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Auto-detect GL version[m
[32m+[m[32m#if !defined(IMGUI_IMPL_OPENGL_ES2) && !defined(IMGUI_IMPL_OPENGL_ES3)[m
[32m+[m[32m#if (defined(__APPLE__) && TARGET_OS_IOS) || (defined(__ANDROID__))[m
[32m+[m[32m#define IMGUI_IMPL_OPENGL_ES3       // iOS, Android  -> GL ES 3, "#version 300 es"[m
[32m+[m[32m#elif defined(__EMSCRIPTEN__)[m
[32m+[m[32m#define IMGUI_IMPL_OPENGL_ES2       // Emscripten    -> GL ES 2, "#version 100"[m
[32m+[m[32m#endif[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if defined(IMGUI_IMPL_OPENGL_ES2)[m
[32m+[m[32m#include <GLES2/gl2.h>[m
[32m+[m[32m#elif defined(IMGUI_IMPL_OPENGL_ES3)[m
[32m+[m[32m#include <GLES3/gl3.h>  // Use GL ES 3[m
[32m+[m[32m#else[m
[32m+[m[32m// About Desktop OpenGL function loaders:[m
[32m+[m[32m//  Modern desktop OpenGL doesn't have a standard portable header file to load OpenGL function pointers.[m
[32m+[m[32m//  Helper libraries are often used for this purpose! Here we are supporting a few common ones (gl3w, glew, glad).[m
[32m+[m[32m//  You may use another loader/header of your choice (glext, glLoadGen, etc.), or chose to manually implement your own.[m
[32m+[m[32m#if defined(IMGUI_IMPL_OPENGL_LOADER_GL3W)[m
[32m+[m[32m#include <GL/gl3w.h>    // Needs to be initialized with gl3wInit() in user's code[m
[32m+[m[32m#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLEW)[m
[32m+[m[32m#include <GL/glew.h>    // Needs to be initialized with glewInit() in user's code[m
[32m+[m[32m#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLAD)[m
[32m+[m[32m#include <glad/glad.h>  // Needs to be initialized with gladLoadGL() in user's code[m
[32m+[m[32m#else[m
[32m+[m[32m#include IMGUI_IMPL_OPENGL_LOADER_CUSTOM[m
[32m+[m[32m#endif[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// OpenGL Data[m
[32m+[m[32mstatic char         g_GlslVersionString[32] = "";[m
[32m+[m[32mstatic GLuint       g_FontTexture = 0;[m
[32m+[m[32mstatic GLuint       g_ShaderHandle = 0, g_VertHandle = 0, g_FragHandle = 0;[m
[32m+[m[32mstatic int          g_AttribLocationTex = 0, g_AttribLocationProjMtx = 0;                                // Uniforms location[m
[32m+[m[32mstatic int          g_AttribLocationVtxPos = 0, g_AttribLocationVtxUV = 0, g_AttribLocationVtxColor = 0; // Vertex attributes location[m
[32m+[m[32mstatic unsigned int g_VboHandle = 0, g_ElementsHandle = 0;[m
[32m+[m
[32m+[m[32m// Functions[m
[32m+[m[32mbool    ImGui_ImplOpenGL3_Init(const char* glsl_version)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m    io.BackendRendererName = "imgui_impl_opengl3";[m
[32m+[m
[32m+[m[32m    // Store GLSL version string so we can refer to it later in case we recreate shaders. Note: GLSL version is NOT the same as GL version. Leave this to NULL if unsure.[m
[32m+[m[32m#if defined(IMGUI_IMPL_OPENGL_ES2)[m
[32m+[m[32m    if (glsl_version == NULL)[m
[32m+[m[32m        glsl_version = "#version 100";[m
[32m+[m[32m#elif defined(IMGUI_IMPL_OPENGL_ES3)[m
[32m+[m[32m    if (glsl_version == NULL)[m
[32m+[m[32m        glsl_version = "#version 300 es";[m
[32m+[m[32m#else[m
[32m+[m[32m    if (glsl_version == NULL)[m
[32m+[m[32m        glsl_version = "#version 130";[m
[32m+[m[32m#endif[m
[32m+[m[32m    IM_ASSERT((int)strlen(glsl_version) + 2 < IM_ARRAYSIZE(g_GlslVersionString));[m
[32m+[m[32m    strcpy(g_GlslVersionString, glsl_version);[m
[32m+[m[32m    strcat(g_GlslVersionString, "\n");[m
[32m+[m
[32m+[m[32m    // Make a dummy GL call (we don't actually need the result)[m
[32m+[m[32m    // IF YOU GET A CRASH HERE: it probably means that you haven't initialized the OpenGL function loader used by this code.[m
[32m+[m[32m    // Desktop OpenGL 3/4 need a function loader. See the IMGUI_IMPL_OPENGL_LOADER_xxx explanation above.[m
[32m+[m[32m    GLint current_texture;[m
[32m+[m[32m    glGetIntegerv(GL_TEXTURE_BINDING_2D, &current_texture);[m
[32m+[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid    ImGui_ImplOpenGL3_Shutdown()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGui_ImplOpenGL3_DestroyDeviceObjects();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid    ImGui_ImplOpenGL3_NewFrame()[m
[32m+[m[32m{[m
[32m+[m[32m    if (!g_FontTexture)[m
[32m+[m[32m        ImGui_ImplOpenGL3_CreateDeviceObjects();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void ImGui_ImplOpenGL3_SetupRenderState(ImDrawData* draw_data, int fb_width, int fb_height, GLuint vertex_array_object)[m
[32m+[m[32m{[m
[32m+[m[32m    // Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled, polygon fill[m
[32m+[m[32m    glEnable(GL_BLEND);[m
[32m+[m[32m    glBlendEquation(GL_FUNC_ADD);[m
[32m+[m[32m    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);[m
[32m+[m[32m    glDisable(GL_CULL_FACE);[m
[32m+[m[32m    glDisable(GL_DEPTH_TEST);[m
[32m+[m[32m    glEnable(GL_SCISSOR_TEST);[m
[32m+[m[32m#ifdef GL_POLYGON_MODE[m
[32m+[m[32m    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m    // Setup viewport, orthographic projection matrix[m
[32m+[m[32m    // Our visible imgui space lies from draw_data->DisplayPos (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right). DisplayMin is typically (0,0) for single viewport apps.[m
[32m+[m[32m    glViewport(0, 0, (GLsizei)fb_width, (GLsizei)fb_height);[m
[32m+[m[32m    float L = draw_data->DisplayPos.x;[m
[32m+[m[32m    float R = draw_data->DisplayPos.x + draw_data->DisplaySize.x;[m
[32m+[m[32m    float T = draw_data->DisplayPos.y;[m
[32m+[m[32m    float B = draw_data->DisplayPos.y + draw_data->DisplaySize.y;[m
[32m+[m[32m    const float ortho_projection[4][4] =[m
[32m+[m[32m    {[m
[32m+[m[32m        { 2.0f/(R-L),   0.0f,         0.0f,   0.0f },[m
[32m+[m[32m        { 0.0f,         2.0f/(T-B),   0.0f,   0.0f },[m
[32m+[m[32m        { 0.0f,         0.0f,        -1.0f,   0.0f },[m
[32m+[m[32m        { (R+L)/(L-R),  (T+B)/(B-T),  0.0f,   1.0f },[m
[32m+[m[32m    };[m
[32m+[m[32m    glUseProgram(g_ShaderHandle);[m
[32m+[m[32m    glUniform1i(g_AttribLocationTex, 0);[m
[32m+[m[32m    glUniformMatrix4fv(g_AttribLocationProjMtx, 1, GL_FALSE, &ortho_projection[0][0]);[m
[32m+[m[32m#ifdef GL_SAMPLER_BINDING[m
[32m+[m[32m    glBindSampler(0, 0); // We use combined texture/sampler state. Applications using GL 3.3 may set that otherwise.[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m    (void)vertex_array_object;[m
[32m+[m[32m#ifndef IMGUI_IMPL_OPENGL_ES2[m
[32m+[m[32m    glBindVertexArray(vertex_array_object);[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m    // Bind vertex/index buffers and setup attributes for ImDrawVert[m
[32m+[m[32m    glBindBuffer(GL_ARRAY_BUFFER, g_VboHandle);[m
[32m+[m[32m    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_ElementsHandle);[m
[32m+[m[32m    glEnableVertexAttribArray(g_AttribLocationVtxPos);[m
[32m+[m[32m    glEnableVertexAttribArray(g_AttribLocationVtxUV);[m
[32m+[m[32m    glEnableVertexAttribArray(g_AttribLocationVtxColor);[m
[32m+[m[32m    glVertexAttribPointer(g_AttribLocationVtxPos,   2, GL_FLOAT,         GL_FALSE, sizeof(ImDrawVert), (GLvoid*)IM_OFFSETOF(ImDrawVert, pos));[m
[32m+[m[32m    glVertexAttribPointer(g_AttribLocationVtxUV,    2, GL_FLOAT,         GL_FALSE, sizeof(ImDrawVert), (GLvoid*)IM_OFFSETOF(ImDrawVert, uv));[m
[32m+[m[32m    glVertexAttribPointer(g_AttribLocationVtxColor, 4, GL_UNSIGNED_BYTE, GL_TRUE,  sizeof(ImDrawVert), (GLvoid*)IM_OFFSETOF(ImDrawVert, col));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// OpenGL3 Render function.[m
[32m+[m[32m// (this used to be set in io.RenderDrawListsFn and called by ImGui::Render(), but you can now call this directly from your main loop)[m
[32m+[m[32m// Note that this implementation is little overcomplicated because we are saving/setting up/restoring every OpenGL state explicitly, in order to be able to run within any OpenGL engine that doesn't do so.[m
[32m+[m[32mvoid    ImGui_ImplOpenGL3_RenderDrawData(ImDrawData* draw_data)[m
[32m+[m[32m{[m
[32m+[m[32m    // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)[m
[32m+[m[32m    int fb_width = (int)(draw_data->DisplaySize.x * draw_data->FramebufferScale.x);[m
[32m+[m[32m    int fb_height = (int)(draw_data->DisplaySize.y * draw_data->FramebufferScale.y);[m
[32m+[m[32m    if (fb_width <= 0 || fb_height <= 0)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // Backup GL state[m
[32m+[m[32m    GLenum last_active_texture; glGetIntegerv(GL_ACTIVE_TEXTURE, (GLint*)&last_active_texture);[m
[32m+[m[32m    glActiveTexture(GL_TEXTURE0);[m
[32m+[m[32m    GLint last_program; glGetIntegerv(GL_CURRENT_PROGRAM, &last_program);[m
[32m+[m[32m    GLint last_texture; glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);[m
[32m+[m[32m#ifdef GL_SAMPLER_BINDING[m
[32m+[m[32m    GLint last_sampler; glGetIntegerv(GL_SAMPLER_BINDING, &last_sampler);[m
[32m+[m[32m#endif[m
[32m+[m[32m    GLint last_array_buffer; glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &last_array_buffer);[m
[32m+[m[32m#ifndef IMGUI_IMPL_OPENGL_ES2[m
[32m+[m[32m    GLint last_vertex_array_object; glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &last_vertex_array_object);[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef GL_POLYGON_MODE[m
[32m+[m[32m    GLint last_polygon_mode[2]; glGetIntegerv(GL_POLYGON_MODE, last_polygon_mode);[m
[32m+[m[32m#endif[m
[32m+[m[32m    GLint last_viewport[4]; glGetIntegerv(GL_VIEWPORT, last_viewport);[m
[32m+[m[32m    GLint last_scissor_box[4]; glGetIntegerv(GL_SCISSOR_BOX, last_scissor_box);[m
[32m+[m[32m    GLenum last_blend_src_rgb; glGetIntegerv(GL_BLEND_SRC_RGB, (GLint*)&last_blend_src_rgb);[m
[32m+[m[32m    GLenum last_blend_dst_rgb; glGetIntegerv(GL_BLEND_DST_RGB, (GLint*)&last_blend_dst_rgb);[m
[32m+[m[32m    GLenum last_blend_src_alpha; glGetIntegerv(GL_BLEND_SRC_ALPHA, (GLint*)&last_blend_src_alpha);[m
[32m+[m[32m    GLenum last_blend_dst_alpha; glGetIntegerv(GL_BLEND_DST_ALPHA, (GLint*)&last_blend_dst_alpha);[m
[32m+[m[32m    GLenum last_blend_equation_rgb; glGetIntegerv(GL_BLEND_EQUATION_RGB, (GLint*)&last_blend_equation_rgb);[m
[32m+[m[32m    GLenum last_blend_equation_alpha; glGetIntegerv(GL_BLEND_EQUATION_ALPHA, (GLint*)&last_blend_equation_alpha);[m
[32m+[m[32m    GLboolean last_enable_blend = glIsEnabled(GL_BLEND);[m
[32m+[m[32m    GLboolean last_enable_cull_face = glIsEnabled(GL_CULL_FACE);[m
[32m+[m[32m    GLboolean last_enable_depth_test = glIsEnabled(GL_DEPTH_TEST);[m
[32m+[m[32m    GLboolean last_enable_scissor_test = glIsEnabled(GL_SCISSOR_TEST);[m
[32m+[m[32m    bool clip_origin_lower_left = true;[m
[32m+[m[32m#if defined(GL_CLIP_ORIGIN) && !defined(__APPLE__)[m
[32m+[m[32m    GLenum last_clip_origin = 0; glGetIntegerv(GL_CLIP_ORIGIN, (GLint*)&last_clip_origin); // Support for GL 4.5's glClipControl(GL_UPPER_LEFT)[m
[32m+[m[32m    if (last_clip_origin == GL_UPPER_LEFT)[m
[32m+[m[32m        clip_origin_lower_left = false;[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m    // Setup desired GL state[m
[32m+[m[32m    // Recreate the VAO every time (this is to easily allow multiple GL contexts to be rendered to. VAO are not shared among GL contexts)[m
[32m+[m[32m    // The renderer would actually work without any VAO bound, but then our VertexAttrib calls would overwrite the default one currently bound.[m
[32m+[m[32m    GLuint vertex_array_object = 0;[m
[32m+[m[32m#ifndef IMGUI_IMPL_OPENGL_ES2[m
[32m+[m[32m    glGenVertexArrays(1, &vertex_array_object);[m
[32m+[m[32m#endif[m
[32m+[m[32m    ImGui_ImplOpenGL3_SetupRenderState(draw_data, fb_width, fb_height, vertex_array_object);[m
[32m+[m
[32m+[m[32m    // Will project scissor/clipping rectangles into framebuffer space[m
[32m+[m[32m    ImVec2 clip_off = draw_data->DisplayPos;         // (0,0) unless using multi-viewports[m
[32m+[m[32m    ImVec2 clip_scale = draw_data->FramebufferScale; // (1,1) unless using retina display which are often (2,2)[m
[32m+[m
[32m+[m[32m    // Render command lists[m
[32m+[m[32m    for (int n = 0; n < draw_data->CmdListsCount; n++)[m
[32m+[m[32m    {[m
[32m+[m[32m        const ImDrawList* cmd_list = draw_data->CmdLists[n];[m
[32m+[m[32m        size_t idx_buffer_offset = 0;[m
[32m+[m
[32m+[m[32m        // Upload vertex/index buffers[m
[32m+[m[32m        glBufferData(GL_ARRAY_BUFFER, (GLsizeiptr)cmd_list->VtxBuffer.Size * sizeof(ImDrawVert), (const GLvoid*)cmd_list->VtxBuffer.Data, GL_STREAM_DRAW);[m
[32m+[m[32m        glBufferData(GL_ELEMENT_ARRAY_BUFFER, (GLsizeiptr)cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx), (const GLvoid*)cmd_list->IdxBuffer.Data, GL_STREAM_DRAW);[m
[32m+[m
[32m+[m[32m        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];[m
[32m+[m[32m            if (pcmd->UserCallback != NULL)[m
[32m+[m[32m            {[m
[32m+[m[32m                // User callback, registered via ImDrawList::AddCallback()[m
[32m+[m[32m                // (ImDrawCallback_ResetRenderState is a special callback value used by the user to request the renderer to reset render state.)[m
[32m+[m[32m                if (pcmd->UserCallback == ImDrawCallback_ResetRenderState)[m
[32m+[m[32m                    ImGui_ImplOpenGL3_SetupRenderState(draw_data, fb_width, fb_height, vertex_array_object);[m
[32m+[m[32m                else[m
[32m+[m[32m                    pcmd->UserCallback(cmd_list, pcmd);[m
[32m+[m[32m            }[m
[32m+[m[32m            else[m
[32m+[m[32m            {[m
[32m+[m[32m                // Project scissor/clipping rectangles into framebuffer space[m
[32m+[m[32m                ImVec4 clip_rect;[m
[32m+[m[32m                clip_rect.x = (pcmd->ClipRect.x - clip_off.x) * clip_scale.x;[m
[32m+[m[32m                clip_rect.y = (pcmd->ClipRect.y - clip_off.y) * clip_scale.y;[m
[32m+[m[32m                clip_rect.z = (pcmd->ClipRect.z - clip_off.x) * clip_scale.x;[m
[32m+[m[32m                clip_rect.w = (pcmd->ClipRect.w - clip_off.y) * clip_scale.y;[m
[32m+[m
[32m+[m[32m                if (clip_rect.x < fb_width && clip_rect.y < fb_height && clip_rect.z >= 0.0f && clip_rect.w >= 0.0f)[m
[32m+[m[32m                {[m
[32m+[m[32m                    // Apply scissor/clipping rectangle[m
[32m+[m[32m                    if (clip_origin_lower_left)[m
[32m+[m[32m                        glScissor((int)clip_rect.x, (int)(fb_height - clip_rect.w), (int)(clip_rect.z - clip_rect.x), (int)(clip_rect.w - clip_rect.y));[m
[32m+[m[32m                    else[m
[32m+[m[32m                        glScissor((int)clip_rect.x, (int)clip_rect.y, (int)clip_rect.z, (int)clip_rect.w); // Support for GL 4.5 rarely used glClipControl(GL_UPPER_LEFT)[m
[32m+[m
[32m+[m[32m                    // Bind texture, Draw[m
[32m+[m[32m                    glBindTexture(GL_TEXTURE_2D, (GLuint)(intptr_t)pcmd->TextureId);[m
[32m+[m[32m                    glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, (void*)idx_buffer_offset);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            idx_buffer_offset += pcmd->ElemCount * sizeof(ImDrawIdx);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Destroy the temporary VAO[m
[32m+[m[32m#ifndef IMGUI_IMPL_OPENGL_ES2[m
[32m+[m[32m    glDeleteVertexArrays(1, &vertex_array_object);[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m    // Restore modified GL state[m
[32m+[m[32m    glUseProgram(last_program);[m
[32m+[m[32m    glBindTexture(GL_TEXTURE_2D, last_texture);[m
[32m+[m[32m#ifdef GL_SAMPLER_BINDING[m
[32m+[m[32m    glBindSampler(0, last_sampler);[m
[32m+[m[32m#endif[m
[32m+[m[32m    glActiveTexture(last_active_texture);[m
[32m+[m[32m#ifndef IMGUI_IMPL_OPENGL_ES2[m
[32m+[m[32m    glBindVertexArray(last_vertex_array_object);[m
[32m+[m[32m#endif[m
[32m+[m[32m    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);[m
[32m+[m[32m    glBlendEquationSeparate(last_blend_equation_rgb, last_blend_equation_alpha);[m
[32m+[m[32m    glBlendFuncSeparate(last_blend_src_rgb, last_blend_dst_rgb, last_blend_src_alpha, last_blend_dst_alpha);[m
[32m+[m[32m    if (last_enable_blend) glEnable(GL_BLEND); else glDisable(GL_BLEND);[m
[32m+[m[32m    if (last_enable_cull_face) glEnable(GL_CULL_FACE); else glDisable(GL_CULL_FACE);[m
[32m+[m[32m    if (last_enable_depth_test) glEnable(GL_DEPTH_TEST); else glDisable(GL_DEPTH_TEST);[m
[32m+[m[32m    if (last_enable_scissor_test) glEnable(GL_SCISSOR_TEST); else glDisable(GL_SCISSOR_TEST);[m
[32m+[m[32m#ifdef GL_POLYGON_MODE[m
[32m+[m[32m    glPolygonMode(GL_FRONT_AND_BACK, (GLenum)last_polygon_mode[0]);[m
[32m+[m[32m#endif[m
[32m+[m[32m    glViewport(last_viewport[0], last_viewport[1], (GLsizei)last_viewport[2], (GLsizei)last_viewport[3]);[m
[32m+[m[32m    glScissor(last_scissor_box[0], last_scissor_box[1], (GLsizei)last_scissor_box[2], (GLsizei)last_scissor_box[3]);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui_ImplOpenGL3_CreateFontsTexture()[m
[32m+[m[32m{[m
[32m+[m[32m    // Build texture atlas[m
[32m+[m[32m    ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m    unsigned char* pixels;[m
[32m+[m[32m    int width, height;[m
[32m+[m[32m    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);   // Load as RGBA 32-bits (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.[m
[32m+[m
[32m+[m[32m    // Upload texture to graphics system[m
[32m+[m[32m    GLint last_texture;[m
[32m+[m[32m    glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);[m
[32m+[m[32m    glGenTextures(1, &g_FontTexture);[m
[32m+[m[32m    glBindTexture(GL_TEXTURE_2D, g_FontTexture);[m
[32m+[m[32m    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);[m
[32m+[m[32m    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);[m
[32m+[m[32m#ifdef GL_UNPACK_ROW_LENGTH[m
[32m+[m[32m    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);[m
[32m+[m[32m#endif[m
[32m+[m[32m    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);[m
[32m+[m
[32m+[m[32m    // Store our identifier[m
[32m+[m[32m    io.Fonts->TexID = (ImTextureID)(intptr_t)g_FontTexture;[m
[32m+[m
[32m+[m[32m    // Restore state[m
[32m+[m[32m    glBindTexture(GL_TEXTURE_2D, last_texture);[m
[32m+[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui_ImplOpenGL3_DestroyFontsTexture()[m
[32m+[m[32m{[m
[32m+[m[32m    if (g_FontTexture)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiIO& io = ImGui::GetIO();[m
[32m+[m[32m        glDeleteTextures(1, &g_FontTexture);[m
[32m+[m[32m        io.Fonts->TexID = 0;[m
[32m+[m[32m        g_FontTexture = 0;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// If you get an error please report on github. You may try different GL context version or GLSL version. See GL<>GLSL version table at the top of this file.[m
[32m+[m[32mstatic bool CheckShader(GLuint handle, const char* desc)[m
[32m+[m[32m{[m
[32m+[m[32m    GLint status = 0, log_length = 0;[m
[32m+[m[32m    glGetShaderiv(handle, GL_COMPILE_STATUS, &status);[m
[32m+[m[32m    glGetShaderiv(handle, GL_INFO_LOG_LENGTH, &log_length);[m
[32m+[m[32m    if ((GLboolean)status == GL_FALSE)[m
[32m+[m[32m        fprintf(stderr, "ERROR: ImGui_ImplOpenGL3_CreateDeviceObjects: failed to compile %s!\n", desc);[m
[32m+[m[32m    if (log_length > 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImVector<char> buf;[m
[32m+[m[32m        buf.resize((int)(log_length + 1));[m
[32m+[m[32m        glGetShaderInfoLog(handle, log_length, NULL, (GLchar*)buf.begin());[m
[32m+[m[32m        fprintf(stderr, "%s\n", buf.begin());[m
[32m+[m[32m    }[m
[32m+[m[32m    return (GLboolean)status == GL_TRUE;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// If you get an error please report on GitHub. You may try different GL context version or GLSL version.[m
[32m+[m[32mstatic bool CheckProgram(GLuint handle, const char* desc)[m
[32m+[m[32m{[m
[32m+[m[32m    GLint status = 0, log_length = 0;[m
[32m+[m[32m    glGetProgramiv(handle, GL_LINK_STATUS, &status);[m
[32m+[m[32m    glGetProgramiv(handle, GL_INFO_LOG_LENGTH, &log_length);[m
[32m+[m[32m    if ((GLboolean)status == GL_FALSE)[m
[32m+[m[32m        fprintf(stderr, "ERROR: ImGui_ImplOpenGL3_CreateDeviceObjects: failed to link %s! (with GLSL '%s')\n", desc, g_GlslVersionString);[m
[32m+[m[32m    if (log_length > 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImVector<char> buf;[m
[32m+[m[32m        buf.resize((int)(log_length + 1));[m
[32m+[m[32m        glGetProgramInfoLog(handle, log_length, NULL, (GLchar*)buf.begin());[m
[32m+[m[32m        fprintf(stderr, "%s\n", buf.begin());[m
[32m+[m[32m    }[m
[32m+[m[32m    return (GLboolean)status == GL_TRUE;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool    ImGui_ImplOpenGL3_CreateDeviceObjects()[m
[32m+[m[32m{[m
[32m+[m[32m    // Backup GL state[m
[32m+[m[32m    GLint last_texture, last_array_buffer;[m
[32m+[m[32m    glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);[m
[32m+[m[32m    glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &last_array_buffer);[m
[32m+[m[32m#ifndef IMGUI_IMPL_OPENGL_ES2[m
[32m+[m[32m    GLint last_vertex_array;[m
[32m+[m[32m    glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &last_vertex_array);[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m    // Parse GLSL version string[m
[32m+[m[32m    int glsl_version = 130;[m
[32m+[m[32m    sscanf(g_GlslVersionString, "#version %d", &glsl_version);[m
[32m+[m
[32m+[m[32m    const GLchar* vertex_shader_glsl_120 =[m
[32m+[m[32m        "uniform mat4 ProjMtx;\n"[m
[32m+[m[32m        "attribute vec2 Position;\n"[m
[32m+[m[32m        "attribute vec2 UV;\n"[m
[32m+[m[32m        "attribute vec4 Color;\n"[m
[32m+[m[32m        "varying vec2 Frag_UV;\n"[m
[32m+[m[32m        "varying vec4 Frag_Color;\n"[m
[32m+[m[32m        "void main()\n"[m
[32m+[m[32m        "{\n"[m
[32m+[m[32m        "    Frag_UV = UV;\n"[m
[32m+[m[32m        "    Frag_Color = Color;\n"[m
[32m+[m[32m        "    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"[m
[32m+[m[32m        "}\n";[m
[32m+[m
[32m+[m[32m    const GLchar* vertex_shader_glsl_130 =[m
[32m+[m[32m        "uniform mat4 ProjMtx;\n"[m
[32m+[m[32m        "in vec2 Position;\n"[m
[32m+[m[32m        "in vec2 UV;\n"[m
[32m+[m[32m        "in vec4 Color;\n"[m
[32m+[m[32m        "out vec2 Frag_UV;\n"[m
[32m+[m[32m        "out vec4 Frag_Color;\n"[m
[32m+[m[32m        "void main()\n"[m
[32m+[m[32m        "{\n"[m
[32m+[m[32m        "    Frag_UV = UV;\n"[m
[32m+[m[32m        "    Frag_Color = Color;\n"[m
[32m+[m[32m        "    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"[m
[32m+[m[32m        "}\n";[m
[32m+[m
[32m+[m[32m    const GLchar* vertex_shader_glsl_300_es =[m
[32m+[m[32m        "precision mediump float;\n"[m
[32m+[m[32m        "layout (location = 0) in vec2 Position;\n"[m
[32m+[m[32m        "layout (location = 1) in vec2 UV;\n"[m
[32m+[m[32m        "layout (location = 2) in vec4 Color;\n"[m
[32m+[m[32m        "uniform mat4 ProjMtx;\n"[m
[32m+[m[32m        "out vec2 Frag_UV;\n"[m
[32m+[m[32m        "out vec4 Frag_Color;\n"[m
[32m+[m[32m        "void main()\n"[m
[32m+[m[32m        "{\n"[m
[32m+[m[32m        "    Frag_UV = UV;\n"[m
[32m+[m[32m        "    Frag_Color = Color;\n"[m
[32m+[m[32m        "    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"[m
[32m+[m[32m        "}\n";[m
[32m+[m
[32m+[m[32m    const GLchar* vertex_shader_glsl_410_core =[m
[32m+[m[32m        "layout (location = 0) in vec2 Position;\n"[m
[32m+[m[32m        "layout (location = 1) in vec2 UV;\n"[m
[32m+[m[32m        "layout (location = 2) in vec4 Color;\n"[m
[32m+[m[32m        "uniform mat4 ProjMtx;\n"[m
[32m+[m[32m        "out vec2 Frag_UV;\n"[m
[32m+[m[32m        "out vec4 Frag_Color;\n"[m
[32m+[m[32m        "void main()\n"[m
[32m+[m[32m        "{\n"[m
[32m+[m[32m        "    Frag_UV = UV;\n"[m
[32m+[m[32m        "    Frag_Color = Color;\n"[m
[32m+[m[32m        "    gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"[m
[32m+[m[32m        "}\n";[m
[32m+[m
[32m+[m[32m    const GLchar* fragment_shader_glsl_120 =[m
[32m+[m[32m        "#ifdef GL_ES\n"[m
[32m+[m[32m        "    precision mediump float;\n"[m
[32m+[m[32m        "#endif\n"[m
[32m+[m[32m        "uniform sampler2D Texture;\n"[m
[32m+[m[32m        "varying vec2 Frag_UV;\n"[m
[32m+[m[32m        "varying vec4 Frag_Color;\n"[m
[32m+[m[32m        "void main()\n"[m
[32m+[m[32m        "{\n"[m
[32m+[m[32m        "    gl_FragColor = Frag_Color * texture2D(Texture, Frag_UV.st);\n"[m
[32m+[m[32m        "}\n";[m
[32m+[m
[32m+[m[32m    const GLchar* fragment_shader_glsl_130 =[m
[32m+[m[32m        "uniform sampler2D Texture;\n"[m
[32m+[m[32m        "in vec2 Frag_UV;\n"[m
[32m+[m[32m        "in vec4 Frag_Color;\n"[m
[32m+[m[32m        "out vec4 Out_Color;\n"[m
[32m+[m[32m        "void main()\n"[m
[32m+[m[32m        "{\n"[m
[32m+[m[32m        "    Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\n"[m
[32m+[m[32m        "}\n";[m
[32m+[m
[32m+[m[32m    const GLchar* fragment_shader_glsl_300_es =[m
[32m+[m[32m        "precision mediump float;\n"[m
[32m+[m[32m        "uniform sampler2D Texture;\n"[m
[32m+[m[32m        "in vec2 Frag_UV;\n"[m
[32m+[m[32m        "in vec4 Frag_Color;\n"[m
[32m+[m[32m        "layout (location = 0) out vec4 Out_Color;\n"[m
[32m+[m[32m        "void main()\n"[m
[32m+[m[32m        "{\n"[m
[32m+[m[32m        "    Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\n"[m
[32m+[m[32m        "}\n";[m
[32m+[m
[32m+[m[32m    const GLchar* fragment_shader_glsl_410_core =[m
[32m+[m[32m        "in vec2 Frag_UV;\n"[m
[32m+[m[32m        "in vec4 Frag_Color;\n"[m
[32m+[m[32m        "uniform sampler2D Texture;\n"[m
[32m+[m[32m        "layout (location = 0) out vec4 Out_Color;\n"[m
[32m+[m[32m        "void main()\n"[m
[32m+[m[32m        "{\n"[m
[32m+[m[32m        "    Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\n"[m
[32m+[m[32m        "}\n";[m
[32m+[m
[32m+[m[32m    // Select shaders matching our GLSL versions[m
[32m+[m[32m    const GLchar* vertex_shader = NULL;[m
[32m+[m[32m    const GLchar* fragment_shader = NULL;[m
[32m+[m[32m    if (glsl_version < 130)[m
[32m+[m[32m    {[m
[32m+[m[32m        vertex_shader = vertex_shader_glsl_120;[m
[32m+[m[32m        fragment_shader = fragment_shader_glsl_120;[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (glsl_version >= 410)[m
[32m+[m[32m    {[m
[32m+[m[32m        vertex_shader = vertex_shader_glsl_410_core;[m
[32m+[m[32m        fragment_shader = fragment_shader_glsl_410_core;[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (glsl_version == 300)[m
[32m+[m[32m    {[m
[32m+[m[32m        vertex_shader = vertex_shader_glsl_300_es;[m
[32m+[m[32m        fragment_shader = fragment_shader_glsl_300_es;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        vertex_shader = vertex_shader_glsl_130;[m
[32m+[m[32m        fragment_shader = fragment_shader_glsl_130;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Create shaders[m
[32m+[m[32m    const GLchar* vertex_shader_with_version[2] = { g_GlslVersionString, vertex_shader };[m
[32m+[m[32m    g_VertHandle = glCreateShader(GL_VERTEX_SHADER);[m
[32m+[m[32m    glShaderSource(g_VertHandle, 2, vertex_shader_with_version, NULL);[m
[32m+[m[32m    glCompileShader(g_VertHandle);[m
[32m+[m[32m    CheckShader(g_VertHandle, "vertex shader");[m
[32m+[m
[32m+[m[32m    const GLchar* fragment_shader_with_version[2] = { g_GlslVersionString, fragment_shader };[m
[32m+[m[32m    g_FragHandle = glCreateShader(GL_FRAGMENT_SHADER);[m
[32m+[m[32m    glShaderSource(g_FragHandle, 2, fragment_shader_with_version, NULL);[m
[32m+[m[32m    glCompileShader(g_FragHandle);[m
[32m+[m[32m    CheckShader(g_FragHandle, "fragment shader");[m
[32m+[m
[32m+[m[32m    g_ShaderHandle = glCreateProgram();[m
[32m+[m[32m    glAttachShader(g_ShaderHandle, g_VertHandle);[m
[32m+[m[32m    glAttachShader(g_ShaderHandle, g_FragHandle);[m
[32m+[m[32m    glLinkProgram(g_ShaderHandle);[m
[32m+[m[32m    CheckProgram(g_ShaderHandle, "shader program");[m
[32m+[m
[32m+[m[32m    g_AttribLocationTex = glGetUniformLocation(g_ShaderHandle, "Texture");[m
[32m+[m[32m    g_AttribLocationProjMtx = glGetUniformLocation(g_ShaderHandle, "ProjMtx");[m
[32m+[m[32m    g_AttribLocationVtxPos = glGetAttribLocation(g_ShaderHandle, "Position");[m
[32m+[m[32m    g_AttribLocationVtxUV = glGetAttribLocation(g_ShaderHandle, "UV");[m
[32m+[m[32m    g_AttribLocationVtxColor = glGetAttribLocation(g_ShaderHandle, "Color");[m
[32m+[m
[32m+[m[32m    // Create buffers[m
[32m+[m[32m    glGenBuffers(1, &g_VboHandle);[m
[32m+[m[32m    glGenBuffers(1, &g_ElementsHandle);[m
[32m+[m
[32m+[m[32m    ImGui_ImplOpenGL3_CreateFontsTexture();[m
[32m+[m
[32m+[m[32m    // Restore modified GL state[m
[32m+[m[32m    glBindTexture(GL_TEXTURE_2D, last_texture);[m
[32m+[m[32m    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);[m
[32m+[m[32m#ifndef IMGUI_IMPL_OPENGL_ES2[m
[32m+[m[32m    glBindVertexArray(last_vertex_array);[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid    ImGui_ImplOpenGL3_DestroyDeviceObjects()[m
[32m+[m[32m{[m
[32m+[m[32m    if (g_VboHandle) glDeleteBuffers(1, &g_VboHandle);[m
[32m+[m[32m    if (g_ElementsHandle) glDeleteBuffers(1, &g_ElementsHandle);[m
[32m+[m[32m    g_VboHandle = g_ElementsHandle = 0;[m
[32m+[m
[32m+[m[32m    if (g_ShaderHandle && g_VertHandle) glDetachShader(g_ShaderHandle, g_VertHandle);[m
[32m+[m[32m    if (g_VertHandle) glDeleteShader(g_VertHandle);[m
[32m+[m[32m    g_VertHandle = 0;[m
[32m+[m
[32m+[m[32m    if (g_ShaderHandle && g_FragHandle) glDetachShader(g_ShaderHandle, g_FragHandle);[m
[32m+[m[32m    if (g_FragHandle) glDeleteShader(g_FragHandle);[m
[32m+[m[32m    g_FragHandle = 0;[m
[32m+[m
[32m+[m[32m    if (g_ShaderHandle) glDeleteProgram(g_ShaderHandle);[m
[32m+[m[32m    g_ShaderHandle = 0;[m
[32m+[m
[32m+[m[32m    ImGui_ImplOpenGL3_DestroyFontsTexture();[m
[32m+[m[32m}[m
[1mdiff --git a/vendor/source/ImGui/imgui_impl_opengl3.h b/vendor/source/ImGui/imgui_impl_opengl3.h[m
[1mnew file mode 100644[m
[1mindex 0000000..9fe2a88[m
[1m--- /dev/null[m
[1m+++ b/vendor/source/ImGui/imgui_impl_opengl3.h[m
[36m@@ -0,0 +1,46 @@[m
[32m+[m[32m// dear imgui: Renderer for modern OpenGL with shaders / programmatic pipeline[m
[32m+[m[32m// - Desktop GL: 3.x 4.x[m
[32m+[m[32m// - Embedded GL: ES 2.0 (WebGL 1.0), ES 3.0 (WebGL 2.0)[m
[32m+[m[32m// This needs to be used along with a Platform Binding (e.g. GLFW, SDL, Win32, custom..)[m
[32m+[m
[32m+[m[32m// Implemented features:[m
[32m+[m[32m//  [X] Renderer: User texture binding. Use 'GLuint' OpenGL texture identifier as void*/ImTextureID. Read the FAQ about ImTextureID in imgui.cpp.[m
[32m+[m
[32m+[m[32m// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.[m
[32m+[m[32m// If you are new to dear imgui, read examples/README.txt and read the documentation at the top of imgui.cpp.[m
[32m+[m[32m// https://github.com/ocornut/imgui[m
[32m+[m
[32m+[m[32m// About Desktop OpenGL function loaders:[m
[32m+[m[32m//  Modern desktop OpenGL doesn't have a standard portable header file to load OpenGL function pointers.[m
[32m+[m[32m//  Helper libraries are often used for this purpose! Here we are supporting a few common ones (gl3w, glew, glad).[m
[32m+[m[32m//  You may use another loader/header of your choice (glext, glLoadGen, etc.), or chose to manually implement your own.[m
[32m+[m
[32m+[m[32m// About GLSL version:[m
[32m+[m[32m//  The 'glsl_version' initialization parameter should be NULL (default) or a "#version XXX" string.[m
[32m+[m[32m//  On computer platform the GLSL version default to "#version 130". On OpenGL ES 3 platform it defaults to "#version 300 es"[m
[32m+[m[32m//  Only override if your GL version doesn't handle this GLSL version. See GLSL version table at the top of imgui_impl_opengl3.cpp.[m
[32m+[m
[32m+[m[32m#pragma once[m
[32m+[m
[32m+[m[32m// Specific OpenGL versions[m
[32m+[m[32m//#define IMGUI_IMPL_OPENGL_ES2     // Auto-detected on Emscripten[m
[32m+[m[32m//#define IMGUI_IMPL_OPENGL_ES3     // Auto-detected on iOS/Android[m
[32m+[m
[32m+[m[32m// Set default OpenGL3 loader to be gl3w[m
[32m+[m[32m#if !defined(IMGUI_IMPL_OPENGL_LOADER_GL3W)     \[m
[32m+[m[32m && !defined(IMGUI_IMPL_OPENGL_LOADER_GLEW)     \[m
[32m+[m[32m && !defined(IMGUI_IMPL_OPENGL_LOADER_GLAD)     \[m
[32m+[m[32m && !defined(IMGUI_IMPL_OPENGL_LOADER_CUSTOM)[m
[32m+[m[32m#define IMGUI_IMPL_OPENGL_LOADER_GL3W[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32mIMGUI_IMPL_API bool     ImGui_ImplOpenGL3_Init(const char* glsl_version = NULL);[m
[32m+[m[32mIMGUI_IMPL_API void     ImGui_ImplOpenGL3_Shutdown();[m
[32m+[m[32mIMGUI_IMPL_API void     ImGui_ImplOpenGL3_NewFrame();[m
[32m+[m[32mIMGUI_IMPL_API void     ImGui_ImplOpenGL3_RenderDrawData(ImDrawData* draw_data);[m
[32m+[m
[32m+[m[32m// Called by Init/NewFrame/Shutdown[m
[32m+[m[32mIMGUI_IMPL_API bool     ImGui_ImplOpenGL3_CreateFontsTexture();[m
[32m+[m[32mIMGUI_IMPL_API void     ImGui_ImplOpenGL3_DestroyFontsTexture();[m
[32m+[m[32mIMGUI_IMPL_API bool     ImGui_ImplOpenGL3_CreateDeviceObjects();[m
[32m+[m[32mIMGUI_IMPL_API void     ImGui_ImplOpenGL3_DestroyDeviceObjects();[m
[1mdiff --git a/vendor/source/ImGui/imgui_internal.h b/vendor/source/ImGui/imgui_internal.h[m
[1mnew file mode 100644[m
[1mindex 0000000..cc98c20[m
[1m--- /dev/null[m
[1m+++ b/vendor/source/ImGui/imgui_internal.h[m
[36m@@ -0,0 +1,1624 @@[m
[32m+[m[32m// dear imgui, v1.70[m
[32m+[m[32m// (internal structures/api)[m
[32m+[m
[32m+[m[32m// You may use this file to debug, understand or extend ImGui features but we don't provide any guarantee of forward compatibility![m
[32m+[m[32m// Set:[m
[32m+[m[32m//   #define IMGUI_DEFINE_MATH_OPERATORS[m
[32m+[m[32m// To implement maths operators for ImVec2 (disabled by default to not collide with using IM_VEC2_CLASS_EXTRA along with your own math types+operators)[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m
[32m+[m[32mIndex of this file:[m
[32m+[m[32m// Header mess[m
[32m+[m[32m// Forward declarations[m
[32m+[m[32m// STB libraries includes[m
[32m+[m[32m// Context pointer[m
[32m+[m[32m// Generic helpers[m
[32m+[m[32m// Misc data structures[m
[32m+[m[32m// Main imgui context[m
[32m+[m[32m// Tab bar, tab item[m
[32m+[m[32m// Internal API[m
[32m+[m
[32m+[m[32m*/[m
[32m+[m
[32m+[m[32m#pragma once[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Header mess[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m#ifndef IMGUI_VERSION[m
[32m+[m[32m#error Must include imgui.h before imgui_internal.h[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#include <stdio.h>      // FILE*[m
[32m+[m[32m#include <stdlib.h>     // NULL, malloc, free, qsort, atoi, atof[m
[32m+[m[32m#include <math.h>       // sqrtf, fabsf, fmodf, powf, floorf, ceilf, cosf, sinf[m
[32m+[m[32m#include <limits.h>     // INT_MIN, INT_MAX[m
[32m+[m
[32m+[m[32m#ifdef _MSC_VER[m
[32m+[m[32m#pragma warning (push)[m
[32m+[m[32m#pragma warning (disable: 4251) // class 'xxx' needs to have dll-interface to be used by clients of struct 'xxx' // when IMGUI_API is set to__declspec(dllexport)[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef __clang__[m
[32m+[m[32m#pragma clang diagnostic push[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wunused-function"                // for stb_textedit.h[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wmissing-prototypes"             // for stb_textedit.h[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wold-style-cast"[m
[32m+[m[32m#if __has_warning("-Wzero-as-null-pointer-constant")[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"[m
[32m+[m[32m#endif[m
[32m+[m[32m#if __has_warning("-Wdouble-promotion")[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wdouble-promotion"[m
[32m+[m[32m#endif[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Forward declarations[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mstruct ImRect;                      // An axis-aligned rectangle (2 points)[m
[32m+[m[32mstruct ImDrawDataBuilder;           // Helper to build a ImDrawData instance[m
[32m+[m[32mstruct ImDrawListSharedData;        // Data shared between all ImDrawList instances[m
[32m+[m[32mstruct ImGuiColorMod;               // Stacked color modifier, backup of modified data so we can restore it[m
[32m+[m[32mstruct ImGuiColumnData;             // Storage data for a single column[m
[32m+[m[32mstruct ImGuiColumns;                // Storage data for a columns set[m
[32m+[m[32mstruct ImGuiContext;                // Main imgui context[m
[32m+[m[32mstruct ImGuiDataTypeInfo;           // Type information associated to a ImGuiDataType enum[m
[32m+[m[32mstruct ImGuiGroupData;              // Stacked storage data for BeginGroup()/EndGroup()[m
[32m+[m[32mstruct ImGuiInputTextState;         // Internal state of the currently focused/edited text input box[m
[32m+[m[32mstruct ImGuiItemHoveredDataBackup;  // Backup and restore IsItemHovered() internal data[m
[32m+[m[32mstruct ImGuiMenuColumns;            // Simple column measurement, currently used for MenuItem() only[m
[32m+[m[32mstruct ImGuiNavMoveResult;          // Result of a directional navigation move query result[m
[32m+[m[32mstruct ImGuiNextWindowData;         // Storage for SetNexWindow** functions[m
[32m+[m[32mstruct ImGuiPopupData;              // Storage for current popup stack[m
[32m+[m[32mstruct ImGuiSettingsHandler;        // Storage for one type registered in the .ini file[m
[32m+[m[32mstruct ImGuiStyleMod;               // Stacked style modifier, backup of modified data so we can restore it[m
[32m+[m[32mstruct ImGuiTabBar;                 // Storage for a tab bar[m
[32m+[m[32mstruct ImGuiTabItem;                // Storage for a tab item (within a tab bar)[m
[32m+[m[32mstruct ImGuiWindow;                 // Storage for one window[m
[32m+[m[32mstruct ImGuiWindowTempData;         // Temporary storage for one window (that's the data which in theory we could ditch at the end of the frame)[m
[32m+[m[32mstruct ImGuiWindowSettings;         // Storage for window settings stored in .ini file (we keep one of those even if the actual window wasn't instanced during this session)[m
[32m+[m
[32m+[m[32m// Use your programming IDE "Go to definition" facility on the names of the center columns to find the actual flags/enum lists.[m
[32m+[m[32mtypedef int ImGuiLayoutType;        // -> enum ImGuiLayoutType_        // Enum: Horizontal or vertical[m
[32m+[m[32mtypedef int ImGuiButtonFlags;       // -> enum ImGuiButtonFlags_       // Flags: for ButtonEx(), ButtonBehavior()[m
[32m+[m[32mtypedef int ImGuiDragFlags;         // -> enum ImGuiDragFlags_         // Flags: for DragBehavior()[m
[32m+[m[32mtypedef int ImGuiItemFlags;         // -> enum ImGuiItemFlags_         // Flags: for PushItemFlag()[m
[32m+[m[32mtypedef int ImGuiItemStatusFlags;   // -> enum ImGuiItemStatusFlags_   // Flags: for DC.LastItemStatusFlags[m
[32m+[m[32mtypedef int ImGuiNavHighlightFlags; // -> enum ImGuiNavHighlightFlags_ // Flags: for RenderNavHighlight()[m
[32m+[m[32mtypedef int ImGuiNavDirSourceFlags; // -> enum ImGuiNavDirSourceFlags_ // Flags: for GetNavInputAmount2d()[m
[32m+[m[32mtypedef int ImGuiNavMoveFlags;      // -> enum ImGuiNavMoveFlags_      // Flags: for navigation requests[m
[32m+[m[32mtypedef int ImGuiSeparatorFlags;    // -> enum ImGuiSeparatorFlags_    // Flags: for Separator() - internal[m
[32m+[m[32mtypedef int ImGuiSliderFlags;       // -> enum ImGuiSliderFlags_       // Flags: for SliderBehavior()[m
[32m+[m[32mtypedef int ImGuiTextFlags;         // -> enum ImGuiTextFlags_         // Flags: for TextEx()[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// STB libraries includes[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mnamespace ImStb[m
[32m+[m[32m{[m
[32m+[m
[32m+[m[32m#undef STB_TEXTEDIT_STRING[m
[32m+[m[32m#undef STB_TEXTEDIT_CHARTYPE[m
[32m+[m[32m#define STB_TEXTEDIT_STRING             ImGuiInputTextState[m
[32m+[m[32m#define STB_TEXTEDIT_CHARTYPE           ImWchar[m
[32m+[m[32m#define STB_TEXTEDIT_GETWIDTH_NEWLINE   -1.0f[m
[32m+[m[32m#define STB_TEXTEDIT_UNDOSTATECOUNT     99[m
[32m+[m[32m#define STB_TEXTEDIT_UNDOCHARCOUNT      999[m
[32m+[m[32m#include "imstb_textedit.h"[m
[32m+[m
[32m+[m[32m} // namespace ImStb[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Context pointer[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m#ifndef GImGui[m
[32m+[m[32mextern IMGUI_API ImGuiContext* GImGui;  // Current implicit ImGui context pointer[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Generic helpers[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m#define IM_PI           3.14159265358979323846f[m
[32m+[m[32m#ifdef _WIN32[m
[32m+[m[32m#define IM_NEWLINE      "\r\n"   // Play it nice with Windows users (2018/05 news: Microsoft announced that Notepad will finally display Unix-style carriage returns!)[m
[32m+[m[32m#else[m
[32m+[m[32m#define IM_NEWLINE      "\n"[m
[32m+[m[32m#endif[m
[32m+[m[32m#define IM_TABSIZE      (4)[m
[32m+[m
[32m+[m[32m#define IMGUI_DEBUG_LOG(_FMT,...)       printf("[%05d] " _FMT, GImGui->FrameCount, __VA_ARGS__)[m
[32m+[m[32m#define IM_STATIC_ASSERT(_COND)         typedef char static_assertion_##__line__[(_COND)?1:-1][m
[32m+[m[32m#define IM_F32_TO_INT8_UNBOUND(_VAL)    ((int)((_VAL) * 255.0f + ((_VAL)>=0 ? 0.5f : -0.5f)))   // Unsaturated, for display purpose[m
[32m+[m[32m#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255[m
[32m+[m
[32m+[m[32m// Enforce cdecl calling convention for functions called by the standard library, in case compilation settings changed the default to e.g. __vectorcall[m
[32m+[m[32m#ifdef _MSC_VER[m
[32m+[m[32m#define IMGUI_CDECL __cdecl[m
[32m+[m[32m#else[m
[32m+[m[32m#define IMGUI_CDECL[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Helpers: UTF-8 <> wchar[m
[32m+[m[32mIMGUI_API int           ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end);      // return output UTF-8 bytes count[m
[32m+[m[32mIMGUI_API int           ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end);          // read one character. return input UTF-8 bytes count[m
[32m+[m[32mIMGUI_API int           ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_remaining = NULL);   // return input UTF-8 bytes count[m
[32m+[m[32mIMGUI_API int           ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end);                            // return number of UTF-8 code-points (NOT bytes count)[m
[32m+[m[32mIMGUI_API int           ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end);                        // return number of bytes to express one char in UTF-8[m
[32m+[m[32mIMGUI_API int           ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end);                   // return number of bytes to express string in UTF-8[m
[32m+[m
[32m+[m[32m// Helpers: Misc[m
[32m+[m[32mIMGUI_API ImU32         ImHashData(const void* data, size_t data_size, ImU32 seed = 0);[m
[32m+[m[32mIMGUI_API ImU32         ImHashStr(const char* data, size_t data_size = 0, ImU32 seed = 0);[m
[32m+[m[32mIMGUI_API void*         ImFileLoadToMemory(const char* filename, const char* file_open_mode, size_t* out_file_size = NULL, int padding_bytes = 0);[m
[32m+[m[32mIMGUI_API FILE*         ImFileOpen(const char* filename, const char* file_open_mode);[m
[32m+[m[32mstatic inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\t'; }[m
[32m+[m[32mstatic inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }[m
[32m+[m[32mstatic inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }[m
[32m+[m[32mstatic inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }[m
[32m+[m[32m#define ImQsort         qsort[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32mstatic inline ImU32     ImHash(const void* data, int size, ImU32 seed = 0) { return size ? ImHashData(data, (size_t)size, seed) : ImHashStr((const char*)data, 0, seed); } // [moved to ImHashStr/ImHashData in 1.68][m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Helpers: Geometry[m
[32m+[m[32mIMGUI_API ImVec2        ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p);[m
[32m+[m[32mIMGUI_API bool          ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);[m
[32m+[m[32mIMGUI_API ImVec2        ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);[m
[32m+[m[32mIMGUI_API void          ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w);[m
[32m+[m[32mIMGUI_API ImGuiDir      ImGetDirQuadrantFromDelta(float dx, float dy);[m
[32m+[m
[32m+[m[32m// Helpers: String[m
[32m+[m[32mIMGUI_API int           ImStricmp(const char* str1, const char* str2);[m
[32m+[m[32mIMGUI_API int           ImStrnicmp(const char* str1, const char* str2, size_t count);[m
[32m+[m[32mIMGUI_API void          ImStrncpy(char* dst, const char* src, size_t count);[m
[32m+[m[32mIMGUI_API char*         ImStrdup(const char* str);[m
[32m+[m[32mIMGUI_API char*         ImStrdupcpy(char* dst, size_t* p_dst_size, const char* str);[m
[32m+[m[32mIMGUI_API const char*   ImStrchrRange(const char* str_begin, const char* str_end, char c);[m
[32m+[m[32mIMGUI_API int           ImStrlenW(const ImWchar* str);[m
[32m+[m[32mIMGUI_API const char*   ImStreolRange(const char* str, const char* str_end);                // End end-of-line[m
[32m+[m[32mIMGUI_API const ImWchar*ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin);   // Find beginning-of-line[m
[32m+[m[32mIMGUI_API const char*   ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end);[m
[32m+[m[32mIMGUI_API void          ImStrTrimBlanks(char* str);[m
[32m+[m[32mIMGUI_API int           ImFormatString(char* buf, size_t buf_size, const char* fmt, ...) IM_FMTARGS(3);[m
[32m+[m[32mIMGUI_API int           ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args) IM_FMTLIST(3);[m
[32m+[m[32mIMGUI_API const char*   ImParseFormatFindStart(const char* format);[m
[32m+[m[32mIMGUI_API const char*   ImParseFormatFindEnd(const char* format);[m
[32m+[m[32mIMGUI_API const char*   ImParseFormatTrimDecorations(const char* format, char* buf, size_t buf_size);[m
[32m+[m[32mIMGUI_API int           ImParseFormatPrecision(const char* format, int default_value);[m
[32m+[m
[32m+[m[32m// Helpers: ImVec2/ImVec4 operators[m
[32m+[m[32m// We are keeping those disabled by default so they don't leak in user space, to allow user enabling implicit cast operators between ImVec2 and their own types (using IM_VEC2_CLASS_EXTRA etc.)[m
[32m+[m[32m// We unfortunately don't have a unary- operator for ImVec2 because this would needs to be defined inside the class itself.[m
[32m+[m[32m#ifdef IMGUI_DEFINE_MATH_OPERATORS[m
[32m+[m[32mstatic inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }[m
[32m+[m[32mstatic inline ImVec2 operator/(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x/rhs, lhs.y/rhs); }[m
[32m+[m[32mstatic inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }[m
[32m+[m[32mstatic inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }[m
[32m+[m[32mstatic inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }[m
[32m+[m[32mstatic inline ImVec2 operator/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x/rhs.x, lhs.y/rhs.y); }[m
[32m+[m[32mstatic inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }[m
[32m+[m[32mstatic inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }[m
[32m+[m[32mstatic inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }[m
[32m+[m[32mstatic inline ImVec2& operator/=(ImVec2& lhs, const float rhs)                  { lhs.x /= rhs; lhs.y /= rhs; return lhs; }[m
[32m+[m[32mstatic inline ImVec4 operator+(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x+rhs.x, lhs.y+rhs.y, lhs.z+rhs.z, lhs.w+rhs.w); }[m
[32m+[m[32mstatic inline ImVec4 operator-(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x-rhs.x, lhs.y-rhs.y, lhs.z-rhs.z, lhs.w-rhs.w); }[m
[32m+[m[32mstatic inline ImVec4 operator*(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x*rhs.x, lhs.y*rhs.y, lhs.z*rhs.z, lhs.w*rhs.w); }[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Helpers: Maths[m
[32m+[m[32m// - Wrapper for standard libs functions. (Note that imgui_demo.cpp does _not_ use them to keep the code easy to copy)[m
[32m+[m[32m#ifndef IMGUI_DISABLE_MATH_FUNCTIONS[m
[32m+[m[32mstatic inline float  ImFabs(float x)                                            { return fabsf(x); }[m
[32m+[m[32mstatic inline float  ImSqrt(float x)                                            { return sqrtf(x); }[m
[32m+[m[32mstatic inline float  ImPow(float x, float y)                                    { return powf(x, y); }[m
[32m+[m[32mstatic inline double ImPow(double x, double y)                                  { return pow(x, y); }[m
[32m+[m[32mstatic inline float  ImFmod(float x, float y)                                   { return fmodf(x, y); }[m
[32m+[m[32mstatic inline double ImFmod(double x, double y)                                 { return fmod(x, y); }[m
[32m+[m[32mstatic inline float  ImCos(float x)                                             { return cosf(x); }[m
[32m+[m[32mstatic inline float  ImSin(float x)                                             { return sinf(x); }[m
[32m+[m[32mstatic inline float  ImAcos(float x)                                            { return acosf(x); }[m
[32m+[m[32mstatic inline float  ImAtan2(float y, float x)                                  { return atan2f(y, x); }[m
[32m+[m[32mstatic inline double ImAtof(const char* s)                                      { return atof(s); }[m
[32m+[m[32mstatic inline float  ImFloorStd(float x)                                        { return floorf(x); }   // we already uses our own ImFloor() { return (float)(int)v } internally so the standard one wrapper is named differently (it's used by stb_truetype)[m
[32m+[m[32mstatic inline float  ImCeil(float x)                                            { return ceilf(x); }[m
[32m+[m[32m#endif[m
[32m+[m[32m// - ImMin/ImMax/ImClamp/ImLerp/ImSwap are used by widgets which support for variety of types: signed/unsigned int/long long float/double[m
[32m+[m[32m// (Exceptionally using templates here but we could also redefine them for variety of types)[m
[32m+[m[32mtemplate<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }[m
[32m+[m[32mtemplate<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }[m
[32m+[m[32mtemplate<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }[m
[32m+[m[32mtemplate<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }[m
[32m+[m[32mtemplate<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }[m
[32m+[m[32mtemplate<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }[m
[32m+[m[32mtemplate<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }[m
[32m+[m[32m// - Misc maths helpers[m
[32m+[m[32mstatic inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }[m
[32m+[m[32mstatic inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }[m
[32m+[m[32mstatic inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }[m
[32m+[m[32mstatic inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }[m
[32m+[m[32mstatic inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }[m
[32m+[m[32mstatic inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }[m
[32m+[m[32mstatic inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }[m
[32m+[m[32mstatic inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }[m
[32m+[m[32mstatic inline float  ImLengthSqr(const ImVec4& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y + lhs.z*lhs.z + lhs.w*lhs.w; }[m
[32m+[m[32mstatic inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f / ImSqrt(d); return fail_value; }[m
[32m+[m[32mstatic inline float  ImFloor(float f)                                           { return (float)(int)f; }[m
[32m+[m[32mstatic inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)v.x, (float)(int)v.y); }[m
[32m+[m[32mstatic inline int    ImModPositive(int a, int b)                                { return (a + b) % b; }[m
[32m+[m[32mstatic inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }[m
[32m+[m[32mstatic inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }[m
[32m+[m[32mstatic inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }[m
[32m+[m[32mstatic inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }[m
[32m+[m
[32m+[m[32m// Helper: ImBoolVector. Store 1-bit per value.[m
[32m+[m[32m// Note that Resize() currently clears the whole vector.[m
[32m+[m[32mstruct ImBoolVector[m
[32m+[m[32m{[m
[32m+[m[32m    ImVector<int>   Storage;[m
[32m+[m[32m    ImBoolVector()  { }[m
[32m+[m[32m    void            Resize(int sz)          { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }[m
[32m+[m[32m    void            Clear()                 { Storage.clear(); }[m
[32m+[m[32m    bool            GetBit(int n) const     { int off = (n >> 5); int mask = 1 << (n & 31); return (Storage[off] & mask) != 0; }[m
[32m+[m[32m    void            SetBit(int n, bool v)   { int off = (n >> 5); int mask = 1 << (n & 31); if (v) Storage[off] |= mask; else Storage[off] &= ~mask; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Helper: ImPool<>. Basic keyed storage for contiguous instances, slow/amortized insertion, O(1) indexable, O(Log N) queries by ID over a dense/hot buffer,[m
[32m+[m[32m// Honor constructor/destructor. Add/remove invalidate all pointers. Indexes have the same lifetime as the associated object.[m
[32m+[m[32mtypedef int ImPoolIdx;[m
[32m+[m[32mtemplate<typename T>[m
[32m+[m[32mstruct IMGUI_API ImPool[m
[32m+[m[32m{[m
[32m+[m[32m    ImVector<T>     Data;       // Contiguous data[m
[32m+[m[32m    ImGuiStorage    Map;        // ID->Index[m
[32m+[m[32m    ImPoolIdx       FreeIdx;    // Next free idx to use[m
[32m+[m
[32m+[m[32m    ImPool()    { FreeIdx = 0; }[m
[32m+[m[32m    ~ImPool()   { Clear(); }[m
[32m+[m[32m    T*          GetByKey(ImGuiID key)               { int idx = Map.GetInt(key, -1); return (idx != -1) ? &Data[idx] : NULL; }[m
[32m+[m[32m    T*          GetByIndex(ImPoolIdx n)             { return &Data[n]; }[m
[32m+[m[32m    ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Data.Data && p < Data.Data + Data.Size); return (ImPoolIdx)(p - Data.Data); }[m
[32m+[m[32m    T*          GetOrAddByKey(ImGuiID key)          { int* p_idx = Map.GetIntRef(key, -1); if (*p_idx != -1) return &Data[*p_idx]; *p_idx = FreeIdx; return Add(); }[m
[32m+[m[32m    bool        Contains(const T* p) const          { return (p >= Data.Data && p < Data.Data + Data.Size); }[m
[32m+[m[32m    void        Clear()                             { for (int n = 0; n < Map.Data.Size; n++) { int idx = Map.Data[n].val_i; if (idx != -1) Data[idx].~T(); } Map.Clear(); Data.clear(); FreeIdx = 0; }[m
[32m+[m[32m    T*          Add()                               { int idx = FreeIdx; if (idx == Data.Size) { Data.resize(Data.Size + 1); FreeIdx++; } else { FreeIdx = *(int*)&Data[idx]; } IM_PLACEMENT_NEW(&Data[idx]) T(); return &Data[idx]; }[m
[32m+[m[32m    void        Remove(ImGuiID key, const T* p)     { Remove(key, GetIndex(p)); }[m
[32m+[m[32m    void        Remove(ImGuiID key, ImPoolIdx idx)  { Data[idx].~T(); *(int*)&Data[idx] = FreeIdx; FreeIdx = idx; Map.SetInt(key, -1); }[m
[32m+[m[32m    void        Reserve(int capacity)               { Data.reserve(capacity); Map.Data.reserve(capacity); }[m
[32m+[m[32m    int         GetSize() const                     { return Data.Size; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Misc data structures[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32menum ImGuiButtonFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiButtonFlags_None                   = 0,[m
[32m+[m[32m    ImGuiButtonFlags_Repeat                 = 1 << 0,   // hold to repeat[m
[32m+[m[32m    ImGuiButtonFlags_PressedOnClickRelease  = 1 << 1,   // [Default] return true on click + release on same item[m
[32m+[m[32m    ImGuiButtonFlags_PressedOnClick         = 1 << 2,   // return true on click (default requires click+release)[m
[32m+[m[32m    ImGuiButtonFlags_PressedOnRelease       = 1 << 3,   // return true on release (default requires click+release)[m
[32m+[m[32m    ImGuiButtonFlags_PressedOnDoubleClick   = 1 << 4,   // return true on double-click (default requires click+release)[m
[32m+[m[32m    ImGuiButtonFlags_FlattenChildren        = 1 << 5,   // allow interactions even if a child window is overlapping[m
[32m+[m[32m    ImGuiButtonFlags_AllowItemOverlap       = 1 << 6,   // require previous frame HoveredId to either match id or be null before being usable, use along with SetItemAllowOverlap()[m
[32m+[m[32m    ImGuiButtonFlags_DontClosePopups        = 1 << 7,   // disable automatically closing parent popup on press // [UNUSED][m
[32m+[m[32m    ImGuiButtonFlags_Disabled               = 1 << 8,   // disable interactions[m
[32m+[m[32m    ImGuiButtonFlags_AlignTextBaseLine      = 1 << 9,   // vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine[m
[32m+[m[32m    ImGuiButtonFlags_NoKeyModifiers         = 1 << 10,  // disable interaction if a key modifier is held[m
[32m+[m[32m    ImGuiButtonFlags_NoHoldingActiveID      = 1 << 11,  // don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)[m
[32m+[m[32m    ImGuiButtonFlags_PressedOnDragDropHold  = 1 << 12,  // press when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)[m
[32m+[m[32m    ImGuiButtonFlags_NoNavFocus             = 1 << 13,  // don't override navigation focus when activated[m
[32m+[m[32m    ImGuiButtonFlags_NoHoveredOnNav         = 1 << 14   // don't report as hovered when navigated on[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImGuiSliderFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiSliderFlags_None                   = 0,[m
[32m+[m[32m    ImGuiSliderFlags_Vertical               = 1 << 0[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImGuiDragFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiDragFlags_None                     = 0,[m
[32m+[m[32m    ImGuiDragFlags_Vertical                 = 1 << 0[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImGuiColumnsFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    // Default: 0[m
[32m+[m[32m    ImGuiColumnsFlags_None                  = 0,[m
[32m+[m[32m    ImGuiColumnsFlags_NoBorder              = 1 << 0,   // Disable column dividers[m
[32m+[m[32m    ImGuiColumnsFlags_NoResize              = 1 << 1,   // Disable resizing columns when clicking on the dividers[m
[32m+[m[32m    ImGuiColumnsFlags_NoPreserveWidths      = 1 << 2,   // Disable column width preservation when adjusting columns[m
[32m+[m[32m    ImGuiColumnsFlags_NoForceWithinWindow   = 1 << 3,   // Disable forcing columns to fit within window[m
[32m+[m[32m    ImGuiColumnsFlags_GrowParentContentsSize= 1 << 4    // (WIP) Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImGuiSelectableFlagsPrivate_[m
[32m+[m[32m{[m
[32m+[m[32m    // NB: need to be in sync with last value of ImGuiSelectableFlags_[m
[32m+[m[32m    ImGuiSelectableFlags_NoHoldingActiveID  = 1 << 10,[m
[32m+[m[32m    ImGuiSelectableFlags_PressedOnClick     = 1 << 11,[m
[32m+[m[32m    ImGuiSelectableFlags_PressedOnRelease   = 1 << 12,[m
[32m+[m[32m    ImGuiSelectableFlags_DrawFillAvailWidth = 1 << 13,  // FIXME: We may be able to remove this (added in 6251d379 for menus)[m
[32m+[m[32m    ImGuiSelectableFlags_AllowItemOverlap   = 1 << 14[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImGuiSeparatorFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiSeparatorFlags_None                = 0,[m
[32m+[m[32m    ImGuiSeparatorFlags_Horizontal          = 1 << 0,   // Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar[m
[32m+[m[32m    ImGuiSeparatorFlags_Vertical            = 1 << 1[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Transient per-window flags, reset at the beginning of the frame. For child window, inherited from parent on first Begin().[m
[32m+[m[32m// This is going to be exposed in imgui.h when stabilized enough.[m
[32m+[m[32menum ImGuiItemFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiItemFlags_NoTabStop                = 1 << 0,  // false[m
[32m+[m[32m    ImGuiItemFlags_ButtonRepeat             = 1 << 1,  // false    // Button() will return true multiple times based on io.KeyRepeatDelay and io.KeyRepeatRate settings.[m
[32m+[m[32m    ImGuiItemFlags_Disabled                 = 1 << 2,  // false    // [BETA] Disable interactions but doesn't affect visuals yet. See github.com/ocornut/imgui/issues/211[m
[32m+[m[32m    ImGuiItemFlags_NoNav                    = 1 << 3,  // false[m
[32m+[m[32m    ImGuiItemFlags_NoNavDefaultFocus        = 1 << 4,  // false[m
[32m+[m[32m    ImGuiItemFlags_SelectableDontClosePopup = 1 << 5,  // false    // MenuItem/Selectable() automatically closes current Popup window[m
[32m+[m[32m    ImGuiItemFlags_Default_                 = 0[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Storage for LastItem data[m
[32m+[m[32menum ImGuiItemStatusFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiItemStatusFlags_None               = 0,[m
[32m+[m[32m    ImGuiItemStatusFlags_HoveredRect        = 1 << 0,[m
[32m+[m[32m    ImGuiItemStatusFlags_HasDisplayRect     = 1 << 1,[m
[32m+[m[32m    ImGuiItemStatusFlags_Edited             = 1 << 2,   // Value exposed by item was edited in the current frame (should match the bool return value of most widgets)[m
[32m+[m[32m    ImGuiItemStatusFlags_ToggledSelection   = 1 << 3    // Set when Selectable(), TreeNode() reports toggling a selection. We can't report "Selected" because reporting the change allows us to handle clipping with less issues.[m
[32m+[m
[32m+[m[32m#ifdef IMGUI_ENABLE_TEST_ENGINE[m
[32m+[m[32m    , // [imgui-test only][m
[32m+[m[32m    ImGuiItemStatusFlags_Openable           = 1 << 10,  //[m
[32m+[m[32m    ImGuiItemStatusFlags_Opened             = 1 << 11,  //[m
[32m+[m[32m    ImGuiItemStatusFlags_Checkable          = 1 << 12,  //[m
[32m+[m[32m    ImGuiItemStatusFlags_Checked            = 1 << 13   //[m
[32m+[m[32m#endif[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImGuiTextFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiTextFlags_None = 0,[m
[32m+[m[32m    ImGuiTextFlags_NoWidthForLargeClippedText = 1 << 0[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// FIXME: this is in development, not exposed/functional as a generic feature yet.[m
[32m+[m[32m// Horizontal/Vertical enums are fixed to 0/1 so they may be used to index ImVec2[m
[32m+[m[32menum ImGuiLayoutType_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiLayoutType_Horizontal = 0,[m
[32m+[m[32m    ImGuiLayoutType_Vertical = 1[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImGuiLogType[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiLogType_None = 0,[m
[32m+[m[32m    ImGuiLogType_TTY,[m
[32m+[m[32m    ImGuiLogType_File,[m
[32m+[m[32m    ImGuiLogType_Buffer,[m
[32m+[m[32m    ImGuiLogType_Clipboard[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// X/Y enums are fixed to 0/1 so they may be used to index ImVec2[m
[32m+[m[32menum ImGuiAxis[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiAxis_None = -1,[m
[32m+[m[32m    ImGuiAxis_X = 0,[m
[32m+[m[32m    ImGuiAxis_Y = 1[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImGuiPlotType[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiPlotType_Lines,[m
[32m+[m[32m    ImGuiPlotType_Histogram[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImGuiInputSource[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiInputSource_None = 0,[m
[32m+[m[32m    ImGuiInputSource_Mouse,[m
[32m+[m[32m    ImGuiInputSource_Nav,[m
[32m+[m[32m    ImGuiInputSource_NavKeyboard,   // Only used occasionally for storage, not tested/handled by most code[m
[32m+[m[32m    ImGuiInputSource_NavGamepad,    // "[m
[32m+[m[32m    ImGuiInputSource_COUNT[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// FIXME-NAV: Clarify/expose various repeat delay/rate[m
[32m+[m[32menum ImGuiInputReadMode[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiInputReadMode_Down,[m
[32m+[m[32m    ImGuiInputReadMode_Pressed,[m
[32m+[m[32m    ImGuiInputReadMode_Released,[m
[32m+[m[32m    ImGuiInputReadMode_Repeat,[m
[32m+[m[32m    ImGuiInputReadMode_RepeatSlow,[m
[32m+[m[32m    ImGuiInputReadMode_RepeatFast[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImGuiNavHighlightFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiNavHighlightFlags_None         = 0,[m
[32m+[m[32m    ImGuiNavHighlightFlags_TypeDefault  = 1 << 0,[m
[32m+[m[32m    ImGuiNavHighlightFlags_TypeThin     = 1 << 1,[m
[32m+[m[32m    ImGuiNavHighlightFlags_AlwaysDraw   = 1 << 2,       // Draw rectangular highlight if (g.NavId == id) _even_ when using the mouse.[m
[32m+[m[32m    ImGuiNavHighlightFlags_NoRounding   = 1 << 3[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImGuiNavDirSourceFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiNavDirSourceFlags_None         = 0,[m
[32m+[m[32m    ImGuiNavDirSourceFlags_Keyboard     = 1 << 0,[m
[32m+[m[32m    ImGuiNavDirSourceFlags_PadDPad      = 1 << 1,[m
[32m+[m[32m    ImGuiNavDirSourceFlags_PadLStick    = 1 << 2[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImGuiNavMoveFlags_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiNavMoveFlags_None                  = 0,[m
[32m+[m[32m    ImGuiNavMoveFlags_LoopX                 = 1 << 0,   // On failed request, restart from opposite side[m
[32m+[m[32m    ImGuiNavMoveFlags_LoopY                 = 1 << 1,[m
[32m+[m[32m    ImGuiNavMoveFlags_WrapX                 = 1 << 2,   // On failed request, request from opposite side one line down (when NavDir==right) or one line up (when NavDir==left)[m
[32m+[m[32m    ImGuiNavMoveFlags_WrapY                 = 1 << 3,   // This is not super useful for provided for completeness[m
[32m+[m[32m    ImGuiNavMoveFlags_AllowCurrentNavId     = 1 << 4,   // Allow scoring and considering the current NavId as a move target candidate. This is used when the move source is offset (e.g. pressing PageDown actually needs to send a Up move request, if we are pressing PageDown from the bottom-most item we need to stay in place)[m
[32m+[m[32m    ImGuiNavMoveFlags_AlsoScoreVisibleSet   = 1 << 5    // Store alternate result in NavMoveResultLocalVisibleSet that only comprise elements that are already fully visible.[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImGuiNavForward[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiNavForward_None,[m
[32m+[m[32m    ImGuiNavForward_ForwardQueued,[m
[32m+[m[32m    ImGuiNavForward_ForwardActive[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImGuiNavLayer[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiNavLayer_Main  = 0,    // Main scrolling layer[m
[32m+[m[32m    ImGuiNavLayer_Menu  = 1,    // Menu layer (access with Alt/ImGuiNavInput_Menu)[m
[32m+[m[32m    ImGuiNavLayer_COUNT[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImGuiPopupPositionPolicy[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiPopupPositionPolicy_Default,[m
[32m+[m[32m    ImGuiPopupPositionPolicy_ComboBox[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// 1D vector (this odd construct is used to facilitate the transition between 1D and 2D, and the maintenance of some branches/patches)[m
[32m+[m[32mstruct ImVec1[m
[32m+[m[32m{[m
[32m+[m[32m    float   x;[m
[32m+[m[32m    ImVec1()         { x = 0.0f; }[m
[32m+[m[32m    ImVec1(float _x) { x = _x; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// 2D axis aligned bounding-box[m
[32m+[m[32m// NB: we can't rely on ImVec2 math operators being available here[m
[32m+[m[32mstruct IMGUI_API ImRect[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2      Min;    // Upper-left[m
[32m+[m[32m    ImVec2      Max;    // Lower-right[m
[32m+[m
[32m+[m[32m    ImRect()                                        : Min(FLT_MAX,FLT_MAX), Max(-FLT_MAX,-FLT_MAX)  {}[m
[32m+[m[32m    ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}[m
[32m+[m[32m    ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}[m
[32m+[m[32m    ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}[m
[32m+[m
[32m+[m[32m    ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }[m
[32m+[m[32m    ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }[m
[32m+[m[32m    float       GetWidth() const                    { return Max.x - Min.x; }[m
[32m+[m[32m    float       GetHeight() const                   { return Max.y - Min.y; }[m
[32m+[m[32m    ImVec2      GetTL() const                       { return Min; }                   // Top-left[m
[32m+[m[32m    ImVec2      GetTR() const                       { return ImVec2(Max.x, Min.y); }  // Top-right[m
[32m+[m[32m    ImVec2      GetBL() const                       { return ImVec2(Min.x, Max.y); }  // Bottom-left[m
[32m+[m[32m    ImVec2      GetBR() const                       { return Max; }                   // Bottom-right[m
[32m+[m[32m    bool        Contains(const ImVec2& p) const     { return p.x     >= Min.x && p.y     >= Min.y && p.x     <  Max.x && p.y     <  Max.y; }[m
[32m+[m[32m    bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }[m
[32m+[m[32m    bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }[m
[32m+[m[32m    void        Add(const ImVec2& p)                { if (Min.x > p.x)     Min.x = p.x;     if (Min.y > p.y)     Min.y = p.y;     if (Max.x < p.x)     Max.x = p.x;     if (Max.y < p.y)     Max.y = p.y; }[m
[32m+[m[32m    void        Add(const ImRect& r)                { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }[m
[32m+[m[32m    void        Expand(const float amount)          { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }[m
[32m+[m[32m    void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }[m
[32m+[m[32m    void        Translate(const ImVec2& d)          { Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y; }[m
[32m+[m[32m    void        TranslateX(float dx)                { Min.x += dx; Max.x += dx; }[m
[32m+[m[32m    void        TranslateY(float dy)                { Min.y += dy; Max.y += dy; }[m
[32m+[m[32m    void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.[m
[32m+[m[32m    void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.[m
[32m+[m[32m    void        Floor()                             { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }[m
[32m+[m[32m    bool        IsInverted() const                  { return Min.x > Max.x || Min.y > Max.y; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Type information associated to one ImGuiDataType. Retrieve with DataTypeGetInfo().[m
[32m+[m[32mstruct ImGuiDataTypeInfo[m
[32m+[m[32m{[m
[32m+[m[32m    size_t      Size;           // Size in byte[m
[32m+[m[32m    const char* PrintFmt;       // Default printf format for the type[m
[32m+[m[32m    const char* ScanFmt;        // Default scanf format for the type[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Stacked color modifier, backup of modified data so we can restore it[m
[32m+[m[32mstruct ImGuiColorMod[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiCol    Col;[m
[32m+[m[32m    ImVec4      BackupValue;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.[m
[32m+[m[32mstruct ImGuiStyleMod[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiStyleVar   VarIdx;[m
[32m+[m[32m    union           { int BackupInt[2]; float BackupFloat[2]; };[m
[32m+[m[32m    ImGuiStyleMod(ImGuiStyleVar idx, int v)     { VarIdx = idx; BackupInt[0] = v; }[m
[32m+[m[32m    ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }[m
[32m+[m[32m    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Stacked storage data for BeginGroup()/EndGroup()[m
[32m+[m[32mstruct ImGuiGroupData[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2      BackupCursorPos;[m
[32m+[m[32m    ImVec2      BackupCursorMaxPos;[m
[32m+[m[32m    ImVec1      BackupIndent;[m
[32m+[m[32m    ImVec1      BackupGroupOffset;[m
[32m+[m[32m    ImVec2      BackupCurrentLineSize;[m
[32m+[m[32m    float       BackupCurrentLineTextBaseOffset;[m
[32m+[m[32m    ImGuiID     BackupActiveIdIsAlive;[m
[32m+[m[32m    bool        BackupActiveIdPreviousFrameIsAlive;[m
[32m+[m[32m    bool        AdvanceCursor;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.[m
[32m+[m[32mstruct IMGUI_API ImGuiMenuColumns[m
[32m+[m[32m{[m
[32m+[m[32m    float       Spacing;[m
[32m+[m[32m    float       Width, NextWidth;[m
[32m+[m[32m    float       Pos[3], NextWidths[3];[m
[32m+[m
[32m+[m[32m    ImGuiMenuColumns();[m
[32m+[m[32m    void        Update(int count, float spacing, bool clear);[m
[32m+[m[32m    float       DeclColumns(float w0, float w1, float w2);[m
[32m+[m[32m    float       CalcExtraSpace(float avail_w);[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Internal state of the currently focused/edited text input box[m
[32m+[m[32mstruct IMGUI_API ImGuiInputTextState[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiID                 ID;                     // widget id owning the text state[m
[32m+[m[32m    int                     CurLenW, CurLenA;       // we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 len is valid even if TextA is not.[m
[32m+[m[32m    ImVector<ImWchar>       TextW;                  // edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.[m
[32m+[m[32m    ImVector<char>          TextA;                  // temporary UTF8 buffer for callbacks and other operations. this is not updated in every code-path! size=capacity.[m
[32m+[m[32m    ImVector<char>          InitialTextA;           // backup of end-user buffer at the time of focus (in UTF-8, unaltered)[m
[32m+[m[32m    bool                    TextAIsValid;           // temporary UTF8 buffer is not initially valid before we make the widget active (until then we pull the data from user argument)[m
[32m+[m[32m    int                     BufCapacityA;           // end-user buffer capacity[m
[32m+[m[32m    float                   ScrollX;                // horizontal scrolling/offset[m
[32m+[m[32m    ImStb::STB_TexteditState Stb;                   // state for stb_textedit.h[m
[32m+[m[32m    float                   CursorAnim;             // timer for cursor blink, reset on every user action so the cursor reappears immediately[m
[32m+[m[32m    bool                    CursorFollow;           // set when we want scrolling to follow the current cursor position (not always!)[m
[32m+[m[32m    bool                    SelectedAllMouseLock;   // after a double-click to select all, we ignore further mouse drags to update selection[m
[32m+[m
[32m+[m[32m    // Temporarily set when active[m
[32m+[m[32m    ImGuiInputTextFlags     UserFlags;[m
[32m+[m[32m    ImGuiInputTextCallback  UserCallback;[m
[32m+[m[32m    void*                   UserCallbackData;[m
[32m+[m
[32m+[m[32m    ImGuiInputTextState()                           { memset(this, 0, sizeof(*this)); }[m
[32m+[m[32m    void                ClearFreeMemory()           { TextW.clear(); TextA.clear(); InitialTextA.clear(); }[m
[32m+[m[32m    void                CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking[m
[32m+[m[32m    void                CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }[m
[32m+[m[32m    bool                HasSelection() const        { return Stb.select_start != Stb.select_end; }[m
[32m+[m[32m    void                ClearSelection()            { Stb.select_start = Stb.select_end = Stb.cursor; }[m
[32m+[m[32m    void                SelectAll()                 { Stb.select_start = 0; Stb.cursor = Stb.select_end = CurLenW; Stb.has_preferred_x = 0; }[m
[32m+[m[32m    int                 GetUndoAvailCount() const   { return Stb.undostate.undo_point; }[m
[32m+[m[32m    int                 GetRedoAvailCount() const   { return STB_TEXTEDIT_UNDOSTATECOUNT - Stb.undostate.redo_point; }[m
[32m+[m[32m    void                OnKeyPressed(int key);      // Cannot be inline because we call in code in stb_textedit.h implementation[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Windows data saved in imgui.ini file[m
[32m+[m[32mstruct ImGuiWindowSettings[m
[32m+[m[32m{[m
[32m+[m[32m    char*       Name;[m
[32m+[m[32m    ImGuiID     ID;[m
[32m+[m[32m    ImVec2      Pos;[m
[32m+[m[32m    ImVec2      Size;[m
[32m+[m[32m    bool        Collapsed;[m
[32m+[m
[32m+[m[32m    ImGuiWindowSettings() { Name = NULL; ID = 0; Pos = Size = ImVec2(0,0); Collapsed = false; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstruct ImGuiSettingsHandler[m
[32m+[m[32m{[m
[32m+[m[32m    const char* TypeName;       // Short description stored in .ini file. Disallowed characters: '[' ']'[m
[32m+[m[32m    ImGuiID     TypeHash;       // == ImHashStr(TypeName)[m
[32m+[m[32m    void*       (*ReadOpenFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, const char* name);              // Read: Called when entering into a new ini entry e.g. "[Window][Name]"[m
[32m+[m[32m    void        (*ReadLineFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, void* entry, const char* line); // Read: Called for every line of text within an ini entry[m
[32m+[m[32m    void        (*WriteAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* out_buf);      // Write: Output every entries into 'out_buf'[m
[32m+[m[32m    void*       UserData;[m
[32m+[m
[32m+[m[32m    ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Storage for current popup stack[m
[32m+[m[32mstruct ImGuiPopupData[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiID             PopupId;        // Set on OpenPopup()[m
[32m+[m[32m    ImGuiWindow*        Window;         // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()[m
[32m+[m[32m    ImGuiWindow*        SourceWindow;   // Set on OpenPopup() copy of NavWindow at the time of opening the popup[m
[32m+[m[32m    int                 OpenFrameCount; // Set on OpenPopup()[m
[32m+[m[32m    ImGuiID             OpenParentId;   // Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)[m
[32m+[m[32m    ImVec2              OpenPopupPos;   // Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)[m
[32m+[m[32m    ImVec2              OpenMousePos;   // Set on OpenPopup(), copy of mouse position at the time of opening popup[m
[32m+[m
[32m+[m[32m    ImGuiPopupData() { PopupId = 0; Window = SourceWindow = NULL; OpenFrameCount = -1; OpenParentId = 0; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstruct ImGuiColumnData[m
[32m+[m[32m{[m
[32m+[m[32m    float               OffsetNorm;         // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)[m
[32m+[m[32m    float               OffsetNormBeforeResize;[m
[32m+[m[32m    ImGuiColumnsFlags   Flags;              // Not exposed[m
[32m+[m[32m    ImRect              ClipRect;[m
[32m+[m
[32m+[m[32m    ImGuiColumnData()   { OffsetNorm = OffsetNormBeforeResize = 0.0f; Flags = ImGuiColumnsFlags_None; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstruct ImGuiColumns[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiID             ID;[m
[32m+[m[32m    ImGuiColumnsFlags   Flags;[m
[32m+[m[32m    bool                IsFirstFrame;[m
[32m+[m[32m    bool                IsBeingResized;[m
[32m+[m[32m    int                 Current;[m
[32m+[m[32m    int                 Count;[m
[32m+[m[32m    float               MinX, MaxX;[m
[32m+[m[32m    float               LineMinY, LineMaxY;[m
[32m+[m[32m    float               BackupCursorPosY;       // Backup of CursorPos at the time of BeginColumns()[m
[32m+[m[32m    float               BackupCursorMaxPosX;    // Backup of CursorMaxPos at the time of BeginColumns()[m
[32m+[m[32m    ImVector<ImGuiColumnData> Columns;[m
[32m+[m
[32m+[m[32m    ImGuiColumns()      { Clear(); }[m
[32m+[m[32m    void Clear()[m
[32m+[m[32m    {[m
[32m+[m[32m        ID = 0;[m
[32m+[m[32m        Flags = ImGuiColumnsFlags_None;[m
[32m+[m[32m        IsFirstFrame = false;[m
[32m+[m[32m        IsBeingResized = false;[m
[32m+[m[32m        Current = 0;[m
[32m+[m[32m        Count = 1;[m
[32m+[m[32m        MinX = MaxX = 0.0f;[m
[32m+[m[32m        LineMinY = LineMaxY = 0.0f;[m
[32m+[m[32m        BackupCursorPosY = 0.0f;[m
[32m+[m[32m        BackupCursorMaxPosX = 0.0f;[m
[32m+[m[32m        Columns.clear();[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Data shared between all ImDrawList instances[m
[32m+[m[32mstruct IMGUI_API ImDrawListSharedData[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2          TexUvWhitePixel;            // UV of white pixel in the atlas[m
[32m+[m[32m    ImFont*         Font;                       // Current/default font (optional, for simplified AddText overload)[m
[32m+[m[32m    float           FontSize;                   // Current/default font size (optional, for simplified AddText overload)[m
[32m+[m[32m    float           CurveTessellationTol;[m
[32m+[m[32m    ImVec4          ClipRectFullscreen;         // Value for PushClipRectFullscreen()[m
[32m+[m
[32m+[m[32m    // Const data[m
[32m+[m[32m    // FIXME: Bake rounded corners fill/borders in atlas[m
[32m+[m[32m    ImVec2          CircleVtx12[12];[m
[32m+[m
[32m+[m[32m    ImDrawListSharedData();[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstruct ImDrawDataBuilder[m
[32m+[m[32m{[m
[32m+[m[32m    ImVector<ImDrawList*>   Layers[2];           // Global layers for: regular, tooltip[m
[32m+[m
[32m+[m[32m    void Clear()            { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].resize(0); }[m
[32m+[m[32m    void ClearFreeMemory()  { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].clear(); }[m
[32m+[m[32m    IMGUI_API void FlattenIntoSingleLayer();[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstruct ImGuiNavMoveResult[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiID       ID;           // Best candidate[m
[32m+[m[32m    ImGuiID       SelectScopeId;// Best candidate window current selectable group ID[m
[32m+[m[32m    ImGuiWindow*  Window;       // Best candidate window[m
[32m+[m[32m    float         DistBox;      // Best candidate box distance to current NavId[m
[32m+[m[32m    float         DistCenter;   // Best candidate center distance to current NavId[m
[32m+[m[32m    float         DistAxial;[m
[32m+[m[32m    ImRect        RectRel;      // Best candidate bounding box in window relative space[m
[32m+[m
[32m+[m[32m    ImGuiNavMoveResult() { Clear(); }[m
[32m+[m[32m    void Clear()         { ID = SelectScopeId = 0; Window = NULL; DistBox = DistCenter = DistAxial = FLT_MAX; RectRel = ImRect(); }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Storage for SetNexWindow** functions[m
[32m+[m[32mstruct ImGuiNextWindowData[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiCond               PosCond;[m
[32m+[m[32m    ImGuiCond               SizeCond;[m
[32m+[m[32m    ImGuiCond               ContentSizeCond;[m
[32m+[m[32m    ImGuiCond               CollapsedCond;[m
[32m+[m[32m    ImGuiCond               SizeConstraintCond;[m
[32m+[m[32m    ImGuiCond               FocusCond;[m
[32m+[m[32m    ImGuiCond               BgAlphaCond;[m
[32m+[m[32m    ImVec2                  PosVal;[m
[32m+[m[32m    ImVec2                  PosPivotVal;[m
[32m+[m[32m    ImVec2                  SizeVal;[m
[32m+[m[32m    ImVec2                  ContentSizeVal;[m
[32m+[m[32m    bool                    CollapsedVal;[m
[32m+[m[32m    ImRect                  SizeConstraintRect;[m
[32m+[m[32m    ImGuiSizeCallback       SizeCallback;[m
[32m+[m[32m    void*                   SizeCallbackUserData;[m
[32m+[m[32m    float                   BgAlphaVal;[m
[32m+[m[32m    ImVec2                  MenuBarOffsetMinVal;                // This is not exposed publicly, so we don't clear it.[m
[32m+[m
[32m+[m[32m    ImGuiNextWindowData()[m
[32m+[m[32m    {[m
[32m+[m[32m        PosCond = SizeCond = ContentSizeCond = CollapsedCond = SizeConstraintCond = FocusCond = BgAlphaCond = 0;[m
[32m+[m[32m        PosVal = PosPivotVal = SizeVal = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m        ContentSizeVal = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m        CollapsedVal = false;[m
[32m+[m[32m        SizeConstraintRect = ImRect();[m
[32m+[m[32m        SizeCallback = NULL;[m
[32m+[m[32m        SizeCallbackUserData = NULL;[m
[32m+[m[32m        BgAlphaVal = FLT_MAX;[m
[32m+[m[32m        MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    void    Clear()[m
[32m+[m[32m    {[m
[32m+[m[32m        PosCond = SizeCond = ContentSizeCond = CollapsedCond = SizeConstraintCond = FocusCond = BgAlphaCond = 0;[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Tabs[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mstruct ImGuiTabBarSortItem[m
[32m+[m[32m{[m
[32m+[m[32m    int             Index;[m
[32m+[m[32m    float           Width;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstruct ImGuiTabBarRef[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiTabBar*    Ptr;                    // Either field can be set, not both. Dock node tab bars are loose while BeginTabBar() ones are in a pool.[m
[32m+[m[32m    int             IndexInMainPool;[m
[32m+[m
[32m+[m[32m    ImGuiTabBarRef(ImGuiTabBar* ptr)        { Ptr = ptr; IndexInMainPool = -1; }[m
[32m+[m[32m    ImGuiTabBarRef(int index_in_main_pool)  { Ptr = NULL; IndexInMainPool = index_in_main_pool; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Main imgui context[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mstruct ImGuiContext[m
[32m+[m[32m{[m
[32m+[m[32m    bool                    Initialized;[m
[32m+[m[32m    bool                    FrameScopeActive;                   // Set by NewFrame(), cleared by EndFrame()[m
[32m+[m[32m    bool                    FrameScopePushedImplicitWindow;     // Set by NewFrame(), cleared by EndFrame()[m
[32m+[m[32m    bool                    FontAtlasOwnedByContext;            // Io.Fonts-> is owned by the ImGuiContext and will be destructed along with it.[m
[32m+[m[32m    ImGuiIO                 IO;[m
[32m+[m[32m    ImGuiStyle              Style;[m
[32m+[m[32m    ImFont*                 Font;                               // (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()[m
[32m+[m[32m    float                   FontSize;                           // (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.[m
[32m+[m[32m    float                   FontBaseSize;                       // (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.[m
[32m+[m[32m    ImDrawListSharedData    DrawListSharedData;[m
[32m+[m
[32m+[m[32m    double                  Time;[m
[32m+[m[32m    int                     FrameCount;[m
[32m+[m[32m    int                     FrameCountEnded;[m
[32m+[m[32m    int                     FrameCountRendered;[m
[32m+[m[32m    ImVector<ImGuiWindow*>  Windows;                            // Windows, sorted in display order, back to front[m
[32m+[m[32m    ImVector<ImGuiWindow*>  WindowsFocusOrder;                  // Windows, sorted in focus order, back to front[m
[32m+[m[32m    ImVector<ImGuiWindow*>  WindowsSortBuffer;[m
[32m+[m[32m    ImVector<ImGuiWindow*>  CurrentWindowStack;[m
[32m+[m[32m    ImGuiStorage            WindowsById;[m
[32m+[m[32m    int                     WindowsActiveCount;[m
[32m+[m[32m    ImGuiWindow*            CurrentWindow;                      // Being drawn into[m
[32m+[m[32m    ImGuiWindow*            HoveredWindow;                      // Will catch mouse inputs[m
[32m+[m[32m    ImGuiWindow*            HoveredRootWindow;                  // Will catch mouse inputs (for focus/move only)[m
[32m+[m[32m    ImGuiID                 HoveredId;                          // Hovered widget[m
[32m+[m[32m    bool                    HoveredIdAllowOverlap;[m
[32m+[m[32m    ImGuiID                 HoveredIdPreviousFrame;[m
[32m+[m[32m    float                   HoveredIdTimer;                     // Measure contiguous hovering time[m
[32m+[m[32m    float                   HoveredIdNotActiveTimer;            // Measure contiguous hovering time where the item has not been active[m
[32m+[m[32m    ImGuiID                 ActiveId;                           // Active widget[m
[32m+[m[32m    ImGuiID                 ActiveIdPreviousFrame;[m
[32m+[m[32m    ImGuiID                 ActiveIdIsAlive;                    // Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)[m
[32m+[m[32m    float                   ActiveIdTimer;[m
[32m+[m[32m    bool                    ActiveIdIsJustActivated;            // Set at the time of activation for one frame[m
[32m+[m[32m    bool                    ActiveIdAllowOverlap;               // Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)[m
[32m+[m[32m    bool                    ActiveIdHasBeenPressed;             // Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.[m
[32m+[m[32m    bool                    ActiveIdHasBeenEdited;              // Was the value associated to the widget Edited over the course of the Active state.[m
[32m+[m[32m    bool                    ActiveIdPreviousFrameIsAlive;[m
[32m+[m[32m    bool                    ActiveIdPreviousFrameHasBeenEdited;[m
[32m+[m[32m    int                     ActiveIdAllowNavDirFlags;           // Active widget allows using directional navigation (e.g. can activate a button and move away from it)[m
[32m+[m[32m    int                     ActiveIdBlockNavInputFlags;[m
[32m+[m[32m    ImVec2                  ActiveIdClickOffset;                // Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)[m
[32m+[m[32m    ImGuiWindow*            ActiveIdWindow;[m
[32m+[m[32m    ImGuiWindow*            ActiveIdPreviousFrameWindow;[m
[32m+[m[32m    ImGuiInputSource        ActiveIdSource;                     // Activating with mouse or nav (gamepad/keyboard)[m
[32m+[m[32m    ImGuiID                 LastActiveId;                       // Store the last non-zero ActiveId, useful for animation.[m
[32m+[m[32m    float                   LastActiveIdTimer;                  // Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.[m
[32m+[m[32m    ImVec2                  LastValidMousePos;[m
[32m+[m[32m    ImGuiWindow*            MovingWindow;                       // Track the window we clicked on (in order to preserve focus). The actually window that is moved is generally MovingWindow->RootWindow.[m
[32m+[m[32m    ImVector<ImGuiColorMod> ColorModifiers;                     // Stack for PushStyleColor()/PopStyleColor()[m
[32m+[m[32m    ImVector<ImGuiStyleMod> StyleModifiers;                     // Stack for PushStyleVar()/PopStyleVar()[m
[32m+[m[32m    ImVector<ImFont*>       FontStack;                          // Stack for PushFont()/PopFont()[m
[32m+[m[32m    ImVector<ImGuiPopupData>OpenPopupStack;                     // Which popups are open (persistent)[m
[32m+[m[32m    ImVector<ImGuiPopupData>BeginPopupStack;                    // Which level of BeginPopup() we are in (reset every frame)[m
[32m+[m[32m    ImGuiNextWindowData     NextWindowData;                     // Storage for SetNextWindow** functions[m
[32m+[m[32m    bool                    NextTreeNodeOpenVal;                // Storage for SetNextTreeNode** functions[m
[32m+[m[32m    ImGuiCond               NextTreeNodeOpenCond;[m
[32m+[m
[32m+[m[32m    // Navigation data (for gamepad/keyboard)[m
[32m+[m[32m    ImGuiWindow*            NavWindow;                          // Focused window for navigation. Could be called 'FocusWindow'[m
[32m+[m[32m    ImGuiID                 NavId;                              // Focused item for navigation[m
[32m+[m[32m    ImGuiID                 NavActivateId;                      // ~~ (g.ActiveId == 0) && IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0, also set when calling ActivateItem()[m
[32m+[m[32m    ImGuiID                 NavActivateDownId;                  // ~~ IsNavInputDown(ImGuiNavInput_Activate) ? NavId : 0[m
[32m+[m[32m    ImGuiID                 NavActivatePressedId;               // ~~ IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0[m
[32m+[m[32m    ImGuiID                 NavInputId;                         // ~~ IsNavInputPressed(ImGuiNavInput_Input) ? NavId : 0[m
[32m+[m[32m    ImGuiID                 NavJustTabbedId;                    // Just tabbed to this id.[m
[32m+[m[32m    ImGuiID                 NavJustMovedToId;                   // Just navigated to this id (result of a successfully MoveRequest).[m
[32m+[m[32m    ImGuiID                 NavJustMovedToMultiSelectScopeId;   // Just navigated to this select scope id (result of a successfully MoveRequest).[m
[32m+[m[32m    ImGuiID                 NavNextActivateId;                  // Set by ActivateItem(), queued until next frame.[m
[32m+[m[32m    ImGuiInputSource        NavInputSource;                     // Keyboard or Gamepad mode? THIS WILL ONLY BE None or NavGamepad or NavKeyboard.[m
[32m+[m[32m    ImRect                  NavScoringRectScreen;               // Rectangle used for scoring, in screen space. Based of window->DC.NavRefRectRel[], modified for directional navigation scoring.[m
[32m+[m[32m    int                     NavScoringCount;                    // Metrics for debugging[m
[32m+[m[32m    ImGuiWindow*            NavWindowingTarget;                 // When selecting a window (holding Menu+FocusPrev/Next, or equivalent of CTRL-TAB) this window is temporarily displayed front-most.[m
[32m+[m[32m    ImGuiWindow*            NavWindowingTargetAnim;             // Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f[m
[32m+[m[32m    ImGuiWindow*            NavWindowingList;[m
[32m+[m[32m    float                   NavWindowingTimer;[m
[32m+[m[32m    float                   NavWindowingHighlightAlpha;[m
[32m+[m[32m    bool                    NavWindowingToggleLayer;[m
[32m+[m[32m    ImGuiNavLayer           NavLayer;                           // Layer we are navigating on. For now the system is hard-coded for 0=main contents and 1=menu/title bar, may expose layers later.[m
[32m+[m[32m    int                     NavIdTabCounter;                    // == NavWindow->DC.FocusIdxTabCounter at time of NavId processing[m
[32m+[m[32m    bool                    NavIdIsAlive;                       // Nav widget has been seen this frame ~~ NavRefRectRel is valid[m
[32m+[m[32m    bool                    NavMousePosDirty;                   // When set we will update mouse position if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)[m
[32m+[m[32m    bool                    NavDisableHighlight;                // When user starts using mouse, we hide gamepad/keyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)[m
[32m+[m[32m    bool                    NavDisableMouseHover;               // When user starts using gamepad/keyboard, we hide mouse hovering highlight until mouse is touched again.[m
[32m+[m[32m    bool                    NavAnyRequest;                      // ~~ NavMoveRequest || NavInitRequest[m
[32m+[m[32m    bool                    NavInitRequest;                     // Init request for appearing window to select first item[m
[32m+[m[32m    bool                    NavInitRequestFromMove;[m
[32m+[m[32m    ImGuiID                 NavInitResultId;[m
[32m+[m[32m    ImRect                  NavInitResultRectRel;[m
[32m+[m[32m    bool                    NavMoveFromClampedRefRect;          // Set by manual scrolling, if we scroll to a point where NavId isn't visible we reset navigation from visible items[m
[32m+[m[32m    bool                    NavMoveRequest;                     // Move request for this frame[m
[32m+[m[32m    ImGuiNavMoveFlags       NavMoveRequestFlags;[m
[32m+[m[32m    ImGuiNavForward         NavMoveRequestForward;              // None / ForwardQueued / ForwardActive (this is used to navigate sibling parent menus from a child menu)[m
[32m+[m[32m    ImGuiDir                NavMoveDir, NavMoveDirLast;         // Direction of the move request (left/right/up/down), direction of the previous move request[m
[32m+[m[32m    ImGuiDir                NavMoveClipDir;[m
[32m+[m[32m    ImGuiNavMoveResult      NavMoveResultLocal;                 // Best move request candidate within NavWindow[m
[32m+[m[32m    ImGuiNavMoveResult      NavMoveResultLocalVisibleSet;       // Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)[m
[32m+[m[32m    ImGuiNavMoveResult      NavMoveResultOther;                 // Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)[m
[32m+[m
[32m+[m[32m    // Tabbing system (older than Nav, active even if Nav is disabled. FIXME-NAV: This needs a redesign!)[m
[32m+[m[32m    ImGuiWindow*            FocusRequestCurrWindow;             //[m
[32m+[m[32m    ImGuiWindow*            FocusRequestNextWindow;             //[m
[32m+[m[32m    int                     FocusRequestCurrCounterAll;         // Any item being requested for focus, stored as an index (we on layout to be stable between the frame pressing TAB and the next frame, semi-ouch)[m
[32m+[m[32m    int                     FocusRequestCurrCounterTab;         // Tab item being requested for focus, stored as an index[m
[32m+[m[32m    int                     FocusRequestNextCounterAll;         // Stored for next frame[m
[32m+[m[32m    int                     FocusRequestNextCounterTab;         // "[m
[32m+[m[32m    bool                    FocusTabPressed;                    //[m
[32m+[m
[32m+[m[32m    // Render[m
[32m+[m[32m    ImDrawData              DrawData;                           // Main ImDrawData instance to pass render information to the user[m
[32m+[m[32m    ImDrawDataBuilder       DrawDataBuilder;[m
[32m+[m[32m    float                   DimBgRatio;                         // 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)[m
[32m+[m[32m    ImDrawList              BackgroundDrawList;                 // First draw list to be rendered.[m
[32m+[m[32m    ImDrawList              ForegroundDrawList;                 // Last draw list to be rendered. This is where we the render software mouse cursor (if io.MouseDrawCursor is set) and most debug overlays.[m
[32m+[m[32m    ImGuiMouseCursor        MouseCursor;[m
[32m+[m
[32m+[m[32m    // Drag and Drop[m
[32m+[m[32m    bool                    DragDropActive;[m
[32m+[m[32m    bool                    DragDropWithinSourceOrTarget;[m
[32m+[m[32m    ImGuiDragDropFlags      DragDropSourceFlags;[m
[32m+[m[32m    int                     DragDropSourceFrameCount;[m
[32m+[m[32m    int                     DragDropMouseButton;[m
[32m+[m[32m    ImGuiPayload            DragDropPayload;[m
[32m+[m[32m    ImRect                  DragDropTargetRect;[m
[32m+[m[32m    ImGuiID                 DragDropTargetId;[m
[32m+[m[32m    ImGuiDragDropFlags      DragDropAcceptFlags;[m
[32m+[m[32m    float                   DragDropAcceptIdCurrRectSurface;    // Target item surface (we resolve overlapping targets by prioritizing the smaller surface)[m
[32m+[m[32m    ImGuiID                 DragDropAcceptIdCurr;               // Target item id (set at the time of accepting the payload)[m
[32m+[m[32m    ImGuiID                 DragDropAcceptIdPrev;               // Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)[m
[32m+[m[32m    int                     DragDropAcceptFrameCount;           // Last time a target expressed a desire to accept the source[m
[32m+[m[32m    ImVector<unsigned char> DragDropPayloadBufHeap;             // We don't expose the ImVector<> directly[m
[32m+[m[32m    unsigned char           DragDropPayloadBufLocal[8];         // Local buffer for small payloads[m
[32m+[m
[32m+[m[32m    // Tab bars[m
[32m+[m[32m    ImPool<ImGuiTabBar>             TabBars;[m
[32m+[m[32m    ImGuiTabBar*                    CurrentTabBar;[m
[32m+[m[32m    ImVector<ImGuiTabBarRef>        CurrentTabBarStack;[m
[32m+[m[32m    ImVector<ImGuiTabBarSortItem>   TabSortByWidthBuffer;[m
[32m+[m
[32m+[m[32m    // Widget state[m
[32m+[m[32m    ImGuiInputTextState     InputTextState;[m
[32m+[m[32m    ImFont                  InputTextPasswordFont;[m
[32m+[m[32m    ImGuiID                 TempInputTextId;                    // Temporary text input when CTRL+clicking on a slider, etc.[m
[32m+[m[32m    ImGuiColorEditFlags     ColorEditOptions;                   // Store user options for color edit widgets[m
[32m+[m[32m    ImVec4                  ColorPickerRef;[m
[32m+[m[32m    bool                    DragCurrentAccumDirty;[m
[32m+[m[32m    float                   DragCurrentAccum;                   // Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings[m
[32m+[m[32m    float                   DragSpeedDefaultRatio;              // If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio[m
[32m+[m[32m    ImVec2                  ScrollbarClickDeltaToGrabCenter;    // Distance between mouse and center of grab box, normalized in parent space. Use storage?[m
[32m+[m[32m    int                     TooltipOverrideCount;[m
[32m+[m[32m    ImVector<char>          PrivateClipboard;                   // If no custom clipboard handler is defined[m
[32m+[m
[32m+[m[32m    // Range-Select/Multi-Select[m
[32m+[m[32m    // [This is unused in this branch, but left here to facilitate merging/syncing multiple branches][m
[32m+[m[32m    ImGuiID                 MultiSelectScopeId;[m
[32m+[m
[32m+[m[32m    // Platform support[m
[32m+[m[32m    ImVec2                  PlatformImePos;                     // Cursor position request & last passed to the OS Input Method Editor[m
[32m+[m[32m    ImVec2                  PlatformImeLastPos;[m
[32m+[m
[32m+[m[32m    // Settings[m
[32m+[m[32m    bool                           SettingsLoaded;[m
[32m+[m[32m    float                          SettingsDirtyTimer;          // Save .ini Settings to memory when time reaches zero[m
[32m+[m[32m    ImGuiTextBuffer                SettingsIniData;             // In memory .ini settings[m
[32m+[m[32m    ImVector<ImGuiSettingsHandler> SettingsHandlers;            // List of .ini settings handlers[m
[32m+[m[32m    ImVector<ImGuiWindowSettings>  SettingsWindows;             // ImGuiWindow .ini settings entries (parsed from the last loaded .ini file and maintained on saving)[m
[32m+[m
[32m+[m[32m    // Logging[m
[32m+[m[32m    bool                    LogEnabled;[m
[32m+[m[32m    ImGuiLogType            LogType;[m
[32m+[m[32m    FILE*                   LogFile;                            // If != NULL log to stdout/ file[m
[32m+[m[32m    ImGuiTextBuffer         LogBuffer;                          // Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.[m
[32m+[m[32m    float                   LogLinePosY;[m
[32m+[m[32m    bool                    LogLineFirstItem;[m
[32m+[m[32m    int                     LogDepthRef;[m
[32m+[m[32m    int                     LogDepthToExpand;[m
[32m+[m[32m    int                     LogDepthToExpandDefault;            // Default/stored value for LogDepthMaxExpand if not specified in the LogXXX function call.[m
[32m+[m
[32m+[m[32m    // Misc[m
[32m+[m[32m    float                   FramerateSecPerFrame[120];          // Calculate estimate of framerate for user over the last 2 seconds.[m
[32m+[m[32m    int                     FramerateSecPerFrameIdx;[m
[32m+[m[32m    float                   FramerateSecPerFrameAccum;[m
[32m+[m[32m    int                     WantCaptureMouseNextFrame;          // Explicit capture via CaptureKeyboardFromApp()/CaptureMouseFromApp() sets those flags[m
[32m+[m[32m    int                     WantCaptureKeyboardNextFrame;[m
[32m+[m[32m    int                     WantTextInputNextFrame;[m
[32m+[m[32m    char                    TempBuffer[1024*3+1];               // Temporary text buffer[m
[32m+[m
[32m+[m[32m    ImGuiContext(ImFontAtlas* shared_font_atlas) : BackgroundDrawList(NULL), ForegroundDrawList(NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        Initialized = false;[m
[32m+[m[32m        FrameScopeActive = FrameScopePushedImplicitWindow = false;[m
[32m+[m[32m        Font = NULL;[m
[32m+[m[32m        FontSize = FontBaseSize = 0.0f;[m
[32m+[m[32m        FontAtlasOwnedByContext = shared_font_atlas ? false : true;[m
[32m+[m[32m        IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)();[m
[32m+[m
[32m+[m[32m        Time = 0.0f;[m
[32m+[m[32m        FrameCount = 0;[m
[32m+[m[32m        FrameCountEnded = FrameCountRendered = -1;[m
[32m+[m[32m        WindowsActiveCount = 0;[m
[32m+[m[32m        CurrentWindow = NULL;[m
[32m+[m[32m        HoveredWindow = NULL;[m
[32m+[m[32m        HoveredRootWindow = NULL;[m
[32m+[m[32m        HoveredId = 0;[m
[32m+[m[32m        HoveredIdAllowOverlap = false;[m
[32m+[m[32m        HoveredIdPreviousFrame = 0;[m
[32m+[m[32m        HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;[m
[32m+[m[32m        ActiveId = 0;[m
[32m+[m[32m        ActiveIdPreviousFrame = 0;[m
[32m+[m[32m        ActiveIdIsAlive = 0;[m
[32m+[m[32m        ActiveIdTimer = 0.0f;[m
[32m+[m[32m        ActiveIdIsJustActivated = false;[m
[32m+[m[32m        ActiveIdAllowOverlap = false;[m
[32m+[m[32m        ActiveIdHasBeenPressed = false;[m
[32m+[m[32m        ActiveIdHasBeenEdited = false;[m
[32m+[m[32m        ActiveIdPreviousFrameIsAlive = false;[m
[32m+[m[32m        ActiveIdPreviousFrameHasBeenEdited = false;[m
[32m+[m[32m        ActiveIdAllowNavDirFlags = 0x00;[m
[32m+[m[32m        ActiveIdBlockNavInputFlags = 0x00;[m
[32m+[m[32m        ActiveIdClickOffset = ImVec2(-1,-1);[m
[32m+[m[32m        ActiveIdWindow = ActiveIdPreviousFrameWindow = NULL;[m
[32m+[m[32m        ActiveIdSource = ImGuiInputSource_None;[m
[32m+[m[32m        LastActiveId = 0;[m
[32m+[m[32m        LastActiveIdTimer = 0.0f;[m
[32m+[m[32m        LastValidMousePos = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m        MovingWindow = NULL;[m
[32m+[m[32m        NextTreeNodeOpenVal = false;[m
[32m+[m[32m        NextTreeNodeOpenCond = 0;[m
[32m+[m
[32m+[m[32m        NavWindow = NULL;[m
[32m+[m[32m        NavId = NavActivateId = NavActivateDownId = NavActivatePressedId = NavInputId = 0;[m
[32m+[m[32m        NavJustTabbedId = NavJustMovedToId = NavJustMovedToMultiSelectScopeId = NavNextActivateId = 0;[m
[32m+[m[32m        NavInputSource = ImGuiInputSource_None;[m
[32m+[m[32m        NavScoringRectScreen = ImRect();[m
[32m+[m[32m        NavScoringCount = 0;[m
[32m+[m[32m        NavWindowingTarget = NavWindowingTargetAnim = NavWindowingList = NULL;[m
[32m+[m[32m        NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;[m
[32m+[m[32m        NavWindowingToggleLayer = false;[m
[32m+[m[32m        NavLayer = ImGuiNavLayer_Main;[m
[32m+[m[32m        NavIdTabCounter = INT_MAX;[m
[32m+[m[32m        NavIdIsAlive = false;[m
[32m+[m[32m        NavMousePosDirty = false;[m
[32m+[m[32m        NavDisableHighlight = true;[m
[32m+[m[32m        NavDisableMouseHover = false;[m
[32m+[m[32m        NavAnyRequest = false;[m
[32m+[m[32m        NavInitRequest = false;[m
[32m+[m[32m        NavInitRequestFromMove = false;[m
[32m+[m[32m        NavInitResultId = 0;[m
[32m+[m[32m        NavMoveFromClampedRefRect = false;[m
[32m+[m[32m        NavMoveRequest = false;[m
[32m+[m[32m        NavMoveRequestFlags = 0;[m
[32m+[m[32m        NavMoveRequestForward = ImGuiNavForward_None;[m
[32m+[m[32m        NavMoveDir = NavMoveDirLast = NavMoveClipDir = ImGuiDir_None;[m
[32m+[m
[32m+[m[32m        FocusRequestCurrWindow = FocusRequestNextWindow = NULL;[m
[32m+[m[32m        FocusRequestCurrCounterAll = FocusRequestCurrCounterTab = INT_MAX;[m
[32m+[m[32m        FocusRequestNextCounterAll = FocusRequestNextCounterTab = INT_MAX;[m
[32m+[m[32m        FocusTabPressed = false;[m
[32m+[m
[32m+[m[32m        DimBgRatio = 0.0f;[m
[32m+[m[32m        BackgroundDrawList._Data = &DrawListSharedData;[m
[32m+[m[32m        BackgroundDrawList._OwnerName = "##Background"; // Give it a name for debugging[m
[32m+[m[32m        ForegroundDrawList._Data = &DrawListSharedData;[m
[32m+[m[32m        ForegroundDrawList._OwnerName = "##Foreground"; // Give it a name for debugging[m
[32m+[m[32m        MouseCursor = ImGuiMouseCursor_Arrow;[m
[32m+[m
[32m+[m[32m        DragDropActive = DragDropWithinSourceOrTarget = false;[m
[32m+[m[32m        DragDropSourceFlags = 0;[m
[32m+[m[32m        DragDropSourceFrameCount = -1;[m
[32m+[m[32m        DragDropMouseButton = -1;[m
[32m+[m[32m        DragDropTargetId = 0;[m
[32m+[m[32m        DragDropAcceptFlags = 0;[m
[32m+[m[32m        DragDropAcceptIdCurrRectSurface = 0.0f;[m
[32m+[m[32m        DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;[m
[32m+[m[32m        DragDropAcceptFrameCount = -1;[m
[32m+[m[32m        memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));[m
[32m+[m
[32m+[m[32m        CurrentTabBar = NULL;[m
[32m+[m
[32m+[m[32m        TempInputTextId = 0;[m
[32m+[m[32m        ColorEditOptions = ImGuiColorEditFlags__OptionsDefault;[m
[32m+[m[32m        DragCurrentAccumDirty = false;[m
[32m+[m[32m        DragCurrentAccum = 0.0f;[m
[32m+[m[32m        DragSpeedDefaultRatio = 1.0f / 100.0f;[m
[32m+[m[32m        ScrollbarClickDeltaToGrabCenter = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m        TooltipOverrideCount = 0;[m
[32m+[m
[32m+[m[32m        MultiSelectScopeId = 0;[m
[32m+[m
[32m+[m[32m        PlatformImePos = PlatformImeLastPos = ImVec2(FLT_MAX, FLT_MAX);[m
[32m+[m
[32m+[m[32m        SettingsLoaded = false;[m
[32m+[m[32m        SettingsDirtyTimer = 0.0f;[m
[32m+[m
[32m+[m[32m        LogEnabled = false;[m
[32m+[m[32m        LogType = ImGuiLogType_None;[m
[32m+[m[32m        LogFile = NULL;[m
[32m+[m[32m        LogLinePosY = FLT_MAX;[m
[32m+[m[32m        LogLineFirstItem = false;[m
[32m+[m[32m        LogDepthRef = 0;[m
[32m+[m[32m        LogDepthToExpand = LogDepthToExpandDefault = 2;[m
[32m+[m
[32m+[m[32m        memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));[m
[32m+[m[32m        FramerateSecPerFrameIdx = 0;[m
[32m+[m[32m        FramerateSecPerFrameAccum = 0.0f;[m
[32m+[m[32m        WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;[m
[32m+[m[32m        memset(TempBuffer, 0, sizeof(TempBuffer));[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// ImGuiWindow[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.[m
[32m+[m[32m// FIXME: That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered.[m
[32m+[m[32mstruct IMGUI_API ImGuiWindowTempData[m
[32m+[m[32m{[m
[32m+[m[32m    ImVec2                  CursorPos;[m
[32m+[m[32m    ImVec2                  CursorPosPrevLine;[m
[32m+[m[32m    ImVec2                  CursorStartPos;         // Initial position in client area with padding[m
[32m+[m[32m    ImVec2                  CursorMaxPos;           // Used to implicitly calculate the size of our contents, always growing during the frame. Turned into window->SizeContents at the beginning of next frame[m
[32m+[m[32m    ImVec2                  CurrentLineSize;[m
[32m+[m[32m    float                   CurrentLineTextBaseOffset;[m
[32m+[m[32m    ImVec2                  PrevLineSize;[m
[32m+[m[32m    float                   PrevLineTextBaseOffset;[m
[32m+[m[32m    int                     TreeDepth;[m
[32m+[m[32m    ImU32                   TreeStoreMayJumpToParentOnPop; // Store a copy of !g.NavIdIsAlive for TreeDepth 0..31.. Could be turned into a ImU64 if necessary.[m
[32m+[m[32m    ImGuiID                 LastItemId;[m
[32m+[m[32m    ImGuiItemStatusFlags    LastItemStatusFlags;[m
[32m+[m[32m    ImRect                  LastItemRect;           // Interaction rect[m
[32m+[m[32m    ImRect                  LastItemDisplayRect;    // End-user display rect (only valid if LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect)[m
[32m+[m[32m    ImGuiNavLayer           NavLayerCurrent;        // Current layer, 0..31 (we currently only use 0..1)[m
[32m+[m[32m    int                     NavLayerCurrentMask;    // = (1 << NavLayerCurrent) used by ItemAdd prior to clipping.[m
[32m+[m[32m    int                     NavLayerActiveMask;     // Which layer have been written to (result from previous frame)[m
[32m+[m[32m    int                     NavLayerActiveMaskNext; // Which layer have been written to (buffer for current frame)[m
[32m+[m[32m    bool                    NavHideHighlightOneFrame;[m
[32m+[m[32m    bool                    NavHasScroll;           // Set when scrolling can be used (ScrollMax > 0.0f)[m
[32m+[m[32m    bool                    MenuBarAppending;       // FIXME: Remove this[m
[32m+[m[32m    ImVec2                  MenuBarOffset;          // MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.[m
[32m+[m[32m    ImVector<ImGuiWindow*>  ChildWindows;[m
[32m+[m[32m    ImGuiStorage*           StateStorage;[m
[32m+[m[32m    ImGuiLayoutType         LayoutType;[m
[32m+[m[32m    ImGuiLayoutType         ParentLayoutType;       // Layout type of parent window at the time of Begin()[m
[32m+[m[32m    int                     FocusCounterAll;        // Counter for focus/tabbing system. Start at -1 and increase as assigned via FocusableItemRegister() (FIXME-NAV: Needs redesign)[m
[32m+[m[32m    int                     FocusCounterTab;        // (same, but only count widgets which you can Tab through)[m
[32m+[m
[32m+[m[32m    // We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.[m
[32m+[m[32m    ImGuiItemFlags          ItemFlags;              // == ItemFlagsStack.back() [empty == ImGuiItemFlags_Default][m
[32m+[m[32m    float                   ItemWidth;              // == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels, <0.0: align xx pixels to the right of window[m
[32m+[m[32m    float                   NextItemWidth;[m
[32m+[m[32m    float                   TextWrapPos;            // == TextWrapPosStack.back() [empty == -1.0f][m
[32m+[m[32m    ImVector<ImGuiItemFlags>ItemFlagsStack;[m
[32m+[m[32m    ImVector<float>         ItemWidthStack;[m
[32m+[m[32m    ImVector<float>         TextWrapPosStack;[m
[32m+[m[32m    ImVector<ImGuiGroupData>GroupStack;[m
[32m+[m[32m    short                   StackSizesBackup[6];    // Store size of various stacks for asserting[m
[32m+[m
[32m+[m[32m    ImVec1                  Indent;                 // Indentation / start position from left of window (increased by TreePush/TreePop, etc.)[m
[32m+[m[32m    ImVec1                  GroupOffset;[m
[32m+[m[32m    ImVec1                  ColumnsOffset;          // Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.[m
[32m+[m[32m    ImGuiColumns*           CurrentColumns;         // Current columns set[m
[32m+[m
[32m+[m[32m    ImGuiWindowTempData()[m
[32m+[m[32m    {[m
[32m+[m[32m        CursorPos = CursorPosPrevLine = CursorStartPos = CursorMaxPos = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m        CurrentLineSize = PrevLineSize = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m        CurrentLineTextBaseOffset = PrevLineTextBaseOffset = 0.0f;[m
[32m+[m[32m        TreeDepth = 0;[m
[32m+[m[32m        TreeStoreMayJumpToParentOnPop = 0x00;[m
[32m+[m[32m        LastItemId = 0;[m
[32m+[m[32m        LastItemStatusFlags = 0;[m
[32m+[m[32m        LastItemRect = LastItemDisplayRect = ImRect();[m
[32m+[m[32m        NavLayerActiveMask = NavLayerActiveMaskNext = 0x00;[m
[32m+[m[32m        NavLayerCurrent = ImGuiNavLayer_Main;[m
[32m+[m[32m        NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);[m
[32m+[m[32m        NavHideHighlightOneFrame = false;[m
[32m+[m[32m        NavHasScroll = false;[m
[32m+[m[32m        MenuBarAppending = false;[m
[32m+[m[32m        MenuBarOffset = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m        StateStorage = NULL;[m
[32m+[m[32m        LayoutType = ParentLayoutType = ImGuiLayoutType_Vertical;[m
[32m+[m[32m        FocusCounterAll = FocusCounterTab = -1;[m
[32m+[m
[32m+[m[32m        ItemFlags = ImGuiItemFlags_Default_;[m
[32m+[m[32m        ItemWidth = 0.0f;[m
[32m+[m[32m        NextItemWidth = +FLT_MAX;[m
[32m+[m[32m        TextWrapPos = -1.0f;[m
[32m+[m[32m        memset(StackSizesBackup, 0, sizeof(StackSizesBackup));[m
[32m+[m
[32m+[m[32m        Indent = ImVec1(0.0f);[m
[32m+[m[32m        GroupOffset = ImVec1(0.0f);[m
[32m+[m[32m        ColumnsOffset = ImVec1(0.0f);[m
[32m+[m[32m        CurrentColumns = NULL;[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Storage for one window[m
[32m+[m[32mstruct IMGUI_API ImGuiWindow[m
[32m+[m[32m{[m
[32m+[m[32m    char*                   Name;[m
[32m+[m[32m    ImGuiID                 ID;                                 // == ImHash(Name)[m
[32m+[m[32m    ImGuiWindowFlags        Flags;                              // See enum ImGuiWindowFlags_[m
[32m+[m[32m    ImVec2                  Pos;                                // Position (always rounded-up to nearest pixel)[m
[32m+[m[32m    ImVec2                  Size;                               // Current size (==SizeFull or collapsed title bar size)[m
[32m+[m[32m    ImVec2                  SizeFull;                           // Size when non collapsed[m
[32m+[m[32m    ImVec2                  SizeFullAtLastBegin;                // Copy of SizeFull at the end of Begin. This is the reference value we'll use on the next frame to decide if we need scrollbars.[m
[32m+[m[32m    ImVec2                  SizeContents;                       // Size of contents (== extents reach of the drawing cursor) from previous frame. Include decoration, window title, border, menu, etc.[m
[32m+[m[32m    ImVec2                  SizeContentsExplicit;               // Size of contents explicitly set by the user via SetNextWindowContentSize()[m
[32m+[m[32m    ImVec2                  WindowPadding;                      // Window padding at the time of begin.[m
[32m+[m[32m    float                   WindowRounding;                     // Window rounding at the time of begin.[m
[32m+[m[32m    float                   WindowBorderSize;                   // Window border size at the time of begin.[m
[32m+[m[32m    int                     NameBufLen;                         // Size of buffer storing Name. May be larger than strlen(Name)![m
[32m+[m[32m    ImGuiID                 MoveId;                             // == window->GetID("#MOVE")[m
[32m+[m[32m    ImGuiID                 ChildId;                            // ID of corresponding item in parent window (for navigation to return from child window to parent window)[m
[32m+[m[32m    ImVec2                  Scroll;[m
[32m+[m[32m    ImVec2                  ScrollTarget;                       // target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)[m
[32m+[m[32m    ImVec2                  ScrollTargetCenterRatio;            // 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered[m
[32m+[m[32m    ImVec2                  ScrollbarSizes;                     // Size taken by scrollbars on each axis[m
[32m+[m[32m    bool                    ScrollbarX, ScrollbarY;[m
[32m+[m[32m    bool                    Active;                             // Set to true on Begin(), unless Collapsed[m
[32m+[m[32m    bool                    WasActive;[m
[32m+[m[32m    bool                    WriteAccessed;                      // Set to true when any widget access the current window[m
[32m+[m[32m    bool                    Collapsed;                          // Set when collapsing window to become only title-bar[m
[32m+[m[32m    bool                    WantCollapseToggle;[m
[32m+[m[32m    bool                    SkipItems;                          // Set when items can safely be all clipped (e.g. window not visible or collapsed)[m
[32m+[m[32m    bool                    Appearing;                          // Set during the frame where the window is appearing (or re-appearing)[m
[32m+[m[32m    bool                    Hidden;                             // Do not display (== (HiddenFrames*** > 0))[m
[32m+[m[32m    bool                    HasCloseButton;                     // Set when the window has a close button (p_open != NULL)[m
[32m+[m[32m    signed char             ResizeBorderHeld;                   // Current border being held for resize (-1: none, otherwise 0-3)[m
[32m+[m[32m    short                   BeginCount;                         // Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)[m
[32m+[m[32m    short                   BeginOrderWithinParent;             // Order within immediate parent window, if we are a child window. Otherwise 0.[m
[32m+[m[32m    short                   BeginOrderWithinContext;            // Order within entire imgui context. This is mostly used for debugging submission order related issues.[m
[32m+[m[32m    ImGuiID                 PopupId;                            // ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)[m
[32m+[m[32m    int                     AutoFitFramesX, AutoFitFramesY;[m
[32m+[m[32m    bool                    AutoFitOnlyGrows;[m
[32m+[m[32m    int                     AutoFitChildAxises;[m
[32m+[m[32m    ImGuiDir                AutoPosLastDirection;[m
[32m+[m[32m    int                     HiddenFramesCanSkipItems;           // Hide the window for N frames[m
[32m+[m[32m    int                     HiddenFramesCannotSkipItems;        // Hide the window for N frames while allowing items to be submitted so we can measure their size[m
[32m+[m[32m    ImGuiCond               SetWindowPosAllowFlags;             // store acceptable condition flags for SetNextWindowPos() use.[m
[32m+[m[32m    ImGuiCond               SetWindowSizeAllowFlags;            // store acceptable condition flags for SetNextWindowSize() use.[m
[32m+[m[32m    ImGuiCond               SetWindowCollapsedAllowFlags;       // store acceptable condition flags for SetNextWindowCollapsed() use.[m
[32m+[m[32m    ImVec2                  SetWindowPosVal;                    // store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)[m
[32m+[m[32m    ImVec2                  SetWindowPosPivot;                  // store window pivot for positioning. ImVec2(0,0) when positioning from top-left corner; ImVec2(0.5f,0.5f) for centering; ImVec2(1,1) for bottom right.[m
[32m+[m
[32m+[m[32m    ImGuiWindowTempData     DC;                                 // Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.[m
[32m+[m[32m    ImVector<ImGuiID>       IDStack;                            // ID stack. ID are hashes seeded with the value at the top of the stack[m
[32m+[m[32m    ImRect                  ClipRect;                           // Current clipping rectangle. = DrawList->clip_rect_stack.back(). Scissoring / clipping rectangle. x1, y1, x2, y2.[m
[32m+[m[32m    ImRect                  OuterRectClipped;                   // = WindowRect just after setup in Begin(). == window->Rect() for root window.[m
[32m+[m[32m    ImRect                  InnerMainRect, InnerClipRect;[m
[32m+[m[32m    ImRect                  ContentsRegionRect;                 // FIXME: This is currently confusing/misleading. Maximum visible content position ~~ Pos + (SizeContentsExplicit ? SizeContentsExplicit : Size - ScrollbarSizes) - CursorStartPos, per axis[m
[32m+[m[32m    int                     LastFrameActive;                    // Last frame number the window was Active.[m
[32m+[m[32m    float                   ItemWidthDefault;[m
[32m+[m[32m    ImGuiMenuColumns        MenuColumns;                        // Simplified columns storage for menu items[m
[32m+[m[32m    ImGuiStorage            StateStorage;[m
[32m+[m[32m    ImVector<ImGuiColumns>  ColumnsStorage;[m
[32m+[m[32m    float                   FontWindowScale;                    // User scale multiplier per-window[m
[32m+[m[32m    int                     SettingsIdx;                        // Index into SettingsWindow[] (indices are always valid as we only grow the array from the back)[m
[32m+[m
[32m+[m[32m    ImDrawList*             DrawList;                           // == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)[m
[32m+[m[32m    ImDrawList              DrawListInst;[m
[32m+[m[32m    ImGuiWindow*            ParentWindow;                       // If we are a child _or_ popup window, this is pointing to our parent. Otherwise NULL.[m
[32m+[m[32m    ImGuiWindow*            RootWindow;                         // Point to ourself or first ancestor that is not a child window.[m
[32m+[m[32m    ImGuiWindow*            RootWindowForTitleBarHighlight;     // Point to ourself or first ancestor which will display TitleBgActive color when this window is active.[m
[32m+[m[32m    ImGuiWindow*            RootWindowForNav;                   // Point to ourself or first ancestor which doesn't have the NavFlattened flag.[m
[32m+[m
[32m+[m[32m    ImGuiWindow*            NavLastChildNavWindow;              // When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)[m
[32m+[m[32m    ImGuiID                 NavLastIds[ImGuiNavLayer_COUNT];    // Last known NavId for this window, per layer (0/1)[m
[32m+[m[32m    ImRect                  NavRectRel[ImGuiNavLayer_COUNT];    // Reference rectangle, in window relative space[m
[32m+[m
[32m+[m[32mpublic:[m
[32m+[m[32m    ImGuiWindow(ImGuiContext* context, const char* name);[m
[32m+[m[32m    ~ImGuiWindow();[m
[32m+[m
[32m+[m[32m    ImGuiID     GetID(const char* str, const char* str_end = NULL);[m
[32m+[m[32m    ImGuiID     GetID(const void* ptr);[m
[32m+[m[32m    ImGuiID     GetIDNoKeepAlive(const char* str, const char* str_end = NULL);[m
[32m+[m[32m    ImGuiID     GetIDNoKeepAlive(const void* ptr);[m
[32m+[m[32m    ImGuiID     GetIDFromRectangle(const ImRect& r_abs);[m
[32m+[m
[32m+[m[32m    // We don't use g.FontSize because the window may be != g.CurrentWidow.[m
[32m+[m[32m    ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }[m
[32m+[m[32m    float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }[m
[32m+[m[32m    float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }[m
[32m+[m[32m    ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }[m
[32m+[m[32m    float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }[m
[32m+[m[32m    ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Backup and restore just enough data to be able to use IsItemHovered() on item A after another B in the same window has overwritten the data.[m
[32m+[m[32mstruct ImGuiItemHoveredDataBackup[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiID                 LastItemId;[m
[32m+[m[32m    ImGuiItemStatusFlags    LastItemStatusFlags;[m
[32m+[m[32m    ImRect                  LastItemRect;[m
[32m+[m[32m    ImRect                  LastItemDisplayRect;[m
[32m+[m
[32m+[m[32m    ImGuiItemHoveredDataBackup() { Backup(); }[m
[32m+[m[32m    void Backup()           { ImGuiWindow* window = GImGui->CurrentWindow; LastItemId = window->DC.LastItemId; LastItemStatusFlags = window->DC.LastItemStatusFlags; LastItemRect = window->DC.LastItemRect; LastItemDisplayRect = window->DC.LastItemDisplayRect; }[m
[32m+[m[32m    void Restore() const    { ImGuiWindow* window = GImGui->CurrentWindow; window->DC.LastItemId = LastItemId; window->DC.LastItemStatusFlags = LastItemStatusFlags; window->DC.LastItemRect = LastItemRect; window->DC.LastItemDisplayRect = LastItemDisplayRect; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Tab bar, tab item[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32menum ImGuiTabBarFlagsPrivate_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiTabBarFlags_DockNode                   = 1 << 20,  // Part of a dock node [we don't use this in the master branch but it facilitate branch syncing to keep this around][m
[32m+[m[32m    ImGuiTabBarFlags_IsFocused                  = 1 << 21,[m
[32m+[m[32m    ImGuiTabBarFlags_SaveSettings               = 1 << 22   // FIXME: Settings are handled by the docking system, this only request the tab bar to mark settings dirty when reordering tabs[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum ImGuiTabItemFlagsPrivate_[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiTabItemFlags_NoCloseButton             = 1 << 20   // Store whether p_open is set or not, which we need to recompute WidthContents during layout.[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Storage for one active tab item (sizeof() 26~32 bytes)[m
[32m+[m[32mstruct ImGuiTabItem[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiID             ID;[m
[32m+[m[32m    ImGuiTabItemFlags   Flags;[m
[32m+[m[32m    int                 LastFrameVisible;[m
[32m+[m[32m    int                 LastFrameSelected;      // This allows us to infer an ordered list of the last activated tabs with little maintenance[m
[32m+[m[32m    int                 NameOffset;             // When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames[m
[32m+[m[32m    float               Offset;                 // Position relative to beginning of tab[m
[32m+[m[32m    float               Width;                  // Width currently displayed[m
[32m+[m[32m    float               WidthContents;          // Width of actual contents, stored during BeginTabItem() call[m
[32m+[m
[32m+[m[32m    ImGuiTabItem()      { ID = Flags = 0; LastFrameVisible = LastFrameSelected = -1; NameOffset = -1; Offset = Width = WidthContents = 0.0f; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Storage for a tab bar (sizeof() 92~96 bytes)[m
[32m+[m[32mstruct ImGuiTabBar[m
[32m+[m[32m{[m
[32m+[m[32m    ImVector<ImGuiTabItem> Tabs;[m
[32m+[m[32m    ImGuiID             ID;                     // Zero for tab-bars used by docking[m
[32m+[m[32m    ImGuiID             SelectedTabId;          // Selected tab[m
[32m+[m[32m    ImGuiID             NextSelectedTabId;[m
[32m+[m[32m    ImGuiID             VisibleTabId;           // Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)[m
[32m+[m[32m    int                 CurrFrameVisible;[m
[32m+[m[32m    int                 PrevFrameVisible;[m
[32m+[m[32m    ImRect              BarRect;[m
[32m+[m[32m    float               ContentsHeight;[m
[32m+[m[32m    float               OffsetMax;              // Distance from BarRect.Min.x, locked during layout[m
[32m+[m[32m    float               OffsetNextTab;          // Distance from BarRect.Min.x, incremented with each BeginTabItem() call, not used if ImGuiTabBarFlags_Reorderable if set.[m
[32m+[m[32m    float               ScrollingAnim;[m
[32m+[m[32m    float               ScrollingTarget;[m
[32m+[m[32m    float               ScrollingTargetDistToVisibility;[m
[32m+[m[32m    float               ScrollingSpeed;[m
[32m+[m[32m    ImGuiTabBarFlags    Flags;[m
[32m+[m[32m    ImGuiID             ReorderRequestTabId;[m
[32m+[m[32m    int                 ReorderRequestDir;[m
[32m+[m[32m    bool                WantLayout;[m
[32m+[m[32m    bool                VisibleTabWasSubmitted;[m
[32m+[m[32m    short               LastTabItemIdx;         // For BeginTabItem()/EndTabItem()[m
[32m+[m[32m    ImVec2              FramePadding;           // style.FramePadding locked at the time of BeginTabBar()[m
[32m+[m[32m    ImGuiTextBuffer     TabsNames;              // For non-docking tab bar we re-append names in a contiguous buffer.[m
[32m+[m
[32m+[m[32m    ImGuiTabBar();[m
[32m+[m[32m    int                 GetTabOrder(const ImGuiTabItem* tab) const  { return Tabs.index_from_ptr(tab); }[m
[32m+[m[32m    const char*         GetTabName(const ImGuiTabItem* tab) const[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(tab->NameOffset != -1 && tab->NameOffset < TabsNames.Buf.Size);[m
[32m+[m[32m        return TabsNames.Buf.Data + tab->NameOffset;[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m[32m// Internal API[m
[32m+[m[32m// No guarantee of forward compatibility here.[m
[32m+[m[32m//-----------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mnamespace ImGui[m
[32m+[m[32m{[m
[32m+[m[32m    // We should always have a CurrentWindow in the stack (there is an implicit "Debug" window)[m
[32m+[m[32m    // If this ever crash because g.CurrentWindow is NULL it means that either[m
[32m+[m[32m    // - ImGui::NewFrame() has never been called, which is illegal.[m
[32m+[m[32m    // - You are calling ImGui functions after ImGui::EndFrame()/ImGui::Render() and before the next ImGui::NewFrame(), which is also illegal.[m
[32m+[m[32m    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }[m
[32m+[m[32m    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }[m
[32m+[m[32m    IMGUI_API ImGuiWindow*  FindWindowByID(ImGuiID id);[m
[32m+[m[32m    IMGUI_API ImGuiWindow*  FindWindowByName(const char* name);[m
[32m+[m[32m    IMGUI_API void          FocusWindow(ImGuiWindow* window);[m
[32m+[m[32m    IMGUI_API void          FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window);[m
[32m+[m[32m    IMGUI_API void          BringWindowToFocusFront(ImGuiWindow* window);[m
[32m+[m[32m    IMGUI_API void          BringWindowToDisplayFront(ImGuiWindow* window);[m
[32m+[m[32m    IMGUI_API void          BringWindowToDisplayBack(ImGuiWindow* window);[m
[32m+[m[32m    IMGUI_API void          UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window);[m
[32m+[m[32m    IMGUI_API ImVec2        CalcWindowExpectedSize(ImGuiWindow* window);[m
[32m+[m[32m    IMGUI_API bool          IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent);[m
[32m+[m[32m    IMGUI_API bool          IsWindowNavFocusable(ImGuiWindow* window);[m
[32m+[m[32m    IMGUI_API void          SetWindowScrollX(ImGuiWindow* window, float new_scroll_x);[m
[32m+[m[32m    IMGUI_API void          SetWindowScrollY(ImGuiWindow* window, float new_scroll_y);[m
[32m+[m[32m    IMGUI_API float         GetWindowScrollMaxX(ImGuiWindow* window);[m
[32m+[m[32m    IMGUI_API float         GetWindowScrollMaxY(ImGuiWindow* window);[m
[32m+[m[32m    IMGUI_API ImRect        GetWindowAllowedExtentRect(ImGuiWindow* window);[m
[32m+[m[32m    IMGUI_API void          SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond);[m
[32m+[m[32m    IMGUI_API void          SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond);[m
[32m+[m[32m    IMGUI_API void          SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond);[m
[32m+[m
[32m+[m[32m    IMGUI_API void          SetCurrentFont(ImFont* font);[m
[32m+[m[32m    inline ImFont*          GetDefaultFont() { ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0]; }[m
[32m+[m
[32m+[m[32m    // Init[m
[32m+[m[32m    IMGUI_API void          Initialize(ImGuiContext* context);[m
[32m+[m[32m    IMGUI_API void          Shutdown(ImGuiContext* context);    // Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().[m
[32m+[m
[32m+[m[32m    // NewFrame[m
[32m+[m[32m    IMGUI_API void          UpdateHoveredWindowAndCaptureFlags();[m
[32m+[m[32m    IMGUI_API void          StartMouseMovingWindow(ImGuiWindow* window);[m
[32m+[m[32m    IMGUI_API void          UpdateMouseMovingWindowNewFrame();[m
[32m+[m[32m    IMGUI_API void          UpdateMouseMovingWindowEndFrame();[m
[32m+[m
[32m+[m[32m    // Settings[m
[32m+[m[32m    IMGUI_API void                  MarkIniSettingsDirty();[m
[32m+[m[32m    IMGUI_API void                  MarkIniSettingsDirty(ImGuiWindow* window);[m
[32m+[m[32m    IMGUI_API ImGuiWindowSettings*  CreateNewWindowSettings(const char* name);[m
[32m+[m[32m    IMGUI_API ImGuiWindowSettings*  FindWindowSettings(ImGuiID id);[m
[32m+[m[32m    IMGUI_API ImGuiWindowSettings*  FindOrCreateWindowSettings(const char* name);[m
[32m+[m[32m    IMGUI_API ImGuiSettingsHandler* FindSettingsHandler(const char* type_name);[m
[32m+[m
[32m+[m[32m    // Basic Accessors[m
[32m+[m[32m    inline ImGuiID          GetItemID()     { ImGuiContext& g = *GImGui; return g.CurrentWindow->DC.LastItemId; }[m
[32m+[m[32m    inline ImGuiID          GetActiveID()   { ImGuiContext& g = *GImGui; return g.ActiveId; }[m
[32m+[m[32m    inline ImGuiID          GetFocusID()    { ImGuiContext& g = *GImGui; return g.NavId; }[m
[32m+[m[32m    IMGUI_API void          SetActiveID(ImGuiID id, ImGuiWindow* window);[m
[32m+[m[32m    IMGUI_API void          SetFocusID(ImGuiID id, ImGuiWindow* window);[m
[32m+[m[32m    IMGUI_API void          ClearActiveID();[m
[32m+[m[32m    IMGUI_API ImGuiID       GetHoveredID();[m
[32m+[m[32m    IMGUI_API void          SetHoveredID(ImGuiID id);[m
[32m+[m[32m    IMGUI_API void          KeepAliveID(ImGuiID id);[m
[32m+[m[32m    IMGUI_API void          MarkItemEdited(ImGuiID id);[m
[32m+[m[32m    IMGUI_API void          PushOverrideID(ImGuiID id);[m
[32m+[m
[32m+[m[32m    // Basic Helpers for widget code[m
[32m+[m[32m    IMGUI_API void          ItemSize(const ImVec2& size, float text_offset_y = 0.0f);[m
[32m+[m[32m    IMGUI_API void          ItemSize(const ImRect& bb, float text_offset_y = 0.0f);[m
[32m+[m[32m    IMGUI_API bool          ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb = NULL);[m
[32m+[m[32m    IMGUI_API bool          ItemHoverable(const ImRect& bb, ImGuiID id);[m
[32m+[m[32m    IMGUI_API bool          IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged);[m
[32m+[m[32m    IMGUI_API bool          FocusableItemRegister(ImGuiWindow* window, ImGuiID id);   // Return true if focus is requested[m
[32m+[m[32m    IMGUI_API void          FocusableItemUnregister(ImGuiWindow* window);[m
[32m+[m[32m    IMGUI_API float         GetNextItemWidth();[m
[32m+[m[32m    IMGUI_API ImVec2        CalcItemSize(ImVec2 size, float default_w, float default_h);[m
[32m+[m[32m    IMGUI_API float         CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x);[m
[32m+[m[32m    IMGUI_API void          PushMultiItemsWidths(int components, float width_full);[m
[32m+[m[32m    IMGUI_API void          PushItemFlag(ImGuiItemFlags option, bool enabled);[m
[32m+[m[32m    IMGUI_API void          PopItemFlag();[m
[32m+[m[32m    IMGUI_API bool          IsItemToggledSelection();                                           // was the last item selection toggled? (after Selectable(), TreeNode() etc. We only returns toggle _event_ in order to handle clipping correctly)[m
[32m+[m[32m    IMGUI_API ImVec2        GetWorkRectMax();[m
[32m+[m
[32m+[m[32m    // Logging/Capture[m
[32m+[m[32m    IMGUI_API void          LogBegin(ImGuiLogType type, int auto_open_depth);   // -> BeginCapture() when we design v2 api, for now stay under the radar by using the old name.[m
[32m+[m[32m    IMGUI_API void          LogToBuffer(int auto_open_depth = -1);              // Start logging/capturing to internal buffer[m
[32m+[m
[32m+[m[32m    // Popups, Modals, Tooltips[m
[32m+[m[32m    IMGUI_API void          OpenPopupEx(ImGuiID id);[m
[32m+[m[32m    IMGUI_API void          ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup);[m
[32m+[m[32m    IMGUI_API void          ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup);[m
[32m+[m[32m    IMGUI_API bool          IsPopupOpen(ImGuiID id); // Test for id within current popup stack level (currently begin-ed into); this doesn't scan the whole popup stack![m
[32m+[m[32m    IMGUI_API bool          BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags);[m
[32m+[m[32m    IMGUI_API void          BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip = true);[m
[32m+[m[32m    IMGUI_API ImGuiWindow*  GetFrontMostPopupModal();[m
[32m+[m[32m    IMGUI_API ImVec2        FindBestWindowPosForPopup(ImGuiWindow* window);[m
[32m+[m[32m    IMGUI_API ImVec2        FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy = ImGuiPopupPositionPolicy_Default);[m
[32m+[m
[32m+[m[32m    // Navigation[m
[32m+[m[32m    IMGUI_API void          NavInitWindow(ImGuiWindow* window, bool force_reinit);[m
[32m+[m[32m    IMGUI_API bool          NavMoveRequestButNoResultYet();[m
[32m+[m[32m    IMGUI_API void          NavMoveRequestCancel();[m
[32m+[m[32m    IMGUI_API void          NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags);[m
[32m+[m[32m    IMGUI_API void          NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags);[m
[32m+[m[32m    IMGUI_API float         GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode);[m
[32m+[m[32m    IMGUI_API ImVec2        GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor = 0.0f, float fast_factor = 0.0f);[m
[32m+[m[32m    IMGUI_API int           CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate);[m
[32m+[m[32m    IMGUI_API void          ActivateItem(ImGuiID id);   // Remotely activate a button, checkbox, tree node etc. given its unique ID. activation is queued and processed on the next frame when the item is encountered again.[m
[32m+[m[32m    IMGUI_API void          SetNavID(ImGuiID id, int nav_layer);[m
[32m+[m[32m    IMGUI_API void          SetNavIDWithRectRel(ImGuiID id, int nav_layer, const ImRect& rect_rel);[m
[32m+[m
[32m+[m[32m    // Inputs[m
[32m+[m[32m    inline bool             IsKeyPressedMap(ImGuiKey key, bool repeat = true)           { const int key_index = GImGui->IO.KeyMap[key]; return (key_index >= 0) ? IsKeyPressed(key_index, repeat) : false; }[m
[32m+[m[32m    inline bool             IsNavInputDown(ImGuiNavInput n)                             { return GImGui->IO.NavInputs[n] > 0.0f; }[m
[32m+[m[32m    inline bool             IsNavInputPressed(ImGuiNavInput n, ImGuiInputReadMode mode) { return GetNavInputAmount(n, mode) > 0.0f; }[m
[32m+[m[32m    inline bool             IsNavInputPressedAnyOfTwo(ImGuiNavInput n1, ImGuiNavInput n2, ImGuiInputReadMode mode) { return (GetNavInputAmount(n1, mode) + GetNavInputAmount(n2, mode)) > 0.0f; }[m
[32m+[m
[32m+[m[32m    // Drag and Drop[m
[32m+[m[32m    IMGUI_API bool          BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id);[m
[32m+[m[32m    IMGUI_API void          ClearDragDrop();[m
[32m+[m[32m    IMGUI_API bool          IsDragDropPayloadBeingAccepted();[m
[32m+[m
[32m+[m[32m    // New Columns API (FIXME-WIP)[m
[32m+[m[32m    IMGUI_API void          BeginColumns(const char* str_id, int count, ImGuiColumnsFlags flags = 0); // setup number of columns. use an identifier to distinguish multiple column sets. close with EndColumns().[m
[32m+[m[32m    IMGUI_API void          EndColumns();                                                             // close columns[m
[32m+[m[32m    IMGUI_API void          PushColumnClipRect(int column_index = -1);[m
[32m+[m[32m    IMGUI_API ImGuiID       GetColumnsID(const char* str_id, int count);[m
[32m+[m[32m    IMGUI_API ImGuiColumns* FindOrCreateColumns(ImGuiWindow* window, ImGuiID id);[m
[32m+[m
[32m+[m[32m    // Tab Bars[m
[32m+[m[32m    IMGUI_API bool          BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect& bb, ImGuiTabBarFlags flags);[m
[32m+[m[32m    IMGUI_API ImGuiTabItem* TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id);[m
[32m+[m[32m    IMGUI_API void          TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id);[m
[32m+[m[32m    IMGUI_API void          TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);[m
[32m+[m[32m    IMGUI_API void          TabBarQueueChangeTabOrder(ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, int dir);[m
[32m+[m[32m    IMGUI_API bool          TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags);[m
[32m+[m[32m    IMGUI_API ImVec2        TabItemCalcSize(const char* label, bool has_close_button);[m
[32m+[m[32m    IMGUI_API void          TabItemBackground(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col);[m
[32m+[m[32m    IMGUI_API bool          TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id);[m
[32m+[m
[32m+[m[32m    // Render helpers[m
[32m+[m[32m    // AVOID USING OUTSIDE OF IMGUI.CPP! NOT FOR PUBLIC CONSUMPTION. THOSE FUNCTIONS ARE A MESS. THEIR SIGNATURE AND BEHAVIOR WILL CHANGE, THEY NEED TO BE REFACTORED INTO SOMETHING DECENT.[m
[32m+[m[32m    // NB: All position are in absolute pixels coordinates (we are never using window coordinates internally)[m
[32m+[m[32m    IMGUI_API void          RenderText(ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true);[m
[32m+[m[32m    IMGUI_API void          RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width);[m
[32m+[m[32m    IMGUI_API void          RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0,0), const ImRect* clip_rect = NULL);[m
[32m+[m[32m    IMGUI_API void          RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0, 0), const ImRect* clip_rect = NULL);[m
[32m+[m[32m    IMGUI_API void          RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f);[m
[32m+[m[32m    IMGUI_API void          RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding = 0.0f);[m
[32m+[m[32m    IMGUI_API void          RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, float grid_step, ImVec2 grid_off, float rounding = 0.0f, int rounding_corners_flags = ~0);[m
[32m+[m[32m    IMGUI_API void          RenderArrow(ImVec2 pos, ImGuiDir dir, float scale = 1.0f);[m
[32m+[m[32m    IMGUI_API void          RenderBullet(ImVec2 pos);[m
[32m+[m[32m    IMGUI_API void          RenderCheckMark(ImVec2 pos, ImU32 col, float sz);[m
[32m+[m[32m    IMGUI_API void          RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags = ImGuiNavHighlightFlags_TypeDefault); // Navigation highlight[m
[32m+[m[32m    IMGUI_API const char*   FindRenderedTextEnd(const char* text, const char* text_end = NULL); // Find the optional ## from which we stop displaying text.[m
[32m+[m[32m    IMGUI_API void          LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end = NULL);[m
[32m+[m
[32m+[m[32m    // Render helpers (those functions don't access any ImGui state!)[m
[32m+[m[32m    IMGUI_API void          RenderMouseCursor(ImDrawList* draw_list, ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor = ImGuiMouseCursor_Arrow);[m
[32m+[m[32m    IMGUI_API void          RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col);[m
[32m+[m[32m    IMGUI_API void          RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding);[m
[32m+[m[32m    IMGUI_API void          RenderPixelEllipsis(ImDrawList* draw_list, ImVec2 pos, int count, ImU32 col);[m
[32m+[m
[32m+[m[32m    // Widgets[m
[32m+[m[32m    IMGUI_API void          TextEx(const char* text, const char* text_end = NULL, ImGuiTextFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          ButtonEx(const char* label, const ImVec2& size_arg = ImVec2(0,0), ImGuiButtonFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          CloseButton(ImGuiID id, const ImVec2& pos, float radius);[m
[32m+[m[32m    IMGUI_API bool          CollapseButton(ImGuiID id, const ImVec2& pos);[m
[32m+[m[32m    IMGUI_API bool          ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size_arg, ImGuiButtonFlags flags);[m
[32m+[m[32m    IMGUI_API void          Scrollbar(ImGuiAxis axis);[m
[32m+[m[32m    IMGUI_API ImGuiID       GetScrollbarID(ImGuiWindow* window, ImGuiAxis axis);[m
[32m+[m[32m    IMGUI_API void          VerticalSeparator();        // Vertical separator, for menu bars (use current line height). Not exposed because it is misleading and it doesn't have an effect on regular layout.[m
[32m+[m
[32m+[m[32m    // Widgets low-level behaviors[m
[32m+[m[32m    IMGUI_API bool          ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = 0);[m
[32m+[m[32m    IMGUI_API bool          DragBehavior(ImGuiID id, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power, ImGuiDragFlags flags);[m
[32m+[m[32m    IMGUI_API bool          SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb);[m
[32m+[m[32m    IMGUI_API bool          SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend = 0.0f, float hover_visibility_delay = 0.0f);[m
[32m+[m[32m    IMGUI_API bool          TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end = NULL);[m
[32m+[m[32m    IMGUI_API bool          TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0);                     // Consume previous SetNextTreeNodeOpened() data, if any. May return true when logging[m
[32m+[m[32m    IMGUI_API void          TreePushOverrideID(ImGuiID id);[m
[32m+[m
[32m+[m[32m    // Template functions are instantiated in imgui_widgets.cpp for a finite number of types.[m
[32m+[m[32m    // To use them externally (for custom widget) you may need an "extern template" statement in your code in order to link to existing instances and silence Clang warnings (see #2036).[m
[32m+[m[32m    // e.g. " extern template IMGUI_API float RoundScalarWithFormatT<float, float>(const char* format, ImGuiDataType data_type, float v); "[m
[32m+[m[32m    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  DragBehaviorT(ImGuiDataType data_type, T* v, float v_speed, T v_min, T v_max, const char* format, float power, ImGuiDragFlags flags);[m
[32m+[m[32m    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, T* v, T v_min, T v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb);[m
[32m+[m[32m    template<typename T, typename FLOAT_T>                      IMGUI_API float SliderCalcRatioFromValueT(ImGuiDataType data_type, T v, T v_min, T v_max, float power, float linear_zero_pos);[m
[32m+[m[32m    template<typename T, typename SIGNED_T>                     IMGUI_API T     RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, T v);[m
[32m+[m
[32m+[m[32m    // Data type helpers[m
[32m+[m[32m    IMGUI_API const ImGuiDataTypeInfo*  DataTypeGetInfo(ImGuiDataType data_type);[m
[32m+[m[32m    IMGUI_API int           DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* data_ptr, const char* format);[m
[32m+[m[32m    IMGUI_API void          DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg_1, const void* arg_2);[m
[32m+[m[32m    IMGUI_API bool          DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* format);[m
[32m+[m
[32m+[m[32m    // InputText[m
[32m+[m[32m    IMGUI_API bool          InputTextEx(const char* label, const char* hint, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);[m
[32m+[m[32m    IMGUI_API bool          TempInputTextScalar(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* data_ptr, const char* format);[m
[32m+[m[32m    inline bool             TempInputTextIsActive(ImGuiID id) { ImGuiContext& g = *GImGui; return (g.ActiveId == id && g.TempInputTextId == id); }[m
[32m+[m
[32m+[m[32m    // Color[m
[32m+[m[32m    IMGUI_API void          ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags);[m
[32m+[m[32m    IMGUI_API void          ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags);[m
[32m+[m[32m    IMGUI_API void          ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags);[m
[32m+[m
[32m+[m[32m    // Plot[m
[32m+[m[32m    IMGUI_API void          PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 frame_size);[m
[32m+[m
[32m+[m[32m    // Shade functions (write over already created vertices)[m
[32m+[m[32m    IMGUI_API void          ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1);[m
[32m+[m[32m    IMGUI_API void          ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp);[m
[32m+[m
[32m+[m[32m} // namespace ImGui[m
[32m+[m
[32m+[m[32m// ImFontAtlas internals[m
[32m+[m[32mIMGUI_API bool              ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas);[m
[32m+[m[32mIMGUI_API void              ImFontAtlasBuildRegisterDefaultCustomRects(ImFontAtlas* atlas);[m
[32m+[m[32mIMGUI_API void              ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent);[m
[32m+[m[32mIMGUI_API void              ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque);[m
[32m+[m[32mIMGUI_API void              ImFontAtlasBuildFinish(ImFontAtlas* atlas);[m
[32m+[m[32mIMGUI_API void              ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_multiply_factor);[m
[32m+[m[32mIMGUI_API void              ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride);[m
[32m+[m
[32m+[m[32m// Test engine hooks (imgui-test)[m
[32m+[m[32m//#define IMGUI_ENABLE_TEST_ENGINE[m
[32m+[m[32m#ifdef IMGUI_ENABLE_TEST_ENGINE[m
[32m+[m[32mextern void                 ImGuiTestEngineHook_PreNewFrame(ImGuiContext* ctx);[m
[32m+[m[32mextern void                 ImGuiTestEngineHook_PostNewFrame(ImGuiContext* ctx);[m
[32m+[m[32mextern void                 ImGuiTestEngineHook_ItemAdd(ImGuiContext* ctx, const ImRect& bb, ImGuiID id);[m
[32m+[m[32mextern void                 ImGuiTestEngineHook_ItemInfo(ImGuiContext* ctx, ImGuiID id, const char* label, ImGuiItemStatusFlags flags);[m
[32m+[m[32m#define IMGUI_TEST_ENGINE_ITEM_ADD(_BB, _ID)                ImGuiTestEngineHook_ItemAdd(&g, _BB, _ID)               // Register status flags[m
[32m+[m[32m#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID, _LABEL, _FLAGS)  ImGuiTestEngineHook_ItemInfo(&g, _ID, _LABEL, _FLAGS)   // Register status flags[m
[32m+[m[32m#else[m
[32m+[m[32m#define IMGUI_TEST_ENGINE_ITEM_ADD(_BB, _ID)                do { } while (0)[m
[32m+[m[32m#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID, _LABEL, _FLAGS)  do { } while (0)[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef __clang__[m
[32m+[m[32m#pragma clang diagnostic pop[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef _MSC_VER[m
[32m+[m[32m#pragma warning (pop)[m
[32m+[m[32m#endif[m
[1mdiff --git a/vendor/source/ImGui/imgui_widgets.cpp b/vendor/source/ImGui/imgui_widgets.cpp[m
[1mnew file mode 100644[m
[1mindex 0000000..5b3ea58[m
[1m--- /dev/null[m
[1m+++ b/vendor/source/ImGui/imgui_widgets.cpp[m
[36m@@ -0,0 +1,7030 @@[m
[32m+[m[32m// dear imgui, v1.70[m
[32m+[m[32m// (widgets code)[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m
[32m+[m[32mIndex of this file:[m
[32m+[m
[32m+[m[32m// [SECTION] Forward Declarations[m
[32m+[m[32m// [SECTION] Widgets: Text, etc.[m
[32m+[m[32m// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)[m
[32m+[m[32m// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)[m
[32m+[m[32m// [SECTION] Widgets: ComboBox[m
[32m+[m[32m// [SECTION] Data Type and Data Formatting Helpers[m
[32m+[m[32m// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.[m
[32m+[m[32m// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.[m
[32m+[m[32m// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.[m
[32m+[m[32m// [SECTION] Widgets: InputText, InputTextMultiline[m
[32m+[m[32m// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.[m
[32m+[m[32m// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.[m
[32m+[m[32m// [SECTION] Widgets: Selectable[m
[32m+[m[32m// [SECTION] Widgets: ListBox[m
[32m+[m[32m// [SECTION] Widgets: PlotLines, PlotHistogram[m
[32m+[m[32m// [SECTION] Widgets: Value helpers[m
[32m+[m[32m// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.[m
[32m+[m[32m// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.[m
[32m+[m[32m// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.[m
[32m+[m
[32m+[m[32m*/[m
[32m+[m
[32m+[m[32m#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)[m
[32m+[m[32m#define _CRT_SECURE_NO_WARNINGS[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#include "imgui.h"[m
[32m+[m[32m#ifndef IMGUI_DEFINE_MATH_OPERATORS[m
[32m+[m[32m#define IMGUI_DEFINE_MATH_OPERATORS[m
[32m+[m[32m#endif[m
[32m+[m[32m#include "imgui_internal.h"[m
[32m+[m
[32m+[m[32m#include <ctype.h>      // toupper[m
[32m+[m[32m#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier[m
[32m+[m[32m#include <stddef.h>     // intptr_t[m
[32m+[m[32m#else[m
[32m+[m[32m#include <stdint.h>     // intptr_t[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Visual Studio warnings[m
[32m+[m[32m#ifdef _MSC_VER[m
[32m+[m[32m#pragma warning (disable: 4127) // condition expression is constant[m
[32m+[m[32m#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// Clang/GCC warnings with -Weverything[m
[32m+[m[32m#ifdef __clang__[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants (typically 0.0f) is ok.[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wformat-nonliteral"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //[m
[32m+[m[32m#if __has_warning("-Wzero-as-null-pointer-constant")[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning : zero as null pointer constant              // some standard header variations use #define NULL 0[m
[32m+[m[32m#endif[m
[32m+[m[32m#if __has_warning("-Wdouble-promotion")[m
[32m+[m[32m#pragma clang diagnostic ignored "-Wdouble-promotion"       // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.[m
[32m+[m[32m#endif[m
[32m+[m[32m#elif defined(__GNUC__)[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wformat-nonliteral"        // warning: format not a string literal, format string not checked[m
[32m+[m[32m#if __GNUC__ >= 8[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wclass-memaccess"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead[m
[32m+[m[32m#endif[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// Data[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Those MIN/MAX values are not define because we need to point to them[m
[32m+[m[32mstatic const signed char    IM_S8_MIN  = -128;[m
[32m+[m[32mstatic const signed char    IM_S8_MAX  = 127;[m
[32m+[m[32mstatic const unsigned char  IM_U8_MIN  = 0;[m
[32m+[m[32mstatic const unsigned char  IM_U8_MAX  = 0xFF;[m
[32m+[m[32mstatic const signed short   IM_S16_MIN = -32768;[m
[32m+[m[32mstatic const signed short   IM_S16_MAX = 32767;[m
[32m+[m[32mstatic const unsigned short IM_U16_MIN = 0;[m
[32m+[m[32mstatic const unsigned short IM_U16_MAX = 0xFFFF;[m
[32m+[m[32mstatic const ImS32          IM_S32_MIN = INT_MIN;    // (-2147483647 - 1), (0x80000000);[m
[32m+[m[32mstatic const ImS32          IM_S32_MAX = INT_MAX;    // (2147483647), (0x7FFFFFFF)[m
[32m+[m[32mstatic const ImU32          IM_U32_MIN = 0;[m
[32m+[m[32mstatic const ImU32          IM_U32_MAX = UINT_MAX;   // (0xFFFFFFFF)[m
[32m+[m[32m#ifdef LLONG_MIN[m
[32m+[m[32mstatic const ImS64          IM_S64_MIN = LLONG_MIN;  // (-9223372036854775807ll - 1ll);[m
[32m+[m[32mstatic const ImS64          IM_S64_MAX = LLONG_MAX;  // (9223372036854775807ll);[m
[32m+[m[32m#else[m
[32m+[m[32mstatic const ImS64          IM_S64_MIN = -9223372036854775807LL - 1;[m
[32m+[m[32mstatic const ImS64          IM_S64_MAX = 9223372036854775807LL;[m
[32m+[m[32m#endif[m
[32m+[m[32mstatic const ImU64          IM_U64_MIN = 0;[m
[32m+[m[32m#ifdef ULLONG_MAX[m
[32m+[m[32mstatic const ImU64          IM_U64_MAX = ULLONG_MAX; // (0xFFFFFFFFFFFFFFFFull);[m
[32m+[m[32m#else[m
[32m+[m[32mstatic const ImU64          IM_U64_MAX = (2ULL * 9223372036854775807LL + 1);[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Forward Declarations[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// For InputTextEx()[m
[32m+[m[32mstatic bool             InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data);[m
[32m+[m[32mstatic int              InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end);[m
[32m+[m[32mstatic ImVec2           InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining = NULL, ImVec2* out_offset = NULL, bool stop_on_new_line = false);[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Widgets: Text, etc.[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - TextUnformatted()[m
[32m+[m[32m// - Text()[m
[32m+[m[32m// - TextV()[m
[32m+[m[32m// - TextColored()[m
[32m+[m[32m// - TextColoredV()[m
[32m+[m[32m// - TextDisabled()[m
[32m+[m[32m// - TextDisabledV()[m
[32m+[m[32m// - TextWrapped()[m
[32m+[m[32m// - TextWrappedV()[m
[32m+[m[32m// - LabelText()[m
[32m+[m[32m// - LabelTextV()[m
[32m+[m[32m// - BulletText()[m
[32m+[m[32m// - BulletTextV()[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mvoid ImGui::TextEx(const char* text, const char* text_end, ImGuiTextFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    IM_ASSERT(text != NULL);[m
[32m+[m[32m    const char* text_begin = text;[m
[32m+[m[32m    if (text_end == NULL)[m
[32m+[m[32m        text_end = text + strlen(text); // FIXME-OPT[m
[32m+[m
[32m+[m[32m    const ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrentLineTextBaseOffset);[m
[32m+[m[32m    const float wrap_pos_x = window->DC.TextWrapPos;[m
[32m+[m[32m    const bool wrap_enabled = (wrap_pos_x >= 0.0f);[m
[32m+[m[32m    if (text_end - text > 2000 && !wrap_enabled)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Long text![m
[32m+[m[32m        // Perform manual coarse clipping to optimize for long multi-line text[m
[32m+[m[32m        // - From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.[m
[32m+[m[32m        // - We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.[m
[32m+[m[32m        // - We use memchr(), pay attention that well optimized versions of those str/mem functions are much faster than a casually written loop.[m
[32m+[m[32m        const char* line = text;[m
[32m+[m[32m        const float line_height = GetTextLineHeight();[m
[32m+[m[32m        ImVec2 text_size(0,0);[m
[32m+[m
[32m+[m[32m        // Lines to skip (can't skip when logging text)[m
[32m+[m[32m        ImVec2 pos = text_pos;[m
[32m+[m[32m        if (!g.LogEnabled)[m
[32m+[m[32m        {[m
[32m+[m[32m            int lines_skippable = (int)((window->ClipRect.Min.y - text_pos.y) / line_height);[m
[32m+[m[32m            if (lines_skippable > 0)[m
[32m+[m[32m            {[m
[32m+[m[32m                int lines_skipped = 0;[m
[32m+[m[32m                while (line < text_end && lines_skipped < lines_skippable)[m
[32m+[m[32m                {[m
[32m+[m[32m                    const char* line_end = (const char*)memchr(line, '\n', text_end - line);[m
[32m+[m[32m                    if (!line_end)[m
[32m+[m[32m                        line_end = text_end;[m
[32m+[m[32m                    if ((flags & ImGuiTextFlags_NoWidthForLargeClippedText) == 0)[m
[32m+[m[32m                        text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);[m
[32m+[m[32m                    line = line_end + 1;[m
[32m+[m[32m                    lines_skipped++;[m
[32m+[m[32m                }[m
[32m+[m[32m                pos.y += lines_skipped * line_height;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Lines to render[m
[32m+[m[32m        if (line < text_end)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImRect line_rect(pos, pos + ImVec2(FLT_MAX, line_height));[m
[32m+[m[32m            while (line < text_end)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (IsClippedEx(line_rect, 0, false))[m
[32m+[m[32m                    break;[m
[32m+[m
[32m+[m[32m                const char* line_end = (const char*)memchr(line, '\n', text_end - line);[m
[32m+[m[32m                if (!line_end)[m
[32m+[m[32m                    line_end = text_end;[m
[32m+[m[32m                text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);[m
[32m+[m[32m                RenderText(pos, line, line_end, false);[m
[32m+[m[32m                line = line_end + 1;[m
[32m+[m[32m                line_rect.Min.y += line_height;[m
[32m+[m[32m                line_rect.Max.y += line_height;[m
[32m+[m[32m                pos.y += line_height;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Count remaining lines[m
[32m+[m[32m            int lines_skipped = 0;[m
[32m+[m[32m            while (line < text_end)[m
[32m+[m[32m            {[m
[32m+[m[32m                const char* line_end = (const char*)memchr(line, '\n', text_end - line);[m
[32m+[m[32m                if (!line_end)[m
[32m+[m[32m                    line_end = text_end;[m
[32m+[m[32m                if ((flags & ImGuiTextFlags_NoWidthForLargeClippedText) == 0)[m
[32m+[m[32m                    text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);[m
[32m+[m[32m                line = line_end + 1;[m
[32m+[m[32m                lines_skipped++;[m
[32m+[m[32m            }[m
[32m+[m[32m            pos.y += lines_skipped * line_height;[m
[32m+[m[32m        }[m
[32m+[m[32m        text_size.y = (pos - text_pos).y;[m
[32m+[m
[32m+[m[32m        ImRect bb(text_pos, text_pos + text_size);[m
[32m+[m[32m        ItemSize(text_size);[m
[32m+[m[32m        ItemAdd(bb, 0);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;[m
[32m+[m[32m        const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);[m
[32m+[m
[32m+[m[32m        ImRect bb(text_pos, text_pos + text_size);[m
[32m+[m[32m        ItemSize(text_size);[m
[32m+[m[32m        if (!ItemAdd(bb, 0))[m
[32m+[m[32m            return;[m
[32m+[m
[32m+[m[32m        // Render (we don't hide text after ## in this end-user function)[m
[32m+[m[32m        RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::TextUnformatted(const char* text, const char* text_end)[m
[32m+[m[32m{[m
[32m+[m[32m    TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::Text(const char* fmt, ...)[m
[32m+[m[32m{[m
[32m+[m[32m    va_list args;[m
[32m+[m[32m    va_start(args, fmt);[m
[32m+[m[32m    TextV(fmt, args);[m
[32m+[m[32m    va_end(args);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::TextV(const char* fmt, va_list args)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const char* text_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);[m
[32m+[m[32m    TextEx(g.TempBuffer, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::TextColored(const ImVec4& col, const char* fmt, ...)[m
[32m+[m[32m{[m
[32m+[m[32m    va_list args;[m
[32m+[m[32m    va_start(args, fmt);[m
[32m+[m[32m    TextColoredV(col, fmt, args);[m
[32m+[m[32m    va_end(args);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)[m
[32m+[m[32m{[m
[32m+[m[32m    PushStyleColor(ImGuiCol_Text, col);[m
[32m+[m[32m    TextV(fmt, args);[m
[32m+[m[32m    PopStyleColor();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::TextDisabled(const char* fmt, ...)[m
[32m+[m[32m{[m
[32m+[m[32m    va_list args;[m
[32m+[m[32m    va_start(args, fmt);[m
[32m+[m[32m    TextDisabledV(fmt, args);[m
[32m+[m[32m    va_end(args);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::TextDisabledV(const char* fmt, va_list args)[m
[32m+[m[32m{[m
[32m+[m[32m    PushStyleColor(ImGuiCol_Text, GImGui->Style.Colors[ImGuiCol_TextDisabled]);[m
[32m+[m[32m    TextV(fmt, args);[m
[32m+[m[32m    PopStyleColor();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::TextWrapped(const char* fmt, ...)[m
[32m+[m[32m{[m
[32m+[m[32m    va_list args;[m
[32m+[m[32m    va_start(args, fmt);[m
[32m+[m[32m    TextWrappedV(fmt, args);[m
[32m+[m[32m    va_end(args);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::TextWrappedV(const char* fmt, va_list args)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    bool need_backup = (window->DC.TextWrapPos < 0.0f);  // Keep existing wrap position if one is already set[m
[32m+[m[32m    if (need_backup)[m
[32m+[m[32m        PushTextWrapPos(0.0f);[m
[32m+[m[32m    TextV(fmt, args);[m
[32m+[m[32m    if (need_backup)[m
[32m+[m[32m        PopTextWrapPos();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::LabelText(const char* label, const char* fmt, ...)[m
[32m+[m[32m{[m
[32m+[m[32m    va_list args;[m
[32m+[m[32m    va_start(args, fmt);[m
[32m+[m[32m    LabelTextV(label, fmt, args);[m
[32m+[m[32m    va_end(args);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Add a label+text combo aligned to other label+value widgets[m
[32m+[m[32mvoid ImGui::LabelTextV(const char* label, const char* fmt, va_list args)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    const float w = GetNextItemWidth();[m
[32m+[m
[32m+[m[32m    const ImVec2 label_size = CalcTextSize(label, NULL, true);[m
[32m+[m[32m    const ImRect value_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2));[m
[32m+[m[32m    const ImRect total_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x : 0.0f), style.FramePadding.y*2) + label_size);[m
[32m+[m[32m    ItemSize(total_bb, style.FramePadding.y);[m
[32m+[m[32m    if (!ItemAdd(total_bb, 0))[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // Render[m
[32m+[m[32m    const char* value_text_begin = &g.TempBuffer[0];[m
[32m+[m[32m    const char* value_text_end = value_text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);[m
[32m+[m[32m    RenderTextClipped(value_bb.Min, value_bb.Max, value_text_begin, value_text_end, NULL, ImVec2(0.0f,0.5f));[m
[32m+[m[32m    if (label_size.x > 0.0f)[m
[32m+[m[32m        RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::BulletText(const char* fmt, ...)[m
[32m+[m[32m{[m
[32m+[m[32m    va_list args;[m
[32m+[m[32m    va_start(args, fmt);[m
[32m+[m[32m    BulletTextV(fmt, args);[m
[32m+[m[32m    va_end(args);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Text with a little bullet aligned to the typical tree node.[m
[32m+[m[32mvoid ImGui::BulletTextV(const char* fmt, va_list args)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m
[32m+[m[32m    const char* text_begin = g.TempBuffer;[m
[32m+[m[32m    const char* text_end = text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);[m
[32m+[m[32m    const ImVec2 label_size = CalcTextSize(text_begin, text_end, false);[m
[32m+[m[32m    const float text_base_offset_y = ImMax(0.0f, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it[m
[32m+[m[32m    const float line_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);[m
[32m+[m[32m    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize + (label_size.x > 0.0f ? (label_size.x + style.FramePadding.x*2) : 0.0f), ImMax(line_height, label_size.y)));  // Empty text doesn't add padding[m
[32m+[m[32m    ItemSize(bb);[m
[32m+[m[32m    if (!ItemAdd(bb, 0))[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // Render[m
[32m+[m[32m    RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));[m
[32m+[m[32m    RenderText(bb.Min+ImVec2(g.FontSize + style.FramePadding.x*2, text_base_offset_y), text_begin, text_end, false);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Widgets: Main[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - ButtonBehavior() [Internal][m
[32m+[m[32m// - Button()[m
[32m+[m[32m// - SmallButton()[m
[32m+[m[32m// - InvisibleButton()[m
[32m+[m[32m// - ArrowButton()[m
[32m+[m[32m// - CloseButton() [Internal][m
[32m+[m[32m// - CollapseButton() [Internal][m
[32m+[m[32m// - Scrollbar() [Internal][m
[32m+[m[32m// - Image()[m
[32m+[m[32m// - ImageButton()[m
[32m+[m[32m// - Checkbox()[m
[32m+[m[32m// - CheckboxFlags()[m
[32m+[m[32m// - RadioButton()[m
[32m+[m[32m// - ProgressBar()[m
[32m+[m[32m// - Bullet()[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// The ButtonBehavior() function is key to many interactions and used by many/most widgets.[m
[32m+[m[32m// Because we handle so many cases (keyboard/gamepad navigation, drag and drop) and many specific behavior (via ImGuiButtonFlags_),[m
[32m+[m[32m// this code is a little complex.[m
[32m+[m[32m// By far the most common path is interacting with the Mouse using the default ImGuiButtonFlags_PressedOnClickRelease button behavior.[m
[32m+[m[32m// See the series of events below and the corresponding state reported by dear imgui:[m
[32m+[m[32m//------------------------------------------------------------------------------------------------------------------------------------------------[m
[32m+[m[32m// with PressedOnClickRelease:             return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()[m
[32m+[m[32m//   Frame N+0 (mouse is outside bb)        -             -                -               -                  -                    -[m[41m    [m
[32m+[m[32m//   Frame N+1 (mouse moves inside bb)      -             true             -               -                  -                    -[m[41m    [m
[32m+[m[32m//   Frame N+2 (mouse button is down)       -             true             true            true               -                    true[m
[32m+[m[32m//   Frame N+3 (mouse button is down)       -             true             true            -                  -                    -[m[41m    [m
[32m+[m[32m//   Frame N+4 (mouse moves outside bb)     -             -                true            -                  -                    -[m
[32m+[m[32m//   Frame N+5 (mouse moves inside bb)      -             true             true            -                  -                    -[m
[32m+[m[32m//   Frame N+6 (mouse button is released)   true          true             -               -                  true                 -[m[41m    [m
[32m+[m[32m//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -[m[41m    [m
[32m+[m[32m//   Frame N+8 (mouse moves outside bb)     -             -                -               -                  -                    -[m[41m    [m
[32m+[m[32m//------------------------------------------------------------------------------------------------------------------------------------------------[m
[32m+[m[32m// with PressedOnClick:                    return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()[m
[32m+[m[32m//   Frame N+2 (mouse button is down)       true          true             true            true               -                    true[m
[32m+[m[32m//   Frame N+3 (mouse button is down)       -             true             true            -                  -                    -[m[41m    [m
[32m+[m[32m//   Frame N+6 (mouse button is released)   -             true             -               -                  true                 -[m[41m    [m
[32m+[m[32m//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -[m[41m    [m
[32m+[m[32m//------------------------------------------------------------------------------------------------------------------------------------------------[m
[32m+[m[32m// with PressedOnRelease:                  return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()[m
[32m+[m[32m//   Frame N+2 (mouse button is down)       -             true             -               -                  -                    true[m
[32m+[m[32m//   Frame N+3 (mouse button is down)       -             true             -               -                  -                    -[m[41m    [m
[32m+[m[32m//   Frame N+6 (mouse button is released)   true          true             -               -                  -                    -[m
[32m+[m[32m//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -[m[41m    [m
[32m+[m[32m//------------------------------------------------------------------------------------------------------------------------------------------------[m
[32m+[m[32m// with PressedOnDoubleClick:              return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()[m
[32m+[m[32m//   Frame N+0 (mouse button is down)       -             true             -               -                  -                    true[m
[32m+[m[32m//   Frame N+1 (mouse button is down)       -             true             -               -                  -                    -[m[41m    [m
[32m+[m[32m//   Frame N+2 (mouse button is released)   -             true             -               -                  -                    -[m
[32m+[m[32m//   Frame N+3 (mouse button is released)   -             true             -               -                  -                    -[m[41m    [m
[32m+[m[32m//   Frame N+4 (mouse button is down)       true          true             true            true               -                    true[m
[32m+[m[32m//   Frame N+5 (mouse button is down)       -             true             true            -                  -                    -[m[41m    [m
[32m+[m[32m//   Frame N+6 (mouse button is released)   -             true             -               -                  true                 -[m
[32m+[m[32m//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -[m[41m    [m
[32m+[m[32m//------------------------------------------------------------------------------------------------------------------------------------------------[m
[32m+[m[32m// Note that some combinations are supported,[m
[32m+[m[32m// - PressedOnDragDropHold can generally be associated with any flag.[m
[32m+[m[32m// - PressedOnDoubleClick can be associated by PressedOnClickRelease/PressedOnRelease, in which case the second release event won't be reported.[m
[32m+[m[32m//------------------------------------------------------------------------------------------------------------------------------------------------[m
[32m+[m[32m// The behavior of the return-value changes when ImGuiButtonFlags_Repeat is set:[m
[32m+[m[32m//                                         Repeat+                  Repeat+           Repeat+             Repeat+[m
[32m+[m[32m//                                         PressedOnClickRelease    PressedOnClick    PressedOnRelease    PressedOnDoubleClick[m
[32m+[m[32m//-------------------------------------------------------------------------------------------------------------------------------------------------[m
[32m+[m[32m//   Frame N+0 (mouse button is down)       -                        true              -                   true[m[41m [m
[32m+[m[32m//   ...                                    -                        -                 -                   -[m
[32m+[m[32m//   Frame N + RepeatDelay                  true                     true              -                   true[m
[32m+[m[32m//   ...                                    -                        -                 -                   -[m
[32m+[m[32m//   Frame N + RepeatDelay + RepeatRate*N   true                     true              -                   true[m
[32m+[m[32m//-------------------------------------------------------------------------------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mbool ImGui::ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m
[32m+[m[32m    if (flags & ImGuiButtonFlags_Disabled)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (out_hovered) *out_hovered = false;[m
[32m+[m[32m        if (out_held) *out_held = false;[m
[32m+[m[32m        if (g.ActiveId == id) ClearActiveID();[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Default behavior requires click+release on same spot[m
[32m+[m[32m    if ((flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick)) == 0)[m
[32m+[m[32m        flags |= ImGuiButtonFlags_PressedOnClickRelease;[m
[32m+[m
[32m+[m[32m    ImGuiWindow* backup_hovered_window = g.HoveredWindow;[m
[32m+[m[32m    if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)[m
[32m+[m[32m        g.HoveredWindow = window;[m
[32m+[m
[32m+[m[32m#ifdef IMGUI_ENABLE_TEST_ENGINE[m
[32m+[m[32m    if (id != 0 && window->DC.LastItemId != id)[m
[32m+[m[32m        ImGuiTestEngineHook_ItemAdd(&g, bb, id);[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m    bool pressed = false;[m
[32m+[m[32m    bool hovered = ItemHoverable(bb, id);[m
[32m+[m
[32m+[m[32m    // Drag source doesn't report as hovered[m
[32m+[m[32m    if (hovered && g.DragDropActive && g.DragDropPayload.SourceId == id && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover))[m
[32m+[m[32m        hovered = false;[m
[32m+[m
[32m+[m[32m    // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button[m
[32m+[m[32m    if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))[m
[32m+[m[32m        if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))[m
[32m+[m[32m        {[m
[32m+[m[32m            hovered = true;[m
[32m+[m[32m            SetHoveredID(id);[m
[32m+[m[32m            if (CalcTypematicPressedRepeatAmount(g.HoveredIdTimer + 0.0001f, g.HoveredIdTimer + 0.0001f - g.IO.DeltaTime, 0.01f, 0.70f)) // FIXME: Our formula for CalcTypematicPressedRepeatAmount() is fishy[m
[32m+[m[32m            {[m
[32m+[m[32m                pressed = true;[m
[32m+[m[32m                FocusWindow(window);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m    if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)[m
[32m+[m[32m        g.HoveredWindow = backup_hovered_window;[m
[32m+[m
[32m+[m[32m    // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match. This allows using patterns where a later submitted widget overlaps a previous one.[m
[32m+[m[32m    if (hovered && (flags & ImGuiButtonFlags_AllowItemOverlap) && (g.HoveredIdPreviousFrame != id && g.HoveredIdPreviousFrame != 0))[m
[32m+[m[32m        hovered = false;[m
[32m+[m
[32m+[m[32m    // Mouse[m
[32m+[m[32m    if (hovered)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))[m
[32m+[m[32m        {[m
[32m+[m[32m            if ((flags & ImGuiButtonFlags_PressedOnClickRelease) && g.IO.MouseClicked[0])[m
[32m+[m[32m            {[m
[32m+[m[32m                SetActiveID(id, window);[m
[32m+[m[32m                if (!(flags & ImGuiButtonFlags_NoNavFocus))[m
[32m+[m[32m                    SetFocusID(id, window);[m
[32m+[m[32m                FocusWindow(window);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (((flags & ImGuiButtonFlags_PressedOnClick) && g.IO.MouseClicked[0]) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseDoubleClicked[0]))[m
[32m+[m[32m            {[m
[32m+[m[32m                pressed = true;[m
[32m+[m[32m                if (flags & ImGuiButtonFlags_NoHoldingActiveID)[m
[32m+[m[32m                    ClearActiveID();[m
[32m+[m[32m                else[m
[32m+[m[32m                    SetActiveID(id, window); // Hold on ID[m
[32m+[m[32m                FocusWindow(window);[m
[32m+[m[32m            }[m
[32m+[m[32m            if ((flags & ImGuiButtonFlags_PressedOnRelease) && g.IO.MouseReleased[0])[m
[32m+[m[32m            {[m
[32m+[m[32m                if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>[m
[32m+[m[32m                    pressed = true;[m
[32m+[m[32m                ClearActiveID();[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).[m
[32m+[m[32m            // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.[m
[32m+[m[32m            if ((flags & ImGuiButtonFlags_Repeat) && g.ActiveId == id && g.IO.MouseDownDuration[0] > 0.0f && IsMouseClicked(0, true))[m
[32m+[m[32m                pressed = true;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (pressed)[m
[32m+[m[32m            g.NavDisableHighlight = true;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Gamepad/Keyboard navigation[m
[32m+[m[32m    // We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse.[m
[32m+[m[32m    if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover && (g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == window->MoveId))[m
[32m+[m[32m        if (!(flags & ImGuiButtonFlags_NoHoveredOnNav))[m
[32m+[m[32m            hovered = true;[m
[32m+[m
[32m+[m[32m    if (g.NavActivateDownId == id)[m
[32m+[m[32m    {[m
[32m+[m[32m        bool nav_activated_by_code = (g.NavActivateId == id);[m
[32m+[m[32m        bool nav_activated_by_inputs = IsNavInputPressed(ImGuiNavInput_Activate, (flags & ImGuiButtonFlags_Repeat) ? ImGuiInputReadMode_Repeat : ImGuiInputReadMode_Pressed);[m
[32m+[m[32m        if (nav_activated_by_code || nav_activated_by_inputs)[m
[32m+[m[32m            pressed = true;[m
[32m+[m[32m        if (nav_activated_by_code || nav_activated_by_inputs || g.ActiveId == id)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.[m
[32m+[m[32m            g.NavActivateId = id; // This is so SetActiveId assign a Nav source[m
[32m+[m[32m            SetActiveID(id, window);[m
[32m+[m[32m            if ((nav_activated_by_code || nav_activated_by_inputs) && !(flags & ImGuiButtonFlags_NoNavFocus))[m
[32m+[m[32m                SetFocusID(id, window);[m
[32m+[m[32m            g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right) | (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    bool held = false;[m
[32m+[m[32m    if (g.ActiveId == id)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (pressed)[m
[32m+[m[32m            g.ActiveIdHasBeenPressed = true;[m
[32m+[m[32m        if (g.ActiveIdSource == ImGuiInputSource_Mouse)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (g.ActiveIdIsJustActivated)[m
[32m+[m[32m                g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;[m
[32m+[m[32m            if (g.IO.MouseDown[0])[m
[32m+[m[32m            {[m
[32m+[m[32m                held = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else[m
[32m+[m[32m            {[m
[32m+[m[32m                if (hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease) && !g.DragDropActive)[m
[32m+[m[32m                {[m
[32m+[m[32m                    bool is_double_click_release = (flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseDownWasDoubleClick[0];[m
[32m+[m[32m                    bool is_repeating_already = (flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay; // Repeat mode trumps <on release>[m
[32m+[m[32m                    if (!is_double_click_release && !is_repeating_already)[m
[32m+[m[32m                        pressed = true;[m
[32m+[m[32m                }[m
[32m+[m[32m                ClearActiveID();[m
[32m+[m[32m            }[m
[32m+[m[32m            if (!(flags & ImGuiButtonFlags_NoNavFocus))[m
[32m+[m[32m                g.NavDisableHighlight = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (g.ActiveIdSource == ImGuiInputSource_Nav)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (g.NavActivateDownId != id)[m
[32m+[m[32m                ClearActiveID();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (out_hovered) *out_hovered = hovered;[m
[32m+[m[32m    if (out_held) *out_held = held;[m
[32m+[m
[32m+[m[32m    return pressed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    const ImGuiID id = window->GetID(label);[m
[32m+[m[32m    const ImVec2 label_size = CalcTextSize(label, NULL, true);[m
[32m+[m
[32m+[m[32m    ImVec2 pos = window->DC.CursorPos;[m
[32m+[m[32m    if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrentLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)[m
[32m+[m[32m        pos.y += window->DC.CurrentLineTextBaseOffset - style.FramePadding.y;[m
[32m+[m[32m    ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);[m
[32m+[m
[32m+[m[32m    const ImRect bb(pos, pos + size);[m
[32m+[m[32m    ItemSize(size, style.FramePadding.y);[m
[32m+[m[32m    if (!ItemAdd(bb, id))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)[m
[32m+[m[32m        flags |= ImGuiButtonFlags_Repeat;[m
[32m+[m[32m    bool hovered, held;[m
[32m+[m[32m    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);[m
[32m+[m[32m    if (pressed)[m
[32m+[m[32m        MarkItemEdited(id);[m
[32m+[m
[32m+[m[32m    // Render[m
[32m+[m[32m    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);[m
[32m+[m[32m    RenderNavHighlight(bb, id);[m
[32m+[m[32m    RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);[m
[32m+[m[32m    RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);[m
[32m+[m
[32m+[m[32m    // Automatically close popups[m
[32m+[m[32m    //if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))[m
[32m+[m[32m    //    CloseCurrentPopup();[m
[32m+[m
[32m+[m[32m    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.LastItemStatusFlags);[m
[32m+[m[32m    return pressed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::Button(const char* label, const ImVec2& size_arg)[m
[32m+[m[32m{[m
[32m+[m[32m    return ButtonEx(label, size_arg, 0);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Small buttons fits within text without additional vertical spacing.[m
[32m+[m[32mbool ImGui::SmallButton(const char* label)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    float backup_padding_y = g.Style.FramePadding.y;[m
[32m+[m[32m    g.Style.FramePadding.y = 0.0f;[m
[32m+[m[32m    bool pressed = ButtonEx(label, ImVec2(0, 0), ImGuiButtonFlags_AlignTextBaseLine);[m
[32m+[m[32m    g.Style.FramePadding.y = backup_padding_y;[m
[32m+[m[32m    return pressed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Tip: use ImGui::PushID()/PopID() to push indices or pointers in the ID stack.[m
[32m+[m[32m// Then you can keep 'str_id' empty or the same for all your buttons (instead of creating a string based on a non-string id)[m
[32m+[m[32mbool ImGui::InvisibleButton(const char* str_id, const ImVec2& size_arg)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    // Cannot use zero-size for InvisibleButton(). Unlike Button() there is not way to fallback using the label size.[m
[32m+[m[32m    IM_ASSERT(size_arg.x != 0.0f && size_arg.y != 0.0f);[m
[32m+[m
[32m+[m[32m    const ImGuiID id = window->GetID(str_id);[m
[32m+[m[32m    ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);[m
[32m+[m[32m    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);[m
[32m+[m[32m    ItemSize(size);[m
[32m+[m[32m    if (!ItemAdd(bb, id))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    bool hovered, held;[m
[32m+[m[32m    bool pressed = ButtonBehavior(bb, id, &hovered, &held);[m
[32m+[m
[32m+[m[32m    return pressed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size, ImGuiButtonFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiID id = window->GetID(str_id);[m
[32m+[m[32m    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);[m
[32m+[m[32m    const float default_size = GetFrameHeight();[m
[32m+[m[32m    ItemSize(size, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);[m
[32m+[m[32m    if (!ItemAdd(bb, id))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)[m
[32m+[m[32m        flags |= ImGuiButtonFlags_Repeat;[m
[32m+[m
[32m+[m[32m    bool hovered, held;[m
[32m+[m[32m    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);[m
[32m+[m
[32m+[m[32m    // Render[m
[32m+[m[32m    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);[m
[32m+[m[32m    RenderNavHighlight(bb, id);[m
[32m+[m[32m    RenderFrame(bb.Min, bb.Max, col, true, g.Style.FrameRounding);[m
[32m+[m[32m    RenderArrow(bb.Min + ImVec2(ImMax(0.0f, (size.x - g.FontSize) * 0.5f), ImMax(0.0f, (size.y - g.FontSize) * 0.5f)), dir);[m
[32m+[m
[32m+[m[32m    return pressed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::ArrowButton(const char* str_id, ImGuiDir dir)[m
[32m+[m[32m{[m
[32m+[m[32m    float sz = GetFrameHeight();[m
[32m+[m[32m    return ArrowButtonEx(str_id, dir, ImVec2(sz, sz), 0);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Button to close a window[m
[32m+[m[32mbool ImGui::CloseButton(ImGuiID id, const ImVec2& pos, float radius)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m
[32m+[m[32m    // We intentionally allow interaction when clipped so that a mechanical Alt,Right,Validate sequence close a window.[m
[32m+[m[32m    // (this isn't the regular behavior of buttons, but it doesn't affect the user much because navigation tends to keep items visible).[m
[32m+[m[32m    const ImRect bb(pos - ImVec2(radius,radius), pos + ImVec2(radius,radius));[m
[32m+[m[32m    bool is_clipped = !ItemAdd(bb, id);[m
[32m+[m
[32m+[m[32m    bool hovered, held;[m
[32m+[m[32m    bool pressed = ButtonBehavior(bb, id, &hovered, &held);[m
[32m+[m[32m    if (is_clipped)[m
[32m+[m[32m        return pressed;[m
[32m+[m
[32m+[m[32m    // Render[m
[32m+[m[32m    ImVec2 center = bb.GetCenter();[m
[32m+[m[32m    if (hovered)[m
[32m+[m[32m        window->DrawList->AddCircleFilled(center, ImMax(2.0f, radius), GetColorU32(held ? ImGuiCol_ButtonActive : ImGuiCol_ButtonHovered), 9);[m
[32m+[m
[32m+[m[32m    float cross_extent = (radius * 0.7071f) - 1.0f;[m
[32m+[m[32m    ImU32 cross_col = GetColorU32(ImGuiCol_Text);[m
[32m+[m[32m    center -= ImVec2(0.5f, 0.5f);[m
[32m+[m[32m    window->DrawList->AddLine(center + ImVec2(+cross_extent,+cross_extent), center + ImVec2(-cross_extent,-cross_extent), cross_col, 1.0f);[m
[32m+[m[32m    window->DrawList->AddLine(center + ImVec2(+cross_extent,-cross_extent), center + ImVec2(-cross_extent,+cross_extent), cross_col, 1.0f);[m
[32m+[m
[32m+[m[32m    return pressed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::CollapseButton(ImGuiID id, const ImVec2& pos)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m
[32m+[m[32m    ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize) + g.Style.FramePadding * 2.0f);[m
[32m+[m[32m    ItemAdd(bb, id);[m
[32m+[m[32m    bool hovered, held;[m
[32m+[m[32m    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_None);[m
[32m+[m
[32m+[m[32m    ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);[m
[32m+[m[32m    if (hovered || held)[m
[32m+[m[32m        window->DrawList->AddCircleFilled(bb.GetCenter() + ImVec2(0.0f, -0.5f), g.FontSize * 0.5f + 1.0f, col, 9);[m
[32m+[m[32m    RenderArrow(bb.Min + g.Style.FramePadding, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);[m
[32m+[m
[32m+[m[32m    // Switch to moving the window after mouse is moved beyond the initial drag threshold[m
[32m+[m[32m    if (IsItemActive() && IsMouseDragging())[m
[32m+[m[32m        StartMouseMovingWindow(window);[m
[32m+[m
[32m+[m[32m    return pressed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiID ImGui::GetScrollbarID(ImGuiWindow* window, ImGuiAxis axis)[m
[32m+[m[32m{[m
[32m+[m[32m    return window->GetIDNoKeepAlive(axis == ImGuiAxis_X ? "#SCROLLX" : "#SCROLLY");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Vertical/Horizontal scrollbar[m
[32m+[m[32m// The entire piece of code below is rather confusing because:[m
[32m+[m[32m// - We handle absolute seeking (when first clicking outside the grab) and relative manipulation (afterward or when clicking inside the grab)[m
[32m+[m[32m// - We store values as normalized ratio and in a form that allows the window content to change while we are holding on a scrollbar[m
[32m+[m[32m// - We handle both horizontal and vertical scrollbars, which makes the terminology not ideal.[m
[32m+[m[32mvoid ImGui::Scrollbar(ImGuiAxis axis)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m
[32m+[m[32m    const bool horizontal = (axis == ImGuiAxis_X);[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    const ImGuiID id = GetScrollbarID(window, axis);[m
[32m+[m[32m    KeepAliveID(id);[m
[32m+[m
[32m+[m[32m    // Render background[m
[32m+[m[32m    bool other_scrollbar = (horizontal ? window->ScrollbarY : window->ScrollbarX);[m
[32m+[m[32m    float other_scrollbar_size_w = other_scrollbar ? style.ScrollbarSize : 0.0f;[m
[32m+[m[32m    const ImRect host_rect = window->Rect();[m
[32m+[m[32m    const float border_size = window->WindowBorderSize;[m
[32m+[m[32m    ImRect bb = horizontal[m
[32m+[m[32m        ? ImRect(host_rect.Min.x + border_size, host_rect.Max.y - style.ScrollbarSize, host_rect.Max.x - other_scrollbar_size_w - border_size, host_rect.Max.y - border_size)[m
[32m+[m[32m        : ImRect(host_rect.Max.x - style.ScrollbarSize, host_rect.Min.y + border_size, host_rect.Max.x - border_size, host_rect.Max.y - other_scrollbar_size_w - border_size);[m
[32m+[m[32m    bb.Min.x = ImMax(host_rect.Min.x, bb.Min.x); // Handle case where the host rectangle is smaller than the scrollbar[m
[32m+[m[32m    bb.Min.y = ImMax(host_rect.Min.y, bb.Min.y);[m
[32m+[m[32m    if (!horizontal)[m
[32m+[m[32m        bb.Min.y += window->TitleBarHeight() + ((window->Flags & ImGuiWindowFlags_MenuBar) ? window->MenuBarHeight() : 0.0f); // FIXME: InnerRect?[m
[32m+[m
[32m+[m[32m    const float bb_width = bb.GetWidth();[m
[32m+[m[32m    const float bb_height = bb.GetHeight();[m
[32m+[m[32m    if (bb_width <= 0.0f || bb_height <= 0.0f)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // When we are too small, start hiding and disabling the grab (this reduce visual noise on very small window and facilitate using the resize grab)[m
[32m+[m[32m    float alpha = 1.0f;[m
[32m+[m[32m    if ((axis == ImGuiAxis_Y) && bb_height < g.FontSize + g.Style.FramePadding.y * 2.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        alpha = ImSaturate((bb_height - g.FontSize) / (g.Style.FramePadding.y * 2.0f));[m
[32m+[m[32m        if (alpha <= 0.0f)[m
[32m+[m[32m            return;[m
[32m+[m[32m    }[m
[32m+[m[32m    const bool allow_interaction = (alpha >= 1.0f);[m
[32m+[m
[32m+[m[32m    int window_rounding_corners;[m
[32m+[m[32m    if (horizontal)[m
[32m+[m[32m        window_rounding_corners = ImDrawCornerFlags_BotLeft | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);[m
[32m+[m[32m    else[m
[32m+[m[32m        window_rounding_corners = (((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar)) ? ImDrawCornerFlags_TopRight : 0) | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);[m
[32m+[m[32m    window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_ScrollbarBg), window->WindowRounding, window_rounding_corners);[m
[32m+[m[32m    bb.Expand(ImVec2(-ImClamp((float)(int)((bb_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp((float)(int)((bb_height - 2.0f) * 0.5f), 0.0f, 3.0f)));[m
[32m+[m
[32m+[m[32m    // V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)[m
[32m+[m[32m    float scrollbar_size_v = horizontal ? bb.GetWidth() : bb.GetHeight();[m
[32m+[m[32m    float scroll_v = horizontal ? window->Scroll.x : window->Scroll.y;[m
[32m+[m[32m    float win_size_avail_v = (horizontal ? window->SizeFull.x : window->SizeFull.y) - other_scrollbar_size_w;[m
[32m+[m[32m    float win_size_contents_v = horizontal ? window->SizeContents.x : window->SizeContents.y;[m
[32m+[m
[32m+[m[32m    // Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)[m
[32m+[m[32m    // But we maintain a minimum size in pixel to allow for the user to still aim inside.[m
[32m+[m[32m    IM_ASSERT(ImMax(win_size_contents_v, win_size_avail_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.[m
[32m+[m[32m    const float win_size_v = ImMax(ImMax(win_size_contents_v, win_size_avail_v), 1.0f);[m
[32m+[m[32m    const float grab_h_pixels = ImClamp(scrollbar_size_v * (win_size_avail_v / win_size_v), style.GrabMinSize, scrollbar_size_v);[m
[32m+[m[32m    const float grab_h_norm = grab_h_pixels / scrollbar_size_v;[m
[32m+[m
[32m+[m[32m    // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().[m
[32m+[m[32m    bool held = false;[m
[32m+[m[32m    bool hovered = false;[m
[32m+[m[32m    const bool previously_held = (g.ActiveId == id);[m
[32m+[m[32m    ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);[m
[32m+[m
[32m+[m[32m    float scroll_max = ImMax(1.0f, win_size_contents_v - win_size_avail_v);[m
[32m+[m[32m    float scroll_ratio = ImSaturate(scroll_v / scroll_max);[m
[32m+[m[32m    float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;[m
[32m+[m[32m    if (held && allow_interaction && grab_h_norm < 1.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        float scrollbar_pos_v = horizontal ? bb.Min.x : bb.Min.y;[m
[32m+[m[32m        float mouse_pos_v = horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;[m
[32m+[m[32m        float* click_delta_to_grab_center_v = horizontal ? &g.ScrollbarClickDeltaToGrabCenter.x : &g.ScrollbarClickDeltaToGrabCenter.y;[m
[32m+[m
[32m+[m[32m        // Click position in scrollbar normalized space (0.0f->1.0f)[m
[32m+[m[32m        const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);[m
[32m+[m[32m        SetHoveredID(id);[m
[32m+[m
[32m+[m[32m        bool seek_absolute = false;[m
[32m+[m[32m        if (!previously_held)[m
[32m+[m[32m        {[m
[32m+[m[32m            // On initial click calculate the distance between mouse and the center of the grab[m
[32m+[m[32m            if (clicked_v_norm >= grab_v_norm && clicked_v_norm <= grab_v_norm + grab_h_norm)[m
[32m+[m[32m            {[m
[32m+[m[32m                *click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm*0.5f;[m
[32m+[m[32m            }[m
[32m+[m[32m            else[m
[32m+[m[32m            {[m
[32m+[m[32m                seek_absolute = true;[m
[32m+[m[32m                *click_delta_to_grab_center_v = 0.0f;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Apply scroll[m
[32m+[m[32m        // It is ok to modify Scroll here because we are being called in Begin() after the calculation of SizeContents and before setting up our starting position[m
[32m+[m[32m        const float scroll_v_norm = ImSaturate((clicked_v_norm - *click_delta_to_grab_center_v - grab_h_norm*0.5f) / (1.0f - grab_h_norm));[m
[32m+[m[32m        scroll_v = (float)(int)(0.5f + scroll_v_norm * scroll_max);//(win_size_contents_v - win_size_v));[m
[32m+[m[32m        if (horizontal)[m
[32m+[m[32m            window->Scroll.x = scroll_v;[m
[32m+[m[32m        else[m
[32m+[m[32m            window->Scroll.y = scroll_v;[m
[32m+[m
[32m+[m[32m        // Update values for rendering[m
[32m+[m[32m        scroll_ratio = ImSaturate(scroll_v / scroll_max);[m
[32m+[m[32m        grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;[m
[32m+[m
[32m+[m[32m        // Update distance to grab now that we have seeked and saturated[m
[32m+[m[32m        if (seek_absolute)[m
[32m+[m[32m            *click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm*0.5f;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Render grab[m
[32m+[m[32m    const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab, alpha);[m
[32m+[m[32m    ImRect grab_rect;[m
[32m+[m[32m    if (horizontal)[m
[32m+[m[32m        grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImMin(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, host_rect.Max.x), bb.Max.y);[m
[32m+[m[32m    else[m
[32m+[m[32m        grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImMin(ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels, host_rect.Max.y));[m
[32m+[m[32m    window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);[m
[32m+[m[32m    if (border_col.w > 0.0f)[m
[32m+[m[32m        bb.Max += ImVec2(2, 2);[m
[32m+[m[32m    ItemSize(bb);[m
[32m+[m[32m    if (!ItemAdd(bb, 0))[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    if (border_col.w > 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f);[m
[32m+[m[32m        window->DrawList->AddImage(user_texture_id, bb.Min + ImVec2(1, 1), bb.Max - ImVec2(1, 1), uv0, uv1, GetColorU32(tint_col));[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        window->DrawList->AddImage(user_texture_id, bb.Min, bb.Max, uv0, uv1, GetColorU32(tint_col));[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// frame_padding < 0: uses FramePadding from style (default)[m
[32m+[m[32m// frame_padding = 0: no framing[m
[32m+[m[32m// frame_padding > 0: set framing size[m
[32m+[m[32m// The color used are the button colors.[m
[32m+[m[32mbool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m
[32m+[m[32m    // Default to using texture ID as ID. User can still push string/integer prefixes.[m
[32m+[m[32m    // We could hash the size/uv to create a unique ID but that would prevent the user from animating UV.[m
[32m+[m[32m    PushID((void*)(intptr_t)user_texture_id);[m
[32m+[m[32m    const ImGuiID id = window->GetID("#image");[m
[32m+[m[32m    PopID();[m
[32m+[m
[32m+[m[32m    const ImVec2 padding = (frame_padding >= 0) ? ImVec2((float)frame_padding, (float)frame_padding) : style.FramePadding;[m
[32m+[m[32m    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size + padding * 2);[m
[32m+[m[32m    const ImRect image_bb(window->DC.CursorPos + padding, window->DC.CursorPos + padding + size);[m
[32m+[m[32m    ItemSize(bb);[m
[32m+[m[32m    if (!ItemAdd(bb, id))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    bool hovered, held;[m
[32m+[m[32m    bool pressed = ButtonBehavior(bb, id, &hovered, &held);[m
[32m+[m
[32m+[m[32m    // Render[m
[32m+[m[32m    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);[m
[32m+[m[32m    RenderNavHighlight(bb, id);[m
[32m+[m[32m    RenderFrame(bb.Min, bb.Max, col, true, ImClamp((float)ImMin(padding.x, padding.y), 0.0f, style.FrameRounding));[m
[32m+[m[32m    if (bg_col.w > 0.0f)[m
[32m+[m[32m        window->DrawList->AddRectFilled(image_bb.Min, image_bb.Max, GetColorU32(bg_col));[m
[32m+[m[32m    window->DrawList->AddImage(user_texture_id, image_bb.Min, image_bb.Max, uv0, uv1, GetColorU32(tint_col));[m
[32m+[m
[32m+[m[32m    return pressed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::Checkbox(const char* label, bool* v)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    const ImGuiID id = window->GetID(label);[m
[32m+[m[32m    const ImVec2 label_size = CalcTextSize(label, NULL, true);[m
[32m+[m
[32m+[m[32m    const float square_sz = GetFrameHeight();[m
[32m+[m[32m    const ImVec2 pos = window->DC.CursorPos;[m
[32m+[m[32m    const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));[m
[32m+[m[32m    ItemSize(total_bb, style.FramePadding.y);[m
[32m+[m[32m    if (!ItemAdd(total_bb, id))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    bool hovered, held;[m
[32m+[m[32m    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);[m
[32m+[m[32m    if (pressed)[m
[32m+[m[32m    {[m
[32m+[m[32m        *v = !(*v);[m
[32m+[m[32m        MarkItemEdited(id);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));[m
[32m+[m[32m    RenderNavHighlight(total_bb, id);[m
[32m+[m[32m    RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);[m
[32m+[m[32m    if (*v)[m
[32m+[m[32m    {[m
[32m+[m[32m        const float pad = ImMax(1.0f, (float)(int)(square_sz / 6.0f));[m
[32m+[m[32m        RenderCheckMark(check_bb.Min + ImVec2(pad, pad), GetColorU32(ImGuiCol_CheckMark), square_sz - pad*2.0f);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (g.LogEnabled)[m
[32m+[m[32m        LogRenderedText(&total_bb.Min, *v ? "[x]" : "[ ]");[m
[32m+[m[32m    if (label_size.x > 0.0f)[m
[32m+[m[32m        RenderText(ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y), label);[m
[32m+[m
[32m+[m[32m    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));[m
[32m+[m[32m    return pressed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)[m
[32m+[m[32m{[m
[32m+[m[32m    bool v = ((*flags & flags_value) == flags_value);[m
[32m+[m[32m    bool pressed = Checkbox(label, &v);[m
[32m+[m[32m    if (pressed)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (v)[m
[32m+[m[32m            *flags |= flags_value;[m
[32m+[m[32m        else[m
[32m+[m[32m            *flags &= ~flags_value;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return pressed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::RadioButton(const char* label, bool active)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    const ImGuiID id = window->GetID(label);[m
[32m+[m[32m    const ImVec2 label_size = CalcTextSize(label, NULL, true);[m
[32m+[m
[32m+[m[32m    const float square_sz = GetFrameHeight();[m
[32m+[m[32m    const ImVec2 pos = window->DC.CursorPos;[m
[32m+[m[32m    const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));[m
[32m+[m[32m    const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));[m
[32m+[m[32m    ItemSize(total_bb, style.FramePadding.y);[m
[32m+[m[32m    if (!ItemAdd(total_bb, id))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImVec2 center = check_bb.GetCenter();[m
[32m+[m[32m    center.x = (float)(int)center.x + 0.5f;[m
[32m+[m[32m    center.y = (float)(int)center.y + 0.5f;[m
[32m+[m[32m    const float radius = (square_sz - 1.0f) * 0.5f;[m
[32m+[m
[32m+[m[32m    bool hovered, held;[m
[32m+[m[32m    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);[m
[32m+[m[32m    if (pressed)[m
[32m+[m[32m        MarkItemEdited(id);[m
[32m+[m
[32m+[m[32m    RenderNavHighlight(total_bb, id);[m
[32m+[m[32m    window->DrawList->AddCircleFilled(center, radius, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), 16);[m
[32m+[m[32m    if (active)[m
[32m+[m[32m    {[m
[32m+[m[32m        const float pad = ImMax(1.0f, (float)(int)(square_sz / 6.0f));[m
[32m+[m[32m        window->DrawList->AddCircleFilled(center, radius - pad, GetColorU32(ImGuiCol_CheckMark), 16);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (style.FrameBorderSize > 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        window->DrawList->AddCircle(center + ImVec2(1,1), radius, GetColorU32(ImGuiCol_BorderShadow), 16, style.FrameBorderSize);[m
[32m+[m[32m        window->DrawList->AddCircle(center, radius, GetColorU32(ImGuiCol_Border), 16, style.FrameBorderSize);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (g.LogEnabled)[m
[32m+[m[32m        LogRenderedText(&total_bb.Min, active ? "(x)" : "( )");[m
[32m+[m[32m    if (label_size.x > 0.0f)[m
[32m+[m[32m        RenderText(ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y), label);[m
[32m+[m
[32m+[m[32m    return pressed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::RadioButton(const char* label, int* v, int v_button)[m
[32m+[m[32m{[m
[32m+[m[32m    const bool pressed = RadioButton(label, *v == v_button);[m
[32m+[m[32m    if (pressed)[m
[32m+[m[32m        *v = v_button;[m
[32m+[m[32m    return pressed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// size_arg (for each axis) < 0.0f: align to end, 0.0f: auto, > 0.0f: specified size[m
[32m+[m[32mvoid ImGui::ProgressBar(float fraction, const ImVec2& size_arg, const char* overlay)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m
[32m+[m[32m    ImVec2 pos = window->DC.CursorPos;[m
[32m+[m[32m    ImVec2 size = CalcItemSize(size_arg, GetNextItemWidth(), g.FontSize + style.FramePadding.y*2.0f);[m
[32m+[m[32m    ImRect bb(pos, pos + size);[m
[32m+[m[32m    ItemSize(size, style.FramePadding.y);[m
[32m+[m[32m    if (!ItemAdd(bb, 0))[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    // Render[m
[32m+[m[32m    fraction = ImSaturate(fraction);[m
[32m+[m[32m    RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);[m
[32m+[m[32m    bb.Expand(ImVec2(-style.FrameBorderSize, -style.FrameBorderSize));[m
[32m+[m[32m    const ImVec2 fill_br = ImVec2(ImLerp(bb.Min.x, bb.Max.x, fraction), bb.Max.y);[m
[32m+[m[32m    RenderRectFilledRangeH(window->DrawList, bb, GetColorU32(ImGuiCol_PlotHistogram), 0.0f, fraction, style.FrameRounding);[m
[32m+[m
[32m+[m[32m    // Default displaying the fraction as percentage string, but user can override it[m
[32m+[m[32m    char overlay_buf[32];[m
[32m+[m[32m    if (!overlay)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImFormatString(overlay_buf, IM_ARRAYSIZE(overlay_buf), "%.0f%%", fraction*100+0.01f);[m
[32m+[m[32m        overlay = overlay_buf;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    ImVec2 overlay_size = CalcTextSize(overlay, NULL);[m
[32m+[m[32m    if (overlay_size.x > 0.0f)[m
[32m+[m[32m        RenderTextClipped(ImVec2(ImClamp(fill_br.x + style.ItemSpacing.x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f,0.5f), &bb);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::Bullet()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    const float line_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);[m
[32m+[m[32m    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize, line_height));[m
[32m+[m[32m    ItemSize(bb);[m
[32m+[m[32m    if (!ItemAdd(bb, 0))[m
[32m+[m[32m    {[m
[32m+[m[32m        SameLine(0, style.FramePadding.x*2);[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Render and stay on same line[m
[32m+[m[32m    RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));[m
[32m+[m[32m    SameLine(0, style.FramePadding.x*2);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Widgets: Low-level Layout helpers[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - Spacing()[m
[32m+[m[32m// - Dummy()[m
[32m+[m[32m// - NewLine()[m
[32m+[m[32m// - AlignTextToFramePadding()[m
[32m+[m[32m// - Separator()[m
[32m+[m[32m// - VerticalSeparator() [Internal][m
[32m+[m[32m// - SplitterBehavior() [Internal][m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mvoid ImGui::Spacing()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m[32m    ItemSize(ImVec2(0,0));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::Dummy(const ImVec2& size)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);[m
[32m+[m[32m    ItemSize(size);[m
[32m+[m[32m    ItemAdd(bb, 0);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::NewLine()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiLayoutType backup_layout_type = window->DC.LayoutType;[m
[32m+[m[32m    window->DC.LayoutType = ImGuiLayoutType_Vertical;[m
[32m+[m[32m    if (window->DC.CurrentLineSize.y > 0.0f)     // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.[m
[32m+[m[32m        ItemSize(ImVec2(0,0));[m
[32m+[m[32m    else[m
[32m+[m[32m        ItemSize(ImVec2(0.0f, g.FontSize));[m
[32m+[m[32m    window->DC.LayoutType = backup_layout_type;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::AlignTextToFramePadding()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    window->DC.CurrentLineSize.y = ImMax(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y * 2);[m
[32m+[m[32m    window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.CurrentLineTextBaseOffset, g.Style.FramePadding.y);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Horizontal/vertical separating line[m
[32m+[m[32mvoid ImGui::Separator()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    // Those flags should eventually be overrideable by the user[m
[32m+[m[32m    ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;[m
[32m+[m[32m    IM_ASSERT(ImIsPowerOfTwo(flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical)));   // Check that only 1 option is selected[m
[32m+[m[32m    if (flags & ImGuiSeparatorFlags_Vertical)[m
[32m+[m[32m    {[m
[32m+[m[32m        VerticalSeparator();[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Horizontal Separator[m
[32m+[m[32m    if (window->DC.CurrentColumns)[m
[32m+[m[32m        PopClipRect();[m
[32m+[m
[32m+[m[32m    float x1 = window->Pos.x;[m
[32m+[m[32m    float x2 = window->Pos.x + window->Size.x;[m
[32m+[m[32m    if (!window->DC.GroupStack.empty())[m
[32m+[m[32m        x1 += window->DC.Indent.x;[m
[32m+[m
[32m+[m[32m    const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y+1.0f));[m
[32m+[m[32m    ItemSize(ImVec2(0.0f, 1.0f)); // NB: we don't provide our width so that it doesn't get feed back into AutoFit[m
[32m+[m[32m    if (!ItemAdd(bb, 0))[m
[32m+[m[32m    {[m
[32m+[m[32m        if (window->DC.CurrentColumns)[m
[32m+[m[32m            PushColumnClipRect();[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    window->DrawList->AddLine(bb.Min, ImVec2(bb.Max.x,bb.Min.y), GetColorU32(ImGuiCol_Separator));[m
[32m+[m
[32m+[m[32m    if (g.LogEnabled)[m
[32m+[m[32m        LogRenderedText(&bb.Min, "--------------------------------");[m
[32m+[m
[32m+[m[32m    if (window->DC.CurrentColumns)[m
[32m+[m[32m    {[m
[32m+[m[32m        PushColumnClipRect();[m
[32m+[m[32m        window->DC.CurrentColumns->LineMinY = window->DC.CursorPos.y;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::VerticalSeparator()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    float y1 = window->DC.CursorPos.y;[m
[32m+[m[32m    float y2 = window->DC.CursorPos.y + window->DC.CurrentLineSize.y;[m
[32m+[m[32m    const ImRect bb(ImVec2(window->DC.CursorPos.x, y1), ImVec2(window->DC.CursorPos.x + 1.0f, y2));[m
[32m+[m[32m    ItemSize(ImVec2(1.0f, 0.0f));[m
[32m+[m[32m    if (!ItemAdd(bb, 0))[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    window->DrawList->AddLine(ImVec2(bb.Min.x, bb.Min.y), ImVec2(bb.Min.x, bb.Max.y), GetColorU32(ImGuiCol_Separator));[m
[32m+[m[32m    if (g.LogEnabled)[m
[32m+[m[32m        LogText(" |");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Using 'hover_visibility_delay' allows us to hide the highlight and mouse cursor for a short time, which can be convenient to reduce visual noise.[m
[32m+[m[32mbool ImGui::SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m
[32m+[m[32m    const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;[m
[32m+[m[32m    window->DC.ItemFlags |= ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus;[m
[32m+[m[32m    bool item_add = ItemAdd(bb, id);[m
[32m+[m[32m    window->DC.ItemFlags = item_flags_backup;[m
[32m+[m[32m    if (!item_add)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    bool hovered, held;[m
[32m+[m[32m    ImRect bb_interact = bb;[m
[32m+[m[32m    bb_interact.Expand(axis == ImGuiAxis_Y ? ImVec2(0.0f, hover_extend) : ImVec2(hover_extend, 0.0f));[m
[32m+[m[32m    ButtonBehavior(bb_interact, id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_AllowItemOverlap);[m
[32m+[m[32m    if (g.ActiveId != id)[m
[32m+[m[32m        SetItemAllowOverlap();[m
[32m+[m
[32m+[m[32m    if (held || (g.HoveredId == id && g.HoveredIdPreviousFrame == id && g.HoveredIdTimer >= hover_visibility_delay))[m
[32m+[m[32m        SetMouseCursor(axis == ImGuiAxis_Y ? ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_ResizeEW);[m
[32m+[m
[32m+[m[32m    ImRect bb_render = bb;[m
[32m+[m[32m    if (held)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImVec2 mouse_delta_2d = g.IO.MousePos - g.ActiveIdClickOffset - bb_interact.Min;[m
[32m+[m[32m        float mouse_delta = (axis == ImGuiAxis_Y) ? mouse_delta_2d.y : mouse_delta_2d.x;[m
[32m+[m
[32m+[m[32m        // Minimum pane size[m
[32m+[m[32m        float size_1_maximum_delta = ImMax(0.0f, *size1 - min_size1);[m
[32m+[m[32m        float size_2_maximum_delta = ImMax(0.0f, *size2 - min_size2);[m
[32m+[m[32m        if (mouse_delta < -size_1_maximum_delta)[m
[32m+[m[32m            mouse_delta = -size_1_maximum_delta;[m
[32m+[m[32m        if (mouse_delta > size_2_maximum_delta)[m
[32m+[m[32m            mouse_delta = size_2_maximum_delta;[m
[32m+[m
[32m+[m[32m        // Apply resize[m
[32m+[m[32m        if (mouse_delta != 0.0f)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (mouse_delta < 0.0f)[m
[32m+[m[32m                IM_ASSERT(*size1 + mouse_delta >= min_size1);[m
[32m+[m[32m            if (mouse_delta > 0.0f)[m
[32m+[m[32m                IM_ASSERT(*size2 - mouse_delta >= min_size2);[m
[32m+[m[32m            *size1 += mouse_delta;[m
[32m+[m[32m            *size2 -= mouse_delta;[m
[32m+[m[32m            bb_render.Translate((axis == ImGuiAxis_X) ? ImVec2(mouse_delta, 0.0f) : ImVec2(0.0f, mouse_delta));[m
[32m+[m[32m            MarkItemEdited(id);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Render[m
[32m+[m[32m    const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : (hovered && g.HoveredIdTimer >= hover_visibility_delay) ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);[m
[32m+[m[32m    window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, col, g.Style.FrameRounding);[m
[32m+[m
[32m+[m[32m    return held;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Widgets: ComboBox[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - BeginCombo()[m
[32m+[m[32m// - EndCombo()[m
[32m+[m[32m// - Combo()[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mstatic float CalcMaxPopupHeightFromItemCount(int items_count)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (items_count <= 0)[m
[32m+[m[32m        return FLT_MAX;[m
[32m+[m[32m    return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    // Always consume the SetNextWindowSizeConstraint() call in our early return paths[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiCond backup_next_window_size_constraint = g.NextWindowData.SizeConstraintCond;[m
[32m+[m[32m    g.NextWindowData.SizeConstraintCond = 0;[m
[32m+[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    IM_ASSERT((flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together[m
[32m+[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    const ImGuiID id = window->GetID(label);[m
[32m+[m
[32m+[m[32m    const float arrow_size = (flags & ImGuiComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight();[m
[32m+[m[32m    const ImVec2 label_size = CalcTextSize(label, NULL, true);[m
[32m+[m[32m    const float expected_w = GetNextItemWidth();[m
[32m+[m[32m    const float w = (flags & ImGuiComboFlags_NoPreview) ? arrow_size : expected_w;[m
[32m+[m[32m    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));[m
[32m+[m[32m    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));[m
[32m+[m[32m    ItemSize(total_bb, style.FramePadding.y);[m
[32m+[m[32m    if (!ItemAdd(total_bb, id, &frame_bb))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    bool hovered, held;[m
[32m+[m[32m    bool pressed = ButtonBehavior(frame_bb, id, &hovered, &held);[m
[32m+[m[32m    bool popup_open = IsPopupOpen(id);[m
[32m+[m
[32m+[m[32m    const ImU32 frame_col = GetColorU32(hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);[m
[32m+[m[32m    const float value_x2 = ImMax(frame_bb.Min.x, frame_bb.Max.x - arrow_size);[m
[32m+[m[32m    RenderNavHighlight(frame_bb, id);[m
[32m+[m[32m    if (!(flags & ImGuiComboFlags_NoPreview))[m
[32m+[m[32m        window->DrawList->AddRectFilled(frame_bb.Min, ImVec2(value_x2, frame_bb.Max.y), frame_col, style.FrameRounding, ImDrawCornerFlags_Left);[m
[32m+[m[32m    if (!(flags & ImGuiComboFlags_NoArrowButton))[m
[32m+[m[32m    {[m
[32m+[m[32m        window->DrawList->AddRectFilled(ImVec2(value_x2, frame_bb.Min.y), frame_bb.Max, GetColorU32((popup_open || hovered) ? ImGuiCol_ButtonHovered : ImGuiCol_Button), style.FrameRounding, (w <= arrow_size) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Right);[m
[32m+[m[32m        RenderArrow(ImVec2(value_x2 + style.FramePadding.y, frame_bb.Min.y + style.FramePadding.y), ImGuiDir_Down);[m
[32m+[m[32m    }[m
[32m+[m[32m    RenderFrameBorder(frame_bb.Min, frame_bb.Max, style.FrameRounding);[m
[32m+[m[32m    if (preview_value != NULL && !(flags & ImGuiComboFlags_NoPreview))[m
[32m+[m[32m        RenderTextClipped(frame_bb.Min + style.FramePadding, ImVec2(value_x2, frame_bb.Max.y), preview_value, NULL, NULL, ImVec2(0.0f,0.0f));[m
[32m+[m[32m    if (label_size.x > 0)[m
[32m+[m[32m        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);[m
[32m+[m
[32m+[m[32m    if ((pressed || g.NavActivateId == id) && !popup_open)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (window->DC.NavLayerCurrent == 0)[m
[32m+[m[32m            window->NavLastIds[0] = id;[m
[32m+[m[32m        OpenPopupEx(id);[m
[32m+[m[32m        popup_open = true;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (!popup_open)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    if (backup_next_window_size_constraint)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.NextWindowData.SizeConstraintCond = backup_next_window_size_constraint;[m
[32m+[m[32m        g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        if ((flags & ImGuiComboFlags_HeightMask_) == 0)[m
[32m+[m[32m            flags |= ImGuiComboFlags_HeightRegular;[m
[32m+[m[32m        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_));    // Only one[m
[32m+[m[32m        int popup_max_height_in_items = -1;[m
[32m+[m[32m        if (flags & ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;[m
[32m+[m[32m        else if (flags & ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;[m
[32m+[m[32m        else if (flags & ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;[m
[32m+[m[32m        SetNextWindowSizeConstraints(ImVec2(w, 0.0f), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    char name[16];[m
[32m+[m[32m    ImFormatString(name, IM_ARRAYSIZE(name), "##Combo_%02d", g.BeginPopupStack.Size); // Recycle windows based on depth[m
[32m+[m
[32m+[m[32m    // Peak into expected window size so we can position it[m
[32m+[m[32m    if (ImGuiWindow* popup_window = FindWindowByName(name))[m
[32m+[m[32m        if (popup_window->WasActive)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImVec2 size_expected = CalcWindowExpectedSize(popup_window);[m
[32m+[m[32m            if (flags & ImGuiComboFlags_PopupAlignLeft)[m
[32m+[m[32m                popup_window->AutoPosLastDirection = ImGuiDir_Left;[m
[32m+[m[32m            ImRect r_outer = GetWindowAllowedExtentRect(popup_window);[m
[32m+[m[32m            ImVec2 pos = FindBestWindowPosForPopupEx(frame_bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, frame_bb, ImGuiPopupPositionPolicy_ComboBox);[m
[32m+[m[32m            SetNextWindowPos(pos);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m    // Horizontally align ourselves with the framed text[m
[32m+[m[32m    ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings;[m
[32m+[m[32m    PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(style.FramePadding.x, style.WindowPadding.y));[m
[32m+[m[32m    bool ret = Begin(name, NULL, window_flags);[m
[32m+[m[32m    PopStyleVar();[m
[32m+[m[32m    if (!ret)[m
[32m+[m[32m    {[m
[32m+[m[32m        EndPopup();[m
[32m+[m[32m        IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::EndCombo()[m
[32m+[m[32m{[m
[32m+[m[32m    EndPopup();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Getter for the old Combo() API: const char*[][m
[32m+[m[32mstatic bool Items_ArrayGetter(void* data, int idx, const char** out_text)[m
[32m+[m[32m{[m
[32m+[m[32m    const char* const* items = (const char* const*)data;[m
[32m+[m[32m    if (out_text)[m
[32m+[m[32m        *out_text = items[idx];[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Getter for the old Combo() API: "item1\0item2\0item3\0"[m
[32m+[m[32mstatic bool Items_SingleStringGetter(void* data, int idx, const char** out_text)[m
[32m+[m[32m{[m
[32m+[m[32m    // FIXME-OPT: we could pre-compute the indices to fasten this. But only 1 active combo means the waste is limited.[m
[32m+[m[32m    const char* items_separated_by_zeros = (const char*)data;[m
[32m+[m[32m    int items_count = 0;[m
[32m+[m[32m    const char* p = items_separated_by_zeros;[m
[32m+[m[32m    while (*p)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (idx == items_count)[m
[32m+[m[32m            break;[m
[32m+[m[32m        p += strlen(p) + 1;[m
[32m+[m[32m        items_count++;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (!*p)[m
[32m+[m[32m        return false;[m
[32m+[m[32m    if (out_text)[m
[32m+[m[32m        *out_text = p;[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Old API, prefer using BeginCombo() nowadays if you can.[m
[32m+[m[32mbool ImGui::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int popup_max_height_in_items)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    // Call the getter to obtain the preview string which is a parameter to BeginCombo()[m
[32m+[m[32m    const char* preview_value = NULL;[m
[32m+[m[32m    if (*current_item >= 0 && *current_item < items_count)[m
[32m+[m[32m        items_getter(data, *current_item, &preview_value);[m
[32m+[m
[32m+[m[32m    // The old Combo() API exposed "popup_max_height_in_items". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.[m
[32m+[m[32m    if (popup_max_height_in_items != -1 && !g.NextWindowData.SizeConstraintCond)[m
[32m+[m[32m        SetNextWindowSizeConstraints(ImVec2(0,0), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));[m
[32m+[m
[32m+[m[32m    if (!BeginCombo(label, preview_value, ImGuiComboFlags_None))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    // Display items[m
[32m+[m[32m    // FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to make sure our call to SetItemDefaultFocus() is processed)[m
[32m+[m[32m    bool value_changed = false;[m
[32m+[m[32m    for (int i = 0; i < items_count; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        PushID((void*)(intptr_t)i);[m
[32m+[m[32m        const bool item_selected = (i == *current_item);[m
[32m+[m[32m        const char* item_text;[m
[32m+[m[32m        if (!items_getter(data, i, &item_text))[m
[32m+[m[32m            item_text = "*Unknown item*";[m
[32m+[m[32m        if (Selectable(item_text, item_selected))[m
[32m+[m[32m        {[m
[32m+[m[32m            value_changed = true;[m
[32m+[m[32m            *current_item = i;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (item_selected)[m
[32m+[m[32m            SetItemDefaultFocus();[m
[32m+[m[32m        PopID();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    EndCombo();[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Combo box helper allowing to pass an array of strings.[m
[32m+[m[32mbool ImGui::Combo(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items)[m
[32m+[m[32m{[m
[32m+[m[32m    const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_in_items);[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Combo box helper allowing to pass all items in a single string literal holding multiple zero-terminated items "item1\0item2\0"[m
[32m+[m[32mbool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)[m
[32m+[m[32m{[m
[32m+[m[32m    int items_count = 0;[m
[32m+[m[32m    const char* p = items_separated_by_zeros;       // FIXME-OPT: Avoid computing this, or at least only when combo is open[m
[32m+[m[32m    while (*p)[m
[32m+[m[32m    {[m
[32m+[m[32m        p += strlen(p) + 1;[m
[32m+[m[32m        items_count++;[m
[32m+[m[32m    }[m
[32m+[m[32m    bool value_changed = Combo(label, current_item, Items_SingleStringGetter, (void*)items_separated_by_zeros, items_count, height_in_items);[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Data Type and Data Formatting Helpers [Internal][m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - PatchFormatStringFloatToInt()[m
[32m+[m[32m// - DataTypeGetInfo()[m
[32m+[m[32m// - DataTypeFormatString()[m
[32m+[m[32m// - DataTypeApplyOp()[m
[32m+[m[32m// - DataTypeApplyOpFromText()[m
[32m+[m[32m// - GetMinimumStepAtDecimalPrecision[m
[32m+[m[32m// - RoundScalarWithFormat<>()[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mstatic const ImGuiDataTypeInfo GDataTypeInfo[] =[m
[32m+[m[32m{[m
[32m+[m[32m    { sizeof(char),             "%d",   "%d"    },  // ImGuiDataType_S8[m
[32m+[m[32m    { sizeof(unsigned char),    "%u",   "%u"    },[m
[32m+[m[32m    { sizeof(short),            "%d",   "%d"    },  // ImGuiDataType_S16[m
[32m+[m[32m    { sizeof(unsigned short),   "%u",   "%u"    },[m
[32m+[m[32m    { sizeof(int),              "%d",   "%d"    },  // ImGuiDataType_S32[m
[32m+[m[32m    { sizeof(unsigned int),     "%u",   "%u"    },[m
[32m+[m[32m#ifdef _MSC_VER[m
[32m+[m[32m    { sizeof(ImS64),            "%I64d","%I64d" },  // ImGuiDataType_S64[m
[32m+[m[32m    { sizeof(ImU64),            "%I64u","%I64u" },[m
[32m+[m[32m#else[m
[32m+[m[32m    { sizeof(ImS64),            "%lld", "%lld"  },  // ImGuiDataType_S64[m
[32m+[m[32m    { sizeof(ImU64),            "%llu", "%llu"  },[m
[32m+[m[32m#endif[m
[32m+[m[32m    { sizeof(float),            "%f",   "%f"    },  // ImGuiDataType_Float (float are promoted to double in va_arg)[m
[32m+[m[32m    { sizeof(double),           "%f",   "%lf"   },  // ImGuiDataType_Double[m
[32m+[m[32m};[m
[32m+[m[32mIM_STATIC_ASSERT(IM_ARRAYSIZE(GDataTypeInfo) == ImGuiDataType_COUNT);[m
[32m+[m
[32m+[m[32m// FIXME-LEGACY: Prior to 1.61 our DragInt() function internally used floats and because of this the compile-time default value for format was "%.0f".[m
[32m+[m[32m// Even though we changed the compile-time default, we expect users to have carried %f around, which would break the display of DragInt() calls.[m
[32m+[m[32m// To honor backward compatibility we are rewriting the format string, unless IMGUI_DISABLE_OBSOLETE_FUNCTIONS is enabled. What could possibly go wrong?![m
[32m+[m[32mstatic const char* PatchFormatStringFloatToInt(const char* fmt)[m
[32m+[m[32m{[m
[32m+[m[32m    if (fmt[0] == '%' && fmt[1] == '.' && fmt[2] == '0' && fmt[3] == 'f' && fmt[4] == 0) // Fast legacy path for "%.0f" which is expected to be the most common case.[m
[32m+[m[32m        return "%d";[m
[32m+[m[32m    const char* fmt_start = ImParseFormatFindStart(fmt);    // Find % (if any, and ignore %%)[m
[32m+[m[32m    const char* fmt_end = ImParseFormatFindEnd(fmt_start);  // Find end of format specifier, which itself is an exercise of confidence/recklessness (because snprintf is dependent on libc or user).[m
[32m+[m[32m    if (fmt_end > fmt_start && fmt_end[-1] == 'f')[m
[32m+[m[32m    {[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32m        if (fmt_start == fmt && fmt_end[0] == 0)[m
[32m+[m[32m            return "%d";[m
[32m+[m[32m        ImGuiContext& g = *GImGui;[m
[32m+[m[32m        ImFormatString(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), "%.*s%%d%s", (int)(fmt_start - fmt), fmt, fmt_end); // Honor leading and trailing decorations, but lose alignment/precision.[m
[32m+[m[32m        return g.TempBuffer;[m
[32m+[m[32m#else[m
[32m+[m[32m        IM_ASSERT(0 && "DragInt(): Invalid format string!"); // Old versions used a default parameter of "%.0f", please replace with e.g. "%d"[m
[32m+[m[32m#endif[m
[32m+[m[32m    }[m
[32m+[m[32m    return fmt;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst ImGuiDataTypeInfo* ImGui::DataTypeGetInfo(ImGuiDataType data_type)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);[m
[32m+[m[32m    return &GDataTypeInfo[data_type];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint ImGui::DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* data_ptr, const char* format)[m
[32m+[m[32m{[m
[32m+[m[32m    // Signedness doesn't matter when pushing integer arguments[m
[32m+[m[32m    if (data_type == ImGuiDataType_S32 || data_type == ImGuiDataType_U32)[m
[32m+[m[32m        return ImFormatString(buf, buf_size, format, *(const ImU32*)data_ptr);[m
[32m+[m[32m    if (data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)[m
[32m+[m[32m        return ImFormatString(buf, buf_size, format, *(const ImU64*)data_ptr);[m
[32m+[m[32m    if (data_type == ImGuiDataType_Float)[m
[32m+[m[32m        return ImFormatString(buf, buf_size, format, *(const float*)data_ptr);[m
[32m+[m[32m    if (data_type == ImGuiDataType_Double)[m
[32m+[m[32m        return ImFormatString(buf, buf_size, format, *(const double*)data_ptr);[m
[32m+[m[32m    if (data_type == ImGuiDataType_S8)[m
[32m+[m[32m        return ImFormatString(buf, buf_size, format, *(const ImS8*)data_ptr);[m
[32m+[m[32m    if (data_type == ImGuiDataType_U8)[m
[32m+[m[32m        return ImFormatString(buf, buf_size, format, *(const ImU8*)data_ptr);[m
[32m+[m[32m    if (data_type == ImGuiDataType_S16)[m
[32m+[m[32m        return ImFormatString(buf, buf_size, format, *(const ImS16*)data_ptr);[m
[32m+[m[32m    if (data_type == ImGuiDataType_U16)[m
[32m+[m[32m        return ImFormatString(buf, buf_size, format, *(const ImU16*)data_ptr);[m
[32m+[m[32m    IM_ASSERT(0);[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg1, const void* arg2)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(op == '+' || op == '-');[m
[32m+[m[32m    switch (data_type)[m
[32m+[m[32m    {[m
[32m+[m[32m        case ImGuiDataType_S8:[m
[32m+[m[32m            if (op == '+') { *(ImS8*)output  = ImAddClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }[m
[32m+[m[32m            if (op == '-') { *(ImS8*)output  = ImSubClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }[m
[32m+[m[32m            return;[m
[32m+[m[32m        case ImGuiDataType_U8:[m
[32m+[m[32m            if (op == '+') { *(ImU8*)output  = ImAddClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }[m
[32m+[m[32m            if (op == '-') { *(ImU8*)output  = ImSubClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }[m
[32m+[m[32m            return;[m
[32m+[m[32m        case ImGuiDataType_S16:[m
[32m+[m[32m            if (op == '+') { *(ImS16*)output = ImAddClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }[m
[32m+[m[32m            if (op == '-') { *(ImS16*)output = ImSubClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }[m
[32m+[m[32m            return;[m
[32m+[m[32m        case ImGuiDataType_U16:[m
[32m+[m[32m            if (op == '+') { *(ImU16*)output = ImAddClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }[m
[32m+[m[32m            if (op == '-') { *(ImU16*)output = ImSubClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }[m
[32m+[m[32m            return;[m
[32m+[m[32m        case ImGuiDataType_S32:[m
[32m+[m[32m            if (op == '+') { *(ImS32*)output = ImAddClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }[m
[32m+[m[32m            if (op == '-') { *(ImS32*)output = ImSubClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }[m
[32m+[m[32m            return;[m
[32m+[m[32m        case ImGuiDataType_U32:[m
[32m+[m[32m            if (op == '+') { *(ImU32*)output = ImAddClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }[m
[32m+[m[32m            if (op == '-') { *(ImU32*)output = ImSubClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }[m
[32m+[m[32m            return;[m
[32m+[m[32m        case ImGuiDataType_S64:[m
[32m+[m[32m            if (op == '+') { *(ImS64*)output = ImAddClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }[m
[32m+[m[32m            if (op == '-') { *(ImS64*)output = ImSubClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }[m
[32m+[m[32m            return;[m
[32m+[m[32m        case ImGuiDataType_U64:[m
[32m+[m[32m            if (op == '+') { *(ImU64*)output = ImAddClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }[m
[32m+[m[32m            if (op == '-') { *(ImU64*)output = ImSubClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }[m
[32m+[m[32m            return;[m
[32m+[m[32m        case ImGuiDataType_Float:[m
[32m+[m[32m            if (op == '+') { *(float*)output = *(const float*)arg1 + *(const float*)arg2; }[m
[32m+[m[32m            if (op == '-') { *(float*)output = *(const float*)arg1 - *(const float*)arg2; }[m
[32m+[m[32m            return;[m
[32m+[m[32m        case ImGuiDataType_Double:[m
[32m+[m[32m            if (op == '+') { *(double*)output = *(const double*)arg1 + *(const double*)arg2; }[m
[32m+[m[32m            if (op == '-') { *(double*)output = *(const double*)arg1 - *(const double*)arg2; }[m
[32m+[m[32m            return;[m
[32m+[m[32m        case ImGuiDataType_COUNT: break;[m
[32m+[m[32m    }[m
[32m+[m[32m    IM_ASSERT(0);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// User can input math operators (e.g. +100) to edit a numerical values.[m
[32m+[m[32m// NB: This is _not_ a full expression evaluator. We should probably add one and replace this dumb mess..[m
[32m+[m[32mbool ImGui::DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* format)[m
[32m+[m[32m{[m
[32m+[m[32m    while (ImCharIsBlankA(*buf))[m
[32m+[m[32m        buf++;[m
[32m+[m
[32m+[m[32m    // We don't support '-' op because it would conflict with inputing negative value.[m
[32m+[m[32m    // Instead you can use +-100 to subtract from an existing value[m
[32m+[m[32m    char op = buf[0];[m
[32m+[m[32m    if (op == '+' || op == '*' || op == '/')[m
[32m+[m[32m    {[m
[32m+[m[32m        buf++;[m
[32m+[m[32m        while (ImCharIsBlankA(*buf))[m
[32m+[m[32m            buf++;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        op = 0;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (!buf[0])[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    // Copy the value in an opaque buffer so we can compare at the end of the function if it changed at all.[m
[32m+[m[32m    IM_ASSERT(data_type < ImGuiDataType_COUNT);[m
[32m+[m[32m    int data_backup[2];[m
[32m+[m[32m    const ImGuiDataTypeInfo* type_info = ImGui::DataTypeGetInfo(data_type);[m
[32m+[m[32m    IM_ASSERT(type_info->Size <= sizeof(data_backup));[m
[32m+[m[32m    memcpy(data_backup, data_ptr, type_info->Size);[m
[32m+[m
[32m+[m[32m    if (format == NULL)[m
[32m+[m[32m        format = type_info->ScanFmt;[m
[32m+[m
[32m+[m[32m    // FIXME-LEGACY: The aim is to remove those operators and write a proper expression evaluator at some point..[m
[32m+[m[32m    int arg1i = 0;[m
[32m+[m[32m    if (data_type == ImGuiDataType_S32)[m
[32m+[m[32m    {[m
[32m+[m[32m        int* v = (int*)data_ptr;[m
[32m+[m[32m        int arg0i = *v;[m
[32m+[m[32m        float arg1f = 0.0f;[m
[32m+[m[32m        if (op && sscanf(initial_value_buf, format, &arg0i) < 1)[m
[32m+[m[32m            return false;[m
[32m+[m[32m        // Store operand in a float so we can use fractional value for multipliers (*1.1), but constant always parsed as integer so we can fit big integers (e.g. 2000000003) past float precision[m
[32m+[m[32m        if (op == '+')      { if (sscanf(buf, "%d", &arg1i)) *v = (int)(arg0i + arg1i); }                   // Add (use "+-" to subtract)[m
[32m+[m[32m        else if (op == '*') { if (sscanf(buf, "%f", &arg1f)) *v = (int)(arg0i * arg1f); }                   // Multiply[m
[32m+[m[32m        else if (op == '/') { if (sscanf(buf, "%f", &arg1f) && arg1f != 0.0f) *v = (int)(arg0i / arg1f); }  // Divide[m
[32m+[m[32m        else                { if (sscanf(buf, format, &arg1i) == 1) *v = arg1i; }                           // Assign constant[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (data_type == ImGuiDataType_Float)[m
[32m+[m[32m    {[m
[32m+[m[32m        // For floats we have to ignore format with precision (e.g. "%.2f") because sscanf doesn't take them in[m
[32m+[m[32m        format = "%f";[m
[32m+[m[32m        float* v = (float*)data_ptr;[m
[32m+[m[32m        float arg0f = *v, arg1f = 0.0f;[m
[32m+[m[32m        if (op && sscanf(initial_value_buf, format, &arg0f) < 1)[m
[32m+[m[32m            return false;[m
[32m+[m[32m        if (sscanf(buf, format, &arg1f) < 1)[m
[32m+[m[32m            return false;[m
[32m+[m[32m        if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)[m
[32m+[m[32m        else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply[m
[32m+[m[32m        else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide[m
[32m+[m[32m        else                { *v = arg1f; }                            // Assign constant[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (data_type == ImGuiDataType_Double)[m
[32m+[m[32m    {[m
[32m+[m[32m        format = "%lf"; // scanf differentiate float/double unlike printf which forces everything to double because of ellipsis[m
[32m+[m[32m        double* v = (double*)data_ptr;[m
[32m+[m[32m        double arg0f = *v, arg1f = 0.0;[m
[32m+[m[32m        if (op && sscanf(initial_value_buf, format, &arg0f) < 1)[m
[32m+[m[32m            return false;[m
[32m+[m[32m        if (sscanf(buf, format, &arg1f) < 1)[m
[32m+[m[32m            return false;[m
[32m+[m[32m        if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)[m
[32m+[m[32m        else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply[m
[32m+[m[32m        else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide[m
[32m+[m[32m        else                { *v = arg1f; }                            // Assign constant[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (data_type == ImGuiDataType_U32 || data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)[m
[32m+[m[32m    {[m
[32m+[m[32m        // All other types assign constant[m
[32m+[m[32m        // We don't bother handling support for legacy operators since they are a little too crappy. Instead we will later implement a proper expression evaluator in the future.[m
[32m+[m[32m        sscanf(buf, format, data_ptr);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // Small types need a 32-bit buffer to receive the result from scanf()[m
[32m+[m[32m        int v32;[m
[32m+[m[32m        sscanf(buf, format, &v32);[m
[32m+[m[32m        if (data_type == ImGuiDataType_S8)[m
[32m+[m[32m            *(ImS8*)data_ptr = (ImS8)ImClamp(v32, (int)IM_S8_MIN, (int)IM_S8_MAX);[m
[32m+[m[32m        else if (data_type == ImGuiDataType_U8)[m
[32m+[m[32m            *(ImU8*)data_ptr = (ImU8)ImClamp(v32, (int)IM_U8_MIN, (int)IM_U8_MAX);[m
[32m+[m[32m        else if (data_type == ImGuiDataType_S16)[m
[32m+[m[32m            *(ImS16*)data_ptr = (ImS16)ImClamp(v32, (int)IM_S16_MIN, (int)IM_S16_MAX);[m
[32m+[m[32m        else if (data_type == ImGuiDataType_U16)[m
[32m+[m[32m            *(ImU16*)data_ptr = (ImU16)ImClamp(v32, (int)IM_U16_MIN, (int)IM_U16_MAX);[m
[32m+[m[32m        else[m
[32m+[m[32m            IM_ASSERT(0);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return memcmp(data_backup, data_ptr, type_info->Size) != 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic float GetMinimumStepAtDecimalPrecision(int decimal_precision)[m
[32m+[m[32m{[m
[32m+[m[32m    static const float min_steps[10] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f };[m
[32m+[m[32m    if (decimal_precision < 0)[m
[32m+[m[32m        return FLT_MIN;[m
[32m+[m[32m    return (decimal_precision < IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mtemplate<typename TYPE>[m
[32m+[m[32mstatic const char* ImAtoi(const char* src, TYPE* output)[m
[32m+[m[32m{[m
[32m+[m[32m    int negative = 0;[m
[32m+[m[32m    if (*src == '-') { negative = 1; src++; }[m
[32m+[m[32m    if (*src == '+') { src++; }[m
[32m+[m[32m    TYPE v = 0;[m
[32m+[m[32m    while (*src >= '0' && *src <= '9')[m
[32m+[m[32m        v = (v * 10) + (*src++ - '0');[m
[32m+[m[32m    *output = negative ? -v : v;[m
[32m+[m[32m    return src;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mtemplate<typename TYPE, typename SIGNEDTYPE>[m
[32m+[m[32mTYPE ImGui::RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, TYPE v)[m
[32m+[m[32m{[m
[32m+[m[32m    const char* fmt_start = ImParseFormatFindStart(format);[m
[32m+[m[32m    if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string[m
[32m+[m[32m        return v;[m
[32m+[m[32m    char v_str[64];[m
[32m+[m[32m    ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);[m
[32m+[m[32m    const char* p = v_str;[m
[32m+[m[32m    while (*p == ' ')[m
[32m+[m[32m        p++;[m
[32m+[m[32m    if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)[m
[32m+[m[32m        v = (TYPE)ImAtof(p);[m
[32m+[m[32m    else[m
[32m+[m[32m        ImAtoi(p, (SIGNEDTYPE*)&v);[m
[32m+[m[32m    return v;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - DragBehaviorT<>() [Internal][m
[32m+[m[32m// - DragBehavior() [Internal][m
[32m+[m[32m// - DragScalar()[m
[32m+[m[32m// - DragScalarN()[m
[32m+[m[32m// - DragFloat()[m
[32m+[m[32m// - DragFloat2()[m
[32m+[m[32m// - DragFloat3()[m
[32m+[m[32m// - DragFloat4()[m
[32m+[m[32m// - DragFloatRange2()[m
[32m+[m[32m// - DragInt()[m
[32m+[m[32m// - DragInt2()[m
[32m+[m[32m// - DragInt3()[m
[32m+[m[32m// - DragInt4()[m
[32m+[m[32m// - DragIntRange2()[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// This is called by DragBehavior() when the widget is active (held by mouse or being manipulated with Nav controls)[m
[32m+[m[32mtemplate<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>[m
[32m+[m[32mbool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiDragFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiAxis axis = (flags & ImGuiDragFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;[m
[32m+[m[32m    const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);[m
[32m+[m[32m    const bool has_min_max = (v_min != v_max);[m
[32m+[m[32m    const bool is_power = (power != 1.0f && is_decimal && has_min_max && (v_max - v_min < FLT_MAX));[m
[32m+[m
[32m+[m[32m    // Default tweak speed[m
[32m+[m[32m    if (v_speed == 0.0f && has_min_max && (v_max - v_min < FLT_MAX))[m
[32m+[m[32m        v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);[m
[32m+[m
[32m+[m[32m    // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings[m
[32m+[m[32m    float adjust_delta = 0.0f;[m
[32m+[m[32m    if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f*1.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        adjust_delta = g.IO.MouseDelta[axis];[m
[32m+[m[32m        if (g.IO.KeyAlt)[m
[32m+[m[32m            adjust_delta *= 1.0f / 100.0f;[m
[32m+[m[32m        if (g.IO.KeyShift)[m
[32m+[m[32m            adjust_delta *= 10.0f;[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (g.ActiveIdSource == ImGuiInputSource_Nav)[m
[32m+[m[32m    {[m
[32m+[m[32m        int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;[m
[32m+[m[32m        adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];[m
[32m+[m[32m        v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));[m
[32m+[m[32m    }[m
[32m+[m[32m    adjust_delta *= v_speed;[m
[32m+[m
[32m+[m[32m    // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.[m
[32m+[m[32m    if (axis == ImGuiAxis_Y)[m
[32m+[m[32m        adjust_delta = -adjust_delta;[m
[32m+[m
[32m+[m[32m    // Clear current value on activation[m
[32m+[m[32m    // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.[m
[32m+[m[32m    bool is_just_activated = g.ActiveIdIsJustActivated;[m
[32m+[m[32m    bool is_already_past_limits_and_pushing_outward = has_min_max && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));[m
[32m+[m[32m    bool is_drag_direction_change_with_power = is_power && ((adjust_delta < 0 && g.DragCurrentAccum > 0) || (adjust_delta > 0 && g.DragCurrentAccum < 0));[m
[32m+[m[32m    if (is_just_activated || is_already_past_limits_and_pushing_outward || is_drag_direction_change_with_power)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.DragCurrentAccum = 0.0f;[m
[32m+[m[32m        g.DragCurrentAccumDirty = false;[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (adjust_delta != 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        g.DragCurrentAccum += adjust_delta;[m
[32m+[m[32m        g.DragCurrentAccumDirty = true;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (!g.DragCurrentAccumDirty)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    TYPE v_cur = *v;[m
[32m+[m[32m    FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;[m
[32m+[m
[32m+[m[32m    if (is_power)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range[m
[32m+[m[32m        FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);[m
[32m+[m[32m        FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));[m
[32m+[m[32m        v_cur = v_min + (TYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);[m
[32m+[m[32m        v_old_ref_for_accum_remainder = v_old_norm_curved;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        v_cur += (TYPE)g.DragCurrentAccum;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Round to user desired precision based on format string[m
[32m+[m[32m    v_cur = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_cur);[m
[32m+[m
[32m+[m[32m    // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.[m
[32m+[m[32m    g.DragCurrentAccumDirty = false;[m
[32m+[m[32m    if (is_power)[m
[32m+[m[32m    {[m
[32m+[m[32m        FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);[m
[32m+[m[32m        g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Lose zero sign for float/double[m
[32m+[m[32m    if (v_cur == (TYPE)-0)[m
[32m+[m[32m        v_cur = (TYPE)0;[m
[32m+[m
[32m+[m[32m    // Clamp values (+ handle overflow/wrap-around for integer types)[m
[32m+[m[32m    if (*v != v_cur && has_min_max)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f && !is_decimal))[m
[32m+[m[32m            v_cur = v_min;[m
[32m+[m[32m        if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f && !is_decimal))[m
[32m+[m[32m            v_cur = v_max;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Apply result[m
[32m+[m[32m    if (*v == v_cur)[m
[32m+[m[32m        return false;[m
[32m+[m[32m    *v = v_cur;[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::DragBehavior(ImGuiID id, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power, ImGuiDragFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.ActiveId == id)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (g.ActiveIdSource == ImGuiInputSource_Mouse && !g.IO.MouseDown[0])[m
[32m+[m[32m            ClearActiveID();[m
[32m+[m[32m        else if (g.ActiveIdSource == ImGuiInputSource_Nav && g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)[m
[32m+[m[32m            ClearActiveID();[m
[32m+[m[32m    }[m
[32m+[m[32m    if (g.ActiveId != id)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    switch (data_type)[m
[32m+[m[32m    {[m
[32m+[m[32m    case ImGuiDataType_S8:     { ImS32 v32 = (ImS32)*(ImS8*)v;  bool r = DragBehaviorT<ImS32, ImS32, float >(ImGuiDataType_S32, &v32, v_speed, v_min ? *(const ImS8*) v_min : IM_S8_MIN,  v_max ? *(const ImS8*)v_max  : IM_S8_MAX,  format, power, flags); if (r) *(ImS8*)v = (ImS8)v32; return r; }[m
[32m+[m[32m    case ImGuiDataType_U8:     { ImU32 v32 = (ImU32)*(ImU8*)v;  bool r = DragBehaviorT<ImU32, ImS32, float >(ImGuiDataType_U32, &v32, v_speed, v_min ? *(const ImU8*) v_min : IM_U8_MIN,  v_max ? *(const ImU8*)v_max  : IM_U8_MAX,  format, power, flags); if (r) *(ImU8*)v = (ImU8)v32; return r; }[m
[32m+[m[32m    case ImGuiDataType_S16:    { ImS32 v32 = (ImS32)*(ImS16*)v; bool r = DragBehaviorT<ImS32, ImS32, float >(ImGuiDataType_S32, &v32, v_speed, v_min ? *(const ImS16*)v_min : IM_S16_MIN, v_max ? *(const ImS16*)v_max : IM_S16_MAX, format, power, flags); if (r) *(ImS16*)v = (ImS16)v32; return r; }[m
[32m+[m[32m    case ImGuiDataType_U16:    { ImU32 v32 = (ImU32)*(ImU16*)v; bool r = DragBehaviorT<ImU32, ImS32, float >(ImGuiDataType_U32, &v32, v_speed, v_min ? *(const ImU16*)v_min : IM_U16_MIN, v_max ? *(const ImU16*)v_max : IM_U16_MAX, format, power, flags); if (r) *(ImU16*)v = (ImU16)v32; return r; }[m
[32m+[m[32m    case ImGuiDataType_S32:    return DragBehaviorT<ImS32, ImS32, float >(data_type, (ImS32*)v,  v_speed, v_min ? *(const ImS32* )v_min : IM_S32_MIN, v_max ? *(const ImS32* )v_max : IM_S32_MAX, format, power, flags);[m
[32m+[m[32m    case ImGuiDataType_U32:    return DragBehaviorT<ImU32, ImS32, float >(data_type, (ImU32*)v,  v_speed, v_min ? *(const ImU32* )v_min : IM_U32_MIN, v_max ? *(const ImU32* )v_max : IM_U32_MAX, format, power, flags);[m
[32m+[m[32m    case ImGuiDataType_S64:    return DragBehaviorT<ImS64, ImS64, double>(data_type, (ImS64*)v,  v_speed, v_min ? *(const ImS64* )v_min : IM_S64_MIN, v_max ? *(const ImS64* )v_max : IM_S64_MAX, format, power, flags);[m
[32m+[m[32m    case ImGuiDataType_U64:    return DragBehaviorT<ImU64, ImS64, double>(data_type, (ImU64*)v,  v_speed, v_min ? *(const ImU64* )v_min : IM_U64_MIN, v_max ? *(const ImU64* )v_max : IM_U64_MAX, format, power, flags);[m
[32m+[m[32m    case ImGuiDataType_Float:  return DragBehaviorT<float, float, float >(data_type, (float*)v,  v_speed, v_min ? *(const float* )v_min : -FLT_MAX,   v_max ? *(const float* )v_max : FLT_MAX,    format, power, flags);[m
[32m+[m[32m    case ImGuiDataType_Double: return DragBehaviorT<double,double,double>(data_type, (double*)v, v_speed, v_min ? *(const double*)v_min : -DBL_MAX,   v_max ? *(const double*)v_max : DBL_MAX,    format, power, flags);[m
[32m+[m[32m    case ImGuiDataType_COUNT:  break;[m
[32m+[m[32m    }[m
[32m+[m[32m    IM_ASSERT(0);[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::DragScalar(const char* label, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    if (power != 1.0f)[m
[32m+[m[32m        IM_ASSERT(v_min != NULL && v_max != NULL); // When using a power curve the drag needs to have known bounds[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    const ImGuiID id = window->GetID(label);[m
[32m+[m[32m    const float w = GetNextItemWidth();[m
[32m+[m
[32m+[m[32m    const ImVec2 label_size = CalcTextSize(label, NULL, true);[m
[32m+[m[32m    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));[m
[32m+[m[32m    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));[m
[32m+[m
[32m+[m[32m    ItemSize(total_bb, style.FramePadding.y);[m
[32m+[m[32m    if (!ItemAdd(total_bb, id, &frame_bb))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    // Default format string when passing NULL[m
[32m+[m[32m    if (format == NULL)[m
[32m+[m[32m        format = DataTypeGetInfo(data_type)->PrintFmt;[m
[32m+[m[32m    else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.)[m
[32m+[m[32m        format = PatchFormatStringFloatToInt(format);[m
[32m+[m
[32m+[m[32m    // Tabbing or CTRL-clicking on Drag turns it into an input box[m
[32m+[m[32m    const bool hovered = ItemHoverable(frame_bb, id);[m
[32m+[m[32m    bool temp_input_is_active = TempInputTextIsActive(id);[m
[32m+[m[32m    bool temp_input_start = false;[m
[32m+[m[32m    if (!temp_input_is_active)[m
[32m+[m[32m    {[m
[32m+[m[32m        const bool focus_requested = FocusableItemRegister(window, id);[m
[32m+[m[32m        const bool clicked = (hovered && g.IO.MouseClicked[0]);[m
[32m+[m[32m        const bool double_clicked = (hovered && g.IO.MouseDoubleClicked[0]);[m
[32m+[m[32m        if (focus_requested || clicked || double_clicked || g.NavActivateId == id || g.NavInputId == id)[m
[32m+[m[32m        {[m
[32m+[m[32m            SetActiveID(id, window);[m
[32m+[m[32m            SetFocusID(id, window);[m
[32m+[m[32m            FocusWindow(window);[m
[32m+[m[32m            g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);[m
[32m+[m[32m            if (focus_requested || (clicked && g.IO.KeyCtrl) || double_clicked || g.NavInputId == id)[m
[32m+[m[32m            {[m
[32m+[m[32m                temp_input_start = true;[m
[32m+[m[32m                FocusableItemUnregister(window);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    if (temp_input_is_active || temp_input_start)[m
[32m+[m[32m        return TempInputTextScalar(frame_bb, id, label, data_type, v, format);[m
[32m+[m
[32m+[m[32m    // Draw frame[m
[32m+[m[32m    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);[m
[32m+[m[32m    RenderNavHighlight(frame_bb, id);[m
[32m+[m[32m    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);[m
[32m+[m
[32m+[m[32m    // Drag behavior[m
[32m+[m[32m    const bool value_changed = DragBehavior(id, data_type, v, v_speed, v_min, v_max, format, power, ImGuiDragFlags_None);[m
[32m+[m[32m    if (value_changed)[m
[32m+[m[32m        MarkItemEdited(id);[m
[32m+[m
[32m+[m[32m    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.[m
[32m+[m[32m    char value_buf[64];[m
[32m+[m[32m    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);[m
[32m+[m[32m    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));[m
[32m+[m
[32m+[m[32m    if (label_size.x > 0.0f)[m
[32m+[m[32m        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);[m
[32m+[m
[32m+[m[32m    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::DragScalarN(const char* label, ImGuiDataType data_type, void* v, int components, float v_speed, const void* v_min, const void* v_max, const char* format, float power)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    bool value_changed = false;[m
[32m+[m[32m    BeginGroup();[m
[32m+[m[32m    PushID(label);[m
[32m+[m[32m    PushMultiItemsWidths(components, GetNextItemWidth());[m
[32m+[m[32m    size_t type_size = GDataTypeInfo[data_type].Size;[m
[32m+[m[32m    for (int i = 0; i < components; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        PushID(i);[m
[32m+[m[32m        value_changed |= DragScalar("", data_type, v, v_speed, v_min, v_max, format, power);[m
[32m+[m[32m        SameLine(0, g.Style.ItemInnerSpacing.x);[m
[32m+[m[32m        PopID();[m
[32m+[m[32m        PopItemWidth();[m
[32m+[m[32m        v = (void*)((char*)v + type_size);[m
[32m+[m[32m    }[m
[32m+[m[32m    PopID();[m
[32m+[m
[32m+[m[32m    TextEx(label, FindRenderedTextEnd(label));[m
[32m+[m[32m    EndGroup();[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, float power)[m
[32m+[m[32m{[m
[32m+[m[32m    return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, power);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, float power)[m
[32m+[m[32m{[m
[32m+[m[32m    return DragScalarN(label, ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, power);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, float power)[m
[32m+[m[32m{[m
[32m+[m[32m    return DragScalarN(label, ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, power);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* format, float power)[m
[32m+[m[32m{[m
[32m+[m[32m    return DragScalarN(label, ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, power);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* format, const char* format_max, float power)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    PushID(label);[m
[32m+[m[32m    BeginGroup();[m
[32m+[m[32m    PushMultiItemsWidths(2, GetNextItemWidth());[m
[32m+[m
[32m+[m[32m    bool value_changed = DragFloat("##min", v_current_min, v_speed, (v_min >= v_max) ? -FLT_MAX : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), format, power);[m
[32m+[m[32m    PopItemWidth();[m
[32m+[m[32m    SameLine(0, g.Style.ItemInnerSpacing.x);[m
[32m+[m[32m    value_changed |= DragFloat("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? FLT_MAX : v_max, format_max ? format_max : format, power);[m
[32m+[m[32m    PopItemWidth();[m
[32m+[m[32m    SameLine(0, g.Style.ItemInnerSpacing.x);[m
[32m+[m
[32m+[m[32m    TextEx(label, FindRenderedTextEnd(label));[m
[32m+[m[32m    EndGroup();[m
[32m+[m[32m    PopID();[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// NB: v_speed is float to allow adjusting the drag speed with more precision[m
[32m+[m[32mbool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* format)[m
[32m+[m[32m{[m
[32m+[m[32m    return DragScalar(label, ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* format)[m
[32m+[m[32m{[m
[32m+[m[32m    return DragScalarN(label, ImGuiDataType_S32, v, 2, v_speed, &v_min, &v_max, format);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* format)[m
[32m+[m[32m{[m
[32m+[m[32m    return DragScalarN(label, ImGuiDataType_S32, v, 3, v_speed, &v_min, &v_max, format);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* format)[m
[32m+[m[32m{[m
[32m+[m[32m    return DragScalarN(label, ImGuiDataType_S32, v, 4, v_speed, &v_min, &v_max, format);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* format, const char* format_max)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    PushID(label);[m
[32m+[m[32m    BeginGroup();[m
[32m+[m[32m    PushMultiItemsWidths(2, GetNextItemWidth());[m
[32m+[m
[32m+[m[32m    bool value_changed = DragInt("##min", v_current_min, v_speed, (v_min >= v_max) ? INT_MIN : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), format);[m
[32m+[m[32m    PopItemWidth();[m
[32m+[m[32m    SameLine(0, g.Style.ItemInnerSpacing.x);[m
[32m+[m[32m    value_changed |= DragInt("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? INT_MAX : v_max, format_max ? format_max : format);[m
[32m+[m[32m    PopItemWidth();[m
[32m+[m[32m    SameLine(0, g.Style.ItemInnerSpacing.x);[m
[32m+[m
[32m+[m[32m    TextEx(label, FindRenderedTextEnd(label));[m
[32m+[m[32m    EndGroup();[m
[32m+[m[32m    PopID();[m
[32m+[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - SliderBehaviorT<>() [Internal][m
[32m+[m[32m// - SliderBehavior() [Internal][m
[32m+[m[32m// - SliderScalar()[m
[32m+[m[32m// - SliderScalarN()[m
[32m+[m[32m// - SliderFloat()[m
[32m+[m[32m// - SliderFloat2()[m
[32m+[m[32m// - SliderFloat3()[m
[32m+[m[32m// - SliderFloat4()[m
[32m+[m[32m// - SliderAngle()[m
[32m+[m[32m// - SliderInt()[m
[32m+[m[32m// - SliderInt2()[m
[32m+[m[32m// - SliderInt3()[m
[32m+[m[32m// - SliderInt4()[m
[32m+[m[32m// - VSliderScalar()[m
[32m+[m[32m// - VSliderFloat()[m
[32m+[m[32m// - VSliderInt()[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mtemplate<typename TYPE, typename FLOATTYPE>[m
[32m+[m[32mfloat ImGui::SliderCalcRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, float power, float linear_zero_pos)[m
[32m+[m[32m{[m
[32m+[m[32m    if (v_min == v_max)[m
[32m+[m[32m        return 0.0f;[m
[32m+[m
[32m+[m[32m    const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);[m
[32m+[m[32m    const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);[m
[32m+[m[32m    if (is_power)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (v_clamped < 0.0f)[m
[32m+[m[32m        {[m
[32m+[m[32m            const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));[m
[32m+[m[32m            return (1.0f - ImPow(f, 1.0f/power)) * linear_zero_pos;[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));[m
[32m+[m[32m            return linear_zero_pos + ImPow(f, 1.0f/power) * (1.0f - linear_zero_pos);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Linear slider[m
[32m+[m[32m    return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// FIXME: Move some of the code into SliderBehavior(). Current responsability is larger than what the equivalent DragBehaviorT<> does, we also do some rendering, etc.[m
[32m+[m[32mtemplate<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>[m
[32m+[m[32mbool ImGui::SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m
[32m+[m[32m    const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;[m
[32m+[m[32m    const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);[m
[32m+[m[32m    const bool is_power = (power != 1.0f) && is_decimal;[m
[32m+[m
[32m+[m[32m    const float grab_padding = 2.0f;[m
[32m+[m[32m    const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;[m
[32m+[m[32m    float grab_sz = style.GrabMinSize;[m
[32m+[m[32m    SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);[m
[32m+[m[32m    if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows[m
[32m+[m[32m        grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit[m
[32m+[m[32m    grab_sz = ImMin(grab_sz, slider_sz);[m
[32m+[m[32m    const float slider_usable_sz = slider_sz - grab_sz;[m
[32m+[m[32m    const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;[m
[32m+[m[32m    const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;[m
[32m+[m
[32m+[m[32m    // For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f[m
[32m+[m[32m    float linear_zero_pos;   // 0.0->1.0f[m
[32m+[m[32m    if (is_power && v_min * v_max < 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Different sign[m
[32m+[m[32m        const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f / power);[m
[32m+[m[32m        const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f / power);[m
[32m+[m[32m        linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // Same sign[m
[32m+[m[32m        linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Process interacting with the slider[m
[32m+[m[32m    bool value_changed = false;[m
[32m+[m[32m    if (g.ActiveId == id)[m
[32m+[m[32m    {[m
[32m+[m[32m        bool set_new_value = false;[m
[32m+[m[32m        float clicked_t = 0.0f;[m
[32m+[m[32m        if (g.ActiveIdSource == ImGuiInputSource_Mouse)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (!g.IO.MouseDown[0])[m
[32m+[m[32m            {[m
[32m+[m[32m                ClearActiveID();[m
[32m+[m[32m            }[m
[32m+[m[32m            else[m
[32m+[m[32m            {[m
[32m+[m[32m                const float mouse_abs_pos = g.IO.MousePos[axis];[m
[32m+[m[32m                clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;[m
[32m+[m[32m                if (axis == ImGuiAxis_Y)[m
[32m+[m[32m                    clicked_t = 1.0f - clicked_t;[m
[32m+[m[32m                set_new_value = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (g.ActiveIdSource == ImGuiInputSource_Nav)[m
[32m+[m[32m        {[m
[32m+[m[32m            const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);[m
[32m+[m[32m            float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;[m
[32m+[m[32m            if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)[m
[32m+[m[32m            {[m
[32m+[m[32m                ClearActiveID();[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (delta != 0.0f)[m
[32m+[m[32m            {[m
[32m+[m[32m                clicked_t = SliderCalcRatioFromValueT<TYPE,FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);[m
[32m+[m[32m                const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;[m
[32m+[m[32m                if ((decimal_precision > 0) || is_power)[m
[32m+[m[32m                {[m
[32m+[m[32m                    delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds[m
[32m+[m[32m                    if (IsNavInputDown(ImGuiNavInput_TweakSlow))[m
[32m+[m[32m                        delta /= 10.0f;[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))[m
[32m+[m[32m                        delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps[m
[32m+[m[32m                    else[m
[32m+[m[32m                        delta /= 100.0f;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (IsNavInputDown(ImGuiNavInput_TweakFast))[m
[32m+[m[32m                    delta *= 10.0f;[m
[32m+[m[32m                set_new_value = true;[m
[32m+[m[32m                if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits[m
[32m+[m[32m                    set_new_value = false;[m
[32m+[m[32m                else[m
[32m+[m[32m                    clicked_t = ImSaturate(clicked_t + delta);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (set_new_value)[m
[32m+[m[32m        {[m
[32m+[m[32m            TYPE v_new;[m
[32m+[m[32m            if (is_power)[m
[32m+[m[32m            {[m
[32m+[m[32m                // Account for power curve scale on both sides of the zero[m
[32m+[m[32m                if (clicked_t < linear_zero_pos)[m
[32m+[m[32m                {[m
[32m+[m[32m                    // Negative: rescale to the negative range before powering[m
[32m+[m[32m                    float a = 1.0f - (clicked_t / linear_zero_pos);[m
[32m+[m[32m                    a = ImPow(a, power);[m
[32m+[m[32m                    v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    // Positive: rescale to the positive range before powering[m
[32m+[m[32m                    float a;[m
[32m+[m[32m                    if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)[m
[32m+[m[32m                        a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);[m
[32m+[m[32m                    else[m
[32m+[m[32m                        a = clicked_t;[m
[32m+[m[32m                    a = ImPow(a, power);[m
[32m+[m[32m                    v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            else[m
[32m+[m[32m            {[m
[32m+[m[32m                // Linear slider[m
[32m+[m[32m                if (is_decimal)[m
[32m+[m[32m                {[m
[32m+[m[32m                    v_new = ImLerp(v_min, v_max, clicked_t);[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    // For integer values we want the clicking position to match the grab box so we round above[m
[32m+[m[32m                    // This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..[m
[32m+[m[32m                    FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;[m
[32m+[m[32m                    TYPE v_new_off_floor = (TYPE)(v_new_off_f);[m
[32m+[m[32m                    TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);[m
[32m+[m[32m                    if (!is_decimal && v_new_off_floor < v_new_off_round)[m
[32m+[m[32m                        v_new = v_min + v_new_off_round;[m
[32m+[m[32m                    else[m
[32m+[m[32m                        v_new = v_min + v_new_off_floor;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Round to user desired precision based on format string[m
[32m+[m[32m            v_new = RoundScalarWithFormatT<TYPE,SIGNEDTYPE>(format, data_type, v_new);[m
[32m+[m
[32m+[m[32m            // Apply result[m
[32m+[m[32m            if (*v != v_new)[m
[32m+[m[32m            {[m
[32m+[m[32m                *v = v_new;[m
[32m+[m[32m                value_changed = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (slider_sz < 1.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        *out_grab_bb = ImRect(bb.Min, bb.Min);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // Output grab position so it can be displayed by the caller[m
[32m+[m[32m        float grab_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);[m
[32m+[m[32m        if (axis == ImGuiAxis_Y)[m
[32m+[m[32m            grab_t = 1.0f - grab_t;[m
[32m+[m[32m        const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);[m
[32m+[m[32m        if (axis == ImGuiAxis_X)[m
[32m+[m[32m            *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);[m
[32m+[m[32m        else[m
[32m+[m[32m            *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// For 32-bits and larger types, slider bounds are limited to half the natural type range.[m
[32m+[m[32m// So e.g. an integer Slider between INT_MAX-10 and INT_MAX will fail, but an integer Slider between INT_MAX/2-10 and INT_MAX/2 will be ok.[m
[32m+[m[32m// It would be possible to lift that limitation with some work but it doesn't seem to be worth it for sliders.[m
[32m+[m[32mbool ImGui::SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb)[m
[32m+[m[32m{[m
[32m+[m[32m    switch (data_type)[m
[32m+[m[32m    {[m
[32m+[m[32m    case ImGuiDataType_S8:  { ImS32 v32 = (ImS32)*(ImS8*)v;  bool r = SliderBehaviorT<ImS32, ImS32, float >(bb, id, ImGuiDataType_S32, &v32, *(const ImS8*)v_min,  *(const ImS8*)v_max,  format, power, flags, out_grab_bb); if (r) *(ImS8*)v  = (ImS8)v32;  return r; }[m
[32m+[m[32m    case ImGuiDataType_U8:  { ImU32 v32 = (ImU32)*(ImU8*)v;  bool r = SliderBehaviorT<ImU32, ImS32, float >(bb, id, ImGuiDataType_U32, &v32, *(const ImU8*)v_min,  *(const ImU8*)v_max,  format, power, flags, out_grab_bb); if (r) *(ImU8*)v  = (ImU8)v32;  return r; }[m
[32m+[m[32m    case ImGuiDataType_S16: { ImS32 v32 = (ImS32)*(ImS16*)v; bool r = SliderBehaviorT<ImS32, ImS32, float >(bb, id, ImGuiDataType_S32, &v32, *(const ImS16*)v_min, *(const ImS16*)v_max, format, power, flags, out_grab_bb); if (r) *(ImS16*)v = (ImS16)v32; return r; }[m
[32m+[m[32m    case ImGuiDataType_U16: { ImU32 v32 = (ImU32)*(ImU16*)v; bool r = SliderBehaviorT<ImU32, ImS32, float >(bb, id, ImGuiDataType_U32, &v32, *(const ImU16*)v_min, *(const ImU16*)v_max, format, power, flags, out_grab_bb); if (r) *(ImU16*)v = (ImU16)v32; return r; }[m
[32m+[m[32m    case ImGuiDataType_S32:[m
[32m+[m[32m        IM_ASSERT(*(const ImS32*)v_min >= IM_S32_MIN/2 && *(const ImS32*)v_max <= IM_S32_MAX/2);[m
[32m+[m[32m        return SliderBehaviorT<ImS32, ImS32, float >(bb, id, data_type, (ImS32*)v,  *(const ImS32*)v_min,  *(const ImS32*)v_max,  format, power, flags, out_grab_bb);[m
[32m+[m[32m    case ImGuiDataType_U32:[m
[32m+[m[32m        IM_ASSERT(*(const ImU32*)v_min <= IM_U32_MAX/2);[m
[32m+[m[32m        return SliderBehaviorT<ImU32, ImS32, float >(bb, id, data_type, (ImU32*)v,  *(const ImU32*)v_min,  *(const ImU32*)v_max,  format, power, flags, out_grab_bb);[m
[32m+[m[32m    case ImGuiDataType_S64:[m
[32m+[m[32m        IM_ASSERT(*(const ImS64*)v_min >= IM_S64_MIN/2 && *(const ImS64*)v_max <= IM_S64_MAX/2);[m
[32m+[m[32m        return SliderBehaviorT<ImS64, ImS64, double>(bb, id, data_type, (ImS64*)v,  *(const ImS64*)v_min,  *(const ImS64*)v_max,  format, power, flags, out_grab_bb);[m
[32m+[m[32m    case ImGuiDataType_U64:[m
[32m+[m[32m        IM_ASSERT(*(const ImU64*)v_min <= IM_U64_MAX/2);[m
[32m+[m[32m        return SliderBehaviorT<ImU64, ImS64, double>(bb, id, data_type, (ImU64*)v,  *(const ImU64*)v_min,  *(const ImU64*)v_max,  format, power, flags, out_grab_bb);[m
[32m+[m[32m    case ImGuiDataType_Float:[m
[32m+[m[32m        IM_ASSERT(*(const float*)v_min >= -FLT_MAX/2.0f && *(const float*)v_max <= FLT_MAX/2.0f);[m
[32m+[m[32m        return SliderBehaviorT<float, float, float >(bb, id, data_type, (float*)v,  *(const float*)v_min,  *(const float*)v_max,  format, power, flags, out_grab_bb);[m
[32m+[m[32m    case ImGuiDataType_Double:[m
[32m+[m[32m        IM_ASSERT(*(const double*)v_min >= -DBL_MAX/2.0f && *(const double*)v_max <= DBL_MAX/2.0f);[m
[32m+[m[32m        return SliderBehaviorT<double,double,double>(bb, id, data_type, (double*)v, *(const double*)v_min, *(const double*)v_max, format, power, flags, out_grab_bb);[m
[32m+[m[32m    case ImGuiDataType_COUNT: break;[m
[32m+[m[32m    }[m
[32m+[m[32m    IM_ASSERT(0);[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::SliderScalar(const char* label, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    const ImGuiID id = window->GetID(label);[m
[32m+[m[32m    const float w = GetNextItemWidth();[m
[32m+[m
[32m+[m[32m    const ImVec2 label_size = CalcTextSize(label, NULL, true);[m
[32m+[m[32m    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));[m
[32m+[m[32m    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));[m
[32m+[m
[32m+[m[32m    ItemSize(total_bb, style.FramePadding.y);[m
[32m+[m[32m    if (!ItemAdd(total_bb, id, &frame_bb))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    // Default format string when passing NULL[m
[32m+[m[32m    if (format == NULL)[m
[32m+[m[32m        format = DataTypeGetInfo(data_type)->PrintFmt;[m
[32m+[m[32m    else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.)[m
[32m+[m[32m        format = PatchFormatStringFloatToInt(format);[m
[32m+[m
[32m+[m[32m    // Tabbing or CTRL-clicking on Slider turns it into an input box[m
[32m+[m[32m    const bool hovered = ItemHoverable(frame_bb, id);[m
[32m+[m[32m    bool temp_input_is_active = TempInputTextIsActive(id);[m
[32m+[m[32m    bool temp_input_start = false;[m
[32m+[m[32m    if (!temp_input_is_active)[m
[32m+[m[32m    {[m
[32m+[m[32m        const bool focus_requested = FocusableItemRegister(window, id);[m
[32m+[m[32m        const bool clicked = (hovered && g.IO.MouseClicked[0]);[m
[32m+[m[32m        if (focus_requested || clicked || g.NavActivateId == id || g.NavInputId == id)[m
[32m+[m[32m        {[m
[32m+[m[32m            SetActiveID(id, window);[m
[32m+[m[32m            SetFocusID(id, window);[m
[32m+[m[32m            FocusWindow(window);[m
[32m+[m[32m            g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);[m
[32m+[m[32m            if (focus_requested || (clicked && g.IO.KeyCtrl) || g.NavInputId == id)[m
[32m+[m[32m            {[m
[32m+[m[32m                temp_input_start = true;[m
[32m+[m[32m                FocusableItemUnregister(window);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    if (temp_input_is_active || temp_input_start)[m
[32m+[m[32m        return TempInputTextScalar(frame_bb, id, label, data_type, v, format);[m
[32m+[m
[32m+[m[32m    // Draw frame[m
[32m+[m[32m    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);[m
[32m+[m[32m    RenderNavHighlight(frame_bb, id);[m
[32m+[m[32m    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);[m
[32m+[m
[32m+[m[32m    // Slider behavior[m
[32m+[m[32m    ImRect grab_bb;[m
[32m+[m[32m    const bool value_changed = SliderBehavior(frame_bb, id, data_type, v, v_min, v_max, format, power, ImGuiSliderFlags_None, &grab_bb);[m
[32m+[m[32m    if (value_changed)[m
[32m+[m[32m        MarkItemEdited(id);[m
[32m+[m
[32m+[m[32m    // Render grab[m
[32m+[m[32m    if (grab_bb.Max.x > grab_bb.Min.x)[m
[32m+[m[32m        window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);[m
[32m+[m
[32m+[m[32m    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.[m
[32m+[m[32m    char value_buf[64];[m
[32m+[m[32m    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);[m
[32m+[m[32m    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.5f));[m
[32m+[m
[32m+[m[32m    if (label_size.x > 0.0f)[m
[32m+[m[32m        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);[m
[32m+[m
[32m+[m[32m    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Add multiple sliders on 1 line for compact edition of multiple components[m
[32m+[m[32mbool ImGui::SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format, float power)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    bool value_changed = false;[m
[32m+[m[32m    BeginGroup();[m
[32m+[m[32m    PushID(label);[m
[32m+[m[32m    PushMultiItemsWidths(components, GetNextItemWidth());[m
[32m+[m[32m    size_t type_size = GDataTypeInfo[data_type].Size;[m
[32m+[m[32m    for (int i = 0; i < components; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        PushID(i);[m
[32m+[m[32m        value_changed |= SliderScalar("", data_type, v, v_min, v_max, format, power);[m
[32m+[m[32m        SameLine(0, g.Style.ItemInnerSpacing.x);[m
[32m+[m[32m        PopID();[m
[32m+[m[32m        PopItemWidth();[m
[32m+[m[32m        v = (void*)((char*)v + type_size);[m
[32m+[m[32m    }[m
[32m+[m[32m    PopID();[m
[32m+[m
[32m+[m[32m    TextEx(label, FindRenderedTextEnd(label));[m
[32m+[m[32m    EndGroup();[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format, float power)[m
[32m+[m[32m{[m
[32m+[m[32m    return SliderScalar(label, ImGuiDataType_Float, v, &v_min, &v_max, format, power);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, float power)[m
[32m+[m[32m{[m
[32m+[m[32m    return SliderScalarN(label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, power);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, float power)[m
[32m+[m[32m{[m
[32m+[m[32m    return SliderScalarN(label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, power);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, float power)[m
[32m+[m[32m{[m
[32m+[m[32m    return SliderScalarN(label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, power);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max, const char* format)[m
[32m+[m[32m{[m
[32m+[m[32m    if (format == NULL)[m
[32m+[m[32m        format = "%.0f deg";[m
[32m+[m[32m    float v_deg = (*v_rad) * 360.0f / (2*IM_PI);[m
[32m+[m[32m    bool value_changed = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, format, 1.0f);[m
[32m+[m[32m    *v_rad = v_deg * (2*IM_PI) / 360.0f;[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* format)[m
[32m+[m[32m{[m
[32m+[m[32m    return SliderScalar(label, ImGuiDataType_S32, v, &v_min, &v_max, format);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format)[m
[32m+[m[32m{[m
[32m+[m[32m    return SliderScalarN(label, ImGuiDataType_S32, v, 2, &v_min, &v_max, format);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format)[m
[32m+[m[32m{[m
[32m+[m[32m    return SliderScalarN(label, ImGuiDataType_S32, v, 3, &v_min, &v_max, format);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format)[m
[32m+[m[32m{[m
[32m+[m[32m    return SliderScalarN(label, ImGuiDataType_S32, v, 4, &v_min, &v_max, format);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    const ImGuiID id = window->GetID(label);[m
[32m+[m
[32m+[m[32m    const ImVec2 label_size = CalcTextSize(label, NULL, true);[m
[32m+[m[32m    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);[m
[32m+[m[32m    const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));[m
[32m+[m
[32m+[m[32m    ItemSize(bb, style.FramePadding.y);[m
[32m+[m[32m    if (!ItemAdd(frame_bb, id))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    // Default format string when passing NULL[m
[32m+[m[32m    if (format == NULL)[m
[32m+[m[32m        format = DataTypeGetInfo(data_type)->PrintFmt;[m
[32m+[m[32m    else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.)[m
[32m+[m[32m        format = PatchFormatStringFloatToInt(format);[m
[32m+[m
[32m+[m[32m    const bool hovered = ItemHoverable(frame_bb, id);[m
[32m+[m[32m    if ((hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || g.NavInputId == id)[m
[32m+[m[32m    {[m
[32m+[m[32m        SetActiveID(id, window);[m
[32m+[m[32m        SetFocusID(id, window);[m
[32m+[m[32m        FocusWindow(window);[m
[32m+[m[32m        g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Draw frame[m
[32m+[m[32m    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);[m
[32m+[m[32m    RenderNavHighlight(frame_bb, id);[m
[32m+[m[32m    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);[m
[32m+[m
[32m+[m[32m    // Slider behavior[m
[32m+[m[32m    ImRect grab_bb;[m
[32m+[m[32m    const bool value_changed = SliderBehavior(frame_bb, id, data_type, v, v_min, v_max, format, power, ImGuiSliderFlags_Vertical, &grab_bb);[m
[32m+[m[32m    if (value_changed)[m
[32m+[m[32m        MarkItemEdited(id);[m
[32m+[m
[32m+[m[32m    // Render grab[m
[32m+[m[32m    if (grab_bb.Max.y > grab_bb.Min.y)[m
[32m+[m[32m        window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);[m
[32m+[m
[32m+[m[32m    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.[m
[32m+[m[32m    // For the vertical slider we allow centered text to overlap the frame padding[m
[32m+[m[32m    char value_buf[64];[m
[32m+[m[32m    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);[m
[32m+[m[32m    RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.0f));[m
[32m+[m[32m    if (label_size.x > 0.0f)[m
[32m+[m[32m        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);[m
[32m+[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format, float power)[m
[32m+[m[32m{[m
[32m+[m[32m    return VSliderScalar(label, size, ImGuiDataType_Float, v, &v_min, &v_max, format, power);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format)[m
[32m+[m[32m{[m
[32m+[m[32m    return VSliderScalar(label, size, ImGuiDataType_S32, v, &v_min, &v_max, format);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - ImParseFormatFindStart() [Internal][m
[32m+[m[32m// - ImParseFormatFindEnd() [Internal][m
[32m+[m[32m// - ImParseFormatTrimDecorations() [Internal][m
[32m+[m[32m// - ImParseFormatPrecision() [Internal][m
[32m+[m[32m// - TempInputTextScalar() [Internal][m
[32m+[m[32m// - InputScalar()[m
[32m+[m[32m// - InputScalarN()[m
[32m+[m[32m// - InputFloat()[m
[32m+[m[32m// - InputFloat2()[m
[32m+[m[32m// - InputFloat3()[m
[32m+[m[32m// - InputFloat4()[m
[32m+[m[32m// - InputInt()[m
[32m+[m[32m// - InputInt2()[m
[32m+[m[32m// - InputInt3()[m
[32m+[m[32m// - InputInt4()[m
[32m+[m[32m// - InputDouble()[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// We don't use strchr() because our strings are usually very short and often start with '%'[m
[32m+[m[32mconst char* ImParseFormatFindStart(const char* fmt)[m
[32m+[m[32m{[m
[32m+[m[32m    while (char c = fmt[0])[m
[32m+[m[32m    {[m
[32m+[m[32m        if (c == '%' && fmt[1] != '%')[m
[32m+[m[32m            return fmt;[m
[32m+[m[32m        else if (c == '%')[m
[32m+[m[32m            fmt++;[m
[32m+[m[32m        fmt++;[m
[32m+[m[32m    }[m
[32m+[m[32m    return fmt;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst char* ImParseFormatFindEnd(const char* fmt)[m
[32m+[m[32m{[m
[32m+[m[32m    // Printf/scanf types modifiers: I/L/h/j/l/t/w/z. Other uppercase letters qualify as types aka end of the format.[m
[32m+[m[32m    if (fmt[0] != '%')[m
[32m+[m[32m        return fmt;[m
[32m+[m[32m    const unsigned int ignored_uppercase_mask = (1 << ('I'-'A')) | (1 << ('L'-'A'));[m
[32m+[m[32m    const unsigned int ignored_lowercase_mask = (1 << ('h'-'a')) | (1 << ('j'-'a')) | (1 << ('l'-'a')) | (1 << ('t'-'a')) | (1 << ('w'-'a')) | (1 << ('z'-'a'));[m
[32m+[m[32m    for (char c; (c = *fmt) != 0; fmt++)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (c >= 'A' && c <= 'Z' && ((1 << (c - 'A')) & ignored_uppercase_mask) == 0)[m
[32m+[m[32m            return fmt + 1;[m
[32m+[m[32m        if (c >= 'a' && c <= 'z' && ((1 << (c - 'a')) & ignored_lowercase_mask) == 0)[m
[32m+[m[32m            return fmt + 1;[m
[32m+[m[32m    }[m
[32m+[m[32m    return fmt;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Extract the format out of a format string with leading or trailing decorations[m
[32m+[m[32m//  fmt = "blah blah"  -> return fmt[m
[32m+[m[32m//  fmt = "%.3f"       -> return fmt[m
[32m+[m[32m//  fmt = "hello %.3f" -> return fmt + 6[m
[32m+[m[32m//  fmt = "%.3f hello" -> return buf written with "%.3f"[m
[32m+[m[32mconst char* ImParseFormatTrimDecorations(const char* fmt, char* buf, size_t buf_size)[m
[32m+[m[32m{[m
[32m+[m[32m    const char* fmt_start = ImParseFormatFindStart(fmt);[m
[32m+[m[32m    if (fmt_start[0] != '%')[m
[32m+[m[32m        return fmt;[m
[32m+[m[32m    const char* fmt_end = ImParseFormatFindEnd(fmt_start);[m
[32m+[m[32m    if (fmt_end[0] == 0) // If we only have leading decoration, we don't need to copy the data.[m
[32m+[m[32m        return fmt_start;[m
[32m+[m[32m    ImStrncpy(buf, fmt_start, ImMin((size_t)(fmt_end - fmt_start) + 1, buf_size));[m
[32m+[m[32m    return buf;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Parse display precision back from the display format string[m
[32m+[m[32m// FIXME: This is still used by some navigation code path to infer a minimum tweak step, but we should aim to rework widgets so it isn't needed.[m
[32m+[m[32mint ImParseFormatPrecision(const char* fmt, int default_precision)[m
[32m+[m[32m{[m
[32m+[m[32m    fmt = ImParseFormatFindStart(fmt);[m
[32m+[m[32m    if (fmt[0] != '%')[m
[32m+[m[32m        return default_precision;[m
[32m+[m[32m    fmt++;[m
[32m+[m[32m    while (*fmt >= '0' && *fmt <= '9')[m
[32m+[m[32m        fmt++;[m
[32m+[m[32m    int precision = INT_MAX;[m
[32m+[m[32m    if (*fmt == '.')[m
[32m+[m[32m    {[m
[32m+[m[32m        fmt = ImAtoi<int>(fmt + 1, &precision);[m
[32m+[m[32m        if (precision < 0 || precision > 99)[m
[32m+[m[32m            precision = default_precision;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (*fmt == 'e' || *fmt == 'E') // Maximum precision with scientific notation[m
[32m+[m[32m        precision = -1;[m
[32m+[m[32m    if ((*fmt == 'g' || *fmt == 'G') && precision == INT_MAX)[m
[32m+[m[32m        precision = -1;[m
[32m+[m[32m    return (precision == INT_MAX) ? default_precision : precision;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Create text input in place of another active widget (e.g. used when doing a CTRL+Click on drag/slider widgets)[m
[32m+[m[32m// FIXME: Facilitate using this in variety of other situations.[m
[32m+[m[32mbool ImGui::TempInputTextScalar(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* data_ptr, const char* format)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    // On the first frame, g.TempInputTextId == 0, then on subsequent frames it becomes == id.[m
[32m+[m[32m    // We clear ActiveID on the first frame to allow the InputText() taking it back.[m
[32m+[m[32m    const bool init = (g.TempInputTextId != id);[m
[32m+[m[32m    if (init)[m
[32m+[m[32m        ClearActiveID();[m
[32m+[m
[32m+[m[32m    char fmt_buf[32];[m
[32m+[m[32m    char data_buf[32];[m
[32m+[m[32m    format = ImParseFormatTrimDecorations(format, fmt_buf, IM_ARRAYSIZE(fmt_buf));[m
[32m+[m[32m    DataTypeFormatString(data_buf, IM_ARRAYSIZE(data_buf), data_type, data_ptr, format);[m
[32m+[m[32m    ImStrTrimBlanks(data_buf);[m
[32m+[m
[32m+[m[32m    g.CurrentWindow->DC.CursorPos = bb.Min;[m
[32m+[m[32m    ImGuiInputTextFlags flags = ImGuiInputTextFlags_AutoSelectAll | ((data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double) ? ImGuiInputTextFlags_CharsScientific : ImGuiInputTextFlags_CharsDecimal);[m
[32m+[m[32m    bool value_changed = InputTextEx(label, NULL, data_buf, IM_ARRAYSIZE(data_buf), bb.GetSize(), flags);[m
[32m+[m[32m    if (init)[m
[32m+[m[32m    {[m
[32m+[m[32m        // First frame we started displaying the InputText widget, we expect it to take the active id.[m
[32m+[m[32m        IM_ASSERT(g.ActiveId == id);[m
[32m+[m[32m        g.TempInputTextId = g.ActiveId;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (value_changed)[m
[32m+[m[32m        return DataTypeApplyOpFromText(data_buf, g.InputTextState.InitialTextA.Data, data_type, data_ptr, NULL);[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::InputScalar(const char* label, ImGuiDataType data_type, void* data_ptr, const void* step, const void* step_fast, const char* format, ImGuiInputTextFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiStyle& style = g.Style;[m
[32m+[m
[32m+[m[32m    if (format == NULL)[m
[32m+[m[32m        format = DataTypeGetInfo(data_type)->PrintFmt;[m
[32m+[m
[32m+[m[32m    char buf[64];[m
[32m+[m[32m    DataTypeFormatString(buf, IM_ARRAYSIZE(buf), data_type, data_ptr, format);[m
[32m+[m
[32m+[m[32m    bool value_changed = false;[m
[32m+[m[32m    if ((flags & (ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsScientific)) == 0)[m
[32m+[m[32m        flags |= ImGuiInputTextFlags_CharsDecimal;[m
[32m+[m[32m    flags |= ImGuiInputTextFlags_AutoSelectAll;[m
[32m+[m
[32m+[m[32m    if (step != NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        const float button_size = GetFrameHeight();[m
[32m+[m
[32m+[m[32m        BeginGroup(); // The only purpose of the group here is to allow the caller to query item data e.g. IsItemActive()[m
[32m+[m[32m        PushID(label);[m
[32m+[m[32m        SetNextItemWidth(ImMax(1.0f, GetNextItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));[m
[32m+[m[32m        if (InputText("", buf, IM_ARRAYSIZE(buf), flags)) // PushId(label) + "" gives us the expected ID from outside point of view[m
[32m+[m[32m            value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialTextA.Data, data_type, data_ptr, format);[m
[32m+[m
[32m+[m[32m        // Step buttons[m
[32m+[m[32m        const ImVec2 backup_frame_padding = style.FramePadding;[m
[32m+[m[32m        style.FramePadding.x = style.FramePadding.y;[m
[32m+[m[32m        ImGuiButtonFlags button_flags = ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups;[m
[32m+[m[32m        if (flags & ImGuiInputTextFlags_ReadOnly)[m
[32m+[m[32m            button_flags |= ImGuiButtonFlags_Disabled;[m
[32m+[m[32m        SameLine(0, style.ItemInnerSpacing.x);[m
[32m+[m[32m        if (ButtonEx("-", ImVec2(button_size, button_size), button_flags))[m
[32m+[m[32m        {[m
[32m+[m[32m            DataTypeApplyOp(data_type, '-', data_ptr, data_ptr, g.IO.KeyCtrl && step_fast ? step_fast : step);[m
[32m+[m[32m            value_changed = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        SameLine(0, style.ItemInnerSpacing.x);[m
[32m+[m[32m        if (ButtonEx("+", ImVec2(button_size, button_size), button_flags))[m
[32m+[m[32m        {[m
[32m+[m[32m            DataTypeApplyOp(data_type, '+', data_ptr, data_ptr, g.IO.KeyCtrl && step_fast ? step_fast : step);[m
[32m+[m[32m            value_changed = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        SameLine(0, style.ItemInnerSpacing.x);[m
[32m+[m[32m        TextEx(label, FindRenderedTextEnd(label));[m
[32m+[m[32m        style.FramePadding = backup_frame_padding;[m
[32m+[m
[32m+[m[32m        PopID();[m
[32m+[m[32m        EndGroup();[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        if (InputText(label, buf, IM_ARRAYSIZE(buf), flags))[m
[32m+[m[32m            value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialTextA.Data, data_type, data_ptr, format);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::InputScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* step, const void* step_fast, const char* format, ImGuiInputTextFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    bool value_changed = false;[m
[32m+[m[32m    BeginGroup();[m
[32m+[m[32m    PushID(label);[m
[32m+[m[32m    PushMultiItemsWidths(components, GetNextItemWidth());[m
[32m+[m[32m    size_t type_size = GDataTypeInfo[data_type].Size;[m
[32m+[m[32m    for (int i = 0; i < components; i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        PushID(i);[m
[32m+[m[32m        value_changed |= InputScalar("", data_type, v, step, step_fast, format, flags);[m
[32m+[m[32m        SameLine(0, g.Style.ItemInnerSpacing.x);[m
[32m+[m[32m        PopID();[m
[32m+[m[32m        PopItemWidth();[m
[32m+[m[32m        v = (void*)((char*)v + type_size);[m
[32m+[m[32m    }[m
[32m+[m[32m    PopID();[m
[32m+[m
[32m+[m[32m    TextEx(label, FindRenderedTextEnd(label));[m
[32m+[m[32m    EndGroup();[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, const char* format, ImGuiInputTextFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    flags |= ImGuiInputTextFlags_CharsScientific;[m
[32m+[m[32m    return InputScalar(label, ImGuiDataType_Float, (void*)v, (void*)(step>0.0f ? &step : NULL), (void*)(step_fast>0.0f ? &step_fast : NULL), format, flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::InputFloat2(const char* label, float v[2], const char* format, ImGuiInputTextFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::InputFloat3(const char* label, float v[3], const char* format, ImGuiInputTextFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::InputFloat4(const char* label, float v[4], const char* format, ImGuiInputTextFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Prefer using "const char* format" directly, which is more flexible and consistent with other API.[m
[32m+[m[32m#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m[32mbool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    char format[16] = "%f";[m
[32m+[m[32m    if (decimal_precision >= 0)[m
[32m+[m[32m        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);[m
[32m+[m[32m    return InputFloat(label, v, step, step_fast, format, flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    char format[16] = "%f";[m
[32m+[m[32m    if (decimal_precision >= 0)[m
[32m+[m[32m        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);[m
[32m+[m[32m    return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    char format[16] = "%f";[m
[32m+[m[32m    if (decimal_precision >= 0)[m
[32m+[m[32m        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);[m
[32m+[m[32m    return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    char format[16] = "%f";[m
[32m+[m[32m    if (decimal_precision >= 0)[m
[32m+[m[32m        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);[m
[32m+[m[32m    return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, flags);[m
[32m+[m[32m}[m
[32m+[m[32m#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS[m
[32m+[m
[32m+[m[32mbool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    // Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.[m
[32m+[m[32m    const char* format = (flags & ImGuiInputTextFlags_CharsHexadecimal) ? "%08X" : "%d";[m
[32m+[m[32m    return InputScalar(label, ImGuiDataType_S32, (void*)v, (void*)(step>0 ? &step : NULL), (void*)(step_fast>0 ? &step_fast : NULL), format, flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    return InputScalarN(label, ImGuiDataType_S32, v, 2, NULL, NULL, "%d", flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    return InputScalarN(label, ImGuiDataType_S32, v, 3, NULL, NULL, "%d", flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    return InputScalarN(label, ImGuiDataType_S32, v, 4, NULL, NULL, "%d", flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::InputDouble(const char* label, double* v, double step, double step_fast, const char* format, ImGuiInputTextFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    flags |= ImGuiInputTextFlags_CharsScientific;[m
[32m+[m[32m    return InputScalar(label, ImGuiDataType_Double, (void*)v, (void*)(step>0.0 ? &step : NULL), (void*)(step_fast>0.0 ? &step_fast : NULL), format, flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Widgets: InputText, InputTextMultiline, InputTextWithHint[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - InputText()[m
[32m+[m[32m// - InputTextWithHint()[m
[32m+[m[32m// - InputTextMultiline()[m
[32m+[m[32m// - InputTextEx() [Internal][m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mbool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()[m
[32m+[m[32m    return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0,0), flags, callback, user_data);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)[m
[32m+[m[32m{[m
[32m+[m[32m    return InputTextEx(label, NULL, buf, (int)buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::InputTextWithHint(const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()[m
[32m+[m[32m    return InputTextEx(label, hint, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end)[m
[32m+[m[32m{[m
[32m+[m[32m    int line_count = 0;[m
[32m+[m[32m    const char* s = text_begin;[m
[32m+[m[32m    while (char c = *s++) // We are only matching for \n so we can ignore UTF-8 decoding[m
[32m+[m[32m        if (c == '\n')[m
[32m+[m[32m            line_count++;[m
[32m+[m[32m    s--;[m
[32m+[m[32m    if (s[0] != '\n' && s[0] != '\r')[m
[32m+[m[32m        line_count++;[m
[32m+[m[32m    *out_text_end = s;[m
[32m+[m[32m    return line_count;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic ImVec2 InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining, ImVec2* out_offset, bool stop_on_new_line)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImFont* font = g.Font;[m
[32m+[m[32m    const float line_height = g.FontSize;[m
[32m+[m[32m    const float scale = line_height / font->FontSize;[m
[32m+[m
[32m+[m[32m    ImVec2 text_size = ImVec2(0,0);[m
[32m+[m[32m    float line_width = 0.0f;[m
[32m+[m
[32m+[m[32m    const ImWchar* s = text_begin;[m
[32m+[m[32m    while (s < text_end)[m
[32m+[m[32m    {[m
[32m+[m[32m        unsigned int c = (unsigned int)(*s++);[m
[32m+[m[32m        if (c == '\n')[m
[32m+[m[32m        {[m
[32m+[m[32m            text_size.x = ImMax(text_size.x, line_width);[m
[32m+[m[32m            text_size.y += line_height;[m
[32m+[m[32m            line_width = 0.0f;[m
[32m+[m[32m            if (stop_on_new_line)[m
[32m+[m[32m                break;[m
[32m+[m[32m            continue;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (c == '\r')[m
[32m+[m[32m            continue;[m
[32m+[m
[32m+[m[32m        const float char_width = font->GetCharAdvance((ImWchar)c) * scale;[m
[32m+[m[32m        line_width += char_width;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (text_size.x < line_width)[m
[32m+[m[32m        text_size.x = line_width;[m
[32m+[m
[32m+[m[32m    if (out_offset)[m
[32m+[m[32m        *out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \n[m
[32m+[m
[32m+[m[32m    if (line_width > 0 || text_size.y == 0.0f)                        // whereas size.y will ignore the trailing \n[m
[32m+[m[32m        text_size.y += line_height;[m
[32m+[m
[32m+[m[32m    if (remaining)[m
[32m+[m[32m        *remaining = s;[m
[32m+[m
[32m+[m[32m    return text_size;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Wrapper for stb_textedit.h to edit text (our wrapper is for: statically sized buffer, single-line, wchar characters. InputText converts between UTF-8 and wchar)[m
[32m+[m[32mnamespace ImStb[m
[32m+[m[32m{[m
[32m+[m
[32m+[m[32mstatic int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj)                             { return obj->CurLenW; }[m
[32m+[m[32mstatic ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx)                      { return obj->TextW[idx]; }[m
[32m+[m[32mstatic float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx+char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize / GImGui->Font->FontSize); }[m
[32m+[m[32mstatic int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x10000 ? 0 : key; }[m
[32m+[m[32mstatic ImWchar STB_TEXTEDIT_NEWLINE = '\n';[m
[32m+[m[32mstatic void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)[m
[32m+[m[32m{[m
[32m+[m[32m    const ImWchar* text = obj->TextW.Data;[m
[32m+[m[32m    const ImWchar* text_remaining = NULL;[m
[32m+[m[32m    const ImVec2 size = InputTextCalcTextSizeW(text + line_start_idx, text + obj->CurLenW, &text_remaining, NULL, true);[m
[32m+[m[32m    r->x0 = 0.0f;[m
[32m+[m[32m    r->x1 = size.x;[m
[32m+[m[32m    r->baseline_y_delta = size.y;[m
[32m+[m[32m    r->ymin = 0.0f;[m
[32m+[m[32m    r->ymax = size.y;[m
[32m+[m[32m    r->num_chars = (int)(text_remaining - (text + line_start_idx));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic bool is_separator(unsigned int c)                                        { return ImCharIsBlankW(c) || c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|'; }[m
[32m+[m[32mstatic int  is_word_boundary_from_right(STB_TEXTEDIT_STRING* obj, int idx)      { return idx > 0 ? (is_separator( obj->TextW[idx-1] ) && !is_separator( obj->TextW[idx] ) ) : 1; }[m
[32m+[m[32mstatic int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)   { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }[m
[32m+[m[32m#ifdef __APPLE__    // FIXME: Move setting to IO structure[m
[32m+[m[32mstatic int  is_word_boundary_from_left(STB_TEXTEDIT_STRING* obj, int idx)       { return idx > 0 ? (!is_separator( obj->TextW[idx-1] ) && is_separator( obj->TextW[idx] ) ) : 1; }[m
[32m+[m[32mstatic int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_left(obj, idx)) idx++; return idx > len ? len : idx; }[m
[32m+[m[32m#else[m
[32m+[m[32mstatic int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }[m
[32m+[m[32m#endif[m
[32m+[m[32m#define STB_TEXTEDIT_MOVEWORDLEFT   STB_TEXTEDIT_MOVEWORDLEFT_IMPL    // They need to be #define for stb_textedit.h[m
[32m+[m[32m#define STB_TEXTEDIT_MOVEWORDRIGHT  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL[m
[32m+[m
[32m+[m[32mstatic void STB_TEXTEDIT_DELETECHARS(STB_TEXTEDIT_STRING* obj, int pos, int n)[m
[32m+[m[32m{[m
[32m+[m[32m    ImWchar* dst = obj->TextW.Data + pos;[m
[32m+[m
[32m+[m[32m    // We maintain our buffer length in both UTF-8 and wchar formats[m
[32m+[m[32m    obj->CurLenA -= ImTextCountUtf8BytesFromStr(dst, dst + n);[m
[32m+[m[32m    obj->CurLenW -= n;[m
[32m+[m
[32m+[m[32m    // Offset remaining text (FIXME-OPT: Use memmove)[m
[32m+[m[32m    const ImWchar* src = obj->TextW.Data + pos + n;[m
[32m+[m[32m    while (ImWchar c = *src++)[m
[32m+[m[32m        *dst++ = c;[m
[32m+[m[32m    *dst = '\0';[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic bool STB_TEXTEDIT_INSERTCHARS(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)[m
[32m+[m[32m{[m
[32m+[m[32m    const bool is_resizable = (obj->UserFlags & ImGuiInputTextFlags_CallbackResize) != 0;[m
[32m+[m[32m    const int text_len = obj->CurLenW;[m
[32m+[m[32m    IM_ASSERT(pos <= text_len);[m
[32m+[m
[32m+[m[32m    const int new_text_len_utf8 = ImTextCountUtf8BytesFromStr(new_text, new_text + new_text_len);[m
[32m+[m[32m    if (!is_resizable && (new_text_len_utf8 + obj->CurLenA + 1 > obj->BufCapacityA))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    // Grow internal buffer if needed[m
[32m+[m[32m    if (new_text_len + text_len + 1 > obj->TextW.Size)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (!is_resizable)[m
[32m+[m[32m            return false;[m
[32m+[m[32m        IM_ASSERT(text_len < obj->TextW.Size);[m
[32m+[m[32m        obj->TextW.resize(text_len + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    ImWchar* text = obj->TextW.Data;[m
[32m+[m[32m    if (pos != text_len)[m
[32m+[m[32m        memmove(text + pos + new_text_len, text + pos, (size_t)(text_len - pos) * sizeof(ImWchar));[m
[32m+[m[32m    memcpy(text + pos, new_text, (size_t)new_text_len * sizeof(ImWchar));[m
[32m+[m
[32m+[m[32m    obj->CurLenW += new_text_len;[m
[32m+[m[32m    obj->CurLenA += new_text_len_utf8;[m
[32m+[m[32m    obj->TextW[obj->CurLenW] = '\0';[m
[32m+[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// We don't use an enum so we can build even with conflicting symbols (if another user of stb_textedit.h leak their STB_TEXTEDIT_K_* symbols)[m
[32m+[m[32m#define STB_TEXTEDIT_K_LEFT         0x10000 // keyboard input to move cursor left[m
[32m+[m[32m#define STB_TEXTEDIT_K_RIGHT        0x10001 // keyboard input to move cursor right[m
[32m+[m[32m#define STB_TEXTEDIT_K_UP           0x10002 // keyboard input to move cursor up[m
[32m+[m[32m#define STB_TEXTEDIT_K_DOWN         0x10003 // keyboard input to move cursor down[m
[32m+[m[32m#define STB_TEXTEDIT_K_LINESTART    0x10004 // keyboard input to move cursor to start of line[m
[32m+[m[32m#define STB_TEXTEDIT_K_LINEEND      0x10005 // keyboard input to move cursor to end of line[m
[32m+[m[32m#define STB_TEXTEDIT_K_TEXTSTART    0x10006 // keyboard input to move cursor to start of text[m
[32m+[m[32m#define STB_TEXTEDIT_K_TEXTEND      0x10007 // keyboard input to move cursor to end of text[m
[32m+[m[32m#define STB_TEXTEDIT_K_DELETE       0x10008 // keyboard input to delete selection or character under cursor[m
[32m+[m[32m#define STB_TEXTEDIT_K_BACKSPACE    0x10009 // keyboard input to delete selection or character left of cursor[m
[32m+[m[32m#define STB_TEXTEDIT_K_UNDO         0x1000A // keyboard input to perform undo[m
[32m+[m[32m#define STB_TEXTEDIT_K_REDO         0x1000B // keyboard input to perform redo[m
[32m+[m[32m#define STB_TEXTEDIT_K_WORDLEFT     0x1000C // keyboard input to move cursor left one word[m
[32m+[m[32m#define STB_TEXTEDIT_K_WORDRIGHT    0x1000D // keyboard input to move cursor right one word[m
[32m+[m[32m#define STB_TEXTEDIT_K_SHIFT        0x20000[m
[32m+[m
[32m+[m[32m#define STB_TEXTEDIT_IMPLEMENTATION[m
[32m+[m[32m#include "imstb_textedit.h"[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGuiInputTextState::OnKeyPressed(int key)[m
[32m+[m[32m{[m
[32m+[m[32m    stb_textedit_key(this, &Stb, key);[m
[32m+[m[32m    CursorFollow = true;[m
[32m+[m[32m    CursorAnimReset();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiInputTextCallbackData::ImGuiInputTextCallbackData()[m
[32m+[m[32m{[m
[32m+[m[32m    memset(this, 0, sizeof(*this));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Public API to manipulate UTF-8 text[m
[32m+[m[32m// We expose UTF-8 to the user (unlike the STB_TEXTEDIT_* functions which are manipulating wchar)[m
[32m+[m[32m// FIXME: The existence of this rarely exercised code path is a bit of a nuisance.[m
[32m+[m[32mvoid ImGuiInputTextCallbackData::DeleteChars(int pos, int bytes_count)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(pos + bytes_count <= BufTextLen);[m
[32m+[m[32m    char* dst = Buf + pos;[m
[32m+[m[32m    const char* src = Buf + pos + bytes_count;[m
[32m+[m[32m    while (char c = *src++)[m
[32m+[m[32m        *dst++ = c;[m
[32m+[m[32m    *dst = '\0';[m
[32m+[m
[32m+[m[32m    if (CursorPos + bytes_count >= pos)[m
[32m+[m[32m        CursorPos -= bytes_count;[m
[32m+[m[32m    else if (CursorPos >= pos)[m
[32m+[m[32m        CursorPos = pos;[m
[32m+[m[32m    SelectionStart = SelectionEnd = CursorPos;[m
[32m+[m[32m    BufDirty = true;[m
[32m+[m[32m    BufTextLen -= bytes_count;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGuiInputTextCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)[m
[32m+[m[32m{[m
[32m+[m[32m    const bool is_resizable = (Flags & ImGuiInputTextFlags_CallbackResize) != 0;[m
[32m+[m[32m    const int new_text_len = new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);[m
[32m+[m[32m    if (new_text_len + BufTextLen >= BufSize)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (!is_resizable)[m
[32m+[m[32m            return;[m
[32m+[m
[32m+[m[32m        // Contrary to STB_TEXTEDIT_INSERTCHARS() this is working in the UTF8 buffer, hence the midly similar code (until we remove the U16 buffer alltogether!)[m
[32m+[m[32m        ImGuiContext& g = *GImGui;[m
[32m+[m[32m        ImGuiInputTextState* edit_state = &g.InputTextState;[m
[32m+[m[32m        IM_ASSERT(edit_state->ID != 0 && g.ActiveId == edit_state->ID);[m
[32m+[m[32m        IM_ASSERT(Buf == edit_state->TextA.Data);[m
[32m+[m[32m        int new_buf_size = BufTextLen + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1;[m
[32m+[m[32m        edit_state->TextA.reserve(new_buf_size + 1);[m
[32m+[m[32m        Buf = edit_state->TextA.Data;[m
[32m+[m[32m        BufSize = edit_state->BufCapacityA = new_buf_size;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (BufTextLen != pos)[m
[32m+[m[32m        memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));[m
[32m+[m[32m    memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));[m
[32m+[m[32m    Buf[BufTextLen + new_text_len] = '\0';[m
[32m+[m
[32m+[m[32m    if (CursorPos >= pos)[m
[32m+[m[32m        CursorPos += new_text_len;[m
[32m+[m[32m    SelectionStart = SelectionEnd = CursorPos;[m
[32m+[m[32m    BufDirty = true;[m
[32m+[m[32m    BufTextLen += new_text_len;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Return false to discard a character.[m
[32m+[m[32mstatic bool InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)[m
[32m+[m[32m{[m
[32m+[m[32m    unsigned int c = *p_char;[m
[32m+[m
[32m+[m[32m    // Filter non-printable (NB: isprint is unreliable! see #2467)[m
[32m+[m[32m    if (c < 0x20)[m
[32m+[m[32m    {[m
[32m+[m[32m        bool pass = false;[m
[32m+[m[32m        pass |= (c == '\n' && (flags & ImGuiInputTextFlags_Multiline));[m
[32m+[m[32m        pass |= (c == '\t' && (flags & ImGuiInputTextFlags_AllowTabInput));[m
[32m+[m[32m        if (!pass)[m
[32m+[m[32m            return false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Filter private Unicode range. GLFW on OSX seems to send private characters for special keys like arrow keys (FIXME)[m
[32m+[m[32m    if (c >= 0xE000 && c <= 0xF8FF)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    // Generic named filters[m
[32m+[m[32m    if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_CharsScientific))[m
[32m+[m[32m    {[m
[32m+[m[32m        if (flags & ImGuiInputTextFlags_CharsDecimal)[m
[32m+[m[32m            if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/'))[m
[32m+[m[32m                return false;[m
[32m+[m
[32m+[m[32m        if (flags & ImGuiInputTextFlags_CharsScientific)[m
[32m+[m[32m            if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/') && (c != 'e') && (c != 'E'))[m
[32m+[m[32m                return false;[m
[32m+[m
[32m+[m[32m        if (flags & ImGuiInputTextFlags_CharsHexadecimal)[m
[32m+[m[32m            if (!(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F'))[m
[32m+[m[32m                return false;[m
[32m+[m
[32m+[m[32m        if (flags & ImGuiInputTextFlags_CharsUppercase)[m
[32m+[m[32m            if (c >= 'a' && c <= 'z')[m
[32m+[m[32m                *p_char = (c += (unsigned int)('A'-'a'));[m
[32m+[m
[32m+[m[32m        if (flags & ImGuiInputTextFlags_CharsNoBlank)[m
[32m+[m[32m            if (ImCharIsBlankW(c))[m
[32m+[m[32m                return false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Custom callback filter[m
[32m+[m[32m    if (flags & ImGuiInputTextFlags_CallbackCharFilter)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiInputTextCallbackData callback_data;[m
[32m+[m[32m        memset(&callback_data, 0, sizeof(ImGuiInputTextCallbackData));[m
[32m+[m[32m        callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;[m
[32m+[m[32m        callback_data.EventChar = (ImWchar)c;[m
[32m+[m[32m        callback_data.Flags = flags;[m
[32m+[m[32m        callback_data.UserData = user_data;[m
[32m+[m[32m        if (callback(&callback_data) != 0)[m
[32m+[m[32m            return false;[m
[32m+[m[32m        *p_char = callback_data.EventChar;[m
[32m+[m[32m        if (!callback_data.EventChar)[m
[32m+[m[32m            return false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Edit a string of text[m
[32m+[m[32m// - buf_size account for the zero-terminator, so a buf_size of 6 can hold "Hello" but not "Hello!".[m
[32m+[m[32m//   This is so we can easily call InputText() on static arrays using ARRAYSIZE() and to match[m
[32m+[m[32m//   Note that in std::string world, capacity() would omit 1 byte used by the zero-terminator.[m
[32m+[m[32m// - When active, hold on a privately held copy of the text (and apply back to 'buf'). So changing 'buf' while the InputText is active has no effect.[m
[32m+[m[32m// - If you want to use ImGui::InputText() with std::string, see misc/cpp/imgui_stdlib.h[m
[32m+[m[32m// (FIXME: Rather confusing and messy function, among the worse part of our codebase, expecting to rewrite a V2 at some point.. Partly because we are[m
[32m+[m[32m//  doing UTF8 > U16 > UTF8 conversions on the go to easily interface with stb_textedit. Ideally should stay in UTF-8 all the time. See https://github.com/nothings/stb/issues/188)[m
[32m+[m[32mbool ImGui::InputTextEx(const char* label, const char* hint, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* callback_user_data)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackHistory) && (flags & ImGuiInputTextFlags_Multiline)));        // Can't use both together (they both use up/down keys)[m
[32m+[m[32m    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackCompletion) && (flags & ImGuiInputTextFlags_AllowTabInput))); // Can't use both together (they both use tab key)[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiIO& io = g.IO;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m
[32m+[m[32m    const bool RENDER_SELECTION_WHEN_INACTIVE = false;[m
[32m+[m[32m    const bool is_multiline = (flags & ImGuiInputTextFlags_Multiline) != 0;[m
[32m+[m[32m    const bool is_readonly = (flags & ImGuiInputTextFlags_ReadOnly) != 0;[m
[32m+[m[32m    const bool is_password = (flags & ImGuiInputTextFlags_Password) != 0;[m
[32m+[m[32m    const bool is_undoable = (flags & ImGuiInputTextFlags_NoUndoRedo) == 0;[m
[32m+[m[32m    const bool is_resizable = (flags & ImGuiInputTextFlags_CallbackResize) != 0;[m
[32m+[m[32m    if (is_resizable)[m
[32m+[m[32m        IM_ASSERT(callback != NULL); // Must provide a callback if you set the ImGuiInputTextFlags_CallbackResize flag![m
[32m+[m
[32m+[m[32m    if (is_multiline) // Open group before calling GetID() because groups tracks id created within their scope,[m
[32m+[m[32m        BeginGroup();[m
[32m+[m[32m    const ImGuiID id = window->GetID(label);[m
[32m+[m[32m    const ImVec2 label_size = CalcTextSize(label, NULL, true);[m
[32m+[m[32m    ImVec2 size = CalcItemSize(size_arg, GetNextItemWidth(), (is_multiline ? GetTextLineHeight() * 8.0f : label_size.y) + style.FramePadding.y*2.0f); // Arbitrary default of 8 lines high for multi-line[m
[32m+[m[32m    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);[m
[32m+[m[32m    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? (style.ItemInnerSpacing.x + label_size.x) : 0.0f, 0.0f));[m
[32m+[m
[32m+[m[32m    ImGuiWindow* draw_window = window;[m
[32m+[m[32m    if (is_multiline)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (!ItemAdd(total_bb, id, &frame_bb))[m
[32m+[m[32m        {[m
[32m+[m[32m            ItemSize(total_bb, style.FramePadding.y);[m
[32m+[m[32m            EndGroup();[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!BeginChildFrame(id, frame_bb.GetSize()))[m
[32m+[m[32m        {[m
[32m+[m[32m            EndChildFrame();[m
[32m+[m[32m            EndGroup();[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        draw_window = GetCurrentWindow();[m
[32m+[m[32m        draw_window->DC.NavLayerActiveMaskNext |= draw_window->DC.NavLayerCurrentMask; // This is to ensure that EndChild() will display a navigation highlight[m
[32m+[m[32m        size.x -= draw_window->ScrollbarSizes.x;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        ItemSize(total_bb, style.FramePadding.y);[m
[32m+[m[32m        if (!ItemAdd(total_bb, id, &frame_bb))[m
[32m+[m[32m            return false;[m
[32m+[m[32m    }[m
[32m+[m[32m    const bool hovered = ItemHoverable(frame_bb, id);[m
[32m+[m[32m    if (hovered)[m
[32m+[m[32m        g.MouseCursor = ImGuiMouseCursor_TextInput;[m
[32m+[m
[32m+[m[32m    // NB: we are only allowed to access 'edit_state' if we are the active widget.[m
[32m+[m[32m    ImGuiInputTextState* state = NULL;[m
[32m+[m[32m    if (g.InputTextState.ID == id)[m
[32m+[m[32m        state = &g.InputTextState;[m
[32m+[m
[32m+[m[32m    const bool focus_requested = FocusableItemRegister(window, id);[m
[32m+[m[32m    const bool focus_requested_by_code = focus_requested && (g.FocusRequestCurrWindow == window && g.FocusRequestCurrCounterAll == window->DC.FocusCounterAll);[m
[32m+[m[32m    const bool focus_requested_by_tab = focus_requested && !focus_requested_by_code;[m
[32m+[m
[32m+[m[32m    const bool user_clicked = hovered && io.MouseClicked[0];[m
[32m+[m[32m    const bool user_nav_input_start = (g.ActiveId != id) && ((g.NavInputId == id) || (g.NavActivateId == id && g.NavInputSource == ImGuiInputSource_NavKeyboard));[m
[32m+[m[32m    const bool user_scroll_finish = is_multiline && state != NULL && g.ActiveId == 0 && g.ActiveIdPreviousFrame == GetScrollbarID(draw_window, ImGuiAxis_Y);[m
[32m+[m[32m    const bool user_scroll_active = is_multiline && state != NULL && g.ActiveId == GetScrollbarID(draw_window, ImGuiAxis_Y);[m
[32m+[m
[32m+[m[32m    bool clear_active_id = false;[m
[32m+[m[32m    bool select_all = (g.ActiveId != id) && ((flags & ImGuiInputTextFlags_AutoSelectAll) != 0 || user_nav_input_start) && (!is_multiline);[m
[32m+[m
[32m+[m[32m    const bool init_make_active = (focus_requested || user_clicked || user_scroll_finish || user_nav_input_start);[m
[32m+[m[32m    const bool init_state = (init_make_active || user_scroll_active);[m
[32m+[m[32m    if (init_state && g.ActiveId != id)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Access state even if we don't own it yet.[m
[32m+[m[32m        state = &g.InputTextState;[m
[32m+[m[32m        state->CursorAnimReset();[m
[32m+[m
[32m+[m[32m        // Take a copy of the initial buffer value (both in original UTF-8 format and converted to wchar)[m
[32m+[m[32m        // From the moment we focused we are ignoring the content of 'buf' (unless we are in read-only mode)[m
[32m+[m[32m        const int buf_len = (int)strlen(buf);[m
[32m+[m[32m        state->InitialTextA.resize(buf_len + 1);    // UTF-8. we use +1 to make sure that .Data is always pointing to at least an empty string.[m
[32m+[m[32m        memcpy(state->InitialTextA.Data, buf, buf_len + 1);[m
[32m+[m
[32m+[m[32m        // Start edition[m
[32m+[m[32m        const char* buf_end = NULL;[m
[32m+[m[32m        state->TextW.resize(buf_size + 1);          // wchar count <= UTF-8 count. we use +1 to make sure that .Data is always pointing to at least an empty string.[m
[32m+[m[32m        state->TextA.resize(0);[m
[32m+[m[32m        state->TextAIsValid = false;                // TextA is not valid yet (we will display buf until then)[m
[32m+[m[32m        state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, buf_size, buf, NULL, &buf_end);[m
[32m+[m[32m        state->CurLenA = (int)(buf_end - buf);      // We can't get the result from ImStrncpy() above because it is not UTF-8 aware. Here we'll cut off malformed UTF-8.[m
[32m+[m
[32m+[m[32m        // Preserve cursor position and undo/redo stack if we come back to same widget[m
[32m+[m[32m        // FIXME: For non-readonly widgets we might be able to require that TextAIsValid && TextA == buf ? (untested) and discard undo stack if user buffer has changed.[m
[32m+[m[32m        const bool recycle_state = (state->ID == id);[m
[32m+[m[32m        if (recycle_state)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Recycle existing cursor/selection/undo stack but clamp position[m
[32m+[m[32m            // Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.[m
[32m+[m[32m            state->CursorClamp();[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            state->ID = id;[m
[32m+[m[32m            state->ScrollX = 0.0f;[m
[32m+[m[32m            stb_textedit_initialize_state(&state->Stb, !is_multiline);[m
[32m+[m[32m            if (!is_multiline && focus_requested_by_code)[m
[32m+[m[32m                select_all = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (flags & ImGuiInputTextFlags_AlwaysInsertMode)[m
[32m+[m[32m            state->Stb.insert_mode = 1;[m
[32m+[m[32m        if (!is_multiline && (focus_requested_by_tab || (user_clicked && io.KeyCtrl)))[m
[32m+[m[32m            select_all = true;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (g.ActiveId != id && init_make_active)[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(state && state->ID == id);[m
[32m+[m[32m        SetActiveID(id, window);[m
[32m+[m[32m        SetFocusID(id, window);[m
[32m+[m[32m        FocusWindow(window);[m
[32m+[m[32m        IM_ASSERT(ImGuiNavInput_COUNT < 32);[m
[32m+[m[32m        g.ActiveIdBlockNavInputFlags = (1 << ImGuiNavInput_Cancel);[m
[32m+[m[32m        if (flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_AllowTabInput))  // Disable keyboard tabbing out as we will use the \t character.[m
[32m+[m[32m            g.ActiveIdBlockNavInputFlags |= (1 << ImGuiNavInput_KeyTab_);[m
[32m+[m[32m        if (!is_multiline && !(flags & ImGuiInputTextFlags_CallbackHistory))[m
[32m+[m[32m            g.ActiveIdAllowNavDirFlags = ((1 << ImGuiDir_Up) | (1 << ImGuiDir_Down));[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // We have an edge case if ActiveId was set through another widget (e.g. widget being swapped), clear id immediately (don't wait until the end of the function)[m
[32m+[m[32m    if (g.ActiveId == id && state == NULL)[m
[32m+[m[32m        ClearActiveID();[m
[32m+[m
[32m+[m[32m    // Release focus when we click outside[m
[32m+[m[32m    if (g.ActiveId == id && io.MouseClicked[0] && !init_state && !init_make_active) //-V560[m
[32m+[m[32m        clear_active_id = true;[m
[32m+[m
[32m+[m[32m    // Lock the decision of whether we are going to take the path displaying the cursor or selection[m
[32m+[m[32m    const bool render_cursor = (g.ActiveId == id) || (state && user_scroll_active);[m
[32m+[m[32m    bool render_selection = state && state->HasSelection() && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);[m
[32m+[m[32m    bool value_changed = false;[m
[32m+[m[32m    bool enter_pressed = false;[m
[32m+[m
[32m+[m[32m    // When read-only we always use the live data passed to the function[m
[32m+[m[32m    // FIXME-OPT: Because our selection/cursor code currently needs the wide text we need to convert it when active, which is not ideal :([m
[32m+[m[32m    if (is_readonly && state != NULL && (render_cursor || render_selection))[m
[32m+[m[32m    {[m
[32m+[m[32m        const char* buf_end = NULL;[m
[32m+[m[32m        state->TextW.resize(buf_size + 1);[m
[32m+[m[32m        state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, state->TextW.Size, buf, NULL, &buf_end);[m
[32m+[m[32m        state->CurLenA = (int)(buf_end - buf);[m
[32m+[m[32m        state->CursorClamp();[m
[32m+[m[32m        render_selection &= state->HasSelection();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Select the buffer to render.[m
[32m+[m[32m    const bool buf_display_from_state = (render_cursor || render_selection || g.ActiveId == id) && !is_readonly && state && state->TextAIsValid;[m
[32m+[m[32m    const bool is_displaying_hint = (hint != NULL && (buf_display_from_state ? state->TextA.Data : buf)[0] == 0);[m
[32m+[m
[32m+[m[32m    // Password pushes a temporary font with only a fallback glyph[m
[32m+[m[32m    if (is_password && !is_displaying_hint)[m
[32m+[m[32m    {[m
[32m+[m[32m        const ImFontGlyph* glyph = g.Font->FindGlyph('*');[m
[32m+[m[32m        ImFont* password_font = &g.InputTextPasswordFont;[m
[32m+[m[32m        password_font->FontSize = g.Font->FontSize;[m
[32m+[m[32m        password_font->Scale = g.Font->Scale;[m
[32m+[m[32m        password_font->DisplayOffset = g.Font->DisplayOffset;[m
[32m+[m[32m        password_font->Ascent = g.Font->Ascent;[m
[32m+[m[32m        password_font->Descent = g.Font->Descent;[m
[32m+[m[32m        password_font->ContainerAtlas = g.Font->ContainerAtlas;[m
[32m+[m[32m        password_font->FallbackGlyph = glyph;[m
[32m+[m[32m        password_font->FallbackAdvanceX = glyph->AdvanceX;[m
[32m+[m[32m        IM_ASSERT(password_font->Glyphs.empty() && password_font->IndexAdvanceX.empty() && password_font->IndexLookup.empty());[m
[32m+[m[32m        PushFont(password_font);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Process mouse inputs and character inputs[m
[32m+[m[32m    int backup_current_text_length = 0;[m
[32m+[m[32m    if (g.ActiveId == id)[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(state != NULL);[m
[32m+[m[32m        backup_current_text_length = state->CurLenA;[m
[32m+[m[32m        state->BufCapacityA = buf_size;[m
[32m+[m[32m        state->UserFlags = flags;[m
[32m+[m[32m        state->UserCallback = callback;[m
[32m+[m[32m        state->UserCallbackData = callback_user_data;[m
[32m+[m
[32m+[m[32m        // Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.[m
[32m+[m[32m        // Down the line we should have a cleaner library-wide concept of Selected vs Active.[m
[32m+[m[32m        g.ActiveIdAllowOverlap = !io.MouseDown[0];[m
[32m+[m[32m        g.WantTextInputNextFrame = 1;[m
[32m+[m
[32m+[m[32m        // Edit in progress[m
[32m+[m[32m        const float mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + state->ScrollX;[m
[32m+[m[32m        const float mouse_y = (is_multiline ? (io.MousePos.y - draw_window->DC.CursorPos.y - style.FramePadding.y) : (g.FontSize*0.5f));[m
[32m+[m
[32m+[m[32m        const bool is_osx = io.ConfigMacOSXBehaviors;[m
[32m+[m[32m        if (select_all || (hovered && !is_osx && io.MouseDoubleClicked[0]))[m
[32m+[m[32m        {[m
[32m+[m[32m            state->SelectAll();[m
[32m+[m[32m            state->SelectedAllMouseLock = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (hovered && is_osx && io.MouseDoubleClicked[0])[m
[32m+[m[32m        {[m
[32m+[m[32m            // Double-click select a word only, OS X style (by simulating keystrokes)[m
[32m+[m[32m            state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT);[m
[32m+[m[32m            state->OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (io.MouseClicked[0] && !state->SelectedAllMouseLock)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (hovered)[m
[32m+[m[32m            {[m
[32m+[m[32m                stb_textedit_click(state, &state->Stb, mouse_x, mouse_y);[m
[32m+[m[32m                state->CursorAnimReset();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (io.MouseDown[0] && !state->SelectedAllMouseLock && (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f))[m
[32m+[m[32m        {[m
[32m+[m[32m            stb_textedit_drag(state, &state->Stb, mouse_x, mouse_y);[m
[32m+[m[32m            state->CursorAnimReset();[m
[32m+[m[32m            state->CursorFollow = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (state->SelectedAllMouseLock && !io.MouseDown[0])[m
[32m+[m[32m            state->SelectedAllMouseLock = false;[m
[32m+[m
[32m+[m[32m        // It is ill-defined whether the back-end needs to send a \t character when pressing the TAB keys.[m
[32m+[m[32m        // Win32 and GLFW naturally do it but not SDL.[m
[32m+[m[32m        const bool ignore_char_inputs = (io.KeyCtrl && !io.KeyAlt) || (is_osx && io.KeySuper);[m
[32m+[m[32m        if ((flags & ImGuiInputTextFlags_AllowTabInput) && IsKeyPressedMap(ImGuiKey_Tab) && !ignore_char_inputs && !io.KeyShift && !is_readonly)[m
[32m+[m[32m            if (!io.InputQueueCharacters.contains('\t'))[m
[32m+[m[32m            {[m
[32m+[m[32m                unsigned int c = '\t'; // Insert TAB[m
[32m+[m[32m                if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))[m
[32m+[m[32m                    state->OnKeyPressed((int)c);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m        // Process regular text input (before we check for Return because using some IME will effectively send a Return?)[m
[32m+[m[32m        // We ignore CTRL inputs, but need to allow ALT+CTRL as some keyboards (e.g. German) use AltGR (which _is_ Alt+Ctrl) to input certain characters.[m
[32m+[m[32m        if (io.InputQueueCharacters.Size > 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (!ignore_char_inputs && !is_readonly && !user_nav_input_start)[m
[32m+[m[32m                for (int n = 0; n < io.InputQueueCharacters.Size; n++)[m
[32m+[m[32m                {[m
[32m+[m[32m                    // Insert character if they pass filtering[m
[32m+[m[32m                    unsigned int c = (unsigned int)io.InputQueueCharacters[n];[m
[32m+[m[32m                    if (c == '\t' && io.KeyShift)[m
[32m+[m[32m                        continue;[m
[32m+[m[32m                    if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))[m
[32m+[m[32m                        state->OnKeyPressed((int)c);[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m            // Consume characters[m
[32m+[m[32m            io.InputQueueCharacters.resize(0);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Process other shortcuts/key-presses[m
[32m+[m[32m    bool cancel_edit = false;[m
[32m+[m[32m    if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id)[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(state != NULL);[m
[32m+[m[32m        const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);[m
[32m+[m[32m        const bool is_osx = io.ConfigMacOSXBehaviors;[m
[32m+[m[32m        const bool is_shortcut_key = (is_osx ? (io.KeySuper && !io.KeyCtrl) : (io.KeyCtrl && !io.KeySuper)) && !io.KeyAlt && !io.KeyShift; // OS X style: Shortcuts using Cmd/Super instead of Ctrl[m
[32m+[m[32m        const bool is_osx_shift_shortcut = is_osx && io.KeySuper && io.KeyShift && !io.KeyCtrl && !io.KeyAlt;[m
[32m+[m[32m        const bool is_wordmove_key_down = is_osx ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl[m
[32m+[m[32m        const bool is_startend_key_down = is_osx && io.KeySuper && !io.KeyCtrl && !io.KeyAlt;  // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End[m
[32m+[m[32m        const bool is_ctrl_key_only = io.KeyCtrl && !io.KeyShift && !io.KeyAlt && !io.KeySuper;[m
[32m+[m[32m        const bool is_shift_key_only = io.KeyShift && !io.KeyCtrl && !io.KeyAlt && !io.KeySuper;[m
[32m+[m
[32m+[m[32m        const bool is_cut   = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_X)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Delete))) && !is_readonly && !is_password && (!is_multiline || state->HasSelection());[m
[32m+[m[32m        const bool is_copy  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_C)) || (is_ctrl_key_only  && IsKeyPressedMap(ImGuiKey_Insert))) && !is_password && (!is_multiline || state->HasSelection());[m
[32m+[m[32m        const bool is_paste = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_V)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Insert))) && !is_readonly;[m
[32m+[m[32m        const bool is_undo  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_Z)) && !is_readonly && is_undoable);[m
[32m+[m[32m        const bool is_redo  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_Y)) || (is_osx_shift_shortcut && IsKeyPressedMap(ImGuiKey_Z))) && !is_readonly && is_undoable;[m
[32m+[m
[32m+[m[32m        if (IsKeyPressedMap(ImGuiKey_LeftArrow))                        { state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask); }[m
[32m+[m[32m        else if (IsKeyPressedMap(ImGuiKey_RightArrow))                  { state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask); }[m
[32m+[m[32m        else if (IsKeyPressedMap(ImGuiKey_UpArrow) && is_multiline)     { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMax(draw_window->Scroll.y - g.FontSize, 0.0f)); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask); }[m
[32m+[m[32m        else if (IsKeyPressedMap(ImGuiKey_DownArrow) && is_multiline)   { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY())); else state->OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }[m
[32m+[m[32m        else if (IsKeyPressedMap(ImGuiKey_Home))                        { state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask); }[m
[32m+[m[32m        else if (IsKeyPressedMap(ImGuiKey_End))                         { state->OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask); }[m
[32m+[m[32m        else if (IsKeyPressedMap(ImGuiKey_Delete) && !is_readonly)      { state->OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask); }[m
[32m+[m[32m        else if (IsKeyPressedMap(ImGuiKey_Backspace) && !is_readonly)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (!state->HasSelection())[m
[32m+[m[32m            {[m
[32m+[m[32m                if (is_wordmove_key_down)[m
[32m+[m[32m                    state->OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT|STB_TEXTEDIT_K_SHIFT);[m
[32m+[m[32m                else if (is_osx && io.KeySuper && !io.KeyAlt && !io.KeyCtrl)[m
[32m+[m[32m                    state->OnKeyPressed(STB_TEXTEDIT_K_LINESTART|STB_TEXTEDIT_K_SHIFT);[m
[32m+[m[32m            }[m
[32m+[m[32m            state->OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (IsKeyPressedMap(ImGuiKey_Enter))[m
[32m+[m[32m        {[m
[32m+[m[32m            bool ctrl_enter_for_new_line = (flags & ImGuiInputTextFlags_CtrlEnterForNewLine) != 0;[m
[32m+[m[32m            if (!is_multiline || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))[m
[32m+[m[32m            {[m
[32m+[m[32m                enter_pressed = clear_active_id = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (!is_readonly)[m
[32m+[m[32m            {[m
[32m+[m[32m                unsigned int c = '\n'; // Insert new line[m
[32m+[m[32m                if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))[m
[32m+[m[32m                    state->OnKeyPressed((int)c);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (IsKeyPressedMap(ImGuiKey_Escape))[m
[32m+[m[32m        {[m
[32m+[m[32m            clear_active_id = cancel_edit = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (is_undo || is_redo)[m
[32m+[m[32m        {[m
[32m+[m[32m            state->OnKeyPressed(is_undo ? STB_TEXTEDIT_K_UNDO : STB_TEXTEDIT_K_REDO);[m
[32m+[m[32m            state->ClearSelection();[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (is_shortcut_key && IsKeyPressedMap(ImGuiKey_A))[m
[32m+[m[32m        {[m
[32m+[m[32m            state->SelectAll();[m
[32m+[m[32m            state->CursorFollow = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (is_cut || is_copy)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Cut, Copy[m
[32m+[m[32m            if (io.SetClipboardTextFn)[m
[32m+[m[32m            {[m
[32m+[m[32m                const int ib = state->HasSelection() ? ImMin(state->Stb.select_start, state->Stb.select_end) : 0;[m
[32m+[m[32m                const int ie = state->HasSelection() ? ImMax(state->Stb.select_start, state->Stb.select_end) : state->CurLenW;[m
[32m+[m[32m                const int clipboard_data_len = ImTextCountUtf8BytesFromStr(state->TextW.Data + ib, state->TextW.Data + ie) + 1;[m
[32m+[m[32m                char* clipboard_data = (char*)IM_ALLOC(clipboard_data_len * sizeof(char));[m
[32m+[m[32m                ImTextStrToUtf8(clipboard_data, clipboard_data_len, state->TextW.Data + ib, state->TextW.Data + ie);[m
[32m+[m[32m                SetClipboardText(clipboard_data);[m
[32m+[m[32m                MemFree(clipboard_data);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (is_cut)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (!state->HasSelection())[m
[32m+[m[32m                    state->SelectAll();[m
[32m+[m[32m                state->CursorFollow = true;[m
[32m+[m[32m                stb_textedit_cut(state, &state->Stb);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (is_paste)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (const char* clipboard = GetClipboardText())[m
[32m+[m[32m            {[m
[32m+[m[32m                // Filter pasted buffer[m
[32m+[m[32m                const int clipboard_len = (int)strlen(clipboard);[m
[32m+[m[32m                ImWchar* clipboard_filtered = (ImWchar*)IM_ALLOC((clipboard_len+1) * sizeof(ImWchar));[m
[32m+[m[32m                int clipboard_filtered_len = 0;[m
[32m+[m[32m                for (const char* s = clipboard; *s; )[m
[32m+[m[32m                {[m
[32m+[m[32m                    unsigned int c;[m
[32m+[m[32m                    s += ImTextCharFromUtf8(&c, s, NULL);[m
[32m+[m[32m                    if (c == 0)[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    if (c >= 0x10000 || !InputTextFilterCharacter(&c, flags, callback, callback_user_data))[m
[32m+[m[32m                        continue;[m
[32m+[m[32m                    clipboard_filtered[clipboard_filtered_len++] = (ImWchar)c;[m
[32m+[m[32m                }[m
[32m+[m[32m                clipboard_filtered[clipboard_filtered_len] = 0;[m
[32m+[m[32m                if (clipboard_filtered_len > 0) // If everything was filtered, ignore the pasting operation[m
[32m+[m[32m                {[m
[32m+[m[32m                    stb_textedit_paste(state, &state->Stb, clipboard_filtered, clipboard_filtered_len);[m
[32m+[m[32m                    state->CursorFollow = true;[m
[32m+[m[32m                }[m
[32m+[m[32m                MemFree(clipboard_filtered);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Update render selection flag after events have been handled, so selection highlight can be displayed during the same frame.[m
[32m+[m[32m        render_selection |= state->HasSelection() && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Process callbacks and apply result back to user's buffer.[m
[32m+[m[32m    if (g.ActiveId == id)[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(state != NULL);[m
[32m+[m[32m        const char* apply_new_text = NULL;[m
[32m+[m[32m        int apply_new_text_length = 0;[m
[32m+[m[32m        if (cancel_edit)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Restore initial value. Only return true if restoring to the initial value changes the current buffer contents.[m
[32m+[m[32m            if (!is_readonly && strcmp(buf, state->InitialTextA.Data) != 0)[m
[32m+[m[32m            {[m
[32m+[m[32m                apply_new_text = state->InitialTextA.Data;[m
[32m+[m[32m                apply_new_text_length = state->InitialTextA.Size - 1;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.[m
[32m+[m[32m        // If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail. Also this allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage.[m
[32m+[m[32m        bool apply_edit_back_to_user_buffer = !cancel_edit || (enter_pressed && (flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0);[m
[32m+[m[32m        if (apply_edit_back_to_user_buffer)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Apply new value immediately - copy modified buffer back[m
[32m+[m[32m            // Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer[m
[32m+[m[32m            // FIXME: We actually always render 'buf' when calling DrawList->AddText, making the comment above incorrect.[m
[32m+[m[32m            // FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.[m
[32m+[m[32m            if (!is_readonly)[m
[32m+[m[32m            {[m
[32m+[m[32m                state->TextAIsValid = true;[m
[32m+[m[32m                state->TextA.resize(state->TextW.Size * 4 + 1);[m
[32m+[m[32m                ImTextStrToUtf8(state->TextA.Data, state->TextA.Size, state->TextW.Data, NULL);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // User callback[m
[32m+[m[32m            if ((flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackAlways)) != 0)[m
[32m+[m[32m            {[m
[32m+[m[32m                IM_ASSERT(callback != NULL);[m
[32m+[m
[32m+[m[32m                // The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.[m
[32m+[m[32m                ImGuiInputTextFlags event_flag = 0;[m
[32m+[m[32m                ImGuiKey event_key = ImGuiKey_COUNT;[m
[32m+[m[32m                if ((flags & ImGuiInputTextFlags_CallbackCompletion) != 0 && IsKeyPressedMap(ImGuiKey_Tab))[m
[32m+[m[32m                {[m
[32m+[m[32m                    event_flag = ImGuiInputTextFlags_CallbackCompletion;[m
[32m+[m[32m                    event_key = ImGuiKey_Tab;[m
[32m+[m[32m                }[m
[32m+[m[32m                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_UpArrow))[m
[32m+[m[32m                {[m
[32m+[m[32m                    event_flag = ImGuiInputTextFlags_CallbackHistory;[m
[32m+[m[32m                    event_key = ImGuiKey_UpArrow;[m
[32m+[m[32m                }[m
[32m+[m[32m                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_DownArrow))[m
[32m+[m[32m                {[m
[32m+[m[32m                    event_flag = ImGuiInputTextFlags_CallbackHistory;[m
[32m+[m[32m                    event_key = ImGuiKey_DownArrow;[m
[32m+[m[32m                }[m
[32m+[m[32m                else if (flags & ImGuiInputTextFlags_CallbackAlways)[m
[32m+[m[32m                    event_flag = ImGuiInputTextFlags_CallbackAlways;[m
[32m+[m
[32m+[m[32m                if (event_flag)[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImGuiInputTextCallbackData callback_data;[m
[32m+[m[32m                    memset(&callback_data, 0, sizeof(ImGuiInputTextCallbackData));[m
[32m+[m[32m                    callback_data.EventFlag = event_flag;[m
[32m+[m[32m                    callback_data.Flags = flags;[m
[32m+[m[32m                    callback_data.UserData = callback_user_data;[m
[32m+[m
[32m+[m[32m                    callback_data.EventKey = event_key;[m
[32m+[m[32m                    callback_data.Buf = state->TextA.Data;[m
[32m+[m[32m                    callback_data.BufTextLen = state->CurLenA;[m
[32m+[m[32m                    callback_data.BufSize = state->BufCapacityA;[m
[32m+[m[32m                    callback_data.BufDirty = false;[m
[32m+[m
[32m+[m[32m                    // We have to convert from wchar-positions to UTF-8-positions, which can be pretty slow (an incentive to ditch the ImWchar buffer, see https://github.com/nothings/stb/issues/188)[m
[32m+[m[32m                    ImWchar* text = state->TextW.Data;[m
[32m+[m[32m                    const int utf8_cursor_pos = callback_data.CursorPos = ImTextCountUtf8BytesFromStr(text, text + state->Stb.cursor);[m
[32m+[m[32m                    const int utf8_selection_start = callback_data.SelectionStart = ImTextCountUtf8BytesFromStr(text, text + state->Stb.select_start);[m
[32m+[m[32m                    const int utf8_selection_end = callback_data.SelectionEnd = ImTextCountUtf8BytesFromStr(text, text + state->Stb.select_end);[m
[32m+[m
[32m+[m[32m                    // Call user code[m
[32m+[m[32m                    callback(&callback_data);[m
[32m+[m
[32m+[m[32m                    // Read back what user may have modified[m
[32m+[m[32m                    IM_ASSERT(callback_data.Buf == state->TextA.Data);  // Invalid to modify those fields[m
[32m+[m[32m                    IM_ASSERT(callback_data.BufSize == state->BufCapacityA);[m
[32m+[m[32m                    IM_ASSERT(callback_data.Flags == flags);[m
[32m+[m[32m                    if (callback_data.CursorPos != utf8_cursor_pos)            { state->Stb.cursor = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.CursorPos); state->CursorFollow = true; }[m
[32m+[m[32m                    if (callback_data.SelectionStart != utf8_selection_start)  { state->Stb.select_start = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionStart); }[m
[32m+[m[32m                    if (callback_data.SelectionEnd != utf8_selection_end)      { state->Stb.select_end = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionEnd); }[m
[32m+[m[32m                    if (callback_data.BufDirty)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        IM_ASSERT(callback_data.BufTextLen == (int)strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text![m
[32m+[m[32m                        if (callback_data.BufTextLen > backup_current_text_length && is_resizable)[m
[32m+[m[32m                            state->TextW.resize(state->TextW.Size + (callback_data.BufTextLen - backup_current_text_length));[m
[32m+[m[32m                        state->CurLenW = ImTextStrFromUtf8(state->TextW.Data, state->TextW.Size, callback_data.Buf, NULL);[m
[32m+[m[32m                        state->CurLenA = callback_data.BufTextLen;  // Assume correct length and valid UTF-8 from user, saves us an extra strlen()[m
[32m+[m[32m                        state->CursorAnimReset();[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Will copy result string if modified[m
[32m+[m[32m            if (!is_readonly && strcmp(state->TextA.Data, buf) != 0)[m
[32m+[m[32m            {[m
[32m+[m[32m                apply_new_text = state->TextA.Data;[m
[32m+[m[32m                apply_new_text_length = state->CurLenA;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Copy result to user buffer[m
[32m+[m[32m        if (apply_new_text)[m
[32m+[m[32m        {[m
[32m+[m[32m            IM_ASSERT(apply_new_text_length >= 0);[m
[32m+[m[32m            if (backup_current_text_length != apply_new_text_length && is_resizable)[m
[32m+[m[32m            {[m
[32m+[m[32m                ImGuiInputTextCallbackData callback_data;[m
[32m+[m[32m                callback_data.EventFlag = ImGuiInputTextFlags_CallbackResize;[m
[32m+[m[32m                callback_data.Flags = flags;[m
[32m+[m[32m                callback_data.Buf = buf;[m
[32m+[m[32m                callback_data.BufTextLen = apply_new_text_length;[m
[32m+[m[32m                callback_data.BufSize = ImMax(buf_size, apply_new_text_length + 1);[m
[32m+[m[32m                callback_data.UserData = callback_user_data;[m
[32m+[m[32m                callback(&callback_data);[m
[32m+[m[32m                buf = callback_data.Buf;[m
[32m+[m[32m                buf_size = callback_data.BufSize;[m
[32m+[m[32m                apply_new_text_length = ImMin(callback_data.BufTextLen, buf_size - 1);[m
[32m+[m[32m                IM_ASSERT(apply_new_text_length <= buf_size);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // If the underlying buffer resize was denied or not carried to the next frame, apply_new_text_length+1 may be >= buf_size.[m
[32m+[m[32m            ImStrncpy(buf, apply_new_text, ImMin(apply_new_text_length + 1, buf_size));[m
[32m+[m[32m            value_changed = true;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Clear temporary user storage[m
[32m+[m[32m        state->UserFlags = 0;[m
[32m+[m[32m        state->UserCallback = NULL;[m
[32m+[m[32m        state->UserCallbackData = NULL;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)[m
[32m+[m[32m    if (clear_active_id && g.ActiveId == id)[m
[32m+[m[32m        ClearActiveID();[m
[32m+[m
[32m+[m[32m    // Render frame[m
[32m+[m[32m    if (!is_multiline)[m
[32m+[m[32m    {[m
[32m+[m[32m        RenderNavHighlight(frame_bb, id);[m
[32m+[m[32m        RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + size.x, frame_bb.Min.y + size.y); // Not using frame_bb.Max because we have adjusted size[m
[32m+[m[32m    ImVec2 draw_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;[m
[32m+[m[32m    ImVec2 text_size(0.0f, 0.0f);[m
[32m+[m
[32m+[m[32m    // Set upper limit of single-line InputTextEx() at 2 million characters strings. The current pathological worst case is a long line[m
[32m+[m[32m    // without any carriage return, which would makes ImFont::RenderText() reserve too many vertices and probably crash. Avoid it altogether.[m
[32m+[m[32m    // Note that we only use this limit on single-line InputText(), so a pathologically large line on a InputTextMultiline() would still crash.[m
[32m+[m[32m    const int buf_display_max_length = 2 * 1024 * 1024;[m
[32m+[m[32m    const char* buf_display = buf_display_from_state ? state->TextA.Data : buf; //-V595[m
[32m+[m[32m    const char* buf_display_end = NULL; // We have specialized paths below for setting the length[m
[32m+[m[32m    if (is_displaying_hint)[m
[32m+[m[32m    {[m
[32m+[m[32m        buf_display = hint;[m
[32m+[m[32m        buf_display_end = hint + strlen(hint);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Render text. We currently only render selection when the widget is active or while scrolling.[m
[32m+[m[32m    // FIXME: We could remove the '&& render_cursor' to keep rendering selection when inactive.[m
[32m+[m[32m    if (render_cursor || render_selection)[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(state != NULL);[m
[32m+[m[32m        if (!is_displaying_hint)[m
[32m+[m[32m            buf_display_end = buf_display + state->CurLenA;[m
[32m+[m
[32m+[m[32m        // Render text (with cursor and selection)[m
[32m+[m[32m        // This is going to be messy. We need to:[m
[32m+[m[32m        // - Display the text (this alone can be more easily clipped)[m
[32m+[m[32m        // - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d->2d cursor position calculation)[m
[32m+[m[32m        // - Measure text height (for scrollbar)[m
[32m+[m[32m        // We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)[m
[32m+[m[32m        // FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.[m
[32m+[m[32m        const ImWchar* text_begin = state->TextW.Data;[m
[32m+[m[32m        ImVec2 cursor_offset, select_start_offset;[m
[32m+[m
[32m+[m[32m        {[m
[32m+[m[32m            // Find lines numbers straddling 'cursor' (slot 0) and 'select_start' (slot 1) positions.[m
[32m+[m[32m            const ImWchar* searches_input_ptr[2] = { NULL, NULL };[m
[32m+[m[32m            int searches_result_line_no[2] = { -1000, -1000 };[m
[32m+[m[32m            int searches_remaining = 0;[m
[32m+[m[32m            if (render_cursor)[m
[32m+[m[32m            {[m
[32m+[m[32m                searches_input_ptr[0] = text_begin + state->Stb.cursor;[m
[32m+[m[32m                searches_result_line_no[0] = -1;[m
[32m+[m[32m                searches_remaining++;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (render_selection)[m
[32m+[m[32m            {[m
[32m+[m[32m                searches_input_ptr[1] = text_begin + ImMin(state->Stb.select_start, state->Stb.select_end);[m
[32m+[m[32m                searches_result_line_no[1] = -1;[m
[32m+[m[32m                searches_remaining++;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Iterate all lines to find our line numbers[m
[32m+[m[32m            // In multi-line mode, we never exit the loop until all lines are counted, so add one extra to the searches_remaining counter.[m
[32m+[m[32m            searches_remaining += is_multiline ? 1 : 0;[m
[32m+[m[32m            int line_count = 0;[m
[32m+[m[32m            //for (const ImWchar* s = text_begin; (s = (const ImWchar*)wcschr((const wchar_t*)s, (wchar_t)'\n')) != NULL; s++)  // FIXME-OPT: Could use this when wchar_t are 16-bits[m
[32m+[m[32m            for (const ImWchar* s = text_begin; *s != 0; s++)[m
[32m+[m[32m                if (*s == '\n')[m
[32m+[m[32m                {[m
[32m+[m[32m                    line_count++;[m
[32m+[m[32m                    if (searches_result_line_no[0] == -1 && s >= searches_input_ptr[0]) { searches_result_line_no[0] = line_count; if (--searches_remaining <= 0) break; }[m
[32m+[m[32m                    if (searches_result_line_no[1] == -1 && s >= searches_input_ptr[1]) { searches_result_line_no[1] = line_count; if (--searches_remaining <= 0) break; }[m
[32m+[m[32m                }[m
[32m+[m[32m            line_count++;[m
[32m+[m[32m            if (searches_result_line_no[0] == -1)[m
[32m+[m[32m                searches_result_line_no[0] = line_count;[m
[32m+[m[32m            if (searches_result_line_no[1] == -1)[m
[32m+[m[32m                searches_result_line_no[1] = line_count;[m
[32m+[m
[32m+[m[32m            // Calculate 2d position by finding the beginning of the line and measuring distance[m
[32m+[m[32m            cursor_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[0], text_begin), searches_input_ptr[0]).x;[m
[32m+[m[32m            cursor_offset.y = searches_result_line_no[0] * g.FontSize;[m
[32m+[m[32m            if (searches_result_line_no[1] >= 0)[m
[32m+[m[32m            {[m
[32m+[m[32m                select_start_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[1], text_begin), searches_input_ptr[1]).x;[m
[32m+[m[32m                select_start_offset.y = searches_result_line_no[1] * g.FontSize;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)[m
[32m+[m[32m            if (is_multiline)[m
[32m+[m[32m                text_size = ImVec2(size.x, line_count * g.FontSize);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Scroll[m
[32m+[m[32m        if (render_cursor && state->CursorFollow)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Horizontal scroll in chunks of quarter width[m
[32m+[m[32m            if (!(flags & ImGuiInputTextFlags_NoHorizontalScroll))[m
[32m+[m[32m            {[m
[32m+[m[32m                const float scroll_increment_x = size.x * 0.25f;[m
[32m+[m[32m                if (cursor_offset.x < state->ScrollX)[m
[32m+[m[32m                    state->ScrollX = (float)(int)ImMax(0.0f, cursor_offset.x - scroll_increment_x);[m
[32m+[m[32m                else if (cursor_offset.x - size.x >= state->ScrollX)[m
[32m+[m[32m                    state->ScrollX = (float)(int)(cursor_offset.x - size.x + scroll_increment_x);[m
[32m+[m[32m            }[m
[32m+[m[32m            else[m
[32m+[m[32m            {[m
[32m+[m[32m                state->ScrollX = 0.0f;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // Vertical scroll[m
[32m+[m[32m            if (is_multiline)[m
[32m+[m[32m            {[m
[32m+[m[32m                float scroll_y = draw_window->Scroll.y;[m
[32m+[m[32m                if (cursor_offset.y - g.FontSize < scroll_y)[m
[32m+[m[32m                    scroll_y = ImMax(0.0f, cursor_offset.y - g.FontSize);[m
[32m+[m[32m                else if (cursor_offset.y - size.y >= scroll_y)[m
[32m+[m[32m                    scroll_y = cursor_offset.y - size.y;[m
[32m+[m[32m                draw_window->DC.CursorPos.y += (draw_window->Scroll.y - scroll_y);   // Manipulate cursor pos immediately avoid a frame of lag[m
[32m+[m[32m                draw_window->Scroll.y = scroll_y;[m
[32m+[m[32m                draw_pos.y = draw_window->DC.CursorPos.y;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            state->CursorFollow = false;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Draw selection[m
[32m+[m[32m        const ImVec2 draw_scroll = ImVec2(state->ScrollX, 0.0f);[m
[32m+[m[32m        if (render_selection)[m
[32m+[m[32m        {[m
[32m+[m[32m            const ImWchar* text_selected_begin = text_begin + ImMin(state->Stb.select_start, state->Stb.select_end);[m
[32m+[m[32m            const ImWchar* text_selected_end = text_begin + ImMax(state->Stb.select_start, state->Stb.select_end);[m
[32m+[m
[32m+[m[32m            ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg, render_cursor ? 1.0f : 0.6f); // FIXME: current code flow mandate that render_cursor is always true here, we are leaving the transparent one for tests.[m
[32m+[m[32m            float bg_offy_up = is_multiline ? 0.0f : -1.0f;    // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.[m
[32m+[m[32m            float bg_offy_dn = is_multiline ? 0.0f : 2.0f;[m
[32m+[m[32m            ImVec2 rect_pos = draw_pos + select_start_offset - draw_scroll;[m
[32m+[m[32m            for (const ImWchar* p = text_selected_begin; p < text_selected_end; )[m
[32m+[m[32m            {[m
[32m+[m[32m                if (rect_pos.y > clip_rect.w + g.FontSize)[m
[32m+[m[32m                    break;[m
[32m+[m[32m                if (rect_pos.y < clip_rect.y)[m
[32m+[m[32m                {[m
[32m+[m[32m                    //p = (const ImWchar*)wmemchr((const wchar_t*)p, '\n', text_selected_end - p);  // FIXME-OPT: Could use this when wchar_t are 16-bits[m
[32m+[m[32m                    //p = p ? p + 1 : text_selected_end;[m
[32m+[m[32m                    while (p < text_selected_end)[m
[32m+[m[32m                        if (*p++ == '\n')[m
[32m+[m[32m                            break;[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    ImVec2 rect_size = InputTextCalcTextSizeW(p, text_selected_end, &p, NULL, true);[m
[32m+[m[32m                    if (rect_size.x <= 0.0f) rect_size.x = (float)(int)(g.Font->GetCharAdvance((ImWchar)' ') * 0.50f); // So we can see selected empty lines[m
[32m+[m[32m                    ImRect rect(rect_pos + ImVec2(0.0f, bg_offy_up - g.FontSize), rect_pos +ImVec2(rect_size.x, bg_offy_dn));[m
[32m+[m[32m                    rect.ClipWith(clip_rect);[m
[32m+[m[32m                    if (rect.Overlaps(clip_rect))[m
[32m+[m[32m                        draw_window->DrawList->AddRectFilled(rect.Min, rect.Max, bg_color);[m
[32m+[m[32m                }[m
[32m+[m[32m                rect_pos.x = draw_pos.x - draw_scroll.x;[m
[32m+[m[32m                rect_pos.y += g.FontSize;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // We test for 'buf_display_max_length' as a way to avoid some pathological cases (e.g. single-line 1 MB string) which would make ImDrawList crash.[m
[32m+[m[32m        if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImU32 col = GetColorU32(is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text);[m
[32m+[m[32m            draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos - draw_scroll, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Draw blinking cursor[m
[32m+[m[32m        if (render_cursor)[m
[32m+[m[32m        {[m
[32m+[m[32m            state->CursorAnim += io.DeltaTime;[m
[32m+[m[32m            bool cursor_is_visible = (!g.IO.ConfigInputTextCursorBlink) || (state->CursorAnim <= 0.0f) || ImFmod(state->CursorAnim, 1.20f) <= 0.80f;[m
[32m+[m[32m            ImVec2 cursor_screen_pos = draw_pos + cursor_offset - draw_scroll;[m
[32m+[m[32m            ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y - g.FontSize + 0.5f, cursor_screen_pos.x + 1.0f, cursor_screen_pos.y - 1.5f);[m
[32m+[m[32m            if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))[m
[32m+[m[32m                draw_window->DrawList->AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));[m
[32m+[m
[32m+[m[32m            // Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)[m
[32m+[m[32m            if (!is_readonly)[m
[32m+[m[32m                g.PlatformImePos = ImVec2(cursor_screen_pos.x - 1.0f, cursor_screen_pos.y - g.FontSize);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // Render text only (no selection, no cursor)[m
[32m+[m[32m        if (is_multiline)[m
[32m+[m[32m            text_size = ImVec2(size.x, InputTextCalcTextLenAndLineCount(buf_display, &buf_display_end) * g.FontSize); // We don't need width[m
[32m+[m[32m        else if (!is_displaying_hint && g.ActiveId == id)[m
[32m+[m[32m            buf_display_end = buf_display + state->CurLenA;[m
[32m+[m[32m        else if (!is_displaying_hint)[m
[32m+[m[32m            buf_display_end = buf_display + strlen(buf_display);[m
[32m+[m
[32m+[m[32m        if (is_multiline || (buf_display_end - buf_display) < buf_display_max_length)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImU32 col = GetColorU32(is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text);[m
[32m+[m[32m            draw_window->DrawList->AddText(g.Font, g.FontSize, draw_pos, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &clip_rect);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (is_multiline)[m
[32m+[m[32m    {[m
[32m+[m[32m        Dummy(text_size + ImVec2(0.0f, g.FontSize)); // Always add room to scroll an extra line[m
[32m+[m[32m        EndChildFrame();[m
[32m+[m[32m        EndGroup();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (is_password && !is_displaying_hint)[m
[32m+[m[32m        PopFont();[m
[32m+[m
[32m+[m[32m    // Log as text[m
[32m+[m[32m    if (g.LogEnabled && !(is_password && !is_displaying_hint))[m
[32m+[m[32m        LogRenderedText(&draw_pos, buf_display, buf_display_end);[m
[32m+[m
[32m+[m[32m    if (label_size.x > 0)[m
[32m+[m[32m        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);[m
[32m+[m
[32m+[m[32m    if (value_changed)[m
[32m+[m[32m        MarkItemEdited(id);[m
[32m+[m
[32m+[m[32m    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);[m
[32m+[m[32m    if ((flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0)[m
[32m+[m[32m        return enter_pressed;[m
[32m+[m[32m    else[m
[32m+[m[32m        return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - ColorEdit3()[m
[32m+[m[32m// - ColorEdit4()[m
[32m+[m[32m// - ColorPicker3()[m
[32m+[m[32m// - RenderColorRectWithAlphaCheckerboard() [Internal][m
[32m+[m[32m// - ColorPicker4()[m
[32m+[m[32m// - ColorButton()[m
[32m+[m[32m// - SetColorEditOptions()[m
[32m+[m[32m// - ColorTooltip() [Internal][m
[32m+[m[32m// - ColorEditOptionsPopup() [Internal][m
[32m+[m[32m// - ColorPickerOptionsPopup() [Internal][m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mbool ImGui::ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    return ColorEdit4(label, col, flags | ImGuiColorEditFlags_NoAlpha);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Edit colors components (each component in 0.0f..1.0f range).[m
[32m+[m[32m// See enum ImGuiColorEditFlags_ for available options. e.g. Only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.[m
[32m+[m[32m// With typical options: Left-click on colored square to open color picker. Right-click to open option menu. CTRL-Click over input fields to edit them and TAB to go to next item.[m
[32m+[m[32mbool ImGui::ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    const float square_sz = GetFrameHeight();[m
[32m+[m[32m    const float w_extra = (flags & ImGuiColorEditFlags_NoSmallPreview) ? 0.0f : (square_sz + style.ItemInnerSpacing.x);[m
[32m+[m[32m    const float w_items_all = GetNextItemWidth() - w_extra;[m
[32m+[m[32m    const char* label_display_end = FindRenderedTextEnd(label);[m
[32m+[m
[32m+[m[32m    BeginGroup();[m
[32m+[m[32m    PushID(label);[m
[32m+[m
[32m+[m[32m    // If we're not showing any slider there's no point in doing any HSV conversions[m
[32m+[m[32m    const ImGuiColorEditFlags flags_untouched = flags;[m
[32m+[m[32m    if (flags & ImGuiColorEditFlags_NoInputs)[m
[32m+[m[32m        flags = (flags & (~ImGuiColorEditFlags__DisplayMask)) | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_NoOptions;[m
[32m+[m
[32m+[m[32m    // Context menu: display and modify options (before defaults are applied)[m
[32m+[m[32m    if (!(flags & ImGuiColorEditFlags_NoOptions))[m
[32m+[m[32m        ColorEditOptionsPopup(col, flags);[m
[32m+[m
[32m+[m[32m    // Read stored options[m
[32m+[m[32m    if (!(flags & ImGuiColorEditFlags__DisplayMask))[m
[32m+[m[32m        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__DisplayMask);[m
[32m+[m[32m    if (!(flags & ImGuiColorEditFlags__DataTypeMask))[m
[32m+[m[32m        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__DataTypeMask);[m
[32m+[m[32m    if (!(flags & ImGuiColorEditFlags__PickerMask))[m
[32m+[m[32m        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__PickerMask);[m
[32m+[m[32m    if (!(flags & ImGuiColorEditFlags__InputMask))[m
[32m+[m[32m        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__InputMask);[m
[32m+[m[32m    flags |= (g.ColorEditOptions & ~(ImGuiColorEditFlags__DisplayMask | ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask | ImGuiColorEditFlags__InputMask));[m
[32m+[m[32m    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__DisplayMask)); // Check that only 1 is selected[m
[32m+[m[32m    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__InputMask));   // Check that only 1 is selected[m
[32m+[m
[32m+[m[32m    const bool alpha = (flags & ImGuiColorEditFlags_NoAlpha) == 0;[m
[32m+[m[32m    const bool hdr = (flags & ImGuiColorEditFlags_HDR) != 0;[m
[32m+[m[32m    const int components = alpha ? 4 : 3;[m
[32m+[m
[32m+[m[32m    // Convert to the formats we need[m
[32m+[m[32m    float f[4] = { col[0], col[1], col[2], alpha ? col[3] : 1.0f };[m
[32m+[m[32m    if ((flags & ImGuiColorEditFlags_InputHSV) && (flags & ImGuiColorEditFlags_DisplayRGB))[m
[32m+[m[32m        ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);[m
[32m+[m[32m    else if ((flags & ImGuiColorEditFlags_InputRGB) && (flags & ImGuiColorEditFlags_DisplayHSV))[m
[32m+[m[32m        ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);[m
[32m+[m[32m    int i[4] = { IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3]) };[m
[32m+[m
[32m+[m[32m    bool value_changed = false;[m
[32m+[m[32m    bool value_changed_as_float = false;[m
[32m+[m
[32m+[m[32m    if ((flags & (ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV)) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        // RGB/HSV 0..255 Sliders[m
[32m+[m[32m        const float w_item_one  = ImMax(1.0f, (float)(int)((w_items_all - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));[m
[32m+[m[32m        const float w_item_last = ImMax(1.0f, (float)(int)(w_items_all - (w_item_one + style.ItemInnerSpacing.x) * (components-1)));[m
[32m+[m
[32m+[m[32m        const bool hide_prefix = (w_item_one <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? "M:0.000" : "M:000").x);[m
[32m+[m[32m        static const char* ids[4] = { "##X", "##Y", "##Z", "##W" };[m
[32m+[m[32m        static const char* fmt_table_int[3][4] =[m
[32m+[m[32m        {[m
[32m+[m[32m            {   "%3d",   "%3d",   "%3d",   "%3d" }, // Short display[m
[32m+[m[32m            { "R:%3d", "G:%3d", "B:%3d", "A:%3d" }, // Long display for RGBA[m
[32m+[m[32m            { "H:%3d", "S:%3d", "V:%3d", "A:%3d" }  // Long display for HSVA[m
[32m+[m[32m        };[m
[32m+[m[32m        static const char* fmt_table_float[3][4] =[m
[32m+[m[32m        {[m
[32m+[m[32m            {   "%0.3f",   "%0.3f",   "%0.3f",   "%0.3f" }, // Short display[m
[32m+[m[32m            { "R:%0.3f", "G:%0.3f", "B:%0.3f", "A:%0.3f" }, // Long display for RGBA[m
[32m+[m[32m            { "H:%0.3f", "S:%0.3f", "V:%0.3f", "A:%0.3f" }  // Long display for HSVA[m
[32m+[m[32m        };[m
[32m+[m[32m        const int fmt_idx = hide_prefix ? 0 : (flags & ImGuiColorEditFlags_DisplayHSV) ? 2 : 1;[m
[32m+[m
[32m+[m[32m        for (int n = 0; n < components; n++)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (n > 0)[m
[32m+[m[32m                SameLine(0, style.ItemInnerSpacing.x);[m
[32m+[m[32m            SetNextItemWidth((n + 1 < components) ? w_item_one : w_item_last);[m
[32m+[m[32m            if (flags & ImGuiColorEditFlags_Float)[m
[32m+[m[32m            {[m
[32m+[m[32m                value_changed |= DragFloat(ids[n], &f[n], 1.0f/255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);[m
[32m+[m[32m                value_changed_as_float |= value_changed;[m
[32m+[m[32m            }[m
[32m+[m[32m            else[m
[32m+[m[32m            {[m
[32m+[m[32m                value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (!(flags & ImGuiColorEditFlags_NoOptions))[m
[32m+[m[32m                OpenPopupOnItemClick("context");[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    else if ((flags & ImGuiColorEditFlags_DisplayHex) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        // RGB Hexadecimal Input[m
[32m+[m[32m        char buf[64];[m
[32m+[m[32m        if (alpha)[m
[32m+[m[32m            ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", ImClamp(i[0],0,255), ImClamp(i[1],0,255), ImClamp(i[2],0,255), ImClamp(i[3],0,255));[m
[32m+[m[32m        else[m
[32m+[m[32m            ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", ImClamp(i[0],0,255), ImClamp(i[1],0,255), ImClamp(i[2],0,255));[m
[32m+[m[32m        SetNextItemWidth(w_items_all);[m
[32m+[m[32m        if (InputText("##Text", buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase))[m
[32m+[m[32m        {[m
[32m+[m[32m            value_changed = true;[m
[32m+[m[32m            char* p = buf;[m
[32m+[m[32m            while (*p == '#' || ImCharIsBlankA(*p))[m
[32m+[m[32m                p++;[m
[32m+[m[32m            i[0] = i[1] = i[2] = i[3] = 0;[m
[32m+[m[32m            if (alpha)[m
[32m+[m[32m                sscanf(p, "%02X%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2], (unsigned int*)&i[3]); // Treat at unsigned (%X is unsigned)[m
[32m+[m[32m            else[m
[32m+[m[32m                sscanf(p, "%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2]);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!(flags & ImGuiColorEditFlags_NoOptions))[m
[32m+[m[32m            OpenPopupOnItemClick("context");[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    ImGuiWindow* picker_active_window = NULL;[m
[32m+[m[32m    if (!(flags & ImGuiColorEditFlags_NoSmallPreview))[m
[32m+[m[32m    {[m
[32m+[m[32m        if (!(flags & ImGuiColorEditFlags_NoInputs))[m
[32m+[m[32m            SameLine(0, style.ItemInnerSpacing.x);[m
[32m+[m
[32m+[m[32m        const ImVec4 col_v4(col[0], col[1], col[2], alpha ? col[3] : 1.0f);[m
[32m+[m[32m        if (ColorButton("##ColorButton", col_v4, flags))[m
[32m+[m[32m        {[m
[32m+[m[32m            if (!(flags & ImGuiColorEditFlags_NoPicker))[m
[32m+[m[32m            {[m
[32m+[m[32m                // Store current color and open a picker[m
[32m+[m[32m                g.ColorPickerRef = col_v4;[m
[32m+[m[32m                OpenPopup("picker");[m
[32m+[m[32m                SetNextWindowPos(window->DC.LastItemRect.GetBL() + ImVec2(-1,style.ItemSpacing.y));[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!(flags & ImGuiColorEditFlags_NoOptions))[m
[32m+[m[32m            OpenPopupOnItemClick("context");[m
[32m+[m
[32m+[m[32m        if (BeginPopup("picker"))[m
[32m+[m[32m        {[m
[32m+[m[32m            picker_active_window = g.CurrentWindow;[m
[32m+[m[32m            if (label != label_display_end)[m
[32m+[m[32m            {[m
[32m+[m[32m                TextEx(label, label_display_end);[m
[32m+[m[32m                Spacing();[m
[32m+[m[32m            }[m
[32m+[m[32m            ImGuiColorEditFlags picker_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask | ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaBar;[m
[32m+[m[32m            ImGuiColorEditFlags picker_flags = (flags_untouched & picker_flags_to_forward) | ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaPreviewHalf;[m
[32m+[m[32m            SetNextItemWidth(square_sz * 12.0f); // Use 256 + bar sizes?[m
[32m+[m[32m            value_changed |= ColorPicker4("##picker", col, picker_flags, &g.ColorPickerRef.x);[m
[32m+[m[32m            EndPopup();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (label != label_display_end && !(flags & ImGuiColorEditFlags_NoLabel))[m
[32m+[m[32m    {[m
[32m+[m[32m        SameLine(0, style.ItemInnerSpacing.x);[m
[32m+[m[32m        TextEx(label, label_display_end);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Convert back[m
[32m+[m[32m    if (value_changed && picker_active_window == NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (!value_changed_as_float)[m
[32m+[m[32m            for (int n = 0; n < 4; n++)[m
[32m+[m[32m                f[n] = i[n] / 255.0f;[m
[32m+[m[32m        if ((flags & ImGuiColorEditFlags_DisplayHSV) && (flags & ImGuiColorEditFlags_InputRGB))[m
[32m+[m[32m            ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);[m
[32m+[m[32m        if ((flags & ImGuiColorEditFlags_DisplayRGB) && (flags & ImGuiColorEditFlags_InputHSV))[m
[32m+[m[32m            ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);[m
[32m+[m
[32m+[m[32m        col[0] = f[0];[m
[32m+[m[32m        col[1] = f[1];[m
[32m+[m[32m        col[2] = f[2];[m
[32m+[m[32m        if (alpha)[m
[32m+[m[32m            col[3] = f[3];[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    PopID();[m
[32m+[m[32m    EndGroup();[m
[32m+[m
[32m+[m[32m    // Drag and Drop Target[m
[32m+[m[32m    // NB: The flag test is merely an optional micro-optimization, BeginDragDropTarget() does the same test.[m
[32m+[m[32m    if ((window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropTarget())[m
[32m+[m[32m    {[m
[32m+[m[32m        bool accepted_drag_drop = false;[m
[32m+[m[32m        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))[m
[32m+[m[32m        {[m
[32m+[m[32m            memcpy((float*)col, payload->Data, sizeof(float) * 3); // Preserve alpha if any //-V512[m
[32m+[m[32m            value_changed = accepted_drag_drop = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))[m
[32m+[m[32m        {[m
[32m+[m[32m            memcpy((float*)col, payload->Data, sizeof(float) * components);[m
[32m+[m[32m            value_changed = accepted_drag_drop = true;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Drag-drop payloads are always RGB[m
[32m+[m[32m        if (accepted_drag_drop && (flags & ImGuiColorEditFlags_InputHSV))[m
[32m+[m[32m            ColorConvertRGBtoHSV(col[0], col[1], col[2], col[0], col[1], col[2]);[m
[32m+[m[32m        EndDragDropTarget();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // When picker is being actively used, use its active id so IsItemActive() will function on ColorEdit4().[m
[32m+[m[32m    if (picker_active_window && g.ActiveId != 0 && g.ActiveIdWindow == picker_active_window)[m
[32m+[m[32m        window->DC.LastItemId = g.ActiveId;[m
[32m+[m
[32m+[m[32m    if (value_changed)[m
[32m+[m[32m        MarkItemEdited(window->DC.LastItemId);[m
[32m+[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    float col4[4] = { col[0], col[1], col[2], 1.0f };[m
[32m+[m[32m    if (!ColorPicker4(label, col4, flags | ImGuiColorEditFlags_NoAlpha))[m
[32m+[m[32m        return false;[m
[32m+[m[32m    col[0] = col4[0]; col[1] = col4[1]; col[2] = col4[2];[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic inline ImU32 ImAlphaBlendColor(ImU32 col_a, ImU32 col_b)[m
[32m+[m[32m{[m
[32m+[m[32m    float t = ((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.f;[m
[32m+[m[32m    int r = ImLerp((int)(col_a >> IM_COL32_R_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_R_SHIFT) & 0xFF, t);[m
[32m+[m[32m    int g = ImLerp((int)(col_a >> IM_COL32_G_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_G_SHIFT) & 0xFF, t);[m
[32m+[m[32m    int b = ImLerp((int)(col_a >> IM_COL32_B_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_B_SHIFT) & 0xFF, t);[m
[32m+[m[32m    return IM_COL32(r, g, b, 0xFF);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Helper for ColorPicker4()[m
[32m+[m[32m// NB: This is rather brittle and will show artifact when rounding this enabled if rounded corners overlap multiple cells. Caller currently responsible for avoiding that.[m
[32m+[m[32m// I spent a non reasonable amount of time trying to getting this right for ColorButton with rounding+anti-aliasing+ImGuiColorEditFlags_HalfAlphaPreview flag + various grid sizes and offsets, and eventually gave up... probably more reasonable to disable rounding alltogether.[m
[32m+[m[32mvoid ImGui::RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 col, float grid_step, ImVec2 grid_off, float rounding, int rounding_corners_flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (((col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT) < 0xFF)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImU32 col_bg1 = GetColorU32(ImAlphaBlendColor(IM_COL32(204,204,204,255), col));[m
[32m+[m[32m        ImU32 col_bg2 = GetColorU32(ImAlphaBlendColor(IM_COL32(128,128,128,255), col));[m
[32m+[m[32m        window->DrawList->AddRectFilled(p_min, p_max, col_bg1, rounding, rounding_corners_flags);[m
[32m+[m
[32m+[m[32m        int yi = 0;[m
[32m+[m[32m        for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++)[m
[32m+[m[32m        {[m
[32m+[m[32m            float y1 = ImClamp(y, p_min.y, p_max.y), y2 = ImMin(y + grid_step, p_max.y);[m
[32m+[m[32m            if (y2 <= y1)[m
[32m+[m[32m                continue;[m
[32m+[m[32m            for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0f)[m
[32m+[m[32m            {[m
[32m+[m[32m                float x1 = ImClamp(x, p_min.x, p_max.x), x2 = ImMin(x + grid_step, p_max.x);[m
[32m+[m[32m                if (x2 <= x1)[m
[32m+[m[32m                    continue;[m
[32m+[m[32m                int rounding_corners_flags_cell = 0;[m
[32m+[m[32m                if (y1 <= p_min.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopRight; }[m
[32m+[m[32m                if (y2 >= p_max.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotRight; }[m
[32m+[m[32m                rounding_corners_flags_cell &= rounding_corners_flags;[m
[32m+[m[32m                window->DrawList->AddRectFilled(ImVec2(x1,y1), ImVec2(x2,y2), col_bg2, rounding_corners_flags_cell ? rounding : 0.0f, rounding_corners_flags_cell);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        window->DrawList->AddRectFilled(p_min, p_max, col, rounding, rounding_corners_flags);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Helper for ColorPicker4()[m
[32m+[m[32mstatic void RenderArrowsForVerticalBar(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, float bar_w)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x + 1,         pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Right, IM_COL32_BLACK);[m
[32m+[m[32m    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x,             pos.y), half_sz,                              ImGuiDir_Right, IM_COL32_WHITE);[m
[32m+[m[32m    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left,  IM_COL32_BLACK);[m
[32m+[m[32m    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x,     pos.y), half_sz,                              ImGuiDir_Left,  IM_COL32_WHITE);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Note: ColorPicker4() only accesses 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.[m
[32m+[m[32m// (In C++ the 'float col[4]' notation for a function argument is equivalent to 'float* col', we only specify a size to facilitate understanding of the code.)[m
[32m+[m[32m// FIXME: we adjust the big color square height based on item width, which may cause a flickering feedback loop (if automatic height makes a vertical scrollbar appears, affecting automatic width..)[m
[32m+[m[32mbool ImGui::ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags, const float* ref_col)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImDrawList* draw_list = window->DrawList;[m
[32m+[m[32m    ImGuiStyle& style = g.Style;[m
[32m+[m[32m    ImGuiIO& io = g.IO;[m
[32m+[m
[32m+[m[32m    PushID(label);[m
[32m+[m[32m    BeginGroup();[m
[32m+[m
[32m+[m[32m    if (!(flags & ImGuiColorEditFlags_NoSidePreview))[m
[32m+[m[32m        flags |= ImGuiColorEditFlags_NoSmallPreview;[m
[32m+[m
[32m+[m[32m    // Context menu: display and store options.[m
[32m+[m[32m    if (!(flags & ImGuiColorEditFlags_NoOptions))[m
[32m+[m[32m        ColorPickerOptionsPopup(col, flags);[m
[32m+[m
[32m+[m[32m    // Read stored options[m
[32m+[m[32m    if (!(flags & ImGuiColorEditFlags__PickerMask))[m
[32m+[m[32m        flags |= ((g.ColorEditOptions & ImGuiColorEditFlags__PickerMask) ? g.ColorEditOptions : ImGuiColorEditFlags__OptionsDefault) & ImGuiColorEditFlags__PickerMask;[m
[32m+[m[32m    if (!(flags & ImGuiColorEditFlags__InputMask))[m
[32m+[m[32m        flags |= ((g.ColorEditOptions & ImGuiColorEditFlags__InputMask) ? g.ColorEditOptions : ImGuiColorEditFlags__OptionsDefault) & ImGuiColorEditFlags__InputMask;[m
[32m+[m[32m    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__PickerMask)); // Check that only 1 is selected[m
[32m+[m[32m    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__InputMask));  // Check that only 1 is selected[m
[32m+[m[32m    if (!(flags & ImGuiColorEditFlags_NoOptions))[m
[32m+[m[32m        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_AlphaBar);[m
[32m+[m
[32m+[m[32m    // Setup[m
[32m+[m[32m    int components = (flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4;[m
[32m+[m[32m    bool alpha_bar = (flags & ImGuiColorEditFlags_AlphaBar) && !(flags & ImGuiColorEditFlags_NoAlpha);[m
[32m+[m[32m    ImVec2 picker_pos = window->DC.CursorPos;[m
[32m+[m[32m    float square_sz = GetFrameHeight();[m
[32m+[m[32m    float bars_width = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars[m
[32m+[m[32m    float sv_picker_size = ImMax(bars_width * 1, GetNextItemWidth() - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box[m
[32m+[m[32m    float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;[m
[32m+[m[32m    float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;[m
[32m+[m[32m    float bars_triangles_half_sz = (float)(int)(bars_width * 0.20f);[m
[32m+[m
[32m+[m[32m    float backup_initial_col[4];[m
[32m+[m[32m    memcpy(backup_initial_col, col, components * sizeof(float));[m
[32m+[m
[32m+[m[32m    float wheel_thickness = sv_picker_size * 0.08f;[m
[32m+[m[32m    float wheel_r_outer = sv_picker_size * 0.50f;[m
[32m+[m[32m    float wheel_r_inner = wheel_r_outer - wheel_thickness;[m
[32m+[m[32m    ImVec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width)*0.5f, picker_pos.y + sv_picker_size*0.5f);[m
[32m+[m
[32m+[m[32m    // Note: the triangle is displayed rotated with triangle_pa pointing to Hue, but most coordinates stays unrotated for logic.[m
[32m+[m[32m    float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);[m
[32m+[m[32m    ImVec2 triangle_pa = ImVec2(triangle_r, 0.0f); // Hue point.[m
[32m+[m[32m    ImVec2 triangle_pb = ImVec2(triangle_r * -0.5f, triangle_r * -0.866025f); // Black point.[m
[32m+[m[32m    ImVec2 triangle_pc = ImVec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.[m
[32m+[m
[32m+[m[32m    float H = col[0], S = col[1], V = col[2];[m
[32m+[m[32m    float R = col[0], G = col[1], B = col[2];[m
[32m+[m[32m    if (flags & ImGuiColorEditFlags_InputRGB)[m
[32m+[m[32m        ColorConvertRGBtoHSV(R, G, B, H, S, V);[m
[32m+[m[32m    else if (flags & ImGuiColorEditFlags_InputHSV)[m
[32m+[m[32m        ColorConvertHSVtoRGB(H, S, V, R, G, B);[m
[32m+[m
[32m+[m[32m    bool value_changed = false, value_changed_h = false, value_changed_sv = false;[m
[32m+[m
[32m+[m[32m    PushItemFlag(ImGuiItemFlags_NoNav, true);[m
[32m+[m[32m    if (flags & ImGuiColorEditFlags_PickerHueWheel)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Hue wheel + SV triangle logic[m
[32m+[m[32m        InvisibleButton("hsv", ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));[m
[32m+[m[32m        if (IsItemActive())[m
[32m+[m[32m        {[m
[32m+[m[32m            ImVec2 initial_off = g.IO.MouseClickedPos[0] - wheel_center;[m
[32m+[m[32m            ImVec2 current_off = g.IO.MousePos - wheel_center;[m
[32m+[m[32m            float initial_dist2 = ImLengthSqr(initial_off);[m
[32m+[m[32m            if (initial_dist2 >= (wheel_r_inner-1)*(wheel_r_inner-1) && initial_dist2 <= (wheel_r_outer+1)*(wheel_r_outer+1))[m
[32m+[m[32m            {[m
[32m+[m[32m                // Interactive with Hue wheel[m
[32m+[m[32m                H = ImAtan2(current_off.y, current_off.x) / IM_PI*0.5f;[m
[32m+[m[32m                if (H < 0.0f)[m
[32m+[m[32m                    H += 1.0f;[m
[32m+[m[32m                value_changed = value_changed_h = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            float cos_hue_angle = ImCos(-H * 2.0f * IM_PI);[m
[32m+[m[32m            float sin_hue_angle = ImSin(-H * 2.0f * IM_PI);[m
[32m+[m[32m            if (ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, ImRotate(initial_off, cos_hue_angle, sin_hue_angle)))[m
[32m+[m[32m            {[m
[32m+[m[32m                // Interacting with SV triangle[m
[32m+[m[32m                ImVec2 current_off_unrotated = ImRotate(current_off, cos_hue_angle, sin_hue_angle);[m
[32m+[m[32m                if (!ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated))[m
[32m+[m[32m                    current_off_unrotated = ImTriangleClosestPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated);[m
[32m+[m[32m                float uu, vv, ww;[m
[32m+[m[32m                ImTriangleBarycentricCoords(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated, uu, vv, ww);[m
[32m+[m[32m                V = ImClamp(1.0f - vv, 0.0001f, 1.0f);[m
[32m+[m[32m                S = ImClamp(uu / V, 0.0001f, 1.0f);[m
[32m+[m[32m                value_changed = value_changed_sv = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!(flags & ImGuiColorEditFlags_NoOptions))[m
[32m+[m[32m            OpenPopupOnItemClick("context");[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (flags & ImGuiColorEditFlags_PickerHueBar)[m
[32m+[m[32m    {[m
[32m+[m[32m        // SV rectangle logic[m
[32m+[m[32m        InvisibleButton("sv", ImVec2(sv_picker_size, sv_picker_size));[m
[32m+[m[32m        if (IsItemActive())[m
[32m+[m[32m        {[m
[32m+[m[32m            S = ImSaturate((io.MousePos.x - picker_pos.x) / (sv_picker_size-1));[m
[32m+[m[32m            V = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));[m
[32m+[m[32m            value_changed = value_changed_sv = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (!(flags & ImGuiColorEditFlags_NoOptions))[m
[32m+[m[32m            OpenPopupOnItemClick("context");[m
[32m+[m
[32m+[m[32m        // Hue bar logic[m
[32m+[m[32m        SetCursorScreenPos(ImVec2(bar0_pos_x, picker_pos.y));[m
[32m+[m[32m        InvisibleButton("hue", ImVec2(bars_width, sv_picker_size));[m
[32m+[m[32m        if (IsItemActive())[m
[32m+[m[32m        {[m
[32m+[m[32m            H = ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));[m
[32m+[m[32m            value_changed = value_changed_h = true;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Alpha bar logic[m
[32m+[m[32m    if (alpha_bar)[m
[32m+[m[32m    {[m
[32m+[m[32m        SetCursorScreenPos(ImVec2(bar1_pos_x, picker_pos.y));[m
[32m+[m[32m        InvisibleButton("alpha", ImVec2(bars_width, sv_picker_size));[m
[32m+[m[32m        if (IsItemActive())[m
[32m+[m[32m        {[m
[32m+[m[32m            col[3] = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));[m
[32m+[m[32m            value_changed = true;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    PopItemFlag(); // ImGuiItemFlags_NoNav[m
[32m+[m
[32m+[m[32m    if (!(flags & ImGuiColorEditFlags_NoSidePreview))[m
[32m+[m[32m    {[m
[32m+[m[32m        SameLine(0, style.ItemInnerSpacing.x);[m
[32m+[m[32m        BeginGroup();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (!(flags & ImGuiColorEditFlags_NoLabel))[m
[32m+[m[32m    {[m
[32m+[m[32m        const char* label_display_end = FindRenderedTextEnd(label);[m
[32m+[m[32m        if (label != label_display_end)[m
[32m+[m[32m        {[m
[32m+[m[32m            if ((flags & ImGuiColorEditFlags_NoSidePreview))[m
[32m+[m[32m                SameLine(0, style.ItemInnerSpacing.x);[m
[32m+[m[32m            TextEx(label, label_display_end);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (!(flags & ImGuiColorEditFlags_NoSidePreview))[m
[32m+[m[32m    {[m
[32m+[m[32m        PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);[m
[32m+[m[32m        ImVec4 col_v4(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);[m
[32m+[m[32m        if ((flags & ImGuiColorEditFlags_NoLabel))[m
[32m+[m[32m            Text("Current");[m
[32m+[m
[32m+[m[32m        ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf | ImGuiColorEditFlags_NoTooltip;[m
[32m+[m[32m        ColorButton("##current", col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2));[m
[32m+[m[32m        if (ref_col != NULL)[m
[32m+[m[32m        {[m
[32m+[m[32m            Text("Original");[m
[32m+[m[32m            ImVec4 ref_col_v4(ref_col[0], ref_col[1], ref_col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : ref_col[3]);[m
[32m+[m[32m            if (ColorButton("##original", ref_col_v4, (flags & sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2)))[m
[32m+[m[32m            {[m
[32m+[m[32m                memcpy(col, ref_col, components * sizeof(float));[m
[32m+[m[32m                value_changed = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        PopItemFlag();[m
[32m+[m[32m        EndGroup();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Convert back color to RGB[m
[32m+[m[32m    if (value_changed_h || value_changed_sv)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (flags & ImGuiColorEditFlags_InputRGB)[m
[32m+[m[32m        {[m
[32m+[m[32m            ColorConvertHSVtoRGB(H >= 1.0f ? H - 10 * 1e-6f : H, S > 0.0f ? S : 10*1e-6f, V > 0.0f ? V : 1e-6f, col[0], col[1], col[2]);[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (flags & ImGuiColorEditFlags_InputHSV)[m
[32m+[m[32m        {[m
[32m+[m[32m            col[0] = H;[m
[32m+[m[32m            col[1] = S;[m
[32m+[m[32m            col[2] = V;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // R,G,B and H,S,V slider color editor[m
[32m+[m[32m    bool value_changed_fix_hue_wrap = false;[m
[32m+[m[32m    if ((flags & ImGuiColorEditFlags_NoInputs) == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x);[m
[32m+[m[32m        ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf;[m
[32m+[m[32m        ImGuiColorEditFlags sub_flags = (flags & sub_flags_to_forward) | ImGuiColorEditFlags_NoPicker;[m
[32m+[m[32m        if (flags & ImGuiColorEditFlags_DisplayRGB || (flags & ImGuiColorEditFlags__DisplayMask) == 0)[m
[32m+[m[32m            if (ColorEdit4("##rgb", col, sub_flags | ImGuiColorEditFlags_DisplayRGB))[m
[32m+[m[32m            {[m
[32m+[m[32m                // FIXME: Hackily differenciating using the DragInt (ActiveId != 0 && !ActiveIdAllowOverlap) vs. using the InputText or DropTarget.[m
[32m+[m[32m                // For the later we don't want to run the hue-wrap canceling code. If you are well versed in HSV picker please provide your input! (See #2050)[m
[32m+[m[32m                value_changed_fix_hue_wrap = (g.ActiveId != 0 && !g.ActiveIdAllowOverlap);[m
[32m+[m[32m                value_changed = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        if (flags & ImGuiColorEditFlags_DisplayHSV || (flags & ImGuiColorEditFlags__DisplayMask) == 0)[m
[32m+[m[32m            value_changed |= ColorEdit4("##hsv", col, sub_flags | ImGuiColorEditFlags_DisplayHSV);[m
[32m+[m[32m        if (flags & ImGuiColorEditFlags_DisplayHex || (flags & ImGuiColorEditFlags__DisplayMask) == 0)[m
[32m+[m[32m            value_changed |= ColorEdit4("##hex", col, sub_flags | ImGuiColorEditFlags_DisplayHex);[m
[32m+[m[32m        PopItemWidth();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Try to cancel hue wrap (after ColorEdit4 call), if any[m
[32m+[m[32m    if (value_changed_fix_hue_wrap && (flags & ImGuiColorEditFlags_InputRGB))[m
[32m+[m[32m    {[m
[32m+[m[32m        float new_H, new_S, new_V;[m
[32m+[m[32m        ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);[m
[32m+[m[32m        if (new_H <= 0 && H > 0)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (new_V <= 0 && V != new_V)[m
[32m+[m[32m                ColorConvertHSVtoRGB(H, S, new_V <= 0 ? V * 0.5f : new_V, col[0], col[1], col[2]);[m
[32m+[m[32m            else if (new_S <= 0)[m
[32m+[m[32m                ColorConvertHSVtoRGB(H, new_S <= 0 ? S * 0.5f : new_S, new_V, col[0], col[1], col[2]);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (value_changed)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (flags & ImGuiColorEditFlags_InputRGB)[m
[32m+[m[32m        {[m
[32m+[m[32m            R = col[0];[m
[32m+[m[32m            G = col[1];[m
[32m+[m[32m            B = col[2];[m
[32m+[m[32m            ColorConvertRGBtoHSV(R, G, B, H, S, V);[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (flags & ImGuiColorEditFlags_InputHSV)[m
[32m+[m[32m        {[m
[32m+[m[32m            H = col[0];[m
[32m+[m[32m            S = col[1];[m
[32m+[m[32m            V = col[2];[m
[32m+[m[32m            ColorConvertHSVtoRGB(H, S, V, R, G, B);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    ImVec4 hue_color_f(1, 1, 1, 1); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);[m
[32m+[m[32m    ImU32 hue_color32 = ColorConvertFloat4ToU32(hue_color_f);[m
[32m+[m[32m    ImU32 col32_no_alpha = ColorConvertFloat4ToU32(ImVec4(R, G, B, 1.0f));[m
[32m+[m
[32m+[m[32m    const ImU32 hue_colors[6+1] = { IM_COL32(255,0,0,255), IM_COL32(255,255,0,255), IM_COL32(0,255,0,255), IM_COL32(0,255,255,255), IM_COL32(0,0,255,255), IM_COL32(255,0,255,255), IM_COL32(255,0,0,255) };[m
[32m+[m[32m    ImVec2 sv_cursor_pos;[m
[32m+[m
[32m+[m[32m    if (flags & ImGuiColorEditFlags_PickerHueWheel)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Render Hue Wheel[m
[32m+[m[32m        const float aeps = 1.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).[m
[32m+[m[32m        const int segment_per_arc = ImMax(4, (int)wheel_r_outer / 12);[m
[32m+[m[32m        for (int n = 0; n < 6; n++)[m
[32m+[m[32m        {[m
[32m+[m[32m            const float a0 = (n)     /6.0f * 2.0f * IM_PI - aeps;[m
[32m+[m[32m            const float a1 = (n+1.0f)/6.0f * 2.0f * IM_PI + aeps;[m
[32m+[m[32m            const int vert_start_idx = draw_list->VtxBuffer.Size;[m
[32m+[m[32m            draw_list->PathArcTo(wheel_center, (wheel_r_inner + wheel_r_outer)*0.5f, a0, a1, segment_per_arc);[m
[32m+[m[32m            draw_list->PathStroke(IM_COL32_WHITE, false, wheel_thickness);[m
[32m+[m[32m            const int vert_end_idx = draw_list->VtxBuffer.Size;[m
[32m+[m
[32m+[m[32m            // Paint colors over existing vertices[m
[32m+[m[32m            ImVec2 gradient_p0(wheel_center.x + ImCos(a0) * wheel_r_inner, wheel_center.y + ImSin(a0) * wheel_r_inner);[m
[32m+[m[32m            ImVec2 gradient_p1(wheel_center.x + ImCos(a1) * wheel_r_inner, wheel_center.y + ImSin(a1) * wheel_r_inner);[m
[32m+[m[32m            ShadeVertsLinearColorGradientKeepAlpha(draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, hue_colors[n], hue_colors[n+1]);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Render Cursor + preview on Hue Wheel[m
[32m+[m[32m        float cos_hue_angle = ImCos(H * 2.0f * IM_PI);[m
[32m+[m[32m        float sin_hue_angle = ImSin(H * 2.0f * IM_PI);[m
[32m+[m[32m        ImVec2 hue_cursor_pos(wheel_center.x + cos_hue_angle * (wheel_r_inner+wheel_r_outer)*0.5f, wheel_center.y + sin_hue_angle * (wheel_r_inner+wheel_r_outer)*0.5f);[m
[32m+[m[32m        float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;[m
[32m+[m[32m        int hue_cursor_segments = ImClamp((int)(hue_cursor_rad / 1.4f), 9, 32);[m
[32m+[m[32m        draw_list->AddCircleFilled(hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments);[m
[32m+[m[32m        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad+1, IM_COL32(128,128,128,255), hue_cursor_segments);[m
[32m+[m[32m        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad, IM_COL32_WHITE, hue_cursor_segments);[m
[32m+[m
[32m+[m[32m        // Render SV triangle (rotated according to hue)[m
[32m+[m[32m        ImVec2 tra = wheel_center + ImRotate(triangle_pa, cos_hue_angle, sin_hue_angle);[m
[32m+[m[32m        ImVec2 trb = wheel_center + ImRotate(triangle_pb, cos_hue_angle, sin_hue_angle);[m
[32m+[m[32m        ImVec2 trc = wheel_center + ImRotate(triangle_pc, cos_hue_angle, sin_hue_angle);[m
[32m+[m[32m        ImVec2 uv_white = GetFontTexUvWhitePixel();[m
[32m+[m[32m        draw_list->PrimReserve(6, 6);[m
[32m+[m[32m        draw_list->PrimVtx(tra, uv_white, hue_color32);[m
[32m+[m[32m        draw_list->PrimVtx(trb, uv_white, hue_color32);[m
[32m+[m[32m        draw_list->PrimVtx(trc, uv_white, IM_COL32_WHITE);[m
[32m+[m[32m        draw_list->PrimVtx(tra, uv_white, IM_COL32_BLACK_TRANS);[m
[32m+[m[32m        draw_list->PrimVtx(trb, uv_white, IM_COL32_BLACK);[m
[32m+[m[32m        draw_list->PrimVtx(trc, uv_white, IM_COL32_BLACK_TRANS);[m
[32m+[m[32m        draw_list->AddTriangle(tra, trb, trc, IM_COL32(128,128,128,255), 1.5f);[m
[32m+[m[32m        sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V));[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (flags & ImGuiColorEditFlags_PickerHueBar)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Render SV Square[m
[32m+[m[32m        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), IM_COL32_WHITE, hue_color32, hue_color32, IM_COL32_WHITE);[m
[32m+[m[32m        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), IM_COL32_BLACK_TRANS, IM_COL32_BLACK_TRANS, IM_COL32_BLACK, IM_COL32_BLACK);[m
[32m+[m[32m        RenderFrameBorder(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), 0.0f);[m
[32m+[m[32m        sv_cursor_pos.x = ImClamp((float)(int)(picker_pos.x + ImSaturate(S)     * sv_picker_size + 0.5f), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much[m
[32m+[m[32m        sv_cursor_pos.y = ImClamp((float)(int)(picker_pos.y + ImSaturate(1 - V) * sv_picker_size + 0.5f), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);[m
[32m+[m
[32m+[m[32m        // Render Hue Bar[m
[32m+[m[32m        for (int i = 0; i < 6; ++i)[m
[32m+[m[32m            draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), hue_colors[i], hue_colors[i], hue_colors[i + 1], hue_colors[i + 1]);[m
[32m+[m[32m        float bar0_line_y = (float)(int)(picker_pos.y + H * sv_picker_size + 0.5f);[m
[32m+[m[32m        RenderFrameBorder(ImVec2(bar0_pos_x, picker_pos.y), ImVec2(bar0_pos_x + bars_width, picker_pos.y + sv_picker_size), 0.0f);[m
[32m+[m[32m        RenderArrowsForVerticalBar(draw_list, ImVec2(bar0_pos_x - 1, bar0_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)[m
[32m+[m[32m    float sv_cursor_rad = value_changed_sv ? 10.0f : 6.0f;[m
[32m+[m[32m    draw_list->AddCircleFilled(sv_cursor_pos, sv_cursor_rad, col32_no_alpha, 12);[m
[32m+[m[32m    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad+1, IM_COL32(128,128,128,255), 12);[m
[32m+[m[32m    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, IM_COL32_WHITE, 12);[m
[32m+[m
[32m+[m[32m    // Render alpha bar[m
[32m+[m[32m    if (alpha_bar)[m
[32m+[m[32m    {[m
[32m+[m[32m        float alpha = ImSaturate(col[3]);[m
[32m+[m[32m        ImRect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size);[m
[32m+[m[32m        RenderColorRectWithAlphaCheckerboard(bar1_bb.Min, bar1_bb.Max, IM_COL32(0,0,0,0), bar1_bb.GetWidth() / 2.0f, ImVec2(0.0f, 0.0f));[m
[32m+[m[32m        draw_list->AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max, col32_no_alpha, col32_no_alpha, col32_no_alpha & ~IM_COL32_A_MASK, col32_no_alpha & ~IM_COL32_A_MASK);[m
[32m+[m[32m        float bar1_line_y = (float)(int)(picker_pos.y + (1.0f - alpha) * sv_picker_size + 0.5f);[m
[32m+[m[32m        RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);[m
[32m+[m[32m        RenderArrowsForVerticalBar(draw_list, ImVec2(bar1_pos_x - 1, bar1_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    EndGroup();[m
[32m+[m
[32m+[m[32m    if (value_changed && memcmp(backup_initial_col, col, components * sizeof(float)) == 0)[m
[32m+[m[32m        value_changed = false;[m
[32m+[m[32m    if (value_changed)[m
[32m+[m[32m        MarkItemEdited(window->DC.LastItemId);[m
[32m+[m
[32m+[m[32m    PopID();[m
[32m+[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// A little colored square. Return true when clicked.[m
[32m+[m[32m// FIXME: May want to display/ignore the alpha component in the color display? Yet show it in the tooltip.[m
[32m+[m[32m// 'desc_id' is not called 'label' because we don't display it next to the button, but only in the tooltip.[m
[32m+[m[32m// Note that 'col' may be encoded in HSV if ImGuiColorEditFlags_InputHSV is set.[m
[32m+[m[32mbool ImGui::ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags, ImVec2 size)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiID id = window->GetID(desc_id);[m
[32m+[m[32m    float default_size = GetFrameHeight();[m
[32m+[m[32m    if (size.x == 0.0f)[m
[32m+[m[32m        size.x = default_size;[m
[32m+[m[32m    if (size.y == 0.0f)[m
[32m+[m[32m        size.y = default_size;[m
[32m+[m[32m    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);[m
[32m+[m[32m    ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);[m
[32m+[m[32m    if (!ItemAdd(bb, id))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    bool hovered, held;[m
[32m+[m[32m    bool pressed = ButtonBehavior(bb, id, &hovered, &held);[m
[32m+[m
[32m+[m[32m    if (flags & ImGuiColorEditFlags_NoAlpha)[m
[32m+[m[32m        flags &= ~(ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf);[m
[32m+[m
[32m+[m[32m    ImVec4 col_rgb = col;[m
[32m+[m[32m    if (flags & ImGuiColorEditFlags_InputHSV)[m
[32m+[m[32m        ColorConvertHSVtoRGB(col_rgb.x, col_rgb.y, col_rgb.z, col_rgb.x, col_rgb.y, col_rgb.z);[m
[32m+[m
[32m+[m[32m    ImVec4 col_rgb_without_alpha(col_rgb.x, col_rgb.y, col_rgb.z, 1.0f);[m
[32m+[m[32m    float grid_step = ImMin(size.x, size.y) / 2.99f;[m
[32m+[m[32m    float rounding = ImMin(g.Style.FrameRounding, grid_step * 0.5f);[m
[32m+[m[32m    ImRect bb_inner = bb;[m
[32m+[m[32m    float off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.[m
[32m+[m[32m    bb_inner.Expand(off);[m
[32m+[m[32m    if ((flags & ImGuiColorEditFlags_AlphaPreviewHalf) && col_rgb.w < 1.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        float mid_x = (float)(int)((bb_inner.Min.x + bb_inner.Max.x) * 0.5f + 0.5f);[m
[32m+[m[32m        RenderColorRectWithAlphaCheckerboard(ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col_rgb), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawCornerFlags_TopRight| ImDrawCornerFlags_BotRight);[m
[32m+[m[32m        window->DrawList->AddRectFilled(bb_inner.Min, ImVec2(mid_x, bb_inner.Max.y), GetColorU32(col_rgb_without_alpha), rounding, ImDrawCornerFlags_TopLeft|ImDrawCornerFlags_BotLeft);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha[m
[32m+[m[32m        ImVec4 col_source = (flags & ImGuiColorEditFlags_AlphaPreview) ? col_rgb : col_rgb_without_alpha;[m
[32m+[m[32m        if (col_source.w < 1.0f)[m
[32m+[m[32m            RenderColorRectWithAlphaCheckerboard(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);[m
[32m+[m[32m        else[m
[32m+[m[32m            window->DrawList->AddRectFilled(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), rounding, ImDrawCornerFlags_All);[m
[32m+[m[32m    }[m
[32m+[m[32m    RenderNavHighlight(bb, id);[m
[32m+[m[32m    if (g.Style.FrameBorderSize > 0.0f)[m
[32m+[m[32m        RenderFrameBorder(bb.Min, bb.Max, rounding);[m
[32m+[m[32m    else[m
[32m+[m[32m        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), rounding); // Color button are often in need of some sort of border[m
[32m+[m
[32m+[m[32m    // Drag and Drop Source[m
[32m+[m[32m    // NB: The ActiveId test is merely an optional micro-optimization, BeginDragDropSource() does the same test.[m
[32m+[m[32m    if (g.ActiveId == id && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropSource())[m
[32m+[m[32m    {[m
[32m+[m[32m        if (flags & ImGuiColorEditFlags_NoAlpha)[m
[32m+[m[32m            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &col_rgb, sizeof(float) * 3, ImGuiCond_Once);[m
[32m+[m[32m        else[m
[32m+[m[32m            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, &col_rgb, sizeof(float) * 4, ImGuiCond_Once);[m
[32m+[m[32m        ColorButton(desc_id, col, flags);[m
[32m+[m[32m        SameLine();[m
[32m+[m[32m        TextEx("Color");[m
[32m+[m[32m        EndDragDropSource();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Tooltip[m
[32m+[m[32m    if (!(flags & ImGuiColorEditFlags_NoTooltip) && hovered)[m
[32m+[m[32m        ColorTooltip(desc_id, &col.x, flags & (ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf));[m
[32m+[m
[32m+[m[32m    if (pressed)[m
[32m+[m[32m        MarkItemEdited(id);[m
[32m+[m
[32m+[m[32m    return pressed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Initialize/override default color options[m
[32m+[m[32mvoid ImGui::SetColorEditOptions(ImGuiColorEditFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if ((flags & ImGuiColorEditFlags__DisplayMask) == 0)[m
[32m+[m[32m        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__DisplayMask;[m
[32m+[m[32m    if ((flags & ImGuiColorEditFlags__DataTypeMask) == 0)[m
[32m+[m[32m        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__DataTypeMask;[m
[32m+[m[32m    if ((flags & ImGuiColorEditFlags__PickerMask) == 0)[m
[32m+[m[32m        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__PickerMask;[m
[32m+[m[32m    if ((flags & ImGuiColorEditFlags__InputMask) == 0)[m
[32m+[m[32m        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__InputMask;[m
[32m+[m[32m    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__DisplayMask));    // Check only 1 option is selected[m
[32m+[m[32m    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__DataTypeMask));   // Check only 1 option is selected[m
[32m+[m[32m    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__PickerMask));     // Check only 1 option is selected[m
[32m+[m[32m    IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiColorEditFlags__InputMask));      // Check only 1 option is selected[m
[32m+[m[32m    g.ColorEditOptions = flags;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.[m
[32m+[m[32mvoid ImGui::ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    BeginTooltipEx(0, true);[m
[32m+[m[32m    const char* text_end = text ? FindRenderedTextEnd(text, NULL) : text;[m
[32m+[m[32m    if (text_end > text)[m
[32m+[m[32m    {[m
[32m+[m[32m        TextEx(text, text_end);[m
[32m+[m[32m        Separator();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    ImVec2 sz(g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2);[m
[32m+[m[32m    ImVec4 cf(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);[m
[32m+[m[32m    int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);[m
[32m+[m[32m    ColorButton("##preview", cf, (flags & (ImGuiColorEditFlags__InputMask | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf)) | ImGuiColorEditFlags_NoTooltip, sz);[m
[32m+[m[32m    SameLine();[m
[32m+[m[32m    if ((flags & ImGuiColorEditFlags_InputRGB) || !(flags & ImGuiColorEditFlags__InputMask))[m
[32m+[m[32m    {[m
[32m+[m[32m        if (flags & ImGuiColorEditFlags_NoAlpha)[m
[32m+[m[32m            Text("#%02X%02X%02X\nR: %d, G: %d, B: %d\n(%.3f, %.3f, %.3f)", cr, cg, cb, cr, cg, cb, col[0], col[1], col[2]);[m
[32m+[m[32m        else[m
[32m+[m[32m            Text("#%02X%02X%02X%02X\nR:%d, G:%d, B:%d, A:%d\n(%.3f, %.3f, %.3f, %.3f)", cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]);[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (flags & ImGuiColorEditFlags_InputHSV)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (flags & ImGuiColorEditFlags_NoAlpha)[m
[32m+[m[32m            Text("H: %.3f, S: %.3f, V: %.3f", col[0], col[1], col[2]);[m
[32m+[m[32m        else[m
[32m+[m[32m            Text("H: %.3f, S: %.3f, V: %.3f, A: %.3f", col[0], col[1], col[2], col[3]);[m
[32m+[m[32m    }[m
[32m+[m[32m    EndTooltip();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    bool allow_opt_inputs = !(flags & ImGuiColorEditFlags__DisplayMask);[m
[32m+[m[32m    bool allow_opt_datatype = !(flags & ImGuiColorEditFlags__DataTypeMask);[m
[32m+[m[32m    if ((!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup("context"))[m
[32m+[m[32m        return;[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiColorEditFlags opts = g.ColorEditOptions;[m
[32m+[m[32m    if (allow_opt_inputs)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (RadioButton("RGB", (opts & ImGuiColorEditFlags_DisplayRGB) != 0)) opts = (opts & ~ImGuiColorEditFlags__DisplayMask) | ImGuiColorEditFlags_DisplayRGB;[m
[32m+[m[32m        if (RadioButton("HSV", (opts & ImGuiColorEditFlags_DisplayHSV) != 0)) opts = (opts & ~ImGuiColorEditFlags__DisplayMask) | ImGuiColorEditFlags_DisplayHSV;[m
[32m+[m[32m        if (RadioButton("Hex", (opts & ImGuiColorEditFlags_DisplayHex) != 0)) opts = (opts & ~ImGuiColorEditFlags__DisplayMask) | ImGuiColorEditFlags_DisplayHex;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (allow_opt_datatype)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (allow_opt_inputs) Separator();[m
[32m+[m[32m        if (RadioButton("0..255",     (opts & ImGuiColorEditFlags_Uint8) != 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Uint8;[m
[32m+[m[32m        if (RadioButton("0.00..1.00", (opts & ImGuiColorEditFlags_Float) != 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Float;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (allow_opt_inputs || allow_opt_datatype)[m
[32m+[m[32m        Separator();[m
[32m+[m[32m    if (Button("Copy as..", ImVec2(-1,0)))[m
[32m+[m[32m        OpenPopup("Copy");[m
[32m+[m[32m    if (BeginPopup("Copy"))[m
[32m+[m[32m    {[m
[32m+[m[32m        int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);[m
[32m+[m[32m        char buf[64];[m
[32m+[m[32m        ImFormatString(buf, IM_ARRAYSIZE(buf), "(%.3ff, %.3ff, %.3ff, %.3ff)", col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);[m
[32m+[m[32m        if (Selectable(buf))[m
[32m+[m[32m            SetClipboardText(buf);[m
[32m+[m[32m        ImFormatString(buf, IM_ARRAYSIZE(buf), "(%d,%d,%d,%d)", cr, cg, cb, ca);[m
[32m+[m[32m        if (Selectable(buf))[m
[32m+[m[32m            SetClipboardText(buf);[m
[32m+[m[32m        if (flags & ImGuiColorEditFlags_NoAlpha)[m
[32m+[m[32m            ImFormatString(buf, IM_ARRAYSIZE(buf), "0x%02X%02X%02X", cr, cg, cb);[m
[32m+[m[32m        else[m
[32m+[m[32m            ImFormatString(buf, IM_ARRAYSIZE(buf), "0x%02X%02X%02X%02X", cr, cg, cb, ca);[m
[32m+[m[32m        if (Selectable(buf))[m
[32m+[m[32m            SetClipboardText(buf);[m
[32m+[m[32m        EndPopup();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    g.ColorEditOptions = opts;[m
[32m+[m[32m    EndPopup();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    bool allow_opt_picker = !(flags & ImGuiColorEditFlags__PickerMask);[m
[32m+[m[32m    bool allow_opt_alpha_bar = !(flags & ImGuiColorEditFlags_NoAlpha) && !(flags & ImGuiColorEditFlags_AlphaBar);[m
[32m+[m[32m    if ((!allow_opt_picker && !allow_opt_alpha_bar) || !BeginPopup("context"))[m
[32m+[m[32m        return;[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (allow_opt_picker)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function[m
[32m+[m[32m        PushItemWidth(picker_size.x);[m
[32m+[m[32m        for (int picker_type = 0; picker_type < 2; picker_type++)[m
[32m+[m[32m        {[m
[32m+[m[32m            // Draw small/thumbnail version of each picker type (over an invisible button for selection)[m
[32m+[m[32m            if (picker_type > 0) Separator();[m
[32m+[m[32m            PushID(picker_type);[m
[32m+[m[32m            ImGuiColorEditFlags picker_flags = ImGuiColorEditFlags_NoInputs|ImGuiColorEditFlags_NoOptions|ImGuiColorEditFlags_NoLabel|ImGuiColorEditFlags_NoSidePreview|(flags & ImGuiColorEditFlags_NoAlpha);[m
[32m+[m[32m            if (picker_type == 0) picker_flags |= ImGuiColorEditFlags_PickerHueBar;[m
[32m+[m[32m            if (picker_type == 1) picker_flags |= ImGuiColorEditFlags_PickerHueWheel;[m
[32m+[m[32m            ImVec2 backup_pos = GetCursorScreenPos();[m
[32m+[m[32m            if (Selectable("##selectable", false, 0, picker_size)) // By default, Selectable() is closing popup[m
[32m+[m[32m                g.ColorEditOptions = (g.ColorEditOptions & ~ImGuiColorEditFlags__PickerMask) | (picker_flags & ImGuiColorEditFlags__PickerMask);[m
[32m+[m[32m            SetCursorScreenPos(backup_pos);[m
[32m+[m[32m            ImVec4 dummy_ref_col;[m
[32m+[m[32m            memcpy(&dummy_ref_col, ref_col, sizeof(float) * ((picker_flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4));[m
[32m+[m[32m            ColorPicker4("##dummypicker", &dummy_ref_col.x, picker_flags);[m
[32m+[m[32m            PopID();[m
[32m+[m[32m        }[m
[32m+[m[32m        PopItemWidth();[m
[32m+[m[32m    }[m
[32m+[m[32m    if (allow_opt_alpha_bar)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (allow_opt_picker) Separator();[m
[32m+[m[32m        CheckboxFlags("Alpha Bar", (unsigned int*)&g.ColorEditOptions, ImGuiColorEditFlags_AlphaBar);[m
[32m+[m[32m    }[m
[32m+[m[32m    EndPopup();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - TreeNode()[m
[32m+[m[32m// - TreeNodeV()[m
[32m+[m[32m// - TreeNodeEx()[m
[32m+[m[32m// - TreeNodeExV()[m
[32m+[m[32m// - TreeNodeBehavior() [Internal][m
[32m+[m[32m// - TreePush()[m
[32m+[m[32m// - TreePop()[m
[32m+[m[32m// - TreeAdvanceToLabelPos()[m
[32m+[m[32m// - GetTreeNodeToLabelSpacing()[m
[32m+[m[32m// - SetNextTreeNodeOpen()[m
[32m+[m[32m// - CollapsingHeader()[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mbool ImGui::TreeNode(const char* str_id, const char* fmt, ...)[m
[32m+[m[32m{[m
[32m+[m[32m    va_list args;[m
[32m+[m[32m    va_start(args, fmt);[m
[32m+[m[32m    bool is_open = TreeNodeExV(str_id, 0, fmt, args);[m
[32m+[m[32m    va_end(args);[m
[32m+[m[32m    return is_open;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)[m
[32m+[m[32m{[m
[32m+[m[32m    va_list args;[m
[32m+[m[32m    va_start(args, fmt);[m
[32m+[m[32m    bool is_open = TreeNodeExV(ptr_id, 0, fmt, args);[m
[32m+[m[32m    va_end(args);[m
[32m+[m[32m    return is_open;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::TreeNode(const char* label)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m[32m    return TreeNodeBehavior(window->GetID(label), 0, label, NULL);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)[m
[32m+[m[32m{[m
[32m+[m[32m    return TreeNodeExV(str_id, 0, fmt, args);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)[m
[32m+[m[32m{[m
[32m+[m[32m    return TreeNodeExV(ptr_id, 0, fmt, args);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    return TreeNodeBehavior(window->GetID(label), flags, label, NULL);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)[m
[32m+[m[32m{[m
[32m+[m[32m    va_list args;[m
[32m+[m[32m    va_start(args, fmt);[m
[32m+[m[32m    bool is_open = TreeNodeExV(str_id, flags, fmt, args);[m
[32m+[m[32m    va_end(args);[m
[32m+[m[32m    return is_open;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)[m
[32m+[m[32m{[m
[32m+[m[32m    va_list args;[m
[32m+[m[32m    va_start(args, fmt);[m
[32m+[m[32m    bool is_open = TreeNodeExV(ptr_id, flags, fmt, args);[m
[32m+[m[32m    va_end(args);[m
[32m+[m[32m    return is_open;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);[m
[32m+[m[32m    return TreeNodeBehavior(window->GetID(str_id), flags, g.TempBuffer, label_end);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);[m
[32m+[m[32m    return TreeNodeBehavior(window->GetID(ptr_id), flags, g.TempBuffer, label_end);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    if (flags & ImGuiTreeNodeFlags_Leaf)[m
[32m+[m[32m        return true;[m
[32m+[m
[32m+[m[32m    // We only write to the tree storage if the user clicks (or explicitly use SetNextTreeNode*** functions)[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    ImGuiStorage* storage = window->DC.StateStorage;[m
[32m+[m
[32m+[m[32m    bool is_open;[m
[32m+[m[32m    if (g.NextTreeNodeOpenCond != 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (g.NextTreeNodeOpenCond & ImGuiCond_Always)[m
[32m+[m[32m        {[m
[32m+[m[32m            is_open = g.NextTreeNodeOpenVal;[m
[32m+[m[32m            storage->SetInt(id, is_open);[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            // We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.[m
[32m+[m[32m            const int stored_value = storage->GetInt(id, -1);[m
[32m+[m[32m            if (stored_value == -1)[m
[32m+[m[32m            {[m
[32m+[m[32m                is_open = g.NextTreeNodeOpenVal;[m
[32m+[m[32m                storage->SetInt(id, is_open);[m
[32m+[m[32m            }[m
[32m+[m[32m            else[m
[32m+[m[32m            {[m
[32m+[m[32m                is_open = stored_value != 0;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        g.NextTreeNodeOpenCond = 0;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        is_open = storage->GetInt(id, (flags & ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).[m
[32m+[m[32m    // NB- If we are above max depth we still allow manually opened nodes to be logged.[m
[32m+[m[32m    if (g.LogEnabled && !(flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog) && (window->DC.TreeDepth - g.LogDepthRef) < g.LogDepthToExpand)[m
[32m+[m[32m        is_open = true;[m
[32m+[m
[32m+[m[32m    return is_open;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    const bool display_frame = (flags & ImGuiTreeNodeFlags_Framed) != 0;[m
[32m+[m[32m    const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, 0.0f);[m
[32m+[m
[32m+[m[32m    if (!label_end)[m
[32m+[m[32m        label_end = FindRenderedTextEnd(label);[m
[32m+[m[32m    const ImVec2 label_size = CalcTextSize(label, label_end, false);[m
[32m+[m
[32m+[m[32m    // We vertically grow up to current line height up the typical widget height.[m
[32m+[m[32m    const float text_base_offset_y = ImMax(padding.y, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it[m
[32m+[m[32m    const float frame_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + style.FramePadding.y*2), label_size.y + padding.y*2);[m
[32m+[m[32m    ImRect frame_bb = ImRect(window->DC.CursorPos, ImVec2(GetWorkRectMax().x, window->DC.CursorPos.y + frame_height));[m
[32m+[m[32m    if (display_frame)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Framed header expand a little outside the default padding[m
[32m+[m[32m        frame_bb.Min.x -= (float)(int)(window->WindowPadding.x*0.5f) - 1;[m
[32m+[m[32m        frame_bb.Max.x += (float)(int)(window->WindowPadding.x*0.5f) - 1;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    const float text_offset_x = (g.FontSize + (display_frame ? padding.x*3 : padding.x*2));   // Collapser arrow width + Spacing[m
[32m+[m[32m    const float text_width = g.FontSize + (label_size.x > 0.0f ? label_size.x + padding.x*2 : 0.0f);   // Include collapser[m
[32m+[m[32m    ItemSize(ImVec2(text_width, frame_height), text_base_offset_y);[m
[32m+[m
[32m+[m[32m    // For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing[m
[32m+[m[32m    // (Ideally we'd want to add a flag for the user to specify if we want the hit test to be done up to the right side of the content or not)[m
[32m+[m[32m    const ImRect interact_bb = display_frame ? frame_bb : ImRect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + text_width + style.ItemSpacing.x*2, frame_bb.Max.y);[m
[32m+[m[32m    bool is_open = TreeNodeBehaviorIsOpen(id, flags);[m
[32m+[m[32m    bool is_leaf = (flags & ImGuiTreeNodeFlags_Leaf) != 0;[m
[32m+[m
[32m+[m[32m    // Store a flag for the current depth to tell if we will allow closing this node when navigating one of its child.[m
[32m+[m[32m    // For this purpose we essentially compare if g.NavIdIsAlive went from 0 to 1 between TreeNode() and TreePop().[m
[32m+[m[32m    // This is currently only support 32 level deep and we are fine with (1 << Depth) overflowing into a zero.[m
[32m+[m[32m    if (is_open && !g.NavIdIsAlive && (flags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere) && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))[m
[32m+[m[32m        window->DC.TreeStoreMayJumpToParentOnPop |= (1 << window->DC.TreeDepth);[m
[32m+[m
[32m+[m[32m    bool item_add = ItemAdd(interact_bb, id);[m
[32m+[m[32m    window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HasDisplayRect;[m
[32m+[m[32m    window->DC.LastItemDisplayRect = frame_bb;[m
[32m+[m
[32m+[m[32m    if (!item_add)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))[m
[32m+[m[32m            TreePushOverrideID(id);[m
[32m+[m[32m        IMGUI_TEST_ENGINE_ITEM_INFO(window->DC.LastItemId, label, window->DC.ItemFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));[m
[32m+[m[32m        return is_open;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Flags that affects opening behavior:[m
[32m+[m[32m    // - 0 (default) .................... single-click anywhere to open[m
[32m+[m[32m    // - OpenOnDoubleClick .............. double-click anywhere to open[m
[32m+[m[32m    // - OpenOnArrow .................... single-click on arrow to open[m
[32m+[m[32m    // - OpenOnDoubleClick|OpenOnArrow .. single-click on arrow or double-click anywhere to open[m
[32m+[m[32m    ImGuiButtonFlags button_flags = ImGuiButtonFlags_NoKeyModifiers;[m
[32m+[m[32m    if (flags & ImGuiTreeNodeFlags_AllowItemOverlap)[m
[32m+[m[32m        button_flags |= ImGuiButtonFlags_AllowItemOverlap;[m
[32m+[m[32m    if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)[m
[32m+[m[32m        button_flags |= ImGuiButtonFlags_PressedOnDoubleClick | ((flags & ImGuiTreeNodeFlags_OpenOnArrow) ? ImGuiButtonFlags_PressedOnClickRelease : 0);[m
[32m+[m[32m    if (!is_leaf)[m
[32m+[m[32m        button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;[m
[32m+[m
[32m+[m[32m    bool selected = (flags & ImGuiTreeNodeFlags_Selected) != 0;[m
[32m+[m[32m    const bool was_selected = selected;[m
[32m+[m
[32m+[m[32m    bool hovered, held;[m
[32m+[m[32m    bool pressed = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags);[m
[32m+[m[32m    bool toggled = false;[m
[32m+[m[32m    if (!is_leaf)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (pressed)[m
[32m+[m[32m        {[m
[32m+[m[32m            toggled = !(flags & (ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick)) || (g.NavActivateId == id);[m
[32m+[m[32m            if (flags & ImGuiTreeNodeFlags_OpenOnArrow)[m
[32m+[m[32m                toggled |= IsMouseHoveringRect(interact_bb.Min, ImVec2(interact_bb.Min.x + text_offset_x, interact_bb.Max.y)) && (!g.NavDisableMouseHover);[m
[32m+[m[32m            if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)[m
[32m+[m[32m                toggled |= g.IO.MouseDoubleClicked[0];[m
[32m+[m[32m            if (g.DragDropActive && is_open) // When using Drag and Drop "hold to open" we keep the node highlighted after opening, but never close it again.[m
[32m+[m[32m                toggled = false;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Left && is_open)[m
[32m+[m[32m        {[m
[32m+[m[32m            toggled = true;[m
[32m+[m[32m            NavMoveRequestCancel();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right && !is_open) // If there's something upcoming on the line we may want to give it the priority?[m
[32m+[m[32m        {[m
[32m+[m[32m            toggled = true;[m
[32m+[m[32m            NavMoveRequestCancel();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (toggled)[m
[32m+[m[32m        {[m
[32m+[m[32m            is_open = !is_open;[m
[32m+[m[32m            window->DC.StateStorage->SetInt(id, is_open);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    if (flags & ImGuiTreeNodeFlags_AllowItemOverlap)[m
[32m+[m[32m        SetItemAllowOverlap();[m
[32m+[m
[32m+[m[32m    // In this branch, TreeNodeBehavior() cannot toggle the selection so this will never trigger.[m
[32m+[m[32m    if (selected != was_selected) //-V547[m
[32m+[m[32m        window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_ToggledSelection;[m
[32m+[m
[32m+[m[32m    // Render[m
[32m+[m[32m    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);[m
[32m+[m[32m    const ImVec2 text_pos = frame_bb.Min + ImVec2(text_offset_x, text_base_offset_y);[m
[32m+[m[32m    ImGuiNavHighlightFlags nav_highlight_flags = ImGuiNavHighlightFlags_TypeThin;[m
[32m+[m[32m    if (display_frame)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Framed type[m
[32m+[m[32m        RenderFrame(frame_bb.Min, frame_bb.Max, col, true, style.FrameRounding);[m
[32m+[m[32m        RenderNavHighlight(frame_bb, id, nav_highlight_flags);[m
[32m+[m[32m        RenderArrow(frame_bb.Min + ImVec2(padding.x, text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 1.0f);[m
[32m+[m[32m        if (g.LogEnabled)[m
[32m+[m[32m        {[m
[32m+[m[32m            // NB: '##' is normally used to hide text (as a library-wide feature), so we need to specify the text range to make sure the ## aren't stripped out here.[m
[32m+[m[32m            const char log_prefix[] = "\n##";[m
[32m+[m[32m            const char log_suffix[] = "##";[m
[32m+[m[32m            LogRenderedText(&text_pos, log_prefix, log_prefix+3);[m
[32m+[m[32m            RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);[m
[32m+[m[32m            LogRenderedText(&text_pos, log_suffix, log_suffix+2);[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m            RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // Unframed typed for tree nodes[m
[32m+[m[32m        if (hovered || selected)[m
[32m+[m[32m        {[m
[32m+[m[32m            RenderFrame(frame_bb.Min, frame_bb.Max, col, false);[m
[32m+[m[32m            RenderNavHighlight(frame_bb, id, nav_highlight_flags);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (flags & ImGuiTreeNodeFlags_Bullet)[m
[32m+[m[32m            RenderBullet(frame_bb.Min + ImVec2(text_offset_x * 0.5f, g.FontSize*0.50f + text_base_offset_y));[m
[32m+[m[32m        else if (!is_leaf)[m
[32m+[m[32m            RenderArrow(frame_bb.Min + ImVec2(padding.x, g.FontSize*0.15f + text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 0.70f);[m
[32m+[m[32m        if (g.LogEnabled)[m
[32m+[m[32m            LogRenderedText(&text_pos, ">");[m
[32m+[m[32m        RenderText(text_pos, label, label_end, false);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))[m
[32m+[m[32m        TreePushOverrideID(id);[m
[32m+[m[32m    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));[m
[32m+[m[32m    return is_open;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::TreePush(const char* str_id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    Indent();[m
[32m+[m[32m    window->DC.TreeDepth++;[m
[32m+[m[32m    PushID(str_id ? str_id : "#TreePush");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::TreePush(const void* ptr_id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    Indent();[m
[32m+[m[32m    window->DC.TreeDepth++;[m
[32m+[m[32m    PushID(ptr_id ? ptr_id : (const void*)"#TreePush");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::TreePushOverrideID(ImGuiID id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    Indent();[m
[32m+[m[32m    window->DC.TreeDepth++;[m
[32m+[m[32m    window->IDStack.push_back(id);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::TreePop()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    Unindent();[m
[32m+[m
[32m+[m[32m    window->DC.TreeDepth--;[m
[32m+[m[32m    if (g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet())[m
[32m+[m[32m        if (g.NavIdIsAlive && (window->DC.TreeStoreMayJumpToParentOnPop & (1 << window->DC.TreeDepth)))[m
[32m+[m[32m        {[m
[32m+[m[32m            SetNavID(window->IDStack.back(), g.NavLayer);[m
[32m+[m[32m            NavMoveRequestCancel();[m
[32m+[m[32m        }[m
[32m+[m[32m    window->DC.TreeStoreMayJumpToParentOnPop &= (1 << window->DC.TreeDepth) - 1;[m
[32m+[m
[32m+[m[32m    IM_ASSERT(window->IDStack.Size > 1); // There should always be 1 element in the IDStack (pushed during window creation). If this triggers you called TreePop/PopID too much.[m
[32m+[m[32m    PopID();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::TreeAdvanceToLabelPos()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.CurrentWindow->DC.CursorPos.x += GetTreeNodeToLabelSpacing();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Horizontal distance preceding label when using TreeNode() or Bullet()[m
[32m+[m[32mfloat ImGui::GetTreeNodeToLabelSpacing()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.FontSize + (g.Style.FramePadding.x * 2.0f);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::SetNextTreeNodeOpen(bool is_open, ImGuiCond cond)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.CurrentWindow->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m[32m    g.NextTreeNodeOpenVal = is_open;[m
[32m+[m[32m    g.NextTreeNodeOpenCond = cond ? cond : ImGuiCond_Always;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// CollapsingHeader returns true when opened but do not indent nor push into the ID stack (because of the ImGuiTreeNodeFlags_NoTreePushOnOpen flag).[m
[32m+[m[32m// This is basically the same as calling TreeNodeEx(label, ImGuiTreeNodeFlags_CollapsingHeader). You can remove the _NoTreePushOnOpen flag if you want behavior closer to normal TreeNode().[m
[32m+[m[32mbool ImGui::CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    return TreeNodeBehavior(window->GetID(label), flags | ImGuiTreeNodeFlags_CollapsingHeader, label);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    if (p_open && !*p_open)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiID id = window->GetID(label);[m
[32m+[m[32m    bool is_open = TreeNodeBehavior(id, flags | ImGuiTreeNodeFlags_CollapsingHeader | (p_open ? ImGuiTreeNodeFlags_AllowItemOverlap : 0), label);[m
[32m+[m[32m    if (p_open)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Create a small overlapping close button // FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.[m
[32m+[m[32m        ImGuiContext& g = *GImGui;[m
[32m+[m[32m        ImGuiItemHoveredDataBackup last_item_backup;[m
[32m+[m[32m        float button_radius = g.FontSize * 0.5f;[m
[32m+[m[32m        ImVec2 button_center = ImVec2(ImMin(window->DC.LastItemRect.Max.x, window->ClipRect.Max.x) - g.Style.FramePadding.x - button_radius, window->DC.LastItemRect.GetCenter().y);[m
[32m+[m[32m        if (CloseButton(window->GetID((void*)((intptr_t)id+1)), button_center, button_radius))[m
[32m+[m[32m            *p_open = false;[m
[32m+[m[32m        last_item_backup.Restore();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return is_open;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Widgets: Selectable[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - Selectable()[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Tip: pass a non-visible label (e.g. "##dummy") then you can use the space to draw other text or image.[m
[32m+[m[32m// But you need to make sure the ID is unique, e.g. enclose calls in PushID/PopID or use ##unique_id.[m
[32m+[m[32mbool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m
[32m+[m[32m    if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.CurrentColumns) // FIXME-OPT: Avoid if vertically clipped.[m
[32m+[m[32m        PopClipRect();[m
[32m+[m
[32m+[m[32m    ImGuiID id = window->GetID(label);[m
[32m+[m[32m    ImVec2 label_size = CalcTextSize(label, NULL, true);[m
[32m+[m[32m    ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);[m
[32m+[m[32m    ImVec2 pos = window->DC.CursorPos;[m
[32m+[m[32m    pos.y += window->DC.CurrentLineTextBaseOffset;[m
[32m+[m[32m    ImRect bb_inner(pos, pos + size);[m
[32m+[m[32m    ItemSize(size);[m
[32m+[m
[32m+[m[32m    // Fill horizontal space.[m
[32m+[m[32m    ImVec2 window_padding = window->WindowPadding;[m
[32m+[m[32m    float max_x = (flags & ImGuiSelectableFlags_SpanAllColumns) ? GetWindowContentRegionMax().x : GetContentRegionMax().x;[m
[32m+[m[32m    float w_draw = ImMax(label_size.x, window->Pos.x + max_x - window_padding.x - pos.x);[m
[32m+[m[32m    ImVec2 size_draw((size_arg.x != 0 && !(flags & ImGuiSelectableFlags_DrawFillAvailWidth)) ? size_arg.x : w_draw, size_arg.y != 0.0f ? size_arg.y : size.y);[m
[32m+[m[32m    ImRect bb(pos, pos + size_draw);[m
[32m+[m[32m    if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_DrawFillAvailWidth))[m
[32m+[m[32m        bb.Max.x += window_padding.x;[m
[32m+[m
[32m+[m[32m    // Selectables are tightly packed together so we extend the box to cover spacing between selectable.[m
[32m+[m[32m    const float spacing_x = style.ItemSpacing.x;[m
[32m+[m[32m    const float spacing_y = style.ItemSpacing.y;[m
[32m+[m[32m    const float spacing_L = (float)(int)(spacing_x * 0.50f);[m
[32m+[m[32m    const float spacing_U = (float)(int)(spacing_y * 0.50f);[m
[32m+[m[32m    bb.Min.x -= spacing_L;[m
[32m+[m[32m    bb.Min.y -= spacing_U;[m
[32m+[m[32m    bb.Max.x += (spacing_x - spacing_L);[m
[32m+[m[32m    bb.Max.y += (spacing_y - spacing_U);[m
[32m+[m
[32m+[m[32m    bool item_add;[m
[32m+[m[32m    if (flags & ImGuiSelectableFlags_Disabled)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiItemFlags backup_item_flags = window->DC.ItemFlags;[m
[32m+[m[32m        window->DC.ItemFlags |= ImGuiItemFlags_Disabled | ImGuiItemFlags_NoNavDefaultFocus;[m
[32m+[m[32m        item_add = ItemAdd(bb, id);[m
[32m+[m[32m        window->DC.ItemFlags = backup_item_flags;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        item_add = ItemAdd(bb, id);[m
[32m+[m[32m    }[m
[32m+[m[32m    if (!item_add)[m
[32m+[m[32m    {[m
[32m+[m[32m        if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.CurrentColumns)[m
[32m+[m[32m            PushColumnClipRect();[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries[m
[32m+[m[32m    ImGuiButtonFlags button_flags = 0;[m
[32m+[m[32m    if (flags & ImGuiSelectableFlags_NoHoldingActiveID) button_flags |= ImGuiButtonFlags_NoHoldingActiveID;[m
[32m+[m[32m    if (flags & ImGuiSelectableFlags_PressedOnClick) button_flags |= ImGuiButtonFlags_PressedOnClick;[m
[32m+[m[32m    if (flags & ImGuiSelectableFlags_PressedOnRelease) button_flags |= ImGuiButtonFlags_PressedOnRelease;[m
[32m+[m[32m    if (flags & ImGuiSelectableFlags_Disabled) button_flags |= ImGuiButtonFlags_Disabled;[m
[32m+[m[32m    if (flags & ImGuiSelectableFlags_AllowDoubleClick) button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;[m
[32m+[m[32m    if (flags & ImGuiSelectableFlags_AllowItemOverlap) button_flags |= ImGuiButtonFlags_AllowItemOverlap;[m
[32m+[m
[32m+[m[32m    if (flags & ImGuiSelectableFlags_Disabled)[m
[32m+[m[32m        selected = false;[m
[32m+[m
[32m+[m[32m    const bool was_selected = selected;[m
[32m+[m[32m    bool hovered, held;[m
[32m+[m[32m    bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);[m
[32m+[m[32m    // Hovering selectable with mouse updates NavId accordingly so navigation can be resumed with gamepad/keyboard (this doesn't happen on most widgets)[m
[32m+[m[32m    if (pressed || hovered)[m
[32m+[m[32m        if (!g.NavDisableMouseHover && g.NavWindow == window && g.NavLayer == window->DC.NavLayerCurrent)[m
[32m+[m[32m        {[m
[32m+[m[32m            g.NavDisableHighlight = true;[m
[32m+[m[32m            SetNavID(id, window->DC.NavLayerCurrent);[m
[32m+[m[32m        }[m
[32m+[m[32m    if (pressed)[m
[32m+[m[32m        MarkItemEdited(id);[m
[32m+[m
[32m+[m[32m    if (flags & ImGuiSelectableFlags_AllowItemOverlap)[m
[32m+[m[32m        SetItemAllowOverlap();[m
[32m+[m
[32m+[m[32m    // In this branch, Selectable() cannot toggle the selection so this will never trigger.[m
[32m+[m[32m    if (selected != was_selected) //-V547[m
[32m+[m[32m        window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_ToggledSelection;[m
[32m+[m
[32m+[m[32m    // Render[m
[32m+[m[32m    if (hovered || selected)[m
[32m+[m[32m    {[m
[32m+[m[32m        const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);[m
[32m+[m[32m        RenderFrame(bb.Min, bb.Max, col, false, 0.0f);[m
[32m+[m[32m        RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.CurrentColumns)[m
[32m+[m[32m    {[m
[32m+[m[32m        PushColumnClipRect();[m
[32m+[m[32m        bb.Max.x -= (GetContentRegionMax().x - max_x);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (flags & ImGuiSelectableFlags_Disabled) PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]);[m
[32m+[m[32m    RenderTextClipped(bb_inner.Min, bb_inner.Max, label, NULL, &label_size, style.SelectableTextAlign, &bb);[m
[32m+[m[32m    if (flags & ImGuiSelectableFlags_Disabled) PopStyleColor();[m
[32m+[m
[32m+[m[32m    // Automatically close popups[m
[32m+[m[32m    if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_DontClosePopups) && !(window->DC.ItemFlags & ImGuiItemFlags_SelectableDontClosePopup))[m
[32m+[m[32m        CloseCurrentPopup();[m
[32m+[m
[32m+[m[32m    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);[m
[32m+[m[32m    return pressed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)[m
[32m+[m[32m{[m
[32m+[m[32m    if (Selectable(label, *p_selected, flags, size_arg))[m
[32m+[m[32m    {[m
[32m+[m[32m        *p_selected = !*p_selected;[m
[32m+[m[32m        return true;[m
[32m+[m[32m    }[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Widgets: ListBox[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - ListBox()[m
[32m+[m[32m// - ListBoxHeader()[m
[32m+[m[32m// - ListBoxFooter()[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// FIXME: This is an old API. We should redesign some of it, rename ListBoxHeader->BeginListBox, ListBoxFooter->EndListBox[m
[32m+[m[32m// and promote using them over existing ListBox() functions, similarly to change with combo boxes.[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// FIXME: In principle this function should be called BeginListBox(). We should rename it after re-evaluating if we want to keep the same signature.[m
[32m+[m[32m// Helper to calculate the size of a listbox and display a label on the right.[m
[32m+[m[32m// Tip: To have a list filling the entire window width, PushItemWidth(-1) and pass an non-visible label e.g. "##empty"[m
[32m+[m[32mbool ImGui::ListBoxHeader(const char* label, const ImVec2& size_arg)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    const ImGuiStyle& style = GetStyle();[m
[32m+[m[32m    const ImGuiID id = GetID(label);[m
[32m+[m[32m    const ImVec2 label_size = CalcTextSize(label, NULL, true);[m
[32m+[m
[32m+[m[32m    // Size default to hold ~7 items. Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.[m
[32m+[m[32m    ImVec2 size = CalcItemSize(size_arg, GetNextItemWidth(), GetTextLineHeightWithSpacing() * 7.4f + style.ItemSpacing.y);[m
[32m+[m[32m    ImVec2 frame_size = ImVec2(size.x, ImMax(size.y, label_size.y));[m
[32m+[m[32m    ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);[m
[32m+[m[32m    ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));[m
[32m+[m[32m    window->DC.LastItemRect = bb; // Forward storage for ListBoxFooter.. dodgy.[m
[32m+[m
[32m+[m[32m    if (!IsRectVisible(bb.Min, bb.Max))[m
[32m+[m[32m    {[m
[32m+[m[32m        ItemSize(bb.GetSize(), style.FramePadding.y);[m
[32m+[m[32m        ItemAdd(bb, 0, &frame_bb);[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    BeginGroup();[m
[32m+[m[32m    if (label_size.x > 0)[m
[32m+[m[32m        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);[m
[32m+[m
[32m+[m[32m    BeginChildFrame(id, frame_bb.GetSize());[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// FIXME: In principle this function should be called EndListBox(). We should rename it after re-evaluating if we want to keep the same signature.[m
[32m+[m[32mbool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)[m
[32m+[m[32m{[m
[32m+[m[32m    // Size default to hold ~7.25 items.[m
[32m+[m[32m    // We add +25% worth of item height to allow the user to see at a glance if there are more items up/down, without looking at the scrollbar.[m
[32m+[m[32m    // We don't add this extra bit if items_count <= height_in_items. It is slightly dodgy, because it means a dynamic list of items will make the widget resize occasionally when it crosses that size.[m
[32m+[m[32m    // I am expecting that someone will come and complain about this behavior in a remote future, then we can advise on a better solution.[m
[32m+[m[32m    if (height_in_items < 0)[m
[32m+[m[32m        height_in_items = ImMin(items_count, 7);[m
[32m+[m[32m    const ImGuiStyle& style = GetStyle();[m
[32m+[m[32m    float height_in_items_f = (height_in_items < items_count) ? (height_in_items + 0.25f) : (height_in_items + 0.00f);[m
[32m+[m
[32m+[m[32m    // We include ItemSpacing.y so that a list sized for the exact number of items doesn't make a scrollbar appears. We could also enforce that by passing a flag to BeginChild().[m
[32m+[m[32m    ImVec2 size;[m
[32m+[m[32m    size.x = 0.0f;[m
[32m+[m[32m    size.y = GetTextLineHeightWithSpacing() * height_in_items_f + style.FramePadding.y * 2.0f;[m
[32m+[m[32m    return ListBoxHeader(label, size);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// FIXME: In principle this function should be called EndListBox(). We should rename it after re-evaluating if we want to keep the same signature.[m
[32m+[m[32mvoid ImGui::ListBoxFooter()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* parent_window = GetCurrentWindow()->ParentWindow;[m
[32m+[m[32m    const ImRect bb = parent_window->DC.LastItemRect;[m
[32m+[m[32m    const ImGuiStyle& style = GetStyle();[m
[32m+[m
[32m+[m[32m    EndChildFrame();[m
[32m+[m
[32m+[m[32m    // Redeclare item size so that it includes the label (we have stored the full size in LastItemRect)[m
[32m+[m[32m    // We call SameLine() to restore DC.CurrentLine* data[m
[32m+[m[32m    SameLine();[m
[32m+[m[32m    parent_window->DC.CursorPos = bb.Min;[m
[32m+[m[32m    ItemSize(bb, style.FramePadding.y);[m
[32m+[m[32m    EndGroup();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_items)[m
[32m+[m[32m{[m
[32m+[m[32m    const bool value_changed = ListBox(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_items);[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)[m
[32m+[m[32m{[m
[32m+[m[32m    if (!ListBoxHeader(label, items_count, height_in_items))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    // Assume all items have even height (= 1 line of text). If you need items of different or variable sizes you can create a custom version of ListBox() in your code without using the clipper.[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    bool value_changed = false;[m
[32m+[m[32m    ImGuiListClipper clipper(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.[m
[32m+[m[32m    while (clipper.Step())[m
[32m+[m[32m        for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            const bool item_selected = (i == *current_item);[m
[32m+[m[32m            const char* item_text;[m
[32m+[m[32m            if (!items_getter(data, i, &item_text))[m
[32m+[m[32m                item_text = "*Unknown item*";[m
[32m+[m
[32m+[m[32m            PushID(i);[m
[32m+[m[32m            if (Selectable(item_text, item_selected))[m
[32m+[m[32m            {[m
[32m+[m[32m                *current_item = i;[m
[32m+[m[32m                value_changed = true;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (item_selected)[m
[32m+[m[32m                SetItemDefaultFocus();[m
[32m+[m[32m            PopID();[m
[32m+[m[32m        }[m
[32m+[m[32m    ListBoxFooter();[m
[32m+[m[32m    if (value_changed)[m
[32m+[m[32m        MarkItemEdited(g.CurrentWindow->DC.LastItemId);[m
[32m+[m
[32m+[m[32m    return value_changed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Widgets: PlotLines, PlotHistogram[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - PlotEx() [Internal][m
[32m+[m[32m// - PlotLines()[m
[32m+[m[32m// - PlotHistogram()[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mvoid ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 frame_size)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    const ImGuiID id = window->GetID(label);[m
[32m+[m
[32m+[m[32m    const ImVec2 label_size = CalcTextSize(label, NULL, true);[m
[32m+[m[32m    if (frame_size.x == 0.0f)[m
[32m+[m[32m        frame_size.x = GetNextItemWidth();[m
[32m+[m[32m    if (frame_size.y == 0.0f)[m
[32m+[m[32m        frame_size.y = label_size.y + (style.FramePadding.y * 2);[m
[32m+[m
[32m+[m[32m    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);[m
[32m+[m[32m    const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);[m
[32m+[m[32m    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0));[m
[32m+[m[32m    ItemSize(total_bb, style.FramePadding.y);[m
[32m+[m[32m    if (!ItemAdd(total_bb, 0, &frame_bb))[m
[32m+[m[32m        return;[m
[32m+[m[32m    const bool hovered = ItemHoverable(frame_bb, id);[m
[32m+[m
[32m+[m[32m    // Determine scale from values if not specified[m
[32m+[m[32m    if (scale_min == FLT_MAX || scale_max == FLT_MAX)[m
[32m+[m[32m    {[m
[32m+[m[32m        float v_min = FLT_MAX;[m
[32m+[m[32m        float v_max = -FLT_MAX;[m
[32m+[m[32m        for (int i = 0; i < values_count; i++)[m
[32m+[m[32m        {[m
[32m+[m[32m            const float v = values_getter(data, i);[m
[32m+[m[32m            if (v != v) // Ignore NaN values[m
[32m+[m[32m                continue;[m
[32m+[m[32m            v_min = ImMin(v_min, v);[m
[32m+[m[32m            v_max = ImMax(v_max, v);[m
[32m+[m[32m        }[m
[32m+[m[32m        if (scale_min == FLT_MAX)[m
[32m+[m[32m            scale_min = v_min;[m
[32m+[m[32m        if (scale_max == FLT_MAX)[m
[32m+[m[32m            scale_max = v_max;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);[m
[32m+[m
[32m+[m[32m    const int values_count_min = (plot_type == ImGuiPlotType_Lines) ? 2 : 1;[m
[32m+[m[32m    if (values_count >= values_count_min)[m
[32m+[m[32m    {[m
[32m+[m[32m        int res_w = ImMin((int)frame_size.x, values_count) + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);[m
[32m+[m[32m        int item_count = values_count + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);[m
[32m+[m
[32m+[m[32m        // Tooltip on hover[m
[32m+[m[32m        int v_hovered = -1;[m
[32m+[m[32m        if (hovered && inner_bb.Contains(g.IO.MousePos))[m
[32m+[m[32m        {[m
[32m+[m[32m            const float t = ImClamp((g.IO.MousePos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x), 0.0f, 0.9999f);[m
[32m+[m[32m            const int v_idx = (int)(t * item_count);[m
[32m+[m[32m            IM_ASSERT(v_idx >= 0 && v_idx < values_count);[m
[32m+[m
[32m+[m[32m            const float v0 = values_getter(data, (v_idx + values_offset) % values_count);[m
[32m+[m[32m            const float v1 = values_getter(data, (v_idx + 1 + values_offset) % values_count);[m
[32m+[m[32m            if (plot_type == ImGuiPlotType_Lines)[m
[32m+[m[32m                SetTooltip("%d: %8.4g\n%d: %8.4g", v_idx, v0, v_idx+1, v1);[m
[32m+[m[32m            else if (plot_type == ImGuiPlotType_Histogram)[m
[32m+[m[32m                SetTooltip("%d: %8.4g", v_idx, v0);[m
[32m+[m[32m            v_hovered = v_idx;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        const float t_step = 1.0f / (float)res_w;[m
[32m+[m[32m        const float inv_scale = (scale_min == scale_max) ? 0.0f : (1.0f / (scale_max - scale_min));[m
[32m+[m
[32m+[m[32m        float v0 = values_getter(data, (0 + values_offset) % values_count);[m
[32m+[m[32m        float t0 = 0.0f;[m
[32m+[m[32m        ImVec2 tp0 = ImVec2( t0, 1.0f - ImSaturate((v0 - scale_min) * inv_scale) );                       // Point in the normalized space of our target rectangle[m
[32m+[m[32m        float histogram_zero_line_t = (scale_min * scale_max < 0.0f) ? (-scale_min * inv_scale) : (scale_min < 0.0f ? 0.0f : 1.0f);   // Where does the zero line stands[m
[32m+[m
[32m+[m[32m        const ImU32 col_base = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLines : ImGuiCol_PlotHistogram);[m
[32m+[m[32m        const ImU32 col_hovered = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLinesHovered : ImGuiCol_PlotHistogramHovered);[m
[32m+[m
[32m+[m[32m        for (int n = 0; n < res_w; n++)[m
[32m+[m[32m        {[m
[32m+[m[32m            const float t1 = t0 + t_step;[m
[32m+[m[32m            const int v1_idx = (int)(t0 * item_count + 0.5f);[m
[32m+[m[32m            IM_ASSERT(v1_idx >= 0 && v1_idx < values_count);[m
[32m+[m[32m            const float v1 = values_getter(data, (v1_idx + values_offset + 1) % values_count);[m
[32m+[m[32m            const ImVec2 tp1 = ImVec2( t1, 1.0f - ImSaturate((v1 - scale_min) * inv_scale) );[m
[32m+[m
[32m+[m[32m            // NB: Draw calls are merged together by the DrawList system. Still, we should render our batch are lower level to save a bit of CPU.[m
[32m+[m[32m            ImVec2 pos0 = ImLerp(inner_bb.Min, inner_bb.Max, tp0);[m
[32m+[m[32m            ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, histogram_zero_line_t));[m
[32m+[m[32m            if (plot_type == ImGuiPlotType_Lines)[m
[32m+[m[32m            {[m
[32m+[m[32m                window->DrawList->AddLine(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (plot_type == ImGuiPlotType_Histogram)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (pos1.x >= pos0.x + 2.0f)[m
[32m+[m[32m                    pos1.x -= 1.0f;[m
[32m+[m[32m                window->DrawList->AddRectFilled(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            t0 = t1;[m
[32m+[m[32m            tp0 = tp1;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Text overlay[m
[32m+[m[32m    if (overlay_text)[m
[32m+[m[32m        RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f,0.0f));[m
[32m+[m
[32m+[m[32m    if (label_size.x > 0.0f)[m
[32m+[m[32m        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstruct ImGuiPlotArrayGetterData[m
[32m+[m[32m{[m
[32m+[m[32m    const float* Values;[m
[32m+[m[32m    int Stride;[m
[32m+[m
[32m+[m[32m    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstatic float Plot_ArrayGetter(void* data, int idx)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiPlotArrayGetterData* plot_data = (ImGuiPlotArrayGetterData*)data;[m
[32m+[m[32m    const float v = *(const float*)(const void*)((const unsigned char*)plot_data->Values + (size_t)idx * plot_data->Stride);[m
[32m+[m[32m    return v;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiPlotArrayGetterData data(values, stride);[m
[32m+[m[32m    PlotEx(ImGuiPlotType_Lines, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)[m
[32m+[m[32m{[m
[32m+[m[32m    PlotEx(ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiPlotArrayGetterData data(values, stride);[m
[32m+[m[32m    PlotEx(ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)[m
[32m+[m[32m{[m
[32m+[m[32m    PlotEx(ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Widgets: Value helpers[m
[32m+[m[32m// Those is not very useful, legacy API.[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - Value()[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mvoid ImGui::Value(const char* prefix, bool b)[m
[32m+[m[32m{[m
[32m+[m[32m    Text("%s: %s", prefix, (b ? "true" : "false"));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::Value(const char* prefix, int v)[m
[32m+[m[32m{[m
[32m+[m[32m    Text("%s: %d", prefix, v);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::Value(const char* prefix, unsigned int v)[m
[32m+[m[32m{[m
[32m+[m[32m    Text("%s: %d", prefix, v);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::Value(const char* prefix, float v, const char* float_format)[m
[32m+[m[32m{[m
[32m+[m[32m    if (float_format)[m
[32m+[m[32m    {[m
[32m+[m[32m        char fmt[64];[m
[32m+[m[32m        ImFormatString(fmt, IM_ARRAYSIZE(fmt), "%%s: %s", float_format);[m
[32m+[m[32m        Text(fmt, prefix, v);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        Text("%s: %.3f", prefix, v);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] MenuItem, BeginMenu, EndMenu, etc.[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - ImGuiMenuColumns [Internal][m
[32m+[m[32m// - BeginMainMenuBar()[m
[32m+[m[32m// - EndMainMenuBar()[m
[32m+[m[32m// - BeginMenuBar()[m
[32m+[m[32m// - EndMenuBar()[m
[32m+[m[32m// - BeginMenu()[m
[32m+[m[32m// - EndMenu()[m
[32m+[m[32m// - MenuItem()[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m// Helpers for internal use[m
[32m+[m[32mImGuiMenuColumns::ImGuiMenuColumns()[m
[32m+[m[32m{[m
[32m+[m[32m    Spacing = Width = NextWidth = 0.0f;[m
[32m+[m[32m    memset(Pos, 0, sizeof(Pos));[m
[32m+[m[32m    memset(NextWidths, 0, sizeof(NextWidths));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGuiMenuColumns::Update(int count, float spacing, bool clear)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(count == IM_ARRAYSIZE(Pos));[m
[32m+[m[32m    IM_UNUSED(count);[m
[32m+[m[32m    Width = NextWidth = 0.0f;[m
[32m+[m[32m    Spacing = spacing;[m
[32m+[m[32m    if (clear)[m
[32m+[m[32m        memset(NextWidths, 0, sizeof(NextWidths));[m
[32m+[m[32m    for (int i = 0; i < IM_ARRAYSIZE(Pos); i++)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (i > 0 && NextWidths[i] > 0.0f)[m
[32m+[m[32m            Width += Spacing;[m
[32m+[m[32m        Pos[i] = (float)(int)Width;[m
[32m+[m[32m        Width += NextWidths[i];[m
[32m+[m[32m        NextWidths[i] = 0.0f;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGuiMenuColumns::DeclColumns(float w0, float w1, float w2) // not using va_arg because they promote float to double[m
[32m+[m[32m{[m
[32m+[m[32m    NextWidth = 0.0f;[m
[32m+[m[32m    NextWidths[0] = ImMax(NextWidths[0], w0);[m
[32m+[m[32m    NextWidths[1] = ImMax(NextWidths[1], w1);[m
[32m+[m[32m    NextWidths[2] = ImMax(NextWidths[2], w2);[m
[32m+[m[32m    for (int i = 0; i < IM_ARRAYSIZE(Pos); i++)[m
[32m+[m[32m        NextWidth += NextWidths[i] + ((i > 0 && NextWidths[i] > 0.0f) ? Spacing : 0.0f);[m
[32m+[m[32m    return ImMax(Width, NextWidth);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfloat ImGuiMenuColumns::CalcExtraSpace(float avail_w)[m
[32m+[m[32m{[m
[32m+[m[32m    return ImMax(0.0f, avail_w - Width);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// For the main menu bar, which cannot be moved, we honor g.Style.DisplaySafeAreaPadding to ensure text can be visible on a TV set.[m
[32m+[m[32mbool ImGui::BeginMainMenuBar()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));[m
[32m+[m[32m    SetNextWindowPos(ImVec2(0.0f, 0.0f));[m
[32m+[m[32m    SetNextWindowSize(ImVec2(g.IO.DisplaySize.x, g.NextWindowData.MenuBarOffsetMinVal.y + g.FontBaseSize + g.Style.FramePadding.y));[m
[32m+[m[32m    PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);[m
[32m+[m[32m    PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0,0));[m
[32m+[m[32m    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_MenuBar;[m
[32m+[m[32m    bool is_open = Begin("##MainMenuBar", NULL, window_flags) && BeginMenuBar();[m
[32m+[m[32m    PopStyleVar(2);[m
[32m+[m[32m    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);[m
[32m+[m[32m    if (!is_open)[m
[32m+[m[32m    {[m
[32m+[m[32m        End();[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m[32m    return true; //-V1020[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::EndMainMenuBar()[m
[32m+[m[32m{[m
[32m+[m[32m    EndMenuBar();[m
[32m+[m
[32m+[m[32m    // When the user has left the menu layer (typically: closed menus through activation of an item), we restore focus to the previous window[m
[32m+[m[32m    // FIXME: With this strategy we won't be able to restore a NULL focus.[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.CurrentWindow == g.NavWindow && g.NavLayer == 0)[m
[32m+[m[32m        FocusTopMostWindowUnderOne(g.NavWindow, NULL);[m
[32m+[m
[32m+[m[32m    End();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::BeginMenuBar()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m[32m    if (!(window->Flags & ImGuiWindowFlags_MenuBar))[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    IM_ASSERT(!window->DC.MenuBarAppending);[m
[32m+[m[32m    BeginGroup(); // Backup position on layer 0[m
[32m+[m[32m    PushID("##menubar");[m
[32m+[m
[32m+[m[32m    // We don't clip with current window clipping rectangle as it is already set to the area below. However we clip with window full rect.[m
[32m+[m[32m    // We remove 1 worth of rounding to Max.x to that text in long menus and small windows don't tend to display over the lower-right rounded area, which looks particularly glitchy.[m
[32m+[m[32m    ImRect bar_rect = window->MenuBarRect();[m
[32m+[m[32m    ImRect clip_rect(ImFloor(bar_rect.Min.x + 0.5f), ImFloor(bar_rect.Min.y + window->WindowBorderSize + 0.5f), ImFloor(ImMax(bar_rect.Min.x, bar_rect.Max.x - window->WindowRounding) + 0.5f), ImFloor(bar_rect.Max.y + 0.5f));[m
[32m+[m[32m    clip_rect.ClipWith(window->OuterRectClipped);[m
[32m+[m[32m    PushClipRect(clip_rect.Min, clip_rect.Max, false);[m
[32m+[m
[32m+[m[32m    window->DC.CursorPos = ImVec2(bar_rect.Min.x + window->DC.MenuBarOffset.x, bar_rect.Min.y + window->DC.MenuBarOffset.y);[m
[32m+[m[32m    window->DC.LayoutType = ImGuiLayoutType_Horizontal;[m
[32m+[m[32m    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;[m
[32m+[m[32m    window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Menu);[m
[32m+[m[32m    window->DC.MenuBarAppending = true;[m
[32m+[m[32m    AlignTextToFramePadding();[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::EndMenuBar()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m
[32m+[m[32m    // Nav: When a move request within one of our child menu failed, capture the request to navigate among our siblings.[m
[32m+[m[32m    if (NavMoveRequestButNoResultYet() && (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right) && (g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiWindow* nav_earliest_child = g.NavWindow;[m
[32m+[m[32m        while (nav_earliest_child->ParentWindow && (nav_earliest_child->ParentWindow->Flags & ImGuiWindowFlags_ChildMenu))[m
[32m+[m[32m            nav_earliest_child = nav_earliest_child->ParentWindow;[m
[32m+[m[32m        if (nav_earliest_child->ParentWindow == window && nav_earliest_child->DC.ParentLayoutType == ImGuiLayoutType_Horizontal && g.NavMoveRequestForward == ImGuiNavForward_None)[m
[32m+[m[32m        {[m
[32m+[m[32m            // To do so we claim focus back, restore NavId and then process the movement request for yet another frame.[m
[32m+[m[32m            // This involve a one-frame delay which isn't very problematic in this situation. We could remove it by scoring in advance for multiple window (probably not worth the hassle/cost)[m
[32m+[m[32m            const ImGuiNavLayer layer = ImGuiNavLayer_Menu;[m
[32m+[m[32m            IM_ASSERT(window->DC.NavLayerActiveMaskNext & (1 << layer)); // Sanity check[m
[32m+[m[32m            FocusWindow(window);[m
[32m+[m[32m            SetNavIDWithRectRel(window->NavLastIds[layer], layer, window->NavRectRel[layer]);[m
[32m+[m[32m            g.NavLayer = layer;[m
[32m+[m[32m            g.NavDisableHighlight = true; // Hide highlight for the current frame so we don't see the intermediary selection.[m
[32m+[m[32m            g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;[m
[32m+[m[32m            NavMoveRequestCancel();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    IM_ASSERT(window->Flags & ImGuiWindowFlags_MenuBar);[m
[32m+[m[32m    IM_ASSERT(window->DC.MenuBarAppending);[m
[32m+[m[32m    PopClipRect();[m
[32m+[m[32m    PopID();[m
[32m+[m[32m    window->DC.MenuBarOffset.x = window->DC.CursorPos.x - window->MenuBarRect().Min.x; // Save horizontal position so next append can reuse it. This is kinda equivalent to a per-layer CursorPos.[m
[32m+[m[32m    window->DC.GroupStack.back().AdvanceCursor = false;[m
[32m+[m[32m    EndGroup(); // Restore position on layer 0[m
[32m+[m[32m    window->DC.LayoutType = ImGuiLayoutType_Vertical;[m
[32m+[m[32m    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;[m
[32m+[m[32m    window->DC.NavLayerCurrentMask = (1 << ImGuiNavLayer_Main);[m
[32m+[m[32m    window->DC.MenuBarAppending = false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::BeginMenu(const char* label, bool enabled)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    const ImGuiID id = window->GetID(label);[m
[32m+[m
[32m+[m[32m    ImVec2 label_size = CalcTextSize(label, NULL, true);[m
[32m+[m
[32m+[m[32m    bool pressed;[m
[32m+[m[32m    bool menu_is_open = IsPopupOpen(id);[m
[32m+[m[32m    bool menuset_is_open = !(window->Flags & ImGuiWindowFlags_Popup) && (g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].OpenParentId == window->IDStack.back());[m
[32m+[m[32m    ImGuiWindow* backed_nav_window = g.NavWindow;[m
[32m+[m[32m    if (menuset_is_open)[m
[32m+[m[32m        g.NavWindow = window;  // Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent)[m
[32m+[m
[32m+[m[32m    // The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu,[m
[32m+[m[32m    // However the final position is going to be different! It is choosen by FindBestWindowPosForPopup().[m
[32m+[m[32m    // e.g. Menus tend to overlap each other horizontally to amplify relative Z-ordering.[m
[32m+[m[32m    ImVec2 popup_pos, pos = window->DC.CursorPos;[m
[32m+[m[32m    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Menu inside an horizontal menu bar[m
[32m+[m[32m        // Selectable extend their highlight by half ItemSpacing in each direction.[m
[32m+[m[32m        // For ChildMenu, the popup position will be overwritten by the call to FindBestWindowPosForPopup() in Begin()[m
[32m+[m[32m        popup_pos = ImVec2(pos.x - 1.0f - (float)(int)(style.ItemSpacing.x * 0.5f), pos.y - style.FramePadding.y + window->MenuBarHeight());[m
[32m+[m[32m        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);[m
[32m+[m[32m        PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(style.ItemSpacing.x * 2.0f, style.ItemSpacing.y));[m
[32m+[m[32m        float w = label_size.x;[m
[32m+[m[32m        pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_PressedOnClick | ImGuiSelectableFlags_DontClosePopups | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));[m
[32m+[m[32m        PopStyleVar();[m
[32m+[m[32m        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // Menu inside a menu[m
[32m+[m[32m        popup_pos = ImVec2(pos.x, pos.y - style.WindowPadding.y);[m
[32m+[m[32m        float w = window->MenuColumns.DeclColumns(label_size.x, 0.0f, (float)(int)(g.FontSize * 1.20f)); // Feedback to next frame[m
[32m+[m[32m        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);[m
[32m+[m[32m        pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_PressedOnClick | ImGuiSelectableFlags_DontClosePopups | ImGuiSelectableFlags_DrawFillAvailWidth | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));[m
[32m+[m[32m        if (!enabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);[m
[32m+[m[32m        RenderArrow(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.30f, 0.0f), ImGuiDir_Right);[m
[32m+[m[32m        if (!enabled) PopStyleColor();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    const bool hovered = enabled && ItemHoverable(window->DC.LastItemRect, id);[m
[32m+[m[32m    if (menuset_is_open)[m
[32m+[m[32m        g.NavWindow = backed_nav_window;[m
[32m+[m
[32m+[m[32m    bool want_open = false;[m
[32m+[m[32m    bool want_close = false;[m
[32m+[m[32m    if (window->DC.LayoutType == ImGuiLayoutType_Vertical) // (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))[m
[32m+[m[32m    {[m
[32m+[m[32m        // Close menu when not hovering it anymore unless we are moving roughly in the direction of the menu[m
[32m+[m[32m        // Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.[m
[32m+[m[32m        bool moving_toward_other_child_menu = false;[m
[32m+[m
[32m+[m[32m        ImGuiWindow* child_menu_window = (g.BeginPopupStack.Size < g.OpenPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].SourceWindow == window) ? g.OpenPopupStack[g.BeginPopupStack.Size].Window : NULL;[m
[32m+[m[32m        if (g.HoveredWindow == window && child_menu_window != NULL && !(window->Flags & ImGuiWindowFlags_MenuBar))[m
[32m+[m[32m        {[m
[32m+[m[32m            // FIXME-DPI: Values should be derived from a master "scale" factor.[m
[32m+[m[32m            ImRect next_window_rect = child_menu_window->Rect();[m
[32m+[m[32m            ImVec2 ta = g.IO.MousePos - g.IO.MouseDelta;[m
[32m+[m[32m            ImVec2 tb = (window->Pos.x < child_menu_window->Pos.x) ? next_window_rect.GetTL() : next_window_rect.GetTR();[m
[32m+[m[32m            ImVec2 tc = (window->Pos.x < child_menu_window->Pos.x) ? next_window_rect.GetBL() : next_window_rect.GetBR();[m
[32m+[m[32m            float extra = ImClamp(ImFabs(ta.x - tb.x) * 0.30f, 5.0f, 30.0f);    // add a bit of extra slack.[m
[32m+[m[32m            ta.x += (window->Pos.x < child_menu_window->Pos.x) ? -0.5f : +0.5f; // to avoid numerical issues[m
[32m+[m[32m            tb.y = ta.y + ImMax((tb.y - extra) - ta.y, -100.0f);                // triangle is maximum 200 high to limit the slope and the bias toward large sub-menus // FIXME: Multiply by fb_scale?[m
[32m+[m[32m            tc.y = ta.y + ImMin((tc.y + extra) - ta.y, +100.0f);[m
[32m+[m[32m            moving_toward_other_child_menu = ImTriangleContainsPoint(ta, tb, tc, g.IO.MousePos);[m
[32m+[m[32m            //GetForegroundDrawList()->AddTriangleFilled(ta, tb, tc, moving_within_opened_triangle ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); // [DEBUG][m
[32m+[m[32m        }[m
[32m+[m[32m        if (menu_is_open && !hovered && g.HoveredWindow == window && g.HoveredIdPreviousFrame != 0 && g.HoveredIdPreviousFrame != id && !moving_toward_other_child_menu)[m
[32m+[m[32m            want_close = true;[m
[32m+[m
[32m+[m[32m        if (!menu_is_open && hovered && pressed) // Click to open[m
[32m+[m[32m            want_open = true;[m
[32m+[m[32m        else if (!menu_is_open && hovered && !moving_toward_other_child_menu) // Hover to open[m
[32m+[m[32m            want_open = true;[m
[32m+[m
[32m+[m[32m        if (g.NavActivateId == id)[m
[32m+[m[32m        {[m
[32m+[m[32m            want_close = menu_is_open;[m
[32m+[m[32m            want_open = !menu_is_open;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right) // Nav-Right to open[m
[32m+[m[32m        {[m
[32m+[m[32m            want_open = true;[m
[32m+[m[32m            NavMoveRequestCancel();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        // Menu bar[m
[32m+[m[32m        if (menu_is_open && pressed && menuset_is_open) // Click an open menu again to close it[m
[32m+[m[32m        {[m
[32m+[m[32m            want_close = true;[m
[32m+[m[32m            want_open = menu_is_open = false;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (pressed || (hovered && menuset_is_open && !menu_is_open)) // First click to open, then hover to open others[m
[32m+[m[32m        {[m
[32m+[m[32m            want_open = true;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Down) // Nav-Down to open[m
[32m+[m[32m        {[m
[32m+[m[32m            want_open = true;[m
[32m+[m[32m            NavMoveRequestCancel();[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (!enabled) // explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu("options", has_object)) { ..use object.. }'[m
[32m+[m[32m        want_close = true;[m
[32m+[m[32m    if (want_close && IsPopupOpen(id))[m
[32m+[m[32m        ClosePopupToLevel(g.BeginPopupStack.Size, true);[m
[32m+[m
[32m+[m[32m    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Openable | (menu_is_open ? ImGuiItemStatusFlags_Opened : 0));[m
[32m+[m
[32m+[m[32m    if (!menu_is_open && want_open && g.OpenPopupStack.Size > g.BeginPopupStack.Size)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Don't recycle same menu level in the same frame, first close the other menu and yield for a frame.[m
[32m+[m[32m        OpenPopup(label);[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    menu_is_open |= want_open;[m
[32m+[m[32m    if (want_open)[m
[32m+[m[32m        OpenPopup(label);[m
[32m+[m
[32m+[m[32m    if (menu_is_open)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Sub-menus are ChildWindow so that mouse can be hovering across them (otherwise top-most popup menu would steal focus and not allow hovering on parent menu)[m
[32m+[m[32m        SetNextWindowPos(popup_pos, ImGuiCond_Always);[m
[32m+[m[32m        ImGuiWindowFlags flags = ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNavFocus;[m
[32m+[m[32m        if (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))[m
[32m+[m[32m            flags |= ImGuiWindowFlags_ChildWindow;[m
[32m+[m[32m        menu_is_open = BeginPopupEx(id, flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return menu_is_open;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::EndMenu()[m
[32m+[m[32m{[m
[32m+[m[32m    // Nav: When a left move request _within our child menu_ failed, close ourselves (the _parent_ menu).[m
[32m+[m[32m    // A menu doesn't close itself because EndMenuBar() wants the catch the last Left<>Right inputs.[m
[32m+[m[32m    // However, it means that with the current code, a BeginMenu() from outside another menu or a menu-bar won't be closable with the Left direction.[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (g.NavWindow && g.NavWindow->ParentWindow == window && g.NavMoveDir == ImGuiDir_Left && NavMoveRequestButNoResultYet() && window->DC.LayoutType == ImGuiLayoutType_Vertical)[m
[32m+[m[32m    {[m
[32m+[m[32m        ClosePopupToLevel(g.BeginPopupStack.Size, true);[m
[32m+[m[32m        NavMoveRequestCancel();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    EndPopup();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiWindow* window = GetCurrentWindow();[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiStyle& style = g.Style;[m
[32m+[m[32m    ImVec2 pos = window->DC.CursorPos;[m
[32m+[m[32m    ImVec2 label_size = CalcTextSize(label, NULL, true);[m
[32m+[m
[32m+[m[32m    ImGuiSelectableFlags flags = ImGuiSelectableFlags_PressedOnRelease | (enabled ? 0 : ImGuiSelectableFlags_Disabled);[m
[32m+[m[32m    bool pressed;[m
[32m+[m[32m    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside a menu bar, which is a little misleading but may be useful[m
[32m+[m[32m        // Note that in this situation we render neither the shortcut neither the selected tick mark[m
[32m+[m[32m        float w = label_size.x;[m
[32m+[m[32m        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);[m
[32m+[m[32m        PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(style.ItemSpacing.x * 2.0f, style.ItemSpacing.y));[m
[32m+[m[32m        pressed = Selectable(label, false, flags, ImVec2(w, 0.0f));[m
[32m+[m[32m        PopStyleVar();[m
[32m+[m[32m        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        ImVec2 shortcut_size = shortcut ? CalcTextSize(shortcut, NULL) : ImVec2(0.0f, 0.0f);[m
[32m+[m[32m        float w = window->MenuColumns.DeclColumns(label_size.x, shortcut_size.x, (float)(int)(g.FontSize * 1.20f)); // Feedback for next frame[m
[32m+[m[32m        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);[m
[32m+[m[32m        pressed = Selectable(label, false, flags | ImGuiSelectableFlags_DrawFillAvailWidth, ImVec2(w, 0.0f));[m
[32m+[m[32m        if (shortcut_size.x > 0.0f)[m
[32m+[m[32m        {[m
[32m+[m[32m            PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);[m
[32m+[m[32m            RenderText(pos + ImVec2(window->MenuColumns.Pos[1] + extra_w, 0.0f), shortcut, NULL, false);[m
[32m+[m[32m            PopStyleColor();[m
[32m+[m[32m        }[m
[32m+[m[32m        if (selected)[m
[32m+[m[32m            RenderCheckMark(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(enabled ? ImGuiCol_Text : ImGuiCol_TextDisabled), g.FontSize  * 0.866f);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    IMGUI_TEST_ENGINE_ITEM_INFO(window->DC.LastItemId, label, window->DC.ItemFlags | ImGuiItemStatusFlags_Checkable | (selected ? ImGuiItemStatusFlags_Checked : 0));[m
[32m+[m[32m    return pressed;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)[m
[32m+[m[32m{[m
[32m+[m[32m    if (MenuItem(label, shortcut, p_selected ? *p_selected : false, enabled))[m
[32m+[m[32m    {[m
[32m+[m[32m        if (p_selected)[m
[32m+[m[32m            *p_selected = !*p_selected;[m
[32m+[m[32m        return true;[m
[32m+[m[32m    }[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [BETA API] API may evolve! This code has been extracted out of the Docking branch,[m
[32m+[m[32m// and some of the construct which are not used in Master may be left here to facilitate merging.[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - BeginTabBar()[m
[32m+[m[32m// - BeginTabBarEx() [Internal][m
[32m+[m[32m// - EndTabBar()[m
[32m+[m[32m// - TabBarLayout() [Internal][m
[32m+[m[32m// - TabBarCalcTabID() [Internal][m
[32m+[m[32m// - TabBarCalcMaxTabWidth() [Internal][m
[32m+[m[32m// - TabBarFindTabById() [Internal][m
[32m+[m[32m// - TabBarRemoveTab() [Internal][m
[32m+[m[32m// - TabBarCloseTab() [Internal][m
[32m+[m[32m// - TabBarScrollClamp()v[m
[32m+[m[32m// - TabBarScrollToTab() [Internal][m
[32m+[m[32m// - TabBarQueueChangeTabOrder() [Internal][m
[32m+[m[32m// - TabBarScrollingButtons() [Internal][m
[32m+[m[32m// - TabBarTabListPopupButton() [Internal][m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mnamespace ImGui[m
[32m+[m[32m{[m
[32m+[m[32m    static void             TabBarLayout(ImGuiTabBar* tab_bar);[m
[32m+[m[32m    static ImU32            TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label);[m
[32m+[m[32m    static float            TabBarCalcMaxTabWidth();[m
[32m+[m[32m    static float            TabBarScrollClamp(ImGuiTabBar* tab_bar, float scrolling);[m
[32m+[m[32m    static void             TabBarScrollToTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);[m
[32m+[m[32m    static ImGuiTabItem*    TabBarScrollingButtons(ImGuiTabBar* tab_bar);[m
[32m+[m[32m    static ImGuiTabItem*    TabBarTabListPopupButton(ImGuiTabBar* tab_bar);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiTabBar::ImGuiTabBar()[m
[32m+[m[32m{[m
[32m+[m[32m    ID = 0;[m
[32m+[m[32m    SelectedTabId = NextSelectedTabId = VisibleTabId = 0;[m
[32m+[m[32m    CurrFrameVisible = PrevFrameVisible = -1;[m
[32m+[m[32m    ContentsHeight = 0.0f;[m
[32m+[m[32m    OffsetMax = OffsetNextTab = 0.0f;[m
[32m+[m[32m    ScrollingAnim = ScrollingTarget = ScrollingTargetDistToVisibility = ScrollingSpeed = 0.0f;[m
[32m+[m[32m    Flags = ImGuiTabBarFlags_None;[m
[32m+[m[32m    ReorderRequestTabId = 0;[m
[32m+[m[32m    ReorderRequestDir = 0;[m
[32m+[m[32m    WantLayout = VisibleTabWasSubmitted = false;[m
[32m+[m[32m    LastTabItemIdx = -1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int IMGUI_CDECL TabItemComparerByVisibleOffset(const void* lhs, const void* rhs)[m
[32m+[m[32m{[m
[32m+[m[32m    const ImGuiTabItem* a = (const ImGuiTabItem*)lhs;[m
[32m+[m[32m    const ImGuiTabItem* b = (const ImGuiTabItem*)rhs;[m
[32m+[m[32m    return (int)(a->Offset - b->Offset);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int IMGUI_CDECL TabBarSortItemComparer(const void* lhs, const void* rhs)[m
[32m+[m[32m{[m
[32m+[m[32m    const ImGuiTabBarSortItem* a = (const ImGuiTabBarSortItem*)lhs;[m
[32m+[m[32m    const ImGuiTabBarSortItem* b = (const ImGuiTabBarSortItem*)rhs;[m
[32m+[m[32m    if (int d = (int)(b->Width - a->Width))[m
[32m+[m[32m        return d;[m
[32m+[m[32m    return (b->Index - a->Index);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic ImGuiTabBar* GetTabBarFromTabBarRef(const ImGuiTabBarRef& ref)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return ref.Ptr ? ref.Ptr : g.TabBars.GetByIndex(ref.IndexInMainPool);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic ImGuiTabBarRef GetTabBarRefFromTabBar(ImGuiTabBar* tab_bar)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    if (g.TabBars.Contains(tab_bar))[m
[32m+[m[32m        return ImGuiTabBarRef(g.TabBars.GetIndex(tab_bar));[m
[32m+[m[32m    return ImGuiTabBarRef(tab_bar);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool    ImGui::BeginTabBar(const char* str_id, ImGuiTabBarFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiID id = window->GetID(str_id);[m
[32m+[m[32m    ImGuiTabBar* tab_bar = g.TabBars.GetOrAddByKey(id);[m
[32m+[m[32m    ImRect tab_bar_bb = ImRect(window->DC.CursorPos.x, window->DC.CursorPos.y, window->InnerClipRect.Max.x, window->DC.CursorPos.y + g.FontSize + g.Style.FramePadding.y * 2);[m
[32m+[m[32m    tab_bar->ID = id;[m
[32m+[m[32m    return BeginTabBarEx(tab_bar, tab_bar_bb, flags | ImGuiTabBarFlags_IsFocused);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool    ImGui::BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect& tab_bar_bb, ImGuiTabBarFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    if ((flags & ImGuiTabBarFlags_DockNode) == 0)[m
[32m+[m[32m        PushOverrideID(tab_bar->ID);[m
[32m+[m
[32m+[m[32m    // Add to stack[m
[32m+[m[32m    g.CurrentTabBarStack.push_back(GetTabBarRefFromTabBar(tab_bar));[m
[32m+[m[32m    g.CurrentTabBar = tab_bar;[m
[32m+[m
[32m+[m[32m    if (tab_bar->CurrFrameVisible == g.FrameCount)[m
[32m+[m[32m    {[m
[32m+[m[32m        //IMGUI_DEBUG_LOG("BeginTabBarEx already called this frame\n", g.FrameCount);[m
[32m+[m[32m        IM_ASSERT(0);[m
[32m+[m[32m        return true;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // When toggling back from ordered to manually-reorderable, shuffle tabs to enforce the last visible order.[m
[32m+[m[32m    // Otherwise, the most recently inserted tabs would move at the end of visible list which can be a little too confusing or magic for the user.[m
[32m+[m[32m    if ((flags & ImGuiTabBarFlags_Reorderable) && !(tab_bar->Flags & ImGuiTabBarFlags_Reorderable) && tab_bar->Tabs.Size > 1 && tab_bar->PrevFrameVisible != -1)[m
[32m+[m[32m        ImQsort(tab_bar->Tabs.Data, tab_bar->Tabs.Size, sizeof(ImGuiTabItem), TabItemComparerByVisibleOffset);[m
[32m+[m
[32m+[m[32m    // Flags[m
[32m+[m[32m    if ((flags & ImGuiTabBarFlags_FittingPolicyMask_) == 0)[m
[32m+[m[32m        flags |= ImGuiTabBarFlags_FittingPolicyDefault_;[m
[32m+[m
[32m+[m[32m    tab_bar->Flags = flags;[m
[32m+[m[32m    tab_bar->BarRect = tab_bar_bb;[m
[32m+[m[32m    tab_bar->WantLayout = true; // Layout will be done on the first call to ItemTab()[m
[32m+[m[32m    tab_bar->PrevFrameVisible = tab_bar->CurrFrameVisible;[m
[32m+[m[32m    tab_bar->CurrFrameVisible = g.FrameCount;[m
[32m+[m[32m    tab_bar->FramePadding = g.Style.FramePadding;[m
[32m+[m
[32m+[m[32m    // Layout[m
[32m+[m[32m    ItemSize(ImVec2(tab_bar->OffsetMax, tab_bar->BarRect.GetHeight()));[m
[32m+[m[32m    window->DC.CursorPos.x = tab_bar->BarRect.Min.x;[m
[32m+[m
[32m+[m[32m    // Draw separator[m
[32m+[m[32m    const ImU32 col = GetColorU32((flags & ImGuiTabBarFlags_IsFocused) ? ImGuiCol_TabActive : ImGuiCol_Tab);[m
[32m+[m[32m    const float y = tab_bar->BarRect.Max.y - 1.0f;[m
[32m+[m[32m    {[m
[32m+[m[32m        const float separator_min_x = tab_bar->BarRect.Min.x - window->WindowPadding.x;[m
[32m+[m[32m        const float separator_max_x = tab_bar->BarRect.Max.x + window->WindowPadding.x;[m
[32m+[m[32m        window->DrawList->AddLine(ImVec2(separator_min_x, y), ImVec2(separator_max_x, y), col, 1.0f);[m
[32m+[m[32m    }[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid    ImGui::EndTabBar()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGuiTabBar* tab_bar = g.CurrentTabBar;[m
[32m+[m[32m    if (tab_bar == NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(tab_bar != NULL && "Mismatched BeginTabBar()/EndTabBar()!");[m
[32m+[m[32m        return; // FIXME-ERRORHANDLING[m
[32m+[m[32m    }[m
[32m+[m[32m    if (tab_bar->WantLayout)[m
[32m+[m[32m        TabBarLayout(tab_bar);[m
[32m+[m
[32m+[m[32m    // Restore the last visible height if no tab is visible, this reduce vertical flicker/movement when a tabs gets removed without calling SetTabItemClosed().[m
[32m+[m[32m    const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);[m
[32m+[m[32m    if (tab_bar->VisibleTabWasSubmitted || tab_bar->VisibleTabId == 0 || tab_bar_appearing)[m
[32m+[m[32m        tab_bar->ContentsHeight = ImMax(window->DC.CursorPos.y - tab_bar->BarRect.Max.y, 0.0f);[m
[32m+[m[32m    else[m
[32m+[m[32m        window->DC.CursorPos.y = tab_bar->BarRect.Max.y + tab_bar->ContentsHeight;[m
[32m+[m
[32m+[m[32m    if ((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0)[m
[32m+[m[32m        PopID();[m
[32m+[m
[32m+[m[32m    g.CurrentTabBarStack.pop_back();[m
[32m+[m[32m    g.CurrentTabBar = g.CurrentTabBarStack.empty() ? NULL : GetTabBarFromTabBarRef(g.CurrentTabBarStack.back());[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// This is called only once a frame before by the first call to ItemTab()[m
[32m+[m[32m// The reason we're not calling it in BeginTabBar() is to leave a chance to the user to call the SetTabItemClosed() functions.[m
[32m+[m[32mstatic void ImGui::TabBarLayout(ImGuiTabBar* tab_bar)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    tab_bar->WantLayout = false;[m
[32m+[m
[32m+[m[32m    // Garbage collect[m
[32m+[m[32m    int tab_dst_n = 0;[m
[32m+[m[32m    for (int tab_src_n = 0; tab_src_n < tab_bar->Tabs.Size; tab_src_n++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiTabItem* tab = &tab_bar->Tabs[tab_src_n];[m
[32m+[m[32m        if (tab->LastFrameVisible < tab_bar->PrevFrameVisible)[m
[32m+[m[32m        {[m
[32m+[m[32m            if (tab->ID == tab_bar->SelectedTabId)[m
[32m+[m[32m                tab_bar->SelectedTabId = 0;[m
[32m+[m[32m            continue;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (tab_dst_n != tab_src_n)[m
[32m+[m[32m            tab_bar->Tabs[tab_dst_n] = tab_bar->Tabs[tab_src_n];[m
[32m+[m[32m        tab_dst_n++;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (tab_bar->Tabs.Size != tab_dst_n)[m
[32m+[m[32m        tab_bar->Tabs.resize(tab_dst_n);[m
[32m+[m
[32m+[m[32m    // Setup next selected tab[m
[32m+[m[32m    ImGuiID scroll_track_selected_tab_id = 0;[m
[32m+[m[32m    if (tab_bar->NextSelectedTabId)[m
[32m+[m[32m    {[m
[32m+[m[32m        tab_bar->SelectedTabId = tab_bar->NextSelectedTabId;[m
[32m+[m[32m        tab_bar->NextSelectedTabId = 0;[m
[32m+[m[32m        scroll_track_selected_tab_id = tab_bar->SelectedTabId;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Process order change request (we could probably process it when requested but it's just saner to do it in a single spot).[m
[32m+[m[32m    if (tab_bar->ReorderRequestTabId != 0)[m
[32m+[m[32m    {[m
[32m+[m[32m        if (ImGuiTabItem* tab1 = TabBarFindTabByID(tab_bar, tab_bar->ReorderRequestTabId))[m
[32m+[m[32m        {[m
[32m+[m[32m            //IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_Reorderable); // <- this may happen when using debug tools[m
[32m+[m[32m            int tab2_order = tab_bar->GetTabOrder(tab1) + tab_bar->ReorderRequestDir;[m
[32m+[m[32m            if (tab2_order >= 0 && tab2_order < tab_bar->Tabs.Size)[m
[32m+[m[32m            {[m
[32m+[m[32m                ImGuiTabItem* tab2 = &tab_bar->Tabs[tab2_order];[m
[32m+[m[32m                ImGuiTabItem item_tmp = *tab1;[m
[32m+[m[32m                *tab1 = *tab2;[m
[32m+[m[32m                *tab2 = item_tmp;[m
[32m+[m[32m                if (tab2->ID == tab_bar->SelectedTabId)[m
[32m+[m[32m                    scroll_track_selected_tab_id = tab2->ID;[m
[32m+[m[32m                tab1 = tab2 = NULL;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (tab_bar->Flags & ImGuiTabBarFlags_SaveSettings)[m
[32m+[m[32m                MarkIniSettingsDirty();[m
[32m+[m[32m        }[m
[32m+[m[32m        tab_bar->ReorderRequestTabId = 0;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Tab List Popup (will alter tab_bar->BarRect and therefore the available width!)[m
[32m+[m[32m    const bool tab_list_popup_button = (tab_bar->Flags & ImGuiTabBarFlags_TabListPopupButton) != 0;[m
[32m+[m[32m    if (tab_list_popup_button)[m
[32m+[m[32m        if (ImGuiTabItem* tab_to_select = TabBarTabListPopupButton(tab_bar)) // NB: Will alter BarRect.Max.x![m
[32m+[m[32m            scroll_track_selected_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;[m
[32m+[m
[32m+[m[32m    ImVector<ImGuiTabBarSortItem>& width_sort_buffer = g.TabSortByWidthBuffer;[m
[32m+[m[32m    width_sort_buffer.resize(tab_bar->Tabs.Size);[m
[32m+[m
[32m+[m[32m    // Compute ideal widths[m
[32m+[m[32m    float width_total_contents = 0.0f;[m
[32m+[m[32m    ImGuiTabItem* most_recently_selected_tab = NULL;[m
[32m+[m[32m    bool found_selected_tab_id = false;[m
[32m+[m[32m    for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];[m
[32m+[m[32m        IM_ASSERT(tab->LastFrameVisible >= tab_bar->PrevFrameVisible);[m
[32m+[m
[32m+[m[32m        if (most_recently_selected_tab == NULL || most_recently_selected_tab->LastFrameSelected < tab->LastFrameSelected)[m
[32m+[m[32m            most_recently_selected_tab = tab;[m
[32m+[m[32m        if (tab->ID == tab_bar->SelectedTabId)[m
[32m+[m[32m            found_selected_tab_id = true;[m
[32m+[m
[32m+[m[32m        // Refresh tab width immediately, otherwise changes of style e.g. style.FramePadding.x would noticeably lag in the tab bar.[m
[32m+[m[32m        // Additionally, when using TabBarAddTab() to manipulate tab bar order we occasionally insert new tabs that don't have a width yet,[m
[32m+[m[32m        // and we cannot wait for the next BeginTabItem() call. We cannot compute this width within TabBarAddTab() because font size depends on the active window.[m
[32m+[m[32m        const char* tab_name = tab_bar->GetTabName(tab);[m
[32m+[m[32m        tab->WidthContents = TabItemCalcSize(tab_name, (tab->Flags & ImGuiTabItemFlags_NoCloseButton) ? false : true).x;[m
[32m+[m
[32m+[m[32m        width_total_contents += (tab_n > 0 ? g.Style.ItemInnerSpacing.x : 0.0f) + tab->WidthContents;[m
[32m+[m
[32m+[m[32m        // Store data so we can build an array sorted by width if we need to shrink tabs down[m
[32m+[m[32m        width_sort_buffer[tab_n].Index = tab_n;[m
[32m+[m[32m        width_sort_buffer[tab_n].Width = tab->WidthContents;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Compute width[m
[32m+[m[32m    const float width_avail = tab_bar->BarRect.GetWidth();[m
[32m+[m[32m    float width_excess = (width_avail < width_total_contents) ? (width_total_contents - width_avail) : 0.0f;[m
[32m+[m[32m    if (width_excess > 0.0f && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyResizeDown))[m
[32m+[m[32m    {[m
[32m+[m[32m        // If we don't have enough room, resize down the largest tabs first[m
[32m+[m[32m        if (tab_bar->Tabs.Size > 1)[m
[32m+[m[32m            ImQsort(width_sort_buffer.Data, (size_t)width_sort_buffer.Size, sizeof(ImGuiTabBarSortItem), TabBarSortItemComparer);[m
[32m+[m[32m        int tab_count_same_width = 1;[m
[32m+[m[32m        while (width_excess > 0.0f && tab_count_same_width < tab_bar->Tabs.Size)[m
[32m+[m[32m        {[m
[32m+[m[32m            while (tab_count_same_width < tab_bar->Tabs.Size && width_sort_buffer[0].Width == width_sort_buffer[tab_count_same_width].Width)[m
[32m+[m[32m                tab_count_same_width++;[m
[32m+[m[32m            float width_to_remove_per_tab_max = (tab_count_same_width < tab_bar->Tabs.Size) ? (width_sort_buffer[0].Width - width_sort_buffer[tab_count_same_width].Width) : (width_sort_buffer[0].Width - 1.0f);[m
[32m+[m[32m            float width_to_remove_per_tab = ImMin(width_excess / tab_count_same_width, width_to_remove_per_tab_max);[m
[32m+[m[32m            for (int tab_n = 0; tab_n < tab_count_same_width; tab_n++)[m
[32m+[m[32m                width_sort_buffer[tab_n].Width -= width_to_remove_per_tab;[m
[32m+[m[32m            width_excess -= width_to_remove_per_tab * tab_count_same_width;[m
[32m+[m[32m        }[m
[32m+[m[32m        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)[m
[32m+[m[32m            tab_bar->Tabs[width_sort_buffer[tab_n].Index].Width = (float)(int)width_sort_buffer[tab_n].Width;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        const float tab_max_width = TabBarCalcMaxTabWidth();[m
[32m+[m[32m        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];[m
[32m+[m[32m            tab->Width = ImMin(tab->WidthContents, tab_max_width);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Layout all active tabs[m
[32m+[m[32m    float offset_x = 0.0f;[m
[32m+[m[32m    for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];[m
[32m+[m[32m        tab->Offset = offset_x;[m
[32m+[m[32m        if (scroll_track_selected_tab_id == 0 && g.NavJustMovedToId == tab->ID)[m
[32m+[m[32m            scroll_track_selected_tab_id = tab->ID;[m
[32m+[m[32m        offset_x += tab->Width + g.Style.ItemInnerSpacing.x;[m
[32m+[m[32m    }[m
[32m+[m[32m    tab_bar->OffsetMax = ImMax(offset_x - g.Style.ItemInnerSpacing.x, 0.0f);[m
[32m+[m[32m    tab_bar->OffsetNextTab = 0.0f;[m
[32m+[m
[32m+[m[32m    // Horizontal scrolling buttons[m
[32m+[m[32m    const bool scrolling_buttons = (tab_bar->OffsetMax > tab_bar->BarRect.GetWidth() && tab_bar->Tabs.Size > 1) && !(tab_bar->Flags & ImGuiTabBarFlags_NoTabListScrollingButtons) && (tab_bar->Flags & ImGuiTabBarFlags_FittingPolicyScroll);[m
[32m+[m[32m    if (scrolling_buttons)[m
[32m+[m[32m        if (ImGuiTabItem* tab_to_select = TabBarScrollingButtons(tab_bar)) // NB: Will alter BarRect.Max.x![m
[32m+[m[32m            scroll_track_selected_tab_id = tab_bar->SelectedTabId = tab_to_select->ID;[m
[32m+[m
[32m+[m[32m    // If we have lost the selected tab, select the next most recently active one[m
[32m+[m[32m    if (found_selected_tab_id == false)[m
[32m+[m[32m        tab_bar->SelectedTabId = 0;[m
[32m+[m[32m    if (tab_bar->SelectedTabId == 0 && tab_bar->NextSelectedTabId == 0 && most_recently_selected_tab != NULL)[m
[32m+[m[32m        scroll_track_selected_tab_id = tab_bar->SelectedTabId = most_recently_selected_tab->ID;[m
[32m+[m
[32m+[m[32m    // Lock in visible tab[m
[32m+[m[32m    tab_bar->VisibleTabId = tab_bar->SelectedTabId;[m
[32m+[m[32m    tab_bar->VisibleTabWasSubmitted = false;[m
[32m+[m
[32m+[m[32m    // Update scrolling[m
[32m+[m[32m    if (scroll_track_selected_tab_id)[m
[32m+[m[32m        if (ImGuiTabItem* scroll_track_selected_tab = TabBarFindTabByID(tab_bar, scroll_track_selected_tab_id))[m
[32m+[m[32m            TabBarScrollToTab(tab_bar, scroll_track_selected_tab);[m
[32m+[m[32m    tab_bar->ScrollingAnim = TabBarScrollClamp(tab_bar, tab_bar->ScrollingAnim);[m
[32m+[m[32m    tab_bar->ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar->ScrollingTarget);[m
[32m+[m[32m    if (tab_bar->ScrollingAnim != tab_bar->ScrollingTarget)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Scrolling speed adjust itself so we can always reach our target in 1/3 seconds.[m
[32m+[m[32m        // Teleport if we are aiming far off the visible line[m
[32m+[m[32m        tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, 70.0f * g.FontSize);[m
[32m+[m[32m        tab_bar->ScrollingSpeed = ImMax(tab_bar->ScrollingSpeed, ImFabs(tab_bar->ScrollingTarget - tab_bar->ScrollingAnim) / 0.3f);[m
[32m+[m[32m        const bool teleport = (tab_bar->PrevFrameVisible + 1 < g.FrameCount) || (tab_bar->ScrollingTargetDistToVisibility > 10.0f * g.FontSize);[m
[32m+[m[32m        tab_bar->ScrollingAnim = teleport ? tab_bar->ScrollingTarget : ImLinearSweep(tab_bar->ScrollingAnim, tab_bar->ScrollingTarget, g.IO.DeltaTime * tab_bar->ScrollingSpeed);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        tab_bar->ScrollingSpeed = 0.0f;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Clear name buffers[m
[32m+[m[32m    if ((tab_bar->Flags & ImGuiTabBarFlags_DockNode) == 0)[m
[32m+[m[32m        tab_bar->TabsNames.Buf.resize(0);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Dockables uses Name/ID in the global namespace. Non-dockable items use the ID stack.[m
[32m+[m[32mstatic ImU32   ImGui::TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label)[m
[32m+[m[32m{[m
[32m+[m[32m    if (tab_bar->Flags & ImGuiTabBarFlags_DockNode)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiID id = ImHashStr(label);[m
[32m+[m[32m        KeepAliveID(id);[m
[32m+[m[32m        return id;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiWindow* window = GImGui->CurrentWindow;[m
[32m+[m[32m        return window->GetID(label);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic float ImGui::TabBarCalcMaxTabWidth()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    return g.FontSize * 20.0f;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImGuiTabItem* ImGui::TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id)[m
[32m+[m[32m{[m
[32m+[m[32m    if (tab_id != 0)[m
[32m+[m[32m        for (int n = 0; n < tab_bar->Tabs.Size; n++)[m
[32m+[m[32m            if (tab_bar->Tabs[n].ID == tab_id)[m
[32m+[m[32m                return &tab_bar->Tabs[n];[m
[32m+[m[32m    return NULL;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// The *TabId fields be already set by the docking system _before_ the actual TabItem was created, so we clear them regardless.[m
[32m+[m[32mvoid ImGui::TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id)[m
[32m+[m[32m{[m
[32m+[m[32m    if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_id))[m
[32m+[m[32m        tab_bar->Tabs.erase(tab);[m
[32m+[m[32m    if (tab_bar->VisibleTabId == tab_id)      { tab_bar->VisibleTabId = 0; }[m
[32m+[m[32m    if (tab_bar->SelectedTabId == tab_id)     { tab_bar->SelectedTabId = 0; }[m
[32m+[m[32m    if (tab_bar->NextSelectedTabId == tab_id) { tab_bar->NextSelectedTabId = 0; }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Called on manual closure attempt[m
[32m+[m[32mvoid ImGui::TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)[m
[32m+[m[32m{[m
[32m+[m[32m    if ((tab_bar->VisibleTabId == tab->ID) && !(tab->Flags & ImGuiTabItemFlags_UnsavedDocument))[m
[32m+[m[32m    {[m
[32m+[m[32m        // This will remove a frame of lag for selecting another tab on closure.[m
[32m+[m[32m        // However we don't run it in the case where the 'Unsaved' flag is set, so user gets a chance to fully undo the closure[m
[32m+[m[32m        tab->LastFrameVisible = -1;[m
[32m+[m[32m        tab_bar->SelectedTabId = tab_bar->NextSelectedTabId = 0;[m
[32m+[m[32m    }[m
[32m+[m[32m    else if ((tab_bar->VisibleTabId != tab->ID) && (tab->Flags & ImGuiTabItemFlags_UnsavedDocument))[m
[32m+[m[32m    {[m
[32m+[m[32m        // Actually select before expecting closure[m
[32m+[m[32m        tab_bar->NextSelectedTabId = tab->ID;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic float ImGui::TabBarScrollClamp(ImGuiTabBar* tab_bar, float scrolling)[m
[32m+[m[32m{[m
[32m+[m[32m    scrolling = ImMin(scrolling, tab_bar->OffsetMax - tab_bar->BarRect.GetWidth());[m
[32m+[m[32m    return ImMax(scrolling, 0.0f);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void ImGui::TabBarScrollToTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    float margin = g.FontSize * 1.0f; // When to scroll to make Tab N+1 visible always make a bit of N visible to suggest more scrolling area (since we don't have a scrollbar)[m
[32m+[m[32m    int order = tab_bar->GetTabOrder(tab);[m
[32m+[m[32m    float tab_x1 = tab->Offset + (order > 0 ? -margin : 0.0f);[m
[32m+[m[32m    float tab_x2 = tab->Offset + tab->Width + (order + 1 < tab_bar->Tabs.Size ? margin : 1.0f);[m
[32m+[m[32m    tab_bar->ScrollingTargetDistToVisibility = 0.0f;[m
[32m+[m[32m    if (tab_bar->ScrollingTarget > tab_x1)[m
[32m+[m[32m    {[m
[32m+[m[32m        tab_bar->ScrollingTargetDistToVisibility = ImMax(tab_bar->ScrollingAnim - tab_x2, 0.0f);[m
[32m+[m[32m        tab_bar->ScrollingTarget = tab_x1;[m
[32m+[m[32m    }[m
[32m+[m[32m    else if (tab_bar->ScrollingTarget < tab_x2 - tab_bar->BarRect.GetWidth())[m
[32m+[m[32m    {[m
[32m+[m[32m        tab_bar->ScrollingTargetDistToVisibility = ImMax((tab_x1 - tab_bar->BarRect.GetWidth()) - tab_bar->ScrollingAnim, 0.0f);[m
[32m+[m[32m        tab_bar->ScrollingTarget = tab_x2 - tab_bar->BarRect.GetWidth();[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::TabBarQueueChangeTabOrder(ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, int dir)[m
[32m+[m[32m{[m
[32m+[m[32m    IM_ASSERT(dir == -1 || dir == +1);[m
[32m+[m[32m    IM_ASSERT(tab_bar->ReorderRequestTabId == 0);[m
[32m+[m[32m    tab_bar->ReorderRequestTabId = tab->ID;[m
[32m+[m[32m    tab_bar->ReorderRequestDir = dir;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic ImGuiTabItem* ImGui::TabBarScrollingButtons(ImGuiTabBar* tab_bar)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m
[32m+[m[32m    const ImVec2 arrow_button_size(g.FontSize - 2.0f, g.FontSize + g.Style.FramePadding.y * 2.0f);[m
[32m+[m[32m    const float scrolling_buttons_width = arrow_button_size.x * 2.0f;[m
[32m+[m
[32m+[m[32m    const ImVec2 backup_cursor_pos = window->DC.CursorPos;[m
[32m+[m[32m    //window->DrawList->AddRect(ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y), ImVec2(tab_bar->BarRect.Max.x, tab_bar->BarRect.Max.y), IM_COL32(255,0,0,255));[m
[32m+[m
[32m+[m[32m    const ImRect avail_bar_rect = tab_bar->BarRect;[m
[32m+[m[32m    bool want_clip_rect = !avail_bar_rect.Contains(ImRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(scrolling_buttons_width, 0.0f)));[m
[32m+[m[32m    if (want_clip_rect)[m
[32m+[m[32m        PushClipRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max + ImVec2(g.Style.ItemInnerSpacing.x, 0.0f), true);[m
[32m+[m
[32m+[m[32m    ImGuiTabItem* tab_to_select = NULL;[m
[32m+[m
[32m+[m[32m    int select_dir = 0;[m
[32m+[m[32m    ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];[m
[32m+[m[32m    arrow_col.w *= 0.5f;[m
[32m+[m
[32m+[m[32m    PushStyleColor(ImGuiCol_Text, arrow_col);[m
[32m+[m[32m    PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));[m
[32m+[m[32m    const float backup_repeat_delay = g.IO.KeyRepeatDelay;[m
[32m+[m[32m    const float backup_repeat_rate = g.IO.KeyRepeatRate;[m
[32m+[m[32m    g.IO.KeyRepeatDelay = 0.250f;[m
[32m+[m[32m    g.IO.KeyRepeatRate = 0.200f;[m
[32m+[m[32m    window->DC.CursorPos = ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y);[m
[32m+[m[32m    if (ArrowButtonEx("##<", ImGuiDir_Left, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))[m
[32m+[m[32m        select_dir = -1;[m
[32m+[m[32m    window->DC.CursorPos = ImVec2(tab_bar->BarRect.Max.x - scrolling_buttons_width + arrow_button_size.x, tab_bar->BarRect.Min.y);[m
[32m+[m[32m    if (ArrowButtonEx("##>", ImGuiDir_Right, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))[m
[32m+[m[32m        select_dir = +1;[m
[32m+[m[32m    PopStyleColor(2);[m
[32m+[m[32m    g.IO.KeyRepeatRate = backup_repeat_rate;[m
[32m+[m[32m    g.IO.KeyRepeatDelay = backup_repeat_delay;[m
[32m+[m
[32m+[m[32m    if (want_clip_rect)[m
[32m+[m[32m        PopClipRect();[m
[32m+[m
[32m+[m[32m    if (select_dir != 0)[m
[32m+[m[32m        if (ImGuiTabItem* tab_item = TabBarFindTabByID(tab_bar, tab_bar->SelectedTabId))[m
[32m+[m[32m        {[m
[32m+[m[32m            int selected_order = tab_bar->GetTabOrder(tab_item);[m
[32m+[m[32m            int target_order = selected_order + select_dir;[m
[32m+[m[32m            tab_to_select = &tab_bar->Tabs[(target_order >= 0 && target_order < tab_bar->Tabs.Size) ? target_order : selected_order]; // If we are at the end of the list, still scroll to make our tab visible[m
[32m+[m[32m        }[m
[32m+[m[32m    window->DC.CursorPos = backup_cursor_pos;[m
[32m+[m[32m    tab_bar->BarRect.Max.x -= scrolling_buttons_width + 1.0f;[m
[32m+[m
[32m+[m[32m    return tab_to_select;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic ImGuiTabItem* ImGui::TabBarTabListPopupButton(ImGuiTabBar* tab_bar)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m
[32m+[m[32m    // We use g.Style.FramePadding.y to match the square ArrowButton size[m
[32m+[m[32m    const float tab_list_popup_button_width = g.FontSize + g.Style.FramePadding.y;[m
[32m+[m[32m    const ImVec2 backup_cursor_pos = window->DC.CursorPos;[m
[32m+[m[32m    window->DC.CursorPos = ImVec2(tab_bar->BarRect.Min.x - g.Style.FramePadding.y, tab_bar->BarRect.Min.y);[m
[32m+[m[32m    tab_bar->BarRect.Min.x += tab_list_popup_button_width;[m
[32m+[m
[32m+[m[32m    ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];[m
[32m+[m[32m    arrow_col.w *= 0.5f;[m
[32m+[m[32m    PushStyleColor(ImGuiCol_Text, arrow_col);[m
[32m+[m[32m    PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));[m
[32m+[m[32m    bool open = BeginCombo("##v", NULL, ImGuiComboFlags_NoPreview);[m
[32m+[m[32m    PopStyleColor(2);[m
[32m+[m
[32m+[m[32m    ImGuiTabItem* tab_to_select = NULL;[m
[32m+[m[32m    if (open)[m
[32m+[m[32m    {[m
[32m+[m[32m        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)[m
[32m+[m[32m        {[m
[32m+[m[32m            ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];[m
[32m+[m[32m            const char* tab_name = tab_bar->GetTabName(tab);[m
[32m+[m[32m            if (Selectable(tab_name, tab_bar->SelectedTabId == tab->ID))[m
[32m+[m[32m                tab_to_select = tab;[m
[32m+[m[32m        }[m
[32m+[m[32m        EndCombo();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    window->DC.CursorPos = backup_cursor_pos;[m
[32m+[m[32m    return tab_to_select;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// [BETA API] API may evolve! This code has been extracted out of the Docking branch,[m
[32m+[m[32m// and some of the construct which are not used in Master may be left here to facilitate merging.[m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m[32m// - BeginTabItem()[m
[32m+[m[32m// - EndTabItem()[m
[32m+[m[32m// - TabItemEx() [Internal][m
[32m+[m[32m// - SetTabItemClosed()[m
[32m+[m[32m// - TabItemCalcSize() [Internal][m
[32m+[m[32m// - TabItemBackground() [Internal][m
[32m+[m[32m// - TabItemLabelAndCloseButton() [Internal][m
[32m+[m[32m//-------------------------------------------------------------------------[m
[32m+[m
[32m+[m[32mbool    ImGui::BeginTabItem(const char* label, bool* p_open, ImGuiTabItemFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    ImGuiTabBar* tab_bar = g.CurrentTabBar;[m
[32m+[m[32m    if (tab_bar == NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(tab_bar && "Needs to be called between BeginTabBar() and EndTabBar()!");[m
[32m+[m[32m        return false; // FIXME-ERRORHANDLING[m
[32m+[m[32m    }[m
[32m+[m[32m    bool ret = TabItemEx(tab_bar, label, p_open, flags);[m
[32m+[m[32m    if (ret && !(flags & ImGuiTabItemFlags_NoPushId))[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiTabItem* tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];[m
[32m+[m[32m        PushOverrideID(tab->ID); // We already hashed 'label' so push into the ID stack directly instead of doing another hash through PushID(label)[m
[32m+[m[32m    }[m
[32m+[m[32m    return ret;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid    ImGui::EndTabItem()[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return;[m
[32m+[m
[32m+[m[32m    ImGuiTabBar* tab_bar = g.CurrentTabBar;[m
[32m+[m[32m    if (tab_bar == NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        IM_ASSERT(tab_bar != NULL && "Needs to be called between BeginTabBar() and EndTabBar()!");[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    IM_ASSERT(tab_bar->LastTabItemIdx >= 0);[m
[32m+[m[32m    ImGuiTabItem* tab = &tab_bar->Tabs[tab_bar->LastTabItemIdx];[m
[32m+[m[32m    if (!(tab->Flags & ImGuiTabItemFlags_NoPushId))[m
[32m+[m[32m        window->IDStack.pop_back();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool    ImGui::TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags)[m
[32m+[m[32m{[m
[32m+[m[32m    // Layout whole tab bar if not already done[m
[32m+[m[32m    if (tab_bar->WantLayout)[m
[32m+[m[32m        TabBarLayout(tab_bar);[m
[32m+[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImGuiWindow* window = g.CurrentWindow;[m
[32m+[m[32m    if (window->SkipItems)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    const ImGuiStyle& style = g.Style;[m
[32m+[m[32m    const ImGuiID id = TabBarCalcTabID(tab_bar, label);[m
[32m+[m
[32m+[m[32m    // If the user called us with *p_open == false, we early out and don't render. We make a dummy call to ItemAdd() so that attempts to use a contextual popup menu with an implicit ID won't use an older ID.[m
[32m+[m[32m    if (p_open && !*p_open)[m
[32m+[m[32m    {[m
[32m+[m[32m        PushItemFlag(ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus, true);[m
[32m+[m[32m        ItemAdd(ImRect(), id);[m
[32m+[m[32m        PopItemFlag();[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Calculate tab contents size[m
[32m+[m[32m    ImVec2 size = TabItemCalcSize(label, p_open != NULL);[m
[32m+[m
[32m+[m[32m    // Acquire tab data[m
[32m+[m[32m    ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, id);[m
[32m+[m[32m    bool tab_is_new = false;[m
[32m+[m[32m    if (tab == NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        tab_bar->Tabs.push_back(ImGuiTabItem());[m
[32m+[m[32m        tab = &tab_bar->Tabs.back();[m
[32m+[m[32m        tab->ID = id;[m
[32m+[m[32m        tab->Width = size.x;[m
[32m+[m[32m        tab_is_new = true;[m
[32m+[m[32m    }[m
[32m+[m[32m    tab_bar->LastTabItemIdx = (short)tab_bar->Tabs.index_from_ptr(tab);[m
[32m+[m[32m    tab->WidthContents = size.x;[m
[32m+[m
[32m+[m[32m    if (p_open == NULL)[m
[32m+[m[32m        flags |= ImGuiTabItemFlags_NoCloseButton;[m
[32m+[m
[32m+[m[32m    const bool tab_bar_appearing = (tab_bar->PrevFrameVisible + 1 < g.FrameCount);[m
[32m+[m[32m    const bool tab_bar_focused = (tab_bar->Flags & ImGuiTabBarFlags_IsFocused) != 0;[m
[32m+[m[32m    const bool tab_appearing = (tab->LastFrameVisible + 1 < g.FrameCount);[m
[32m+[m[32m    tab->LastFrameVisible = g.FrameCount;[m
[32m+[m[32m    tab->Flags = flags;[m
[32m+[m
[32m+[m[32m    // Append name with zero-terminator[m
[32m+[m[32m    tab->NameOffset = tab_bar->TabsNames.size();[m
[32m+[m[32m    tab_bar->TabsNames.append(label, label + strlen(label) + 1);[m
[32m+[m
[32m+[m[32m    // If we are not reorderable, always reset offset based on submission order.[m
[32m+[m[32m    // (We already handled layout and sizing using the previous known order, but sizing is not affected by order!)[m
[32m+[m[32m    if (!tab_appearing && !(tab_bar->Flags & ImGuiTabBarFlags_Reorderable))[m
[32m+[m[32m    {[m
[32m+[m[32m        tab->Offset = tab_bar->OffsetNextTab;[m
[32m+[m[32m        tab_bar->OffsetNextTab += tab->Width + g.Style.ItemInnerSpacing.x;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Update selected tab[m
[32m+[m[32m    if (tab_appearing && (tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs) && tab_bar->NextSelectedTabId == 0)[m
[32m+[m[32m        if (!tab_bar_appearing || tab_bar->SelectedTabId == 0)[m
[32m+[m[32m            tab_bar->NextSelectedTabId = id;  // New tabs gets activated[m
[32m+[m[32m    if ((flags & ImGuiTabItemFlags_SetSelected) && (tab_bar->SelectedTabId != id)) // SetSelected can only be passed on explicit tab bar[m
[32m+[m[32m        tab_bar->NextSelectedTabId = id;[m
[32m+[m
[32m+[m[32m    // Lock visibility[m
[32m+[m[32m    bool tab_contents_visible = (tab_bar->VisibleTabId == id);[m
[32m+[m[32m    if (tab_contents_visible)[m
[32m+[m[32m        tab_bar->VisibleTabWasSubmitted = true;[m
[32m+[m
[32m+[m[32m    // On the very first frame of a tab bar we let first tab contents be visible to minimize appearing glitches[m
[32m+[m[32m    if (!tab_contents_visible && tab_bar->SelectedTabId == 0 && tab_bar_appearing)[m
[32m+[m[32m        if (tab_bar->Tabs.Size == 1 && !(tab_bar->Flags & ImGuiTabBarFlags_AutoSelectNewTabs))[m
[32m+[m[32m            tab_contents_visible = true;[m
[32m+[m
[32m+[m[32m    if (tab_appearing && !(tab_bar_appearing && !tab_is_new))[m
[32m+[m[32m    {[m
[32m+[m[32m        PushItemFlag(ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus, true);[m
[32m+[m[32m        ItemAdd(ImRect(), id);[m
[32m+[m[32m        PopItemFlag();[m
[32m+[m[32m        return tab_contents_visible;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (tab_bar->SelectedTabId == id)[m
[32m+[m[32m        tab->LastFrameSelected = g.FrameCount;[m
[32m+[m
[32m+[m[32m    // Backup current layout position[m
[32m+[m[32m    const ImVec2 backup_main_cursor_pos = window->DC.CursorPos;[m
[32m+[m
[32m+[m[32m    // Layout[m
[32m+[m[32m    size.x = tab->Width;[m
[32m+[m[32m    window->DC.CursorPos = tab_bar->BarRect.Min + ImVec2((float)(int)tab->Offset - tab_bar->ScrollingAnim, 0.0f);[m
[32m+[m[32m    ImVec2 pos = window->DC.CursorPos;[m
[32m+[m[32m    ImRect bb(pos, pos + size);[m
[32m+[m
[32m+[m[32m    // We don't have CPU clipping primitives to clip the CloseButton (until it becomes a texture), so need to add an extra draw call (temporary in the case of vertical animation)[m
[32m+[m[32m    bool want_clip_rect = (bb.Min.x < tab_bar->BarRect.Min.x) || (bb.Max.x >= tab_bar->BarRect.Max.x);[m
[32m+[m[32m    if (want_clip_rect)[m
[32m+[m[32m        PushClipRect(ImVec2(ImMax(bb.Min.x, tab_bar->BarRect.Min.x), bb.Min.y - 1), ImVec2(tab_bar->BarRect.Max.x, bb.Max.y), true);[m
[32m+[m
[32m+[m[32m    ItemSize(bb, style.FramePadding.y);[m
[32m+[m[32m    if (!ItemAdd(bb, id))[m
[32m+[m[32m    {[m
[32m+[m[32m        if (want_clip_rect)[m
[32m+[m[32m            PopClipRect();[m
[32m+[m[32m        window->DC.CursorPos = backup_main_cursor_pos;[m
[32m+[m[32m        return tab_contents_visible;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Click to Select a tab[m
[32m+[m[32m    ImGuiButtonFlags button_flags = (ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_AllowItemOverlap);[m
[32m+[m[32m    if (g.DragDropActive)[m
[32m+[m[32m        button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;[m
[32m+[m[32m    bool hovered, held;[m
[32m+[m[32m    bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);[m
[32m+[m[32m    if (pressed)[m
[32m+[m[32m        tab_bar->NextSelectedTabId = id;[m
[32m+[m[32m    hovered |= (g.HoveredId == id);[m
[32m+[m
[32m+[m[32m    // Allow the close button to overlap unless we are dragging (in which case we don't want any overlapping tabs to be hovered)[m
[32m+[m[32m    if (!held)[m
[32m+[m[32m        SetItemAllowOverlap();[m
[32m+[m
[32m+[m[32m    // Drag and drop: re-order tabs[m
[32m+[m[32m    if (held && !tab_appearing && IsMouseDragging(0))[m
[32m+[m[32m    {[m
[32m+[m[32m        if (!g.DragDropActive && (tab_bar->Flags & ImGuiTabBarFlags_Reorderable))[m
[32m+[m[32m        {[m
[32m+[m[32m            // While moving a tab it will jump on the other side of the mouse, so we also test for MouseDelta.x[m
[32m+[m[32m            if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < bb.Min.x)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (tab_bar->Flags & ImGuiTabBarFlags_Reorderable)[m
[32m+[m[32m                    TabBarQueueChangeTabOrder(tab_bar, tab, -1);[m
[32m+[m[32m            }[m
[32m+[m[32m            else if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > bb.Max.x)[m
[32m+[m[32m            {[m
[32m+[m[32m                if (tab_bar->Flags & ImGuiTabBarFlags_Reorderable)[m
[32m+[m[32m                    TabBarQueueChangeTabOrder(tab_bar, tab, +1);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m#if 0[m
[32m+[m[32m    if (hovered && g.HoveredIdNotActiveTimer > 0.50f && bb.GetWidth() < tab->WidthContents)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Enlarge tab display when hovering[m
[32m+[m[32m        bb.Max.x = bb.Min.x + (float)(int)ImLerp(bb.GetWidth(), tab->WidthContents, ImSaturate((g.HoveredIdNotActiveTimer - 0.40f) * 6.0f));[m
[32m+[m[32m        display_draw_list = GetForegroundDrawList(window);[m
[32m+[m[32m        TabItemBackground(display_draw_list, bb, flags, GetColorU32(ImGuiCol_TitleBgActive));[m
[32m+[m[32m    }[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m    // Render tab shape[m
[32m+[m[32m    ImDrawList* display_draw_list = window->DrawList;[m
[32m+[m[32m    const ImU32 tab_col = GetColorU32((held || hovered) ? ImGuiCol_TabHovered : tab_contents_visible ? (tab_bar_focused ? ImGuiCol_TabActive : ImGuiCol_TabUnfocusedActive) : (tab_bar_focused ? ImGuiCol_Tab : ImGuiCol_TabUnfocused));[m
[32m+[m[32m    TabItemBackground(display_draw_list, bb, flags, tab_col);[m
[32m+[m[32m    RenderNavHighlight(bb, id);[m
[32m+[m
[32m+[m[32m    // Select with right mouse button. This is so the common idiom for context menu automatically highlight the current widget.[m
[32m+[m[32m    const bool hovered_unblocked = IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup);[m
[32m+[m[32m    if (hovered_unblocked && (IsMouseClicked(1) || IsMouseReleased(1)))[m
[32m+[m[32m        tab_bar->NextSelectedTabId = id;[m
[32m+[m
[32m+[m[32m    if (tab_bar->Flags & ImGuiTabBarFlags_NoCloseWithMiddleMouseButton)[m
[32m+[m[32m        flags |= ImGuiTabItemFlags_NoCloseWithMiddleMouseButton;[m
[32m+[m
[32m+[m[32m    // Render tab label, process close button[m
[32m+[m[32m    const ImGuiID close_button_id = p_open ? window->GetID((void*)((intptr_t)id + 1)) : 0;[m
[32m+[m[32m    bool just_closed = TabItemLabelAndCloseButton(display_draw_list, bb, flags, tab_bar->FramePadding, label, id, close_button_id);[m
[32m+[m[32m    if (just_closed && p_open != NULL)[m
[32m+[m[32m    {[m
[32m+[m[32m        *p_open = false;[m
[32m+[m[32m        TabBarCloseTab(tab_bar, tab);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Restore main window position so user can draw there[m
[32m+[m[32m    if (want_clip_rect)[m
[32m+[m[32m        PopClipRect();[m
[32m+[m[32m    window->DC.CursorPos = backup_main_cursor_pos;[m
[32m+[m
[32m+[m[32m    // Tooltip (FIXME: Won't work over the close button because ItemOverlap systems messes up with HoveredIdTimer)[m
[32m+[m[32m    // We test IsItemHovered() to discard e.g. when another item is active or drag and drop over the tab bar (which g.HoveredId ignores)[m
[32m+[m[32m    if (g.HoveredId == id && !held && g.HoveredIdNotActiveTimer > 0.50f && IsItemHovered())[m
[32m+[m[32m        if (!(tab_bar->Flags & ImGuiTabBarFlags_NoTooltip))[m
[32m+[m[32m            SetTooltip("%.*s", (int)(FindRenderedTextEnd(label) - label), label);[m
[32m+[m
[32m+[m[32m    return tab_contents_visible;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// [Public] This is call is 100% optional but it allows to remove some one-frame glitches when a tab has been unexpectedly removed.[m
[32m+[m[32m// To use it to need to call the function SetTabItemClosed() after BeginTabBar() and before any call to BeginTabItem()[m
[32m+[m[32mvoid    ImGui::SetTabItemClosed(const char* label)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    bool is_within_manual_tab_bar = g.CurrentTabBar && !(g.CurrentTabBar->Flags & ImGuiTabBarFlags_DockNode);[m
[32m+[m[32m    if (is_within_manual_tab_bar)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiTabBar* tab_bar = g.CurrentTabBar;[m
[32m+[m[32m        IM_ASSERT(tab_bar->WantLayout);         // Needs to be called AFTER BeginTabBar() and BEFORE the first call to BeginTabItem()[m
[32m+[m[32m        ImGuiID tab_id = TabBarCalcTabID(tab_bar, label);[m
[32m+[m[32m        TabBarRemoveTab(tab_bar, tab_id);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mImVec2 ImGui::TabItemCalcSize(const char* label, bool has_close_button)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImVec2 label_size = CalcTextSize(label, NULL, true);[m
[32m+[m[32m    ImVec2 size = ImVec2(label_size.x + g.Style.FramePadding.x, label_size.y + g.Style.FramePadding.y * 2.0f);[m
[32m+[m[32m    if (has_close_button)[m
[32m+[m[32m        size.x += g.Style.FramePadding.x + (g.Style.ItemInnerSpacing.x + g.FontSize); // We use Y intentionally to fit the close button circle.[m
[32m+[m[32m    else[m
[32m+[m[32m        size.x += g.Style.FramePadding.x + 1.0f;[m
[32m+[m[32m    return ImVec2(ImMin(size.x, TabBarCalcMaxTabWidth()), size.y);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ImGui::TabItemBackground(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col)[m
[32m+[m[32m{[m
[32m+[m[32m    // While rendering tabs, we trim 1 pixel off the top of our bounding box so they can fit within a regular frame height while looking "detached" from it.[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    const float width = bb.GetWidth();[m
[32m+[m[32m    IM_UNUSED(flags);[m
[32m+[m[32m    IM_ASSERT(width > 0.0f);[m
[32m+[m[32m    const float rounding = ImMax(0.0f, ImMin(g.Style.TabRounding, width * 0.5f - 1.0f));[m
[32m+[m[32m    const float y1 = bb.Min.y + 1.0f;[m
[32m+[m[32m    const float y2 = bb.Max.y - 1.0f;[m
[32m+[m[32m    draw_list->PathLineTo(ImVec2(bb.Min.x, y2));[m
[32m+[m[32m    draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding, y1 + rounding), rounding, 6, 9);[m
[32m+[m[32m    draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding, y1 + rounding), rounding, 9, 12);[m
[32m+[m[32m    draw_list->PathLineTo(ImVec2(bb.Max.x, y2));[m
[32m+[m[32m    draw_list->PathFillConvex(col);[m
[32m+[m[32m    if (g.Style.TabBorderSize > 0.0f)[m
[32m+[m[32m    {[m
[32m+[m[32m        draw_list->PathLineTo(ImVec2(bb.Min.x + 0.5f, y2));[m
[32m+[m[32m        draw_list->PathArcToFast(ImVec2(bb.Min.x + rounding + 0.5f, y1 + rounding + 0.5f), rounding, 6, 9);[m
[32m+[m[32m        draw_list->PathArcToFast(ImVec2(bb.Max.x - rounding - 0.5f, y1 + rounding + 0.5f), rounding, 9, 12);[m
[32m+[m[32m        draw_list->PathLineTo(ImVec2(bb.Max.x - 0.5f, y2));[m
[32m+[m[32m        draw_list->PathStroke(GetColorU32(ImGuiCol_Border), false, g.Style.TabBorderSize);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Render text label (with custom clipping) + Unsaved Document marker + Close Button logic[m
[32m+[m[32m// We tend to lock style.FramePadding for a given tab-bar, hence the 'frame_padding' parameter.[m
[32m+[m[32mbool ImGui::TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id)[m
[32m+[m[32m{[m
[32m+[m[32m    ImGuiContext& g = *GImGui;[m
[32m+[m[32m    ImVec2 label_size = CalcTextSize(label, NULL, true);[m
[32m+[m[32m    if (bb.GetWidth() <= 1.0f)[m
[32m+[m[32m        return false;[m
[32m+[m
[32m+[m[32m    // Render text label (with clipping + alpha gradient) + unsaved marker[m
[32m+[m[32m    const char* TAB_UNSAVED_MARKER = "*";[m
[32m+[m[32m    ImRect text_pixel_clip_bb(bb.Min.x + frame_padding.x, bb.Min.y + frame_padding.y, bb.Max.x - frame_padding.x, bb.Max.y);[m
[32m+[m[32m    if (flags & ImGuiTabItemFlags_UnsavedDocument)[m
[32m+[m[32m    {[m
[32m+[m[32m        text_pixel_clip_bb.Max.x -= CalcTextSize(TAB_UNSAVED_MARKER, NULL, false).x;[m
[32m+[m[32m        ImVec2 unsaved_marker_pos(ImMin(bb.Min.x + frame_padding.x + label_size.x + 2, text_pixel_clip_bb.Max.x), bb.Min.y + frame_padding.y + (float)(int)(-g.FontSize * 0.25f));[m
[32m+[m[32m        RenderTextClippedEx(draw_list, unsaved_marker_pos, bb.Max - frame_padding, TAB_UNSAVED_MARKER, NULL, NULL);[m
[32m+[m[32m    }[m
[32m+[m[32m    ImRect text_ellipsis_clip_bb = text_pixel_clip_bb;[m
[32m+[m
[32m+[m[32m    // Close Button[m
[32m+[m[32m    // We are relying on a subtle and confusing distinction between 'hovered' and 'g.HoveredId' which happens because we are using ImGuiButtonFlags_AllowOverlapMode + SetItemAllowOverlap()[m
[32m+[m[32m    //  'hovered' will be true when hovering the Tab but NOT when hovering the close button[m
[32m+[m[32m    //  'g.HoveredId==id' will be true when hovering the Tab including when hovering the close button[m
[32m+[m[32m    //  'g.ActiveId==close_button_id' will be true when we are holding on the close button, in which case both hovered booleans are false[m
[32m+[m[32m    bool close_button_pressed = false;[m
[32m+[m[32m    bool close_button_visible = false;[m
[32m+[m[32m    if (close_button_id != 0)[m
[32m+[m[32m        if (g.HoveredId == tab_id || g.HoveredId == close_button_id || g.ActiveId == close_button_id)[m
[32m+[m[32m            close_button_visible = true;[m
[32m+[m[32m    if (close_button_visible)[m
[32m+[m[32m    {[m
[32m+[m[32m        ImGuiItemHoveredDataBackup last_item_backup;[m
[32m+[m[32m        const float close_button_sz = g.FontSize * 0.5f;[m
[32m+[m[32m        if (CloseButton(close_button_id, ImVec2(bb.Max.x - frame_padding.x - close_button_sz, bb.Min.y + frame_padding.y + close_button_sz), close_button_sz))[m
[32m+[m[32m            close_button_pressed = true;[m
[32m+[m[32m        last_item_backup.Restore();[m
[32m+[m
[32m+[m[32m        // Close with middle mouse button[m
[32m+[m[32m        if (!(flags & ImGuiTabItemFlags_NoCloseWithMiddleMouseButton) && IsMouseClicked(2))[m
[32m+[m[32m            close_button_pressed = true;[m
[32m+[m
[32m+[m[32m        text_pixel_clip_bb.Max.x -= close_button_sz * 2.0f;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Label with ellipsis[m
[32m+[m[32m    // FIXME: This should be extracted into a helper but the use of text_pixel_clip_bb and !close_button_visible makes it tricky to abstract at the moment[m
[32m+[m[32m    const char* label_display_end = FindRenderedTextEnd(label);[m
[32m+[m[32m    if (label_size.x > text_ellipsis_clip_bb.GetWidth())[m
[32m+[m[32m    {[m
[32m+[m[32m        const int ellipsis_dot_count = 3;[m
[32m+[m[32m        const float ellipsis_width = (1.0f + 1.0f) * ellipsis_dot_count - 1.0f;[m
[32m+[m[32m        const char* label_end = NULL;[m
[32m+[m[32m        float label_size_clipped_x = g.Font->CalcTextSizeA(g.FontSize, text_ellipsis_clip_bb.GetWidth() - ellipsis_width + 1.0f, 0.0f, label, label_display_end, &label_end).x;[m
[32m+[m[32m        if (label_end == label && label_end < label_display_end)    // Always display at least 1 character if there's no room for character + ellipsis[m
[32m+[m[32m        {[m
[32m+[m[32m            label_end = label + ImTextCountUtf8BytesFromChar(label, label_display_end);[m
[32m+[m[32m            label_size_clipped_x = g.Font->CalcTextSizeA(g.FontSize, FLT_MAX, 0.0f, label, label_end).x;[m
[32m+[m[32m        }[m
[32m+[m[32m        while (label_end > label && ImCharIsBlankA(label_end[-1])) // Trim trailing space[m
[32m+[m[32m        {[m
[32m+[m[32m            label_end--;[m
[32m+[m[32m            label_size_clipped_x -= g.Font->CalcTextSizeA(g.FontSize, FLT_MAX, 0.0f, label_end, label_end + 1).x; // Ascii blanks are always 1 byte[m
[32m+[m[32m        }[m
[32m+[m[32m        RenderTextClippedEx(draw_list, text_pixel_clip_bb.Min, text_pixel_clip_bb.Max, label, label_end, &label_size, ImVec2(0.0f, 0.0f));[m
[32m+[m
[32m+[m[32m        const float ellipsis_x = text_pixel_clip_bb.Min.x + label_size_clipped_x + 1.0f;[m
[32m+[m[32m        if (!close_button_visible && ellipsis_x + ellipsis_width <= bb.Max.x)[m
[32m+[m[32m            RenderPixelEllipsis(draw_list, ImVec2(ellipsis_x, text_pixel_clip_bb.Min.y), ellipsis_dot_count, GetColorU32(ImGuiCol_Text));[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m        RenderTextClippedEx(draw_list, text_pixel_clip_bb.Min, text_pixel_clip_bb.Max, label, label_display_end, &label_size, ImVec2(0.0f, 0.0f));[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return close_button_pressed;[m
[32m+[m[32m}[m
[1mdiff --git a/vendor/source/ImGui/imstb_rectpack.h b/vendor/source/ImGui/imstb_rectpack.h[m
[1mnew file mode 100644[m
[1mindex 0000000..23f922a[m
[1m--- /dev/null[m
[1m+++ b/vendor/source/ImGui/imstb_rectpack.h[m
[36m@@ -0,0 +1,630 @@[m
[32m+[m[32m// [DEAR IMGUI][m[41m [m
[32m+[m[32m// This is a slightly modified version of stb_rect_pack.h 0.99.[m[41m [m
[32m+[m[32m// Those changes would need to be pushed into nothings/stb:[m
[32m+[m[32m// - Added STBRP__CDECL[m
[32m+[m[32m// Grep for [DEAR IMGUI] to find the changes.[m
[32m+[m
[32m+[m[32m// stb_rect_pack.h - v0.99 - public domain - rectangle packing[m
[32m+[m[32m// Sean Barrett 2014[m
[32m+[m[32m//[m
[32m+[m[32m// Useful for e.g. packing rectangular textures into an atlas.[m
[32m+[m[32m// Does not do rotation.[m
[32m+[m[32m//[m
[32m+[m[32m// Not necessarily the awesomest packing method, but better than[m
[32m+[m[32m// the totally naive one in stb_truetype (which is primarily what[m
[32m+[m[32m// this is meant to replace).[m
[32m+[m[32m//[m
[32m+[m[32m// Has only had a few tests run, may have issues.[m
[32m+[m[32m//[m
[32m+[m[32m// More docs to come.[m
[32m+[m[32m//[m
[32m+[m[32m// No memory allocations; uses qsort() and assert() from stdlib.[m
[32m+[m[32m// Can override those by defining STBRP_SORT and STBRP_ASSERT.[m
[32m+[m[32m//[m
[32m+[m[32m// This library currently uses the Skyline Bottom-Left algorithm.[m
[32m+[m[32m//[m
[32m+[m[32m// Please note: better rectangle packers are welcome! Please[m
[32m+[m[32m// implement them to the same API, but with a different init[m
[32m+[m[32m// function.[m
[32m+[m[32m//[m
[32m+[m[32m// Credits[m
[32m+[m[32m//[m
[32m+[m[32m//  Library[m
[32m+[m[32m//    Sean Barrett[m
[32m+[m[32m//  Minor features[m
[32m+[m[32m//    Martins Mozeiko[m
[32m+[m[32m//    github:IntellectualKitty[m
[32m+[m[32m//[m[41m    [m
[32m+[m[32m//  Bugfixes / warning fixes[m
[32m+[m[32m//    Jeremy Jaussaud[m
[32m+[m[32m//[m
[32m+[m[32m// Version history:[m
[32m+[m[32m//[m
[32m+[m[32m//     0.99  (2019-02-07)  warning fixes[m
[32m+[m[32m//     0.11  (2017-03-03)  return packing success/fail result[m
[32m+[m[32m//     0.10  (2016-10-25)  remove cast-away-const to avoid warnings[m
[32m+[m[32m//     0.09  (2016-08-27)  fix compiler warnings[m
[32m+[m[32m//     0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)[m
[32m+[m[32m//     0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)[m
[32m+[m[32m//     0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort[m
[32m+[m[32m//     0.05:  added STBRP_ASSERT to allow replacing assert[m
[32m+[m[32m//     0.04:  fixed minor bug in STBRP_LARGE_RECTS support[m
[32m+[m[32m//     0.01:  initial release[m
[32m+[m[32m//[m
[32m+[m[32m// LICENSE[m
[32m+[m[32m//[m
[32m+[m[32m//   See end of file for license information.[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m//       INCLUDE SECTION[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32m#ifndef STB_INCLUDE_STB_RECT_PACK_H[m
[32m+[m[32m#define STB_INCLUDE_STB_RECT_PACK_H[m
[32m+[m
[32m+[m[32m#define STB_RECT_PACK_VERSION  1[m
[32m+[m
[32m+[m[32m#ifdef STBRP_STATIC[m
[32m+[m[32m#define STBRP_DEF static[m
[32m+[m[32m#else[m
[32m+[m[32m#define STBRP_DEF extern[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32mextern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32mtypedef struct stbrp_context stbrp_context;[m
[32m+[m[32mtypedef struct stbrp_node    stbrp_node;[m
[32m+[m[32mtypedef struct stbrp_rect    stbrp_rect;[m
[32m+[m
[32m+[m[32m#ifdef STBRP_LARGE_RECTS[m
[32m+[m[32mtypedef int            stbrp_coord;[m
[32m+[m[32m#else[m
[32m+[m[32mtypedef unsigned short stbrp_coord;[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32mSTBRP_DEF int stbrp_pack_rects (stbrp_context *context, stbrp_rect *rects, int num_rects);[m
[32m+[m[32m// Assign packed locations to rectangles. The rectangles are of type[m
[32m+[m[32m// 'stbrp_rect' defined below, stored in the array 'rects', and there[m
[32m+[m[32m// are 'num_rects' many of them.[m
[32m+[m[32m//[m
[32m+[m[32m// Rectangles which are successfully packed have the 'was_packed' flag[m
[32m+[m[32m// set to a non-zero value and 'x' and 'y' store the minimum location[m
[32m+[m[32m// on each axis (i.e. bottom-left in cartesian coordinates, top-left[m
[32m+[m[32m// if you imagine y increasing downwards). Rectangles which do not fit[m
[32m+[m[32m// have the 'was_packed' flag set to 0.[m
[32m+[m[32m//[m
[32m+[m[32m// You should not try to access the 'rects' array from another thread[m
[32m+[m[32m// while this function is running, as the function temporarily reorders[m
[32m+[m[32m// the array while it executes.[m
[32m+[m[32m//[m
[32m+[m[32m// To pack into another rectangle, you need to call stbrp_init_target[m
[32m+[m[32m// again. To continue packing into the same rectangle, you can call[m
[32m+[m[32m// this function again. Calling this multiple times with multiple rect[m
[32m+[m[32m// arrays will probably produce worse packing results than calling it[m
[32m+[m[32m// a single time with the full rectangle array, but the option is[m
[32m+[m[32m// available.[m
[32m+[m[32m//[m
[32m+[m[32m// The function returns 1 if all of the rectangles were successfully[m
[32m+[m[32m// packed and 0 otherwise.[m
[32m+[m
[32m+[m[32mstruct stbrp_rect[m
[32m+[m[32m{[m
[32m+[m[32m   // reserved for your use:[m
[32m+[m[32m   int            id;[m
[32m+[m
[32m+[m[32m   // input:[m
[32m+[m[32m   stbrp_coord    w, h;[m
[32m+[m
[32m+[m[32m   // output:[m
[32m+[m[32m   stbrp_coord    x, y;[m
[32m+[m[32m   int            was_packed;  // non-zero if valid packing[m
[32m+[m
[32m+[m[32m}; // 16 bytes, nominally[m
[32m+[m
[32m+[m
[32m+[m[32mSTBRP_DEF void stbrp_init_target (stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes);[m
[32m+[m[32m// Initialize a rectangle packer to:[m
[32m+[m[32m//    pack a rectangle that is 'width' by 'height' in dimensions[m
[32m+[m[32m//    using temporary storage provided by the array 'nodes', which is 'num_nodes' long[m
[32m+[m[32m//[m
[32m+[m[32m// You must call this function every time you start packing into a new target.[m
[32m+[m[32m//[m
[32m+[m[32m// There is no "shutdown" function. The 'nodes' memory must stay valid for[m
[32m+[m[32m// the following stbrp_pack_rects() call (or calls), but can be freed after[m
[32m+[m[32m// the call (or calls) finish.[m
[32m+[m[32m//[m
[32m+[m[32m// Note: to guarantee best results, either:[m
[32m+[m[32m//       1. make sure 'num_nodes' >= 'width'[m
[32m+[m[32m//   or  2. call stbrp_allow_out_of_mem() defined below with 'allow_out_of_mem = 1'[m
[32m+[m[32m//[m
[32m+[m[32m// If you don't do either of the above things, widths will be quantized to multiples[m
[32m+[m[32m// of small integers to guarantee the algorithm doesn't run out of temporary storage.[m
[32m+[m[32m//[m
[32m+[m[32m// If you do #2, then the non-quantized algorithm will be used, but the algorithm[m
[32m+[m[32m// may run out of temporary storage and be unable to pack some rectangles.[m
[32m+[m
[32m+[m[32mSTBRP_DEF void stbrp_setup_allow_out_of_mem (stbrp_context *context, int allow_out_of_mem);[m
[32m+[m[32m// Optionally call this function after init but before doing any packing to[m
[32m+[m[32m// change the handling of the out-of-temp-memory scenario, described above.[m
[32m+[m[32m// If you call init again, this will be reset to the default (false).[m
[32m+[m
[32m+[m
[32m+[m[32mSTBRP_DEF void stbrp_setup_heuristic (stbrp_context *context, int heuristic);[m
[32m+[m[32m// Optionally select which packing heuristic the library should use. Different[m
[32m+[m[32m// heuristics will produce better/worse results for different data sets.[m
[32m+[m[32m// If you call init again, this will be reset to the default.[m
[32m+[m
[32m+[m[32menum[m
[32m+[m[32m{[m
[32m+[m[32m   STBRP_HEURISTIC_Skyline_default=0,[m
[32m+[m[32m   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,[m
[32m+[m[32m   STBRP_HEURISTIC_Skyline_BF_sortHeight[m
[32m+[m[32m};[m
[32m+[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// the details of the following structures don't matter to you, but they must[m
[32m+[m[32m// be visible so you can handle the memory allocations for them[m
[32m+[m
[32m+[m[32mstruct stbrp_node[m
[32m+[m[32m{[m
[32m+[m[32m   stbrp_coord  x,y;[m
[32m+[m[32m   stbrp_node  *next;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstruct stbrp_context[m
[32m+[m[32m{[m
[32m+[m[32m   int width;[m
[32m+[m[32m   int height;[m
[32m+[m[32m   int align;[m
[32m+[m[32m   int init_mode;[m
[32m+[m[32m   int heuristic;[m
[32m+[m[32m   int num_nodes;[m
[32m+[m[32m   stbrp_node *active_head;[m
[32m+[m[32m   stbrp_node *free_head;[m
[32m+[m[32m   stbrp_node extra[2]; // we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m//     IMPLEMENTATION SECTION[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32m#ifdef STB_RECT_PACK_IMPLEMENTATION[m
[32m+[m[32m#ifndef STBRP_SORT[m
[32m+[m[32m#include <stdlib.h>[m
[32m+[m[32m#define STBRP_SORT qsort[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifndef STBRP_ASSERT[m
[32m+[m[32m#include <assert.h>[m
[32m+[m[32m#define STBRP_ASSERT assert[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// [DEAR IMGUI] Added STBRP__CDECL[m
[32m+[m[32m#ifdef _MSC_VER[m
[32m+[m[32m#define STBRP__NOTUSED(v)  (void)(v)[m
[32m+[m[32m#define STBRP__CDECL __cdecl[m
[32m+[m[32m#else[m
[32m+[m[32m#define STBRP__NOTUSED(v)  (void)sizeof(v)[m
[32m+[m[32m#define STBRP__CDECL[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32menum[m
[32m+[m[32m{[m
[32m+[m[32m   STBRP__INIT_skyline = 1[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mSTBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)[m
[32m+[m[32m{[m
[32m+[m[32m   switch (context->init_mode) {[m
[32m+[m[32m      case STBRP__INIT_skyline:[m
[32m+[m[32m         STBRP_ASSERT(heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight);[m
[32m+[m[32m         context->heuristic = heuristic;[m
[32m+[m[32m         break;[m
[32m+[m[32m      default:[m
[32m+[m[32m         STBRP_ASSERT(0);[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)[m
[32m+[m[32m{[m
[32m+[m[32m   if (allow_out_of_mem)[m
[32m+[m[32m      // if it's ok to run out of memory, then don't bother aligning them;[m
[32m+[m[32m      // this gives better packing, but may fail due to OOM (even though[m
[32m+[m[32m      // the rectangles easily fit). @TODO a smarter approach would be to only[m
[32m+[m[32m      // quantize once we've hit OOM, then we could get rid of this parameter.[m
[32m+[m[32m      context->align = 1;[m
[32m+[m[32m   else {[m
[32m+[m[32m      // if it's not ok to run out of memory, then quantize the widths[m
[32m+[m[32m      // so that num_nodes is always enough nodes.[m
[32m+[m[32m      //[m
[32m+[m[32m      // I.e. num_nodes * align >= width[m
[32m+[m[32m      //                  align >= width / num_nodes[m
[32m+[m[32m      //                  align = ceil(width/num_nodes)[m
[32m+[m
[32m+[m[32m      context->align = (context->width + context->num_nodes-1) / context->num_nodes;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)[m
[32m+[m[32m{[m
[32m+[m[32m   int i;[m
[32m+[m[32m#ifndef STBRP_LARGE_RECTS[m
[32m+[m[32m   STBRP_ASSERT(width <= 0xffff && height <= 0xffff);[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m   for (i=0; i < num_nodes-1; ++i)[m
[32m+[m[32m      nodes[i].next = &nodes[i+1];[m
[32m+[m[32m   nodes[i].next = NULL;[m
[32m+[m[32m   context->init_mode = STBRP__INIT_skyline;[m
[32m+[m[32m   context->heuristic = STBRP_HEURISTIC_Skyline_default;[m
[32m+[m[32m   context->free_head = &nodes[0];[m
[32m+[m[32m   context->active_head = &context->extra[0];[m
[32m+[m[32m   context->width = width;[m
[32m+[m[32m   context->height = height;[m
[32m+[m[32m   context->num_nodes = num_nodes;[m
[32m+[m[32m   stbrp_setup_allow_out_of_mem(context, 0);[m
[32m+[m
[32m+[m[32m   // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)[m
[32m+[m[32m   context->extra[0].x = 0;[m
[32m+[m[32m   context->extra[0].y = 0;[m
[32m+[m[32m   context->extra[0].next = &context->extra[1];[m
[32m+[m[32m   context->extra[1].x = (stbrp_coord) width;[m
[32m+[m[32m#ifdef STBRP_LARGE_RECTS[m
[32m+[m[32m   context->extra[1].y = (1<<30);[m
[32m+[m[32m#else[m
[32m+[m[32m   context->extra[1].y = 65535;[m
[32m+[m[32m#endif[m
[32m+[m[32m   context->extra[1].next = NULL;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// find minimum y position if it starts at x1[m
[32m+[m[32mstatic int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)[m
[32m+[m[32m{[m
[32m+[m[32m   stbrp_node *node = first;[m
[32m+[m[32m   int x1 = x0 + width;[m
[32m+[m[32m   int min_y, visited_width, waste_area;[m
[32m+[m
[32m+[m[32m   STBRP__NOTUSED(c);[m
[32m+[m
[32m+[m[32m   STBRP_ASSERT(first->x <= x0);[m
[32m+[m
[32m+[m[32m   #if 0[m
[32m+[m[32m   // skip in case we're past the node[m
[32m+[m[32m   while (node->next->x <= x0)[m
[32m+[m[32m      ++node;[m
[32m+[m[32m   #else[m
[32m+[m[32m   STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency[m
[32m+[m[32m   #endif[m
[32m+[m
[32m+[m[32m   STBRP_ASSERT(node->x <= x0);[m
[32m+[m
[32m+[m[32m   min_y = 0;[m
[32m+[m[32m   waste_area = 0;[m
[32m+[m[32m   visited_width = 0;[m
[32m+[m[32m   while (node->x < x1) {[m
[32m+[m[32m      if (node->y > min_y) {[m
[32m+[m[32m         // raise min_y higher.[m
[32m+[m[32m         // we've accounted for all waste up to min_y,[m
[32m+[m[32m         // but we'll now add more waste for everything we've visted[m
[32m+[m[32m         waste_area += visited_width * (node->y - min_y);[m
[32m+[m[32m         min_y = node->y;[m
[32m+[m[32m         // the first time through, visited_width might be reduced[m
[32m+[m[32m         if (node->x < x0)[m
[32m+[m[32m            visited_width += node->next->x - x0;[m
[32m+[m[32m         else[m
[32m+[m[32m            visited_width += node->next->x - node->x;[m
[32m+[m[32m      } else {[m
[32m+[m[32m         // add waste area[m
[32m+[m[32m         int under_width = node->next->x - node->x;[m
[32m+[m[32m         if (under_width + visited_width > width)[m
[32m+[m[32m            under_width = width - visited_width;[m
[32m+[m[32m         waste_area += under_width * (min_y - node->y);[m
[32m+[m[32m         visited_width += under_width;[m
[32m+[m[32m      }[m
[32m+[m[32m      node = node->next;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   *pwaste = waste_area;[m
[32m+[m[32m   return min_y;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m   int x,y;[m
[32m+[m[32m   stbrp_node **prev_link;[m
[32m+[m[32m} stbrp__findresult;[m
[32m+[m
[32m+[m[32mstatic stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)[m
[32m+[m[32m{[m
[32m+[m[32m   int best_waste = (1<<30), best_x, best_y = (1 << 30);[m
[32m+[m[32m   stbrp__findresult fr;[m
[32m+[m[32m   stbrp_node **prev, *node, *tail, **best = NULL;[m
[32m+[m
[32m+[m[32m   // align to multiple of c->align[m
[32m+[m[32m   width = (width + c->align - 1);[m
[32m+[m[32m   width -= width % c->align;[m
[32m+[m[32m   STBRP_ASSERT(width % c->align == 0);[m
[32m+[m
[32m+[m[32m   node = c->active_head;[m
[32m+[m[32m   prev = &c->active_head;[m
[32m+[m[32m   while (node->x + width <= c->width) {[m
[32m+[m[32m      int y,waste;[m
[32m+[m[32m      y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);[m
[32m+[m[32m      if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL[m
[32m+[m[32m         // bottom left[m
[32m+[m[32m         if (y < best_y) {[m
[32m+[m[32m            best_y = y;[m
[32m+[m[32m            best = prev;[m
[32m+[m[32m         }[m
[32m+[m[32m      } else {[m
[32m+[m[32m         // best-fit[m
[32m+[m[32m         if (y + height <= c->height) {[m
[32m+[m[32m            // can only use it if it first vertically[m
[32m+[m[32m            if (y < best_y || (y == best_y && waste < best_waste)) {[m
[32m+[m[32m               best_y = y;[m
[32m+[m[32m               best_waste = waste;[m
[32m+[m[32m               best = prev;[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m
[32m+[m[32m      }[m
[32m+[m[32m      prev = &node->next;[m
[32m+[m[32m      node = node->next;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   best_x = (best == NULL) ? 0 : (*best)->x;[m
[32m+[m
[32m+[m[32m   // if doing best-fit (BF), we also have to try aligning right edge to each node position[m
[32m+[m[32m   //[m
[32m+[m[32m   // e.g, if fitting[m
[32m+[m[32m   //[m
[32m+[m[32m   //     ____________________[m
[32m+[m[32m   //    |____________________|[m
[32m+[m[32m   //[m
[32m+[m[32m   //            into[m
[32m+[m[32m   //[m
[32m+[m[32m   //   |                         |[m
[32m+[m[32m   //   |             ____________|[m
[32m+[m[32m   //   |____________|[m
[32m+[m[32m   //[m
[32m+[m[32m   // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned[m
[32m+[m[32m   //[m
[32m+[m[32m   // This makes BF take about 2x the time[m
[32m+[m
[32m+[m[32m   if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {[m
[32m+[m[32m      tail = c->active_head;[m
[32m+[m[32m      node = c->active_head;[m
[32m+[m[32m      prev = &c->active_head;[m
[32m+[m[32m      // find first node that's admissible[m
[32m+[m[32m      while (tail->x < width)[m
[32m+[m[32m         tail = tail->next;[m
[32m+[m[32m      while (tail) {[m
[32m+[m[32m         int xpos = tail->x - width;[m
[32m+[m[32m         int y,waste;[m
[32m+[m[32m         STBRP_ASSERT(xpos >= 0);[m
[32m+[m[32m         // find the left position that matches this[m
[32m+[m[32m         while (node->next->x <= xpos) {[m
[32m+[m[32m            prev = &node->next;[m
[32m+[m[32m            node = node->next;[m
[32m+[m[32m         }[m
[32m+[m[32m         STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);[m
[32m+[m[32m         y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);[m
[32m+[m[32m         if (y + height < c->height) {[m
[32m+[m[32m            if (y <= best_y) {[m
[32m+[m[32m               if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {[m
[32m+[m[32m                  best_x = xpos;[m
[32m+[m[32m                  STBRP_ASSERT(y <= best_y);[m
[32m+[m[32m                  best_y = y;[m
[32m+[m[32m                  best_waste = waste;[m
[32m+[m[32m                  best = prev;[m
[32m+[m[32m               }[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m
[32m+[m[32m         tail = tail->next;[m
[32m+[m[32m      }[m[41m         [m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   fr.prev_link = best;[m
[32m+[m[32m   fr.x = best_x;[m
[32m+[m[32m   fr.y = best_y;[m
[32m+[m[32m   return fr;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)[m
[32m+[m[32m{[m
[32m+[m[32m   // find best position according to heuristic[m
[32m+[m[32m   stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);[m
[32m+[m[32m   stbrp_node *node, *cur;[m
[32m+[m
[32m+[m[32m   // bail if:[m
[32m+[m[32m   //    1. it failed[m
[32m+[m[32m   //    2. the best node doesn't fit (we don't always check this)[m
[32m+[m[32m   //    3. we're out of memory[m
[32m+[m[32m   if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {[m
[32m+[m[32m      res.prev_link = NULL;[m
[32m+[m[32m      return res;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   // on success, create new node[m
[32m+[m[32m   node = context->free_head;[m
[32m+[m[32m   node->x = (stbrp_coord) res.x;[m
[32m+[m[32m   node->y = (stbrp_coord) (res.y + height);[m
[32m+[m
[32m+[m[32m   context->free_head = node->next;[m
[32m+[m
[32m+[m[32m   // insert the new node into the right starting point, and[m
[32m+[m[32m   // let 'cur' point to the remaining nodes needing to be[m
[32m+[m[32m   // stiched back in[m
[32m+[m
[32m+[m[32m   cur = *res.prev_link;[m
[32m+[m[32m   if (cur->x < res.x) {[m
[32m+[m[32m      // preserve the existing one, so start testing with the next one[m
[32m+[m[32m      stbrp_node *next = cur->next;[m
[32m+[m[32m      cur->next = node;[m
[32m+[m[32m      cur = next;[m
[32m+[m[32m   } else {[m
[32m+[m[32m      *res.prev_link = node;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   // from here, traverse cur and free the nodes, until we get to one[m
[32m+[m[32m   // that shouldn't be freed[m
[32m+[m[32m   while (cur->next && cur->next->x <= res.x + width) {[m
[32m+[m[32m      stbrp_node *next = cur->next;[m
[32m+[m[32m      // move the current node to the free list[m
[32m+[m[32m      cur->next = context->free_head;[m
[32m+[m[32m      context->free_head = cur;[m
[32m+[m[32m      cur = next;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   // stitch the list back in[m
[32m+[m[32m   node->next = cur;[m
[32m+[m
[32m+[m[32m   if (cur->x < res.x + width)[m
[32m+[m[32m      cur->x = (stbrp_coord) (res.x + width);[m
[32m+[m
[32m+[m[32m#ifdef _DEBUG[m
[32m+[m[32m   cur = context->active_head;[m
[32m+[m[32m   while (cur->x < context->width) {[m
[32m+[m[32m      STBRP_ASSERT(cur->x < cur->next->x);[m
[32m+[m[32m      cur = cur->next;[m
[32m+[m[32m   }[m
[32m+[m[32m   STBRP_ASSERT(cur->next == NULL);[m
[32m+[m
[32m+[m[32m   {[m
[32m+[m[32m      int count=0;[m
[32m+[m[32m      cur = context->active_head;[m
[32m+[m[32m      while (cur) {[m
[32m+[m[32m         cur = cur->next;[m
[32m+[m[32m         ++count;[m
[32m+[m[32m      }[m
[32m+[m[32m      cur = context->free_head;[m
[32m+[m[32m      while (cur) {[m
[32m+[m[32m         cur = cur->next;[m
[32m+[m[32m         ++count;[m
[32m+[m[32m      }[m
[32m+[m[32m      STBRP_ASSERT(count == context->num_nodes+2);[m
[32m+[m[32m   }[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m   return res;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// [DEAR IMGUI] Added STBRP__CDECL[m
[32m+[m[32mstatic int STBRP__CDECL rect_height_compare(const void *a, const void *b)[m
[32m+[m[32m{[m
[32m+[m[32m   const stbrp_rect *p = (const stbrp_rect *) a;[m
[32m+[m[32m   const stbrp_rect *q = (const stbrp_rect *) b;[m
[32m+[m[32m   if (p->h > q->h)[m
[32m+[m[32m      return -1;[m
[32m+[m[32m   if (p->h < q->h)[m
[32m+[m[32m      return  1;[m
[32m+[m[32m   return (p->w > q->w) ? -1 : (p->w < q->w);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// [DEAR IMGUI] Added STBRP__CDECL[m
[32m+[m[32mstatic int STBRP__CDECL rect_original_order(const void *a, const void *b)[m
[32m+[m[32m{[m
[32m+[m[32m   const stbrp_rect *p = (const stbrp_rect *) a;[m
[32m+[m[32m   const stbrp_rect *q = (const stbrp_rect *) b;[m
[32m+[m[32m   return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#ifdef STBRP_LARGE_RECTS[m
[32m+[m[32m#define STBRP__MAXVAL  0xffffffff[m
[32m+[m[32m#else[m
[32m+[m[32m#define STBRP__MAXVAL  0xffff[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32mSTBRP_DEF int stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)[m
[32m+[m[32m{[m
[32m+[m[32m   int i, all_rects_packed = 1;[m
[32m+[m
[32m+[m[32m   // we use the 'was_packed' field internally to allow sorting/unsorting[m
[32m+[m[32m   for (i=0; i < num_rects; ++i) {[m
[32m+[m[32m      rects[i].was_packed = i;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   // sort according to heuristic[m
[32m+[m[32m   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);[m
[32m+[m
[32m+[m[32m   for (i=0; i < num_rects; ++i) {[m
[32m+[m[32m      if (rects[i].w == 0 || rects[i].h == 0) {[m
[32m+[m[32m         rects[i].x = rects[i].y = 0;  // empty rect needs no space[m
[32m+[m[32m      } else {[m
[32m+[m[32m         stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);[m
[32m+[m[32m         if (fr.prev_link) {[m
[32m+[m[32m            rects[i].x = (stbrp_coord) fr.x;[m
[32m+[m[32m            rects[i].y = (stbrp_coord) fr.y;[m
[32m+[m[32m         } else {[m
[32m+[m[32m            rects[i].x = rects[i].y = STBRP__MAXVAL;[m
[32m+[m[32m         }[m
[32m+[m[32m      }[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   // unsort[m
[32m+[m[32m   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);[m
[32m+[m
[32m+[m[32m   // set was_packed flags and all_rects_packed status[m
[32m+[m[32m   for (i=0; i < num_rects; ++i) {[m
[32m+[m[32m      rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);[m
[32m+[m[32m      if (!rects[i].was_packed)[m
[32m+[m[32m         all_rects_packed = 0;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   // return the all_rects_packed status[m
[32m+[m[32m   return all_rects_packed;[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m[32m------------------------------------------------------------------------------[m
[32m+[m[32mThis software is available under 2 licenses -- choose whichever you prefer.[m
[32m+[m[32m------------------------------------------------------------------------------[m
[32m+[m[32mALTERNATIVE A - MIT License[m
[32m+[m[32mCopyright (c) 2017 Sean Barrett[m
[32m+[m[32mPermission is hereby granted, free of charge, to any person obtaining a copy of[m[41m [m
[32m+[m[32mthis software and associated documentation files (the "Software"), to deal in[m[41m [m
[32m+[m[32mthe Software without restriction, including without limitation the rights to[m[41m [m
[32m+[m[32muse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies[m[41m [m
[32m+[m[32mof the Software, and to permit persons to whom the Software is furnished to do[m[41m [m
[32m+[m[32mso, subject to the following conditions:[m
[32m+[m[32mThe above copyright notice and this permission notice shall be included in all[m[41m [m
[32m+[m[32mcopies or substantial portions of the Software.[m
[32m+[m[32mTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR[m[41m [m
[32m+[m[32mIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,[m[41m [m
[32m+[m[32mFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE[m[41m [m
[32m+[m[32mAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER[m[41m [m
[32m+[m[32mLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,[m[41m [m
[32m+[m[32mOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE[m[41m [m
[32m+[m[32mSOFTWARE.[m
[32m+[m[32m------------------------------------------------------------------------------[m
[32m+[m[32mALTERNATIVE B - Public Domain (www.unlicense.org)[m
[32m+[m[32mThis is free and unencumbered software released into the public domain.[m
[32m+[m[32mAnyone is free to copy, modify, publish, use, compile, sell, or distribute this[m[41m [m
[32m+[m[32msoftware, either in source code form or as a compiled binary, for any purpose,[m[41m [m
[32m+[m[32mcommercial or non-commercial, and by any means.[m
[32m+[m[32mIn jurisdictions that recognize copyright laws, the author or authors of this[m[41m [m
[32m+[m[32msoftware dedicate any and all copyright interest in the software to the public[m[41m [m
[32m+[m[32mdomain. We make this dedication for the benefit of the public at large and to[m[41m [m
[32m+[m[32mthe detriment of our heirs and successors. We intend this dedication to be an[m[41m [m
[32m+[m[32movert act of relinquishment in perpetuity of all present and future rights to[m[41m [m
[32m+[m[32mthis software under copyright law.[m
[32m+[m[32mTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR[m[41m [m
[32m+[m[32mIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,[m[41m [m
[32m+[m[32mFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE[m[41m [m
[32m+[m[32mAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN[m[41m [m
[32m+[m[32mACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION[m[41m [m
[32m+[m[32mWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.[m
[32m+[m[32m------------------------------------------------------------------------------[m
[32m+[m[32m*/[m
[1mdiff --git a/vendor/source/ImGui/imstb_textedit.h b/vendor/source/ImGui/imstb_textedit.h[m
[1mnew file mode 100644[m
[1mindex 0000000..d7fcbd6[m
[1m--- /dev/null[m
[1m+++ b/vendor/source/ImGui/imstb_textedit.h[m
[36m@@ -0,0 +1,1417 @@[m
[32m+[m[32m// [DEAR IMGUI][m[41m [m
[32m+[m[32m// This is a slightly modified version of stb_textedit.h 1.13.[m[41m [m
[32m+[m[32m// Those changes would need to be pushed into nothings/stb:[m
[32m+[m[32m// - Fix in stb_textedit_discard_redo (see https://github.com/nothings/stb/issues/321)[m
[32m+[m[32m// Grep for [DEAR IMGUI] to find the changes.[m
[32m+[m
[32m+[m[32m// stb_textedit.h - v1.13  - public domain - Sean Barrett[m
[32m+[m[32m// Development of this library was sponsored by RAD Game Tools[m
[32m+[m[32m//[m
[32m+[m[32m// This C header file implements the guts of a multi-line text-editing[m
[32m+[m[32m// widget; you implement display, word-wrapping, and low-level string[m
[32m+[m[32m// insertion/deletion, and stb_textedit will map user inputs into[m
[32m+[m[32m// insertions & deletions, plus updates to the cursor position,[m
[32m+[m[32m// selection state, and undo state.[m
[32m+[m[32m//[m
[32m+[m[32m// It is intended for use in games and other systems that need to build[m
[32m+[m[32m// their own custom widgets and which do not have heavy text-editing[m
[32m+[m[32m// requirements (this library is not recommended for use for editing large[m
[32m+[m[32m// texts, as its performance does not scale and it has limited undo).[m
[32m+[m[32m//[m
[32m+[m[32m// Non-trivial behaviors are modelled after Windows text controls.[m
[32m+[m[32m//[m[41m [m
[32m+[m[32m//[m
[32m+[m[32m// LICENSE[m
[32m+[m[32m//[m
[32m+[m[32m// See end of file for license information.[m
[32m+[m[32m//[m
[32m+[m[32m//[m
[32m+[m[32m// DEPENDENCIES[m
[32m+[m[32m//[m
[32m+[m[32m// Uses the C runtime function 'memmove', which you can override[m
[32m+[m[32m// by defining STB_TEXTEDIT_memmove before the implementation.[m
[32m+[m[32m// Uses no other functions. Performs no runtime allocations.[m
[32m+[m[32m//[m
[32m+[m[32m//[m
[32m+[m[32m// VERSION HISTORY[m
[32m+[m[32m//[m
[32m+[m[32m//   1.13 (2019-02-07) fix bug in undo size management[m
[32m+[m[32m//   1.12 (2018-01-29) user can change STB_TEXTEDIT_KEYTYPE, fix redo to avoid crash[m
[32m+[m[32m//   1.11 (2017-03-03) fix HOME on last line, dragging off single-line textfield[m
[32m+[m[32m//   1.10 (2016-10-25) supress warnings about casting away const with -Wcast-qual[m
[32m+[m[32m//   1.9  (2016-08-27) customizable move-by-word[m
[32m+[m[32m//   1.8  (2016-04-02) better keyboard handling when mouse button is down[m
[32m+[m[32m//   1.7  (2015-09-13) change y range handling in case baseline is non-0[m
[32m+[m[32m//   1.6  (2015-04-15) allow STB_TEXTEDIT_memmove[m
[32m+[m[32m//   1.5  (2014-09-10) add support for secondary keys for OS X[m
[32m+[m[32m//   1.4  (2014-08-17) fix signed/unsigned warnings[m
[32m+[m[32m//   1.3  (2014-06-19) fix mouse clicking to round to nearest char boundary[m
[32m+[m[32m//   1.2  (2014-05-27) fix some RAD types that had crept into the new code[m
[32m+[m[32m//   1.1  (2013-12-15) move-by-word (requires STB_TEXTEDIT_IS_SPACE )[m
[32m+[m[32m//   1.0  (2012-07-26) improve documentation, initial public release[m
[32m+[m[32m//   0.3  (2012-02-24) bugfixes, single-line mode; insert mode[m
[32m+[m[32m//   0.2  (2011-11-28) fixes to undo/redo[m
[32m+[m[32m//   0.1  (2010-07-08) initial version[m
[32m+[m[32m//[m
[32m+[m[32m// ADDITIONAL CONTRIBUTORS[m
[32m+[m[32m//[m
[32m+[m[32m//   Ulf Winklemann: move-by-word in 1.1[m
[32m+[m[32m//   Fabian Giesen: secondary key inputs in 1.5[m
[32m+[m[32m//   Martins Mozeiko: STB_TEXTEDIT_memmove in 1.6[m
[32m+[m[32m//[m
[32m+[m[32m//   Bugfixes:[m
[32m+[m[32m//      Scott Graham[m
[32m+[m[32m//      Daniel Keller[m
[32m+[m[32m//      Omar Cornut[m
[32m+[m[32m//      Dan Thompson[m
[32m+[m[32m//[m
[32m+[m[32m// USAGE[m
[32m+[m[32m//[m
[32m+[m[32m// This file behaves differently depending on what symbols you define[m
[32m+[m[32m// before including it.[m
[32m+[m[32m//[m
[32m+[m[32m//[m
[32m+[m[32m// Header-file mode:[m
[32m+[m[32m//[m
[32m+[m[32m//   If you do not define STB_TEXTEDIT_IMPLEMENTATION before including this,[m
[32m+[m[32m//   it will operate in "header file" mode. In this mode, it declares a[m
[32m+[m[32m//   single public symbol, STB_TexteditState, which encapsulates the current[m
[32m+[m[32m//   state of a text widget (except for the string, which you will store[m
[32m+[m[32m//   separately).[m
[32m+[m[32m//[m
[32m+[m[32m//   To compile in this mode, you must define STB_TEXTEDIT_CHARTYPE to a[m
[32m+[m[32m//   primitive type that defines a single character (e.g. char, wchar_t, etc).[m
[32m+[m[32m//[m
[32m+[m[32m//   To save space or increase undo-ability, you can optionally define the[m
[32m+[m[32m//   following things that are used by the undo system:[m
[32m+[m[32m//[m
[32m+[m[32m//      STB_TEXTEDIT_POSITIONTYPE         small int type encoding a valid cursor position[m
[32m+[m[32m//      STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow[m
[32m+[m[32m//      STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer[m
[32m+[m[32m//[m
[32m+[m[32m//   If you don't define these, they are set to permissive types and[m
[32m+[m[32m//   moderate sizes. The undo system does no memory allocations, so[m
[32m+[m[32m//   it grows STB_TexteditState by the worst-case storage which is (in bytes):[m
[32m+[m[32m//[m
[32m+[m[32m//        [4 + 3 * sizeof(STB_TEXTEDIT_POSITIONTYPE)] * STB_TEXTEDIT_UNDOSTATE_COUNT[m
[32m+[m[32m//      +          sizeof(STB_TEXTEDIT_CHARTYPE)      * STB_TEXTEDIT_UNDOCHAR_COUNT[m
[32m+[m[32m//[m
[32m+[m[32m//[m
[32m+[m[32m// Implementation mode:[m
[32m+[m[32m//[m
[32m+[m[32m//   If you define STB_TEXTEDIT_IMPLEMENTATION before including this, it[m
[32m+[m[32m//   will compile the implementation of the text edit widget, depending[m
[32m+[m[32m//   on a large number of symbols which must be defined before the include.[m
[32m+[m[32m//[m
[32m+[m[32m//   The implementation is defined only as static functions. You will then[m
[32m+[m[32m//   need to provide your own APIs in the same file which will access the[m
[32m+[m[32m//   static functions.[m
[32m+[m[32m//[m
[32m+[m[32m//   The basic concept is that you provide a "string" object which[m
[32m+[m[32m//   behaves like an array of characters. stb_textedit uses indices to[m
[32m+[m[32m//   refer to positions in the string, implicitly representing positions[m
[32m+[m[32m//   in the displayed textedit. This is true for both plain text and[m
[32m+[m[32m//   rich text; even with rich text stb_truetype interacts with your[m
[32m+[m[32m//   code as if there was an array of all the displayed characters.[m
[32m+[m[32m//[m
[32m+[m[32m// Symbols that must be the same in header-file and implementation mode:[m
[32m+[m[32m//[m
[32m+[m[32m//     STB_TEXTEDIT_CHARTYPE             the character type[m
[32m+[m[32m//     STB_TEXTEDIT_POSITIONTYPE         small type that is a valid cursor position[m
[32m+[m[32m//     STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow[m
[32m+[m[32m//     STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer[m
[32m+[m[32m//[m
[32m+[m[32m// Symbols you must define for implementation mode:[m
[32m+[m[32m//[m
[32m+[m[32m//    STB_TEXTEDIT_STRING               the type of object representing a string being edited,[m
[32m+[m[32m//                                      typically this is a wrapper object with other data you need[m
[32m+[m[32m//[m
[32m+[m[32m//    STB_TEXTEDIT_STRINGLEN(obj)       the length of the string (ideally O(1))[m
[32m+[m[32m//    STB_TEXTEDIT_LAYOUTROW(&r,obj,n)  returns the results of laying out a line of characters[m
[32m+[m[32m//                                        starting from character #n (see discussion below)[m
[32m+[m[32m//    STB_TEXTEDIT_GETWIDTH(obj,n,i)    returns the pixel delta from the xpos of the i'th character[m
[32m+[m[32m//                                        to the xpos of the i+1'th char for a line of characters[m
[32m+[m[32m//                                        starting at character #n (i.e. accounts for kerning[m
[32m+[m[32m//                                        with previous char)[m
[32m+[m[32m//    STB_TEXTEDIT_KEYTOTEXT(k)         maps a keyboard input to an insertable character[m
[32m+[m[32m//                                        (return type is int, -1 means not valid to insert)[m
[32m+[m[32m//    STB_TEXTEDIT_GETCHAR(obj,i)       returns the i'th character of obj, 0-based[m
[32m+[m[32m//    STB_TEXTEDIT_NEWLINE              the character returned by _GETCHAR() we recognize[m
[32m+[m[32m//                                        as manually wordwrapping for end-of-line positioning[m
[32m+[m[32m//[m
[32m+[m[32m//    STB_TEXTEDIT_DELETECHARS(obj,i,n)      delete n characters starting at i[m
[32m+[m[32m//    STB_TEXTEDIT_INSERTCHARS(obj,i,c*,n)   insert n characters at i (pointed to by STB_TEXTEDIT_CHARTYPE*)[m
[32m+[m[32m//[m
[32m+[m[32m//    STB_TEXTEDIT_K_SHIFT       a power of two that is or'd in to a keyboard input to represent the shift key[m
[32m+[m[32m//[m
[32m+[m[32m//    STB_TEXTEDIT_K_LEFT        keyboard input to move cursor left[m
[32m+[m[32m//    STB_TEXTEDIT_K_RIGHT       keyboard input to move cursor right[m
[32m+[m[32m//    STB_TEXTEDIT_K_UP          keyboard input to move cursor up[m
[32m+[m[32m//    STB_TEXTEDIT_K_DOWN        keyboard input to move cursor down[m
[32m+[m[32m//    STB_TEXTEDIT_K_LINESTART   keyboard input to move cursor to start of line  // e.g. HOME[m
[32m+[m[32m//    STB_TEXTEDIT_K_LINEEND     keyboard input to move cursor to end of line    // e.g. END[m
[32m+[m[32m//    STB_TEXTEDIT_K_TEXTSTART   keyboard input to move cursor to start of text  // e.g. ctrl-HOME[m
[32m+[m[32m//    STB_TEXTEDIT_K_TEXTEND     keyboard input to move cursor to end of text    // e.g. ctrl-END[m
[32m+[m[32m//    STB_TEXTEDIT_K_DELETE      keyboard input to delete selection or character under cursor[m
[32m+[m[32m//    STB_TEXTEDIT_K_BACKSPACE   keyboard input to delete selection or character left of cursor[m
[32m+[m[32m//    STB_TEXTEDIT_K_UNDO        keyboard input to perform undo[m
[32m+[m[32m//    STB_TEXTEDIT_K_REDO        keyboard input to perform redo[m
[32m+[m[32m//[m
[32m+[m[32m// Optional:[m
[32m+[m[32m//    STB_TEXTEDIT_K_INSERT              keyboard input to toggle insert mode[m
[32m+[m[32m//    STB_TEXTEDIT_IS_SPACE(ch)          true if character is whitespace (e.g. 'isspace'),[m
[32m+[m[32m//                                          required for default WORDLEFT/WORDRIGHT handlers[m
[32m+[m[32m//    STB_TEXTEDIT_MOVEWORDLEFT(obj,i)   custom handler for WORDLEFT, returns index to move cursor to[m
[32m+[m[32m//    STB_TEXTEDIT_MOVEWORDRIGHT(obj,i)  custom handler for WORDRIGHT, returns index to move cursor to[m
[32m+[m[32m//    STB_TEXTEDIT_K_WORDLEFT            keyboard input to move cursor left one word // e.g. ctrl-LEFT[m
[32m+[m[32m//    STB_TEXTEDIT_K_WORDRIGHT           keyboard input to move cursor right one word // e.g. ctrl-RIGHT[m
[32m+[m[32m//    STB_TEXTEDIT_K_LINESTART2          secondary keyboard input to move cursor to start of line[m
[32m+[m[32m//    STB_TEXTEDIT_K_LINEEND2            secondary keyboard input to move cursor to end of line[m
[32m+[m[32m//    STB_TEXTEDIT_K_TEXTSTART2          secondary keyboard input to move cursor to start of text[m
[32m+[m[32m//    STB_TEXTEDIT_K_TEXTEND2            secondary keyboard input to move cursor to end of text[m
[32m+[m[32m//[m
[32m+[m[32m// Todo:[m
[32m+[m[32m//    STB_TEXTEDIT_K_PGUP        keyboard input to move cursor up a page[m
[32m+[m[32m//    STB_TEXTEDIT_K_PGDOWN      keyboard input to move cursor down a page[m
[32m+[m[32m//[m
[32m+[m[32m// Keyboard input must be encoded as a single integer value; e.g. a character code[m
[32m+[m[32m// and some bitflags that represent shift states. to simplify the interface, SHIFT must[m
[32m+[m[32m// be a bitflag, so we can test the shifted state of cursor movements to allow selection,[m
[32m+[m[32m// i.e. (STB_TEXTED_K_RIGHT|STB_TEXTEDIT_K_SHIFT) should be shifted right-arrow.[m
[32m+[m[32m//[m
[32m+[m[32m// You can encode other things, such as CONTROL or ALT, in additional bits, and[m
[32m+[m[32m// then test for their presence in e.g. STB_TEXTEDIT_K_WORDLEFT. For example,[m
[32m+[m[32m// my Windows implementations add an additional CONTROL bit, and an additional KEYDOWN[m
[32m+[m[32m// bit. Then all of the STB_TEXTEDIT_K_ values bitwise-or in the KEYDOWN bit,[m
[32m+[m[32m// and I pass both WM_KEYDOWN and WM_CHAR events to the "key" function in the[m
[32m+[m[32m// API below. The control keys will only match WM_KEYDOWN events because of the[m
[32m+[m[32m// keydown bit I add, and STB_TEXTEDIT_KEYTOTEXT only tests for the KEYDOWN[m
[32m+[m[32m// bit so it only decodes WM_CHAR events.[m
[32m+[m[32m//[m
[32m+[m[32m// STB_TEXTEDIT_LAYOUTROW returns information about the shape of one displayed[m
[32m+[m[32m// row of characters assuming they start on the i'th character--the width and[m
[32m+[m[32m// the height and the number of characters consumed. This allows this library[m
[32m+[m[32m// to traverse the entire layout incrementally. You need to compute word-wrapping[m
[32m+[m[32m// here.[m
[32m+[m[32m//[m
[32m+[m[32m// Each textfield keeps its own insert mode state, which is not how normal[m
[32m+[m[32m// applications work. To keep an app-wide insert mode, update/copy the[m
[32m+[m[32m// "insert_mode" field of STB_TexteditState before/after calling API functions.[m
[32m+[m[32m//[m
[32m+[m[32m// API[m
[32m+[m[32m//[m
[32m+[m[32m//    void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)[m
[32m+[m[32m//[m
[32m+[m[32m//    void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)[m
[32m+[m[32m//    void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)[m
[32m+[m[32m//    int  stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)[m
[32m+[m[32m//    int  stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)[m
[32m+[m[32m//    void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXEDIT_KEYTYPE key)[m
[32m+[m[32m//[m
[32m+[m[32m//    Each of these functions potentially updates the string and updates the[m
[32m+[m[32m//    state.[m
[32m+[m[32m//[m
[32m+[m[32m//      initialize_state:[m
[32m+[m[32m//          set the textedit state to a known good default state when initially[m
[32m+[m[32m//          constructing the textedit.[m
[32m+[m[32m//[m
[32m+[m[32m//      click:[m
[32m+[m[32m//          call this with the mouse x,y on a mouse down; it will update the cursor[m
[32m+[m[32m//          and reset the selection start/end to the cursor point. the x,y must[m
[32m+[m[32m//          be relative to the text widget, with (0,0) being the top left.[m
[32m+[m[32m//[m[41m     [m
[32m+[m[32m//      drag:[m
[32m+[m[32m//          call this with the mouse x,y on a mouse drag/up; it will update the[m
[32m+[m[32m//          cursor and the selection end point[m
[32m+[m[32m//[m[41m     [m
[32m+[m[32m//      cut:[m
[32m+[m[32m//          call this to delete the current selection; returns true if there was[m
[32m+[m[32m//          one. you should FIRST copy the current selection to the system paste buffer.[m
[32m+[m[32m//          (To copy, just copy the current selection out of the string yourself.)[m
[32m+[m[32m//[m[41m     [m
[32m+[m[32m//      paste:[m
[32m+[m[32m//          call this to paste text at the current cursor point or over the current[m
[32m+[m[32m//          selection if there is one.[m
[32m+[m[32m//[m[41m     [m
[32m+[m[32m//      key:[m
[32m+[m[32m//          call this for keyboard inputs sent to the textfield. you can use it[m
[32m+[m[32m//          for "key down" events or for "translated" key events. if you need to[m
[32m+[m[32m//          do both (as in Win32), or distinguish Unicode characters from control[m
[32m+[m[32m//          inputs, set a high bit to distinguish the two; then you can define the[m
[32m+[m[32m//          various definitions like STB_TEXTEDIT_K_LEFT have the is-key-event bit[m
[32m+[m[32m//          set, and make STB_TEXTEDIT_KEYTOCHAR check that the is-key-event bit is[m
[32m+[m[32m//          clear. STB_TEXTEDIT_KEYTYPE defaults to int, but you can #define it to[m
[32m+[m[32m//          anything other type you wante before including.[m
[32m+[m[32m//[m
[32m+[m[32m//[m[41m     [m
[32m+[m[32m//   When rendering, you can read the cursor position and selection state from[m
[32m+[m[32m//   the STB_TexteditState.[m
[32m+[m[32m//[m
[32m+[m[32m//[m
[32m+[m[32m// Notes:[m
[32m+[m[32m//[m
[32m+[m[32m// This is designed to be usable in IMGUI, so it allows for the possibility of[m
[32m+[m[32m// running in an IMGUI that has NOT cached the multi-line layout. For this[m
[32m+[m[32m// reason, it provides an interface that is compatible with computing the[m
[32m+[m[32m// layout incrementally--we try to make sure we make as few passes through[m
[32m+[m[32m// as possible. (For example, to locate the mouse pointer in the text, we[m
[32m+[m[32m// could define functions that return the X and Y positions of characters[m
[32m+[m[32m// and binary search Y and then X, but if we're doing dynamic layout this[m
[32m+[m[32m// will run the layout algorithm many times, so instead we manually search[m
[32m+[m[32m// forward in one pass. Similar logic applies to e.g. up-arrow and[m
[32m+[m[32m// down-arrow movement.)[m
[32m+[m[32m//[m
[32m+[m[32m// If it's run in a widget that *has* cached the layout, then this is less[m
[32m+[m[32m// efficient, but it's not horrible on modern computers. But you wouldn't[m
[32m+[m[32m// want to edit million-line files with it.[m
[32m+[m
[32m+[m
[32m+[m[32m////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m////[m
[32m+[m[32m////   Header-file mode[m
[32m+[m[32m////[m
[32m+[m[32m////[m
[32m+[m
[32m+[m[32m#ifndef INCLUDE_STB_TEXTEDIT_H[m
[32m+[m[32m#define INCLUDE_STB_TEXTEDIT_H[m
[32m+[m
[32m+[m[32m////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m//     STB_TexteditState[m
[32m+[m[32m//[m
[32m+[m[32m// Definition of STB_TexteditState which you should store[m
[32m+[m[32m// per-textfield; it includes cursor position, selection state,[m
[32m+[m[32m// and undo state.[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32m#ifndef STB_TEXTEDIT_UNDOSTATECOUNT[m
[32m+[m[32m#define STB_TEXTEDIT_UNDOSTATECOUNT   99[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifndef STB_TEXTEDIT_UNDOCHARCOUNT[m
[32m+[m[32m#define STB_TEXTEDIT_UNDOCHARCOUNT   999[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifndef STB_TEXTEDIT_CHARTYPE[m
[32m+[m[32m#define STB_TEXTEDIT_CHARTYPE        int[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifndef STB_TEXTEDIT_POSITIONTYPE[m
[32m+[m[32m#define STB_TEXTEDIT_POSITIONTYPE    int[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m   // private data[m
[32m+[m[32m   STB_TEXTEDIT_POSITIONTYPE  where;[m
[32m+[m[32m   STB_TEXTEDIT_POSITIONTYPE  insert_length;[m
[32m+[m[32m   STB_TEXTEDIT_POSITIONTYPE  delete_length;[m
[32m+[m[32m   int                        char_storage;[m
[32m+[m[32m} StbUndoRecord;[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m   // private data[m
[32m+[m[32m   StbUndoRecord          undo_rec [STB_TEXTEDIT_UNDOSTATECOUNT];[m
[32m+[m[32m   STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];[m
[32m+[m[32m   short undo_point, redo_point;[m
[32m+[m[32m   int undo_char_point, redo_char_point;[m
[32m+[m[32m} StbUndoState;[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m   /////////////////////[m
[32m+[m[32m   //[m
[32m+[m[32m   // public data[m
[32m+[m[32m   //[m
[32m+[m
[32m+[m[32m   int cursor;[m
[32m+[m[32m   // position of the text cursor within the string[m
[32m+[m
[32m+[m[32m   int select_start;          // selection start point[m
[32m+[m[32m   int select_end;[m
[32m+[m[32m   // selection start and end point in characters; if equal, no selection.[m
[32m+[m[32m   // note that start may be less than or greater than end (e.g. when[m
[32m+[m[32m   // dragging the mouse, start is where the initial click was, and you[m
[32m+[m[32m   // can drag in either direction)[m
[32m+[m
[32m+[m[32m   unsigned char insert_mode;[m
[32m+[m[32m   // each textfield keeps its own insert mode state. to keep an app-wide[m
[32m+[m[32m   // insert mode, copy this value in/out of the app state[m
[32m+[m
[32m+[m[32m   /////////////////////[m
[32m+[m[32m   //[m
[32m+[m[32m   // private data[m
[32m+[m[32m   //[m
[32m+[m[32m   unsigned char cursor_at_end_of_line; // not implemented yet[m
[32m+[m[32m   unsigned char initialized;[m
[32m+[m[32m   unsigned char has_preferred_x;[m
[32m+[m[32m   unsigned char single_line;[m
[32m+[m[32m   unsigned char padding1, padding2, padding3;[m
[32m+[m[32m   float preferred_x; // this determines where the cursor up/down tries to seek to along x[m
[32m+[m[32m   StbUndoState undostate;[m
[32m+[m[32m} STB_TexteditState;[m
[32m+[m
[32m+[m
[32m+[m[32m////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m//     StbTexteditRow[m
[32m+[m[32m//[m
[32m+[m[32m// Result of layout query, used by stb_textedit to determine where[m
[32m+[m[32m// the text in each row is.[m
[32m+[m
[32m+[m[32m// result of layout query[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m   float x0,x1;             // starting x location, end x location (allows for align=right, etc)[m
[32m+[m[32m   float baseline_y_delta;  // position of baseline relative to previous row's baseline[m
[32m+[m[32m   float ymin,ymax;         // height of row above and below baseline[m
[32m+[m[32m   int num_chars;[m
[32m+[m[32m} StbTexteditRow;[m
[32m+[m[32m#endif //INCLUDE_STB_TEXTEDIT_H[m
[32m+[m
[32m+[m
[32m+[m[32m////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m////[m
[32m+[m[32m////   Implementation mode[m
[32m+[m[32m////[m
[32m+[m[32m////[m
[32m+[m
[32m+[m
[32m+[m[32m// implementation isn't include-guarded, since it might have indirectly[m
[32m+[m[32m// included just the "header" portion[m
[32m+[m[32m#ifdef STB_TEXTEDIT_IMPLEMENTATION[m
[32m+[m
[32m+[m[32m#ifndef STB_TEXTEDIT_memmove[m
[32m+[m[32m#include <string.h>[m
[32m+[m[32m#define STB_TEXTEDIT_memmove memmove[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m
[32m+[m[32m/////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m//      Mouse input handling[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32m// traverse the layout to locate the nearest character to a display position[m
[32m+[m[32mstatic int stb_text_locate_coord(STB_TEXTEDIT_STRING *str, float x, float y)[m
[32m+[m[32m{[m
[32m+[m[32m   StbTexteditRow r;[m
[32m+[m[32m   int n = STB_TEXTEDIT_STRINGLEN(str);[m
[32m+[m[32m   float base_y = 0, prev_x;[m
[32m+[m[32m   int i=0, k;[m
[32m+[m
[32m+[m[32m   r.x0 = r.x1 = 0;[m
[32m+[m[32m   r.ymin = r.ymax = 0;[m
[32m+[m[32m   r.num_chars = 0;[m
[32m+[m
[32m+[m[32m   // search rows to find one that straddles 'y'[m
[32m+[m[32m   while (i < n) {[m
[32m+[m[32m      STB_TEXTEDIT_LAYOUTROW(&r, str, i);[m
[32m+[m[32m      if (r.num_chars <= 0)[m
[32m+[m[32m         return n;[m
[32m+[m
[32m+[m[32m      if (i==0 && y < base_y + r.ymin)[m
[32m+[m[32m         return 0;[m
[32m+[m
[32m+[m[32m      if (y < base_y + r.ymax)[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      i += r.num_chars;[m
[32m+[m[32m      base_y += r.baseline_y_delta;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   // below all text, return 'after' last character[m
[32m+[m[32m   if (i >= n)[m
[32m+[m[32m      return n;[m
[32m+[m
[32m+[m[32m   // check if it's before the beginning of the line[m
[32m+[m[32m   if (x < r.x0)[m
[32m+[m[32m      return i;[m
[32m+[m
[32m+[m[32m   // check if it's before the end of the line[m
[32m+[m[32m   if (x < r.x1) {[m
[32m+[m[32m      // search characters in row for one that straddles 'x'[m
[32m+[m[32m      prev_x = r.x0;[m
[32m+[m[32m      for (k=0; k < r.num_chars; ++k) {[m
[32m+[m[32m         float w = STB_TEXTEDIT_GETWIDTH(str, i, k);[m
[32m+[m[32m         if (x < prev_x+w) {[m
[32m+[m[32m            if (x < prev_x+w/2)[m
[32m+[m[32m               return k+i;[m
[32m+[m[32m            else[m
[32m+[m[32m               return k+i+1;[m
[32m+[m[32m         }[m
[32m+[m[32m         prev_x += w;[m
[32m+[m[32m      }[m
[32m+[m[32m      // shouldn't happen, but if it does, fall through to end-of-line case[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   // if the last character is a newline, return that. otherwise return 'after' the last character[m
[32m+[m[32m   if (STB_TEXTEDIT_GETCHAR(str, i+r.num_chars-1) == STB_TEXTEDIT_NEWLINE)[m
[32m+[m[32m      return i+r.num_chars-1;[m
[32m+[m[32m   else[m
[32m+[m[32m      return i+r.num_chars;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// API click: on mouse down, move the cursor to the clicked location, and reset the selection[m
[32m+[m[32mstatic void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)[m
[32m+[m[32m{[m
[32m+[m[32m   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse[m
[32m+[m[32m   // goes off the top or bottom of the text[m
[32m+[m[32m   if( state->single_line )[m
[32m+[m[32m   {[m
[32m+[m[32m      StbTexteditRow r;[m
[32m+[m[32m      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);[m
[32m+[m[32m      y = r.ymin;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   state->cursor = stb_text_locate_coord(str, x, y);[m
[32m+[m[32m   state->select_start = state->cursor;[m
[32m+[m[32m   state->select_end = state->cursor;[m
[32m+[m[32m   state->has_preferred_x = 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location[m
[32m+[m[32mstatic void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)[m
[32m+[m[32m{[m
[32m+[m[32m   int p = 0;[m
[32m+[m
[32m+[m[32m   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse[m
[32m+[m[32m   // goes off the top or bottom of the text[m
[32m+[m[32m   if( state->single_line )[m
[32m+[m[32m   {[m
[32m+[m[32m      StbTexteditRow r;[m
[32m+[m[32m      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);[m
[32m+[m[32m      y = r.ymin;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   if (state->select_start == state->select_end)[m
[32m+[m[32m      state->select_start = state->cursor;[m
[32m+[m
[32m+[m[32m   p = stb_text_locate_coord(str, x, y);[m
[32m+[m[32m   state->cursor = state->select_end = p;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m//      Keyboard input handling[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32m// forward declarations[m
[32m+[m[32mstatic void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);[m
[32m+[m[32mstatic void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);[m
[32m+[m[32mstatic void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length);[m
[32m+[m[32mstatic void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length);[m
[32m+[m[32mstatic void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length);[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m   float x,y;    // position of n'th character[m
[32m+[m[32m   float height; // height of line[m
[32m+[m[32m   int first_char, length; // first char of row, and length[m
[32m+[m[32m   int prev_first;  // first char of previous row[m
[32m+[m[32m} StbFindState;[m
[32m+[m
[32m+[m[32m// find the x/y location of a character, and remember info about the previous row in[m
[32m+[m[32m// case we get a move-up event (for page up, we'll have to rescan)[m
[32m+[m[32mstatic void stb_textedit_find_charpos(StbFindState *find, STB_TEXTEDIT_STRING *str, int n, int single_line)[m
[32m+[m[32m{[m
[32m+[m[32m   StbTexteditRow r;[m
[32m+[m[32m   int prev_start = 0;[m
[32m+[m[32m   int z = STB_TEXTEDIT_STRINGLEN(str);[m
[32m+[m[32m   int i=0, first;[m
[32m+[m
[32m+[m[32m   if (n == z) {[m
[32m+[m[32m      // if it's at the end, then find the last line -- simpler than trying to[m
[32m+[m[32m      // explicitly handle this case in the regular code[m
[32m+[m[32m      if (single_line) {[m
[32m+[m[32m         STB_TEXTEDIT_LAYOUTROW(&r, str, 0);[m
[32m+[m[32m         find->y = 0;[m
[32m+[m[32m         find->first_char = 0;[m
[32m+[m[32m         find->length = z;[m
[32m+[m[32m         find->height = r.ymax - r.ymin;[m
[32m+[m[32m         find->x = r.x1;[m
[32m+[m[32m      } else {[m
[32m+[m[32m         find->y = 0;[m
[32m+[m[32m         find->x = 0;[m
[32m+[m[32m         find->height = 1;[m
[32m+[m[32m         while (i < z) {[m
[32m+[m[32m            STB_TEXTEDIT_LAYOUTROW(&r, str, i);[m
[32m+[m[32m            prev_start = i;[m
[32m+[m[32m            i += r.num_chars;[m
[32m+[m[32m         }[m
[32m+[m[32m         find->first_char = i;[m
[32m+[m[32m         find->length = 0;[m
[32m+[m[32m         find->prev_first = prev_start;[m
[32m+[m[32m      }[m
[32m+[m[32m      return;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   // search rows to find the one that straddles character n[m
[32m+[m[32m   find->y = 0;[m
[32m+[m
[32m+[m[32m   for(;;) {[m
[32m+[m[32m      STB_TEXTEDIT_LAYOUTROW(&r, str, i);[m
[32m+[m[32m      if (n < i + r.num_chars)[m
[32m+[m[32m         break;[m
[32m+[m[32m      prev_start = i;[m
[32m+[m[32m      i += r.num_chars;[m
[32m+[m[32m      find->y += r.baseline_y_delta;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   find->first_char = first = i;[m
[32m+[m[32m   find->length = r.num_chars;[m
[32m+[m[32m   find->height = r.ymax - r.ymin;[m
[32m+[m[32m   find->prev_first = prev_start;[m
[32m+[m
[32m+[m[32m   // now scan to find xpos[m
[32m+[m[32m   find->x = r.x0;[m
[32m+[m[32m   for (i=0; first+i < n; ++i)[m
[32m+[m[32m      find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#define STB_TEXT_HAS_SELECTION(s)   ((s)->select_start != (s)->select_end)[m
[32m+[m
[32m+[m[32m// make the selection/cursor state valid if client altered the string[m
[32m+[m[32mstatic void stb_textedit_clamp(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)[m
[32m+[m[32m{[m
[32m+[m[32m   int n = STB_TEXTEDIT_STRINGLEN(str);[m
[32m+[m[32m   if (STB_TEXT_HAS_SELECTION(state)) {[m
[32m+[m[32m      if (state->select_start > n) state->select_start = n;[m
[32m+[m[32m      if (state->select_end   > n) state->select_end = n;[m
[32m+[m[32m      // if clamping forced them to be equal, move the cursor to match[m
[32m+[m[32m      if (state->select_start == state->select_end)[m
[32m+[m[32m         state->cursor = state->select_start;[m
[32m+[m[32m   }[m
[32m+[m[32m   if (state->cursor > n) state->cursor = n;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// delete characters while updating undo[m
[32m+[m[32mstatic void stb_textedit_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)[m
[32m+[m[32m{[m
[32m+[m[32m   stb_text_makeundo_delete(str, state, where, len);[m
[32m+[m[32m   STB_TEXTEDIT_DELETECHARS(str, where, len);[m
[32m+[m[32m   state->has_preferred_x = 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// delete the section[m
[32m+[m[32mstatic void stb_textedit_delete_selection(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)[m
[32m+[m[32m{[m
[32m+[m[32m   stb_textedit_clamp(str, state);[m
[32m+[m[32m   if (STB_TEXT_HAS_SELECTION(state)) {[m
[32m+[m[32m      if (state->select_start < state->select_end) {[m
[32m+[m[32m         stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);[m
[32m+[m[32m         state->select_end = state->cursor = state->select_start;[m
[32m+[m[32m      } else {[m
[32m+[m[32m         stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);[m
[32m+[m[32m         state->select_start = state->cursor = state->select_end;[m
[32m+[m[32m      }[m
[32m+[m[32m      state->has_preferred_x = 0;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// canoncialize the selection so start <= end[m
[32m+[m[32mstatic void stb_textedit_sortselection(STB_TexteditState *state)[m
[32m+[m[32m{[m
[32m+[m[32m   if (state->select_end < state->select_start) {[m
[32m+[m[32m      int temp = state->select_end;[m
[32m+[m[32m      state->select_end = state->select_start;[m
[32m+[m[32m      state->select_start = temp;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// move cursor to first character of selection[m
[32m+[m[32mstatic void stb_textedit_move_to_first(STB_TexteditState *state)[m
[32m+[m[32m{[m
[32m+[m[32m   if (STB_TEXT_HAS_SELECTION(state)) {[m
[32m+[m[32m      stb_textedit_sortselection(state);[m
[32m+[m[32m      state->cursor = state->select_start;[m
[32m+[m[32m      state->select_end = state->select_start;[m
[32m+[m[32m      state->has_preferred_x = 0;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// move cursor to last character of selection[m
[32m+[m[32mstatic void stb_textedit_move_to_last(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)[m
[32m+[m[32m{[m
[32m+[m[32m   if (STB_TEXT_HAS_SELECTION(state)) {[m
[32m+[m[32m      stb_textedit_sortselection(state);[m
[32m+[m[32m      stb_textedit_clamp(str, state);[m
[32m+[m[32m      state->cursor = state->select_end;[m
[32m+[m[32m      state->select_start = state->select_end;[m
[32m+[m[32m      state->has_preferred_x = 0;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#ifdef STB_TEXTEDIT_IS_SPACE[m
[32m+[m[32mstatic int is_word_boundary( STB_TEXTEDIT_STRING *str, int idx )[m
[32m+[m[32m{[m
[32m+[m[32m   return idx > 0 ? (STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str,idx-1) ) && !STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str, idx) ) ) : 1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#ifndef STB_TEXTEDIT_MOVEWORDLEFT[m
[32m+[m[32mstatic int stb_textedit_move_to_word_previous( STB_TEXTEDIT_STRING *str, int c )[m
[32m+[m[32m{[m
[32m+[m[32m   --c; // always move at least one character[m
[32m+[m[32m   while( c >= 0 && !is_word_boundary( str, c ) )[m
[32m+[m[32m      --c;[m
[32m+[m
[32m+[m[32m   if( c < 0 )[m
[32m+[m[32m      c = 0;[m
[32m+[m
[32m+[m[32m   return c;[m
[32m+[m[32m}[m
[32m+[m[32m#define STB_TEXTEDIT_MOVEWORDLEFT stb_textedit_move_to_word_previous[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifndef STB_TEXTEDIT_MOVEWORDRIGHT[m
[32m+[m[32mstatic int stb_textedit_move_to_word_next( STB_TEXTEDIT_STRING *str, int c )[m
[32m+[m[32m{[m
[32m+[m[32m   const int len = STB_TEXTEDIT_STRINGLEN(str);[m
[32m+[m[32m   ++c; // always move at least one character[m
[32m+[m[32m   while( c < len && !is_word_boundary( str, c ) )[m
[32m+[m[32m      ++c;[m
[32m+[m
[32m+[m[32m   if( c > len )[m
[32m+[m[32m      c = len;[m
[32m+[m
[32m+[m[32m   return c;[m
[32m+[m[32m}[m
[32m+[m[32m#define STB_TEXTEDIT_MOVEWORDRIGHT stb_textedit_move_to_word_next[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// update selection and cursor to match each other[m
[32m+[m[32mstatic void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)[m
[32m+[m[32m{[m
[32m+[m[32m   if (!STB_TEXT_HAS_SELECTION(state))[m
[32m+[m[32m      state->select_start = state->select_end = state->cursor;[m
[32m+[m[32m   else[m
[32m+[m[32m      state->cursor = state->select_end;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// API cut: delete selection[m
[32m+[m[32mstatic int stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)[m
[32m+[m[32m{[m
[32m+[m[32m   if (STB_TEXT_HAS_SELECTION(state)) {[m
[32m+[m[32m      stb_textedit_delete_selection(str,state); // implicitly clamps[m
[32m+[m[32m      state->has_preferred_x = 0;[m
[32m+[m[32m      return 1;[m
[32m+[m[32m   }[m
[32m+[m[32m   return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// API paste: replace existing selection with passed-in text[m
[32m+[m[32mstatic int stb_textedit_paste_internal(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)[m
[32m+[m[32m{[m
[32m+[m[32m   // if there's a selection, the paste should delete it[m
[32m+[m[32m   stb_textedit_clamp(str, state);[m
[32m+[m[32m   stb_textedit_delete_selection(str,state);[m
[32m+[m[32m   // try to insert the characters[m
[32m+[m[32m   if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {[m
[32m+[m[32m      stb_text_makeundo_insert(state, state->cursor, len);[m
[32m+[m[32m      state->cursor += len;[m
[32m+[m[32m      state->has_preferred_x = 0;[m
[32m+[m[32m      return 1;[m
[32m+[m[32m   }[m
[32m+[m[32m   // remove the undo since we didn't actually insert the characters[m
[32m+[m[32m   if (state->undostate.undo_point)[m
[32m+[m[32m      --state->undostate.undo_point;[m
[32m+[m[32m   return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#ifndef STB_TEXTEDIT_KEYTYPE[m
[32m+[m[32m#define STB_TEXTEDIT_KEYTYPE int[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// API key: process a keyboard input[m
[32m+[m[32mstatic void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_KEYTYPE key)[m
[32m+[m[32m{[m
[32m+[m[32mretry:[m
[32m+[m[32m   switch (key) {[m
[32m+[m[32m      default: {[m
[32m+[m[32m         int c = STB_TEXTEDIT_KEYTOTEXT(key);[m
[32m+[m[32m         if (c > 0) {[m
[32m+[m[32m            STB_TEXTEDIT_CHARTYPE ch = (STB_TEXTEDIT_CHARTYPE) c;[m
[32m+[m
[32m+[m[32m            // can't add newline in single-line mode[m
[32m+[m[32m            if (c == '\n' && state->single_line)[m
[32m+[m[32m               break;[m
[32m+[m
[32m+[m[32m            if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {[m
[32m+[m[32m               stb_text_makeundo_replace(str, state, state->cursor, 1, 1);[m
[32m+[m[32m               STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);[m
[32m+[m[32m               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {[m
[32m+[m[32m                  ++state->cursor;[m
[32m+[m[32m                  state->has_preferred_x = 0;[m
[32m+[m[32m               }[m
[32m+[m[32m            } else {[m
[32m+[m[32m               stb_textedit_delete_selection(str,state); // implicitly clamps[m
[32m+[m[32m               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {[m
[32m+[m[32m                  stb_text_makeundo_insert(state, state->cursor, 1);[m
[32m+[m[32m                  ++state->cursor;[m
[32m+[m[32m                  state->has_preferred_x = 0;[m
[32m+[m[32m               }[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m
[32m+[m[32m         break;[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m#ifdef STB_TEXTEDIT_K_INSERT[m
[32m+[m[32m      case STB_TEXTEDIT_K_INSERT:[m
[32m+[m[32m         state->insert_mode = !state->insert_mode;[m
[32m+[m[32m         break;[m
[32m+[m[32m#endif[m
[32m+[m[41m         [m
[32m+[m[32m      case STB_TEXTEDIT_K_UNDO:[m
[32m+[m[32m         stb_text_undo(str, state);[m
[32m+[m[32m         state->has_preferred_x = 0;[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case STB_TEXTEDIT_K_REDO:[m
[32m+[m[32m         stb_text_redo(str, state);[m
[32m+[m[32m         state->has_preferred_x = 0;[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case STB_TEXTEDIT_K_LEFT:[m
[32m+[m[32m         // if currently there's a selection, move cursor to start of selection[m
[32m+[m[32m         if (STB_TEXT_HAS_SELECTION(state))[m
[32m+[m[32m            stb_textedit_move_to_first(state);[m
[32m+[m[32m         else[m[41m [m
[32m+[m[32m            if (state->cursor > 0)[m
[32m+[m[32m               --state->cursor;[m
[32m+[m[32m         state->has_preferred_x = 0;[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case STB_TEXTEDIT_K_RIGHT:[m
[32m+[m[32m         // if currently there's a selection, move cursor to end of selection[m
[32m+[m[32m         if (STB_TEXT_HAS_SELECTION(state))[m
[32m+[m[32m            stb_textedit_move_to_last(str, state);[m
[32m+[m[32m         else[m
[32m+[m[32m            ++state->cursor;[m
[32m+[m[32m         stb_textedit_clamp(str, state);[m
[32m+[m[32m         state->has_preferred_x = 0;[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:[m
[32m+[m[32m         stb_textedit_clamp(str, state);[m
[32m+[m[32m         stb_textedit_prep_selection_at_cursor(state);[m
[32m+[m[32m         // move selection left[m
[32m+[m[32m         if (state->select_end > 0)[m
[32m+[m[32m            --state->select_end;[m
[32m+[m[32m         state->cursor = state->select_end;[m
[32m+[m[32m         state->has_preferred_x = 0;[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m#ifdef STB_TEXTEDIT_MOVEWORDLEFT[m
[32m+[m[32m      case STB_TEXTEDIT_K_WORDLEFT:[m
[32m+[m[32m         if (STB_TEXT_HAS_SELECTION(state))[m
[32m+[m[32m            stb_textedit_move_to_first(state);[m
[32m+[m[32m         else {[m
[32m+[m[32m            state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);[m
[32m+[m[32m            stb_textedit_clamp( str, state );[m
[32m+[m[32m         }[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:[m
[32m+[m[32m         if( !STB_TEXT_HAS_SELECTION( state ) )[m
[32m+[m[32m            stb_textedit_prep_selection_at_cursor(state);[m
[32m+[m
[32m+[m[32m         state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);[m
[32m+[m[32m         state->select_end = state->cursor;[m
[32m+[m
[32m+[m[32m         stb_textedit_clamp( str, state );[m
[32m+[m[32m         break;[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef STB_TEXTEDIT_MOVEWORDRIGHT[m
[32m+[m[32m      case STB_TEXTEDIT_K_WORDRIGHT:[m
[32m+[m[32m         if (STB_TEXT_HAS_SELECTION(state))[m[41m [m
[32m+[m[32m            stb_textedit_move_to_last(str, state);[m
[32m+[m[32m         else {[m
[32m+[m[32m            state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);[m
[32m+[m[32m            stb_textedit_clamp( str, state );[m
[32m+[m[32m         }[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:[m
[32m+[m[32m         if( !STB_TEXT_HAS_SELECTION( state ) )[m
[32m+[m[32m            stb_textedit_prep_selection_at_cursor(state);[m
[32m+[m
[32m+[m[32m         state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);[m
[32m+[m[32m         state->select_end = state->cursor;[m
[32m+[m
[32m+[m[32m         stb_textedit_clamp( str, state );[m
[32m+[m[32m         break;[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m      case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:[m
[32m+[m[32m         stb_textedit_prep_selection_at_cursor(state);[m
[32m+[m[32m         // move selection right[m
[32m+[m[32m         ++state->select_end;[m
[32m+[m[32m         stb_textedit_clamp(str, state);[m
[32m+[m[32m         state->cursor = state->select_end;[m
[32m+[m[32m         state->has_preferred_x = 0;[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case STB_TEXTEDIT_K_DOWN:[m
[32m+[m[32m      case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT: {[m
[32m+[m[32m         StbFindState find;[m
[32m+[m[32m         StbTexteditRow row;[m
[32m+[m[32m         int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;[m
[32m+[m
[32m+[m[32m         if (state->single_line) {[m
[32m+[m[32m            // on windows, up&down in single-line behave like left&right[m
[32m+[m[32m            key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);[m
[32m+[m[32m            goto retry;[m
[32m+[m[32m         }[m
[32m+[m
[32m+[m[32m         if (sel)[m
[32m+[m[32m            stb_textedit_prep_selection_at_cursor(state);[m
[32m+[m[32m         else if (STB_TEXT_HAS_SELECTION(state))[m
[32m+[m[32m            stb_textedit_move_to_last(str,state);[m
[32m+[m
[32m+[m[32m         // compute current position of cursor point[m
[32m+[m[32m         stb_textedit_clamp(str, state);[m
[32m+[m[32m         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);[m
[32m+[m
[32m+[m[32m         // now find character position down a row[m
[32m+[m[32m         if (find.length) {[m
[32m+[m[32m            float goal_x = state->has_preferred_x ? state->preferred_x : find.x;[m
[32m+[m[32m            float x;[m
[32m+[m[32m            int start = find.first_char + find.length;[m
[32m+[m[32m            state->cursor = start;[m
[32m+[m[32m            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);[m
[32m+[m[32m            x = row.x0;[m
[32m+[m[32m            for (i=0; i < row.num_chars; ++i) {[m
[32m+[m[32m               float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);[m
[32m+[m[32m               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE[m
[32m+[m[32m               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)[m
[32m+[m[32m                  break;[m
[32m+[m[32m               #endif[m
[32m+[m[32m               x += dx;[m
[32m+[m[32m               if (x > goal_x)[m
[32m+[m[32m                  break;[m
[32m+[m[32m               ++state->cursor;[m
[32m+[m[32m            }[m
[32m+[m[32m            stb_textedit_clamp(str, state);[m
[32m+[m
[32m+[m[32m            state->has_preferred_x = 1;[m
[32m+[m[32m            state->preferred_x = goal_x;[m
[32m+[m
[32m+[m[32m            if (sel)[m
[32m+[m[32m               state->select_end = state->cursor;[m
[32m+[m[32m         }[m
[32m+[m[32m         break;[m
[32m+[m[32m      }[m
[32m+[m[41m         [m
[32m+[m[32m      case STB_TEXTEDIT_K_UP:[m
[32m+[m[32m      case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT: {[m
[32m+[m[32m         StbFindState find;[m
[32m+[m[32m         StbTexteditRow row;[m
[32m+[m[32m         int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;[m
[32m+[m
[32m+[m[32m         if (state->single_line) {[m
[32m+[m[32m            // on windows, up&down become left&right[m
[32m+[m[32m            key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);[m
[32m+[m[32m            goto retry;[m
[32m+[m[32m         }[m
[32m+[m
[32m+[m[32m         if (sel)[m
[32m+[m[32m            stb_textedit_prep_selection_at_cursor(state);[m
[32m+[m[32m         else if (STB_TEXT_HAS_SELECTION(state))[m
[32m+[m[32m            stb_textedit_move_to_first(state);[m
[32m+[m
[32m+[m[32m         // compute current position of cursor point[m
[32m+[m[32m         stb_textedit_clamp(str, state);[m
[32m+[m[32m         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);[m
[32m+[m
[32m+[m[32m         // can only go up if there's a previous row[m
[32m+[m[32m         if (find.prev_first != find.first_char) {[m
[32m+[m[32m            // now find character position up a row[m
[32m+[m[32m            float goal_x = state->has_preferred_x ? state->preferred_x : find.x;[m
[32m+[m[32m            float x;[m
[32m+[m[32m            state->cursor = find.prev_first;[m
[32m+[m[32m            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);[m
[32m+[m[32m            x = row.x0;[m
[32m+[m[32m            for (i=0; i < row.num_chars; ++i) {[m
[32m+[m[32m               float dx = STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i);[m
[32m+[m[32m               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE[m
[32m+[m[32m               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)[m
[32m+[m[32m                  break;[m
[32m+[m[32m               #endif[m
[32m+[m[32m               x += dx;[m
[32m+[m[32m               if (x > goal_x)[m
[32m+[m[32m                  break;[m
[32m+[m[32m               ++state->cursor;[m
[32m+[m[32m            }[m
[32m+[m[32m            stb_textedit_clamp(str, state);[m
[32m+[m
[32m+[m[32m            state->has_preferred_x = 1;[m
[32m+[m[32m            state->preferred_x = goal_x;[m
[32m+[m
[32m+[m[32m            if (sel)[m
[32m+[m[32m               state->select_end = state->cursor;[m
[32m+[m[32m         }[m
[32m+[m[32m         break;[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      case STB_TEXTEDIT_K_DELETE:[m
[32m+[m[32m      case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:[m
[32m+[m[32m         if (STB_TEXT_HAS_SELECTION(state))[m
[32m+[m[32m            stb_textedit_delete_selection(str, state);[m
[32m+[m[32m         else {[m
[32m+[m[32m            int n = STB_TEXTEDIT_STRINGLEN(str);[m
[32m+[m[32m            if (state->cursor < n)[m
[32m+[m[32m               stb_textedit_delete(str, state, state->cursor, 1);[m
[32m+[m[32m         }[m
[32m+[m[32m         state->has_preferred_x = 0;[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case STB_TEXTEDIT_K_BACKSPACE:[m
[32m+[m[32m      case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:[m
[32m+[m[32m         if (STB_TEXT_HAS_SELECTION(state))[m
[32m+[m[32m            stb_textedit_delete_selection(str, state);[m
[32m+[m[32m         else {[m
[32m+[m[32m            stb_textedit_clamp(str, state);[m
[32m+[m[32m            if (state->cursor > 0) {[m
[32m+[m[32m               stb_textedit_delete(str, state, state->cursor-1, 1);[m
[32m+[m[32m               --state->cursor;[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m
[32m+[m[32m         state->has_preferred_x = 0;[m
[32m+[m[32m         break;[m
[32m+[m[41m         [m
[32m+[m[32m#ifdef STB_TEXTEDIT_K_TEXTSTART2[m
[32m+[m[32m      case STB_TEXTEDIT_K_TEXTSTART2:[m
[32m+[m[32m#endif[m
[32m+[m[32m      case STB_TEXTEDIT_K_TEXTSTART:[m
[32m+[m[32m         state->cursor = state->select_start = state->select_end = 0;[m
[32m+[m[32m         state->has_preferred_x = 0;[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m#ifdef STB_TEXTEDIT_K_TEXTEND2[m
[32m+[m[32m      case STB_TEXTEDIT_K_TEXTEND2:[m
[32m+[m[32m#endif[m
[32m+[m[32m      case STB_TEXTEDIT_K_TEXTEND:[m
[32m+[m[32m         state->cursor = STB_TEXTEDIT_STRINGLEN(str);[m
[32m+[m[32m         state->select_start = state->select_end = 0;[m
[32m+[m[32m         state->has_preferred_x = 0;[m
[32m+[m[32m         break;[m
[32m+[m[41m        [m
[32m+[m[32m#ifdef STB_TEXTEDIT_K_TEXTSTART2[m
[32m+[m[32m      case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:[m
[32m+[m[32m#endif[m
[32m+[m[32m      case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:[m
[32m+[m[32m         stb_textedit_prep_selection_at_cursor(state);[m
[32m+[m[32m         state->cursor = state->select_end = 0;[m
[32m+[m[32m         state->has_preferred_x = 0;[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m#ifdef STB_TEXTEDIT_K_TEXTEND2[m
[32m+[m[32m      case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:[m
[32m+[m[32m#endif[m
[32m+[m[32m      case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:[m
[32m+[m[32m         stb_textedit_prep_selection_at_cursor(state);[m
[32m+[m[32m         state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);[m
[32m+[m[32m         state->has_preferred_x = 0;[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m
[32m+[m[32m#ifdef STB_TEXTEDIT_K_LINESTART2[m
[32m+[m[32m      case STB_TEXTEDIT_K_LINESTART2:[m
[32m+[m[32m#endif[m
[32m+[m[32m      case STB_TEXTEDIT_K_LINESTART:[m
[32m+[m[32m         stb_textedit_clamp(str, state);[m
[32m+[m[32m         stb_textedit_move_to_first(state);[m
[32m+[m[32m         if (state->single_line)[m
[32m+[m[32m            state->cursor = 0;[m
[32m+[m[32m         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)[m
[32m+[m[32m            --state->cursor;[m
[32m+[m[32m         state->has_preferred_x = 0;[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m#ifdef STB_TEXTEDIT_K_LINEEND2[m
[32m+[m[32m      case STB_TEXTEDIT_K_LINEEND2:[m
[32m+[m[32m#endif[m
[32m+[m[32m      case STB_TEXTEDIT_K_LINEEND: {[m
[32m+[m[32m         int n = STB_TEXTEDIT_STRINGLEN(str);[m
[32m+[m[32m         stb_textedit_clamp(str, state);[m
[32m+[m[32m         stb_textedit_move_to_first(state);[m
[32m+[m[32m         if (state->single_line)[m
[32m+[m[32m             state->cursor = n;[m
[32m+[m[32m         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)[m
[32m+[m[32m             ++state->cursor;[m
[32m+[m[32m         state->has_preferred_x = 0;[m
[32m+[m[32m         break;[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m#ifdef STB_TEXTEDIT_K_LINESTART2[m
[32m+[m[32m      case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:[m
[32m+[m[32m#endif[m
[32m+[m[32m      case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:[m
[32m+[m[32m         stb_textedit_clamp(str, state);[m
[32m+[m[32m         stb_textedit_prep_selection_at_cursor(state);[m
[32m+[m[32m         if (state->single_line)[m
[32m+[m[32m            state->cursor = 0;[m
[32m+[m[32m         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)[m
[32m+[m[32m            --state->cursor;[m
[32m+[m[32m         state->select_end = state->cursor;[m
[32m+[m[32m         state->has_preferred_x = 0;[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m#ifdef STB_TEXTEDIT_K_LINEEND2[m
[32m+[m[32m      case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:[m
[32m+[m[32m#endif[m
[32m+[m[32m      case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {[m
[32m+[m[32m         int n = STB_TEXTEDIT_STRINGLEN(str);[m
[32m+[m[32m         stb_textedit_clamp(str, state);[m
[32m+[m[32m         stb_textedit_prep_selection_at_cursor(state);[m
[32m+[m[32m         if (state->single_line)[m
[32m+[m[32m             state->cursor = n;[m
[32m+[m[32m         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)[m
[32m+[m[32m            ++state->cursor;[m
[32m+[m[32m         state->select_end = state->cursor;[m
[32m+[m[32m         state->has_preferred_x = 0;[m
[32m+[m[32m         break;[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m// @TODO:[m
[32m+[m[32m//    STB_TEXTEDIT_K_PGUP      - move cursor up a page[m
[32m+[m[32m//    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m//      Undo processing[m
[32m+[m[32m//[m
[32m+[m[32m// @OPTIMIZE: the undo/redo buffer should be circular[m
[32m+[m
[32m+[m[32mstatic void stb_textedit_flush_redo(StbUndoState *state)[m
[32m+[m[32m{[m
[32m+[m[32m   state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;[m
[32m+[m[32m   state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// discard the oldest entry in the undo list[m
[32m+[m[32mstatic void stb_textedit_discard_undo(StbUndoState *state)[m
[32m+[m[32m{[m
[32m+[m[32m   if (state->undo_point > 0) {[m
[32m+[m[32m      // if the 0th undo state has characters, clean those up[m
[32m+[m[32m      if (state->undo_rec[0].char_storage >= 0) {[m
[32m+[m[32m         int n = state->undo_rec[0].insert_length, i;[m
[32m+[m[32m         // delete n characters from all other records[m
[32m+[m[32m         state->undo_char_point -= n;[m
[32m+[m[32m         STB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t) (state->undo_char_point*sizeof(STB_TEXTEDIT_CHARTYPE)));[m
[32m+[m[32m         for (i=0; i < state->undo_point; ++i)[m
[32m+[m[32m            if (state->undo_rec[i].char_storage >= 0)[m
[32m+[m[32m               state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it[m
[32m+[m[32m      }[m
[32m+[m[32m      --state->undo_point;[m
[32m+[m[32m      STB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec+1, (size_t) (state->undo_point*sizeof(state->undo_rec[0])));[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// discard the oldest entry in the redo list--it's bad if this[m
[32m+[m[32m// ever happens, but because undo & redo have to store the actual[m
[32m+[m[32m// characters in different cases, the redo character buffer can[m
[32m+[m[32m// fill up even though the undo buffer didn't[m
[32m+[m[32mstatic void stb_textedit_discard_redo(StbUndoState *state)[m
[32m+[m[32m{[m
[32m+[m[32m   int k = STB_TEXTEDIT_UNDOSTATECOUNT-1;[m
[32m+[m
[32m+[m[32m   if (state->redo_point <= k) {[m
[32m+[m[32m      // if the k'th undo state has characters, clean those up[m
[32m+[m[32m      if (state->undo_rec[k].char_storage >= 0) {[m
[32m+[m[32m         int n = state->undo_rec[k].insert_length, i;[m
[32m+[m[32m         // move the remaining redo character data to the end of the buffer[m
[32m+[m[32m         state->redo_char_point += n;[m
[32m+[m[32m         STB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point-n, (size_t) ((STB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point)*sizeof(STB_TEXTEDIT_CHARTYPE)));[m
[32m+[m[32m         // adjust the position of all the other records to account for above memmove[m
[32m+[m[32m         for (i=state->redo_point; i < k; ++i)[m
[32m+[m[32m            if (state->undo_rec[i].char_storage >= 0)[m
[32m+[m[32m               state->undo_rec[i].char_storage += n;[m
[32m+[m[32m      }[m
[32m+[m[32m      // now move all the redo records towards the end of the buffer; the first one is at 'redo_point'[m
[32m+[m[32m      // {DEAR IMGUI][m
[32m+[m[32m      size_t move_size = (size_t)((STB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point - 1) * sizeof(state->undo_rec[0]));[m
[32m+[m[32m      const char* buf_begin = (char*)state->undo_rec; (void)buf_begin;[m
[32m+[m[32m      const char* buf_end   = (char*)state->undo_rec + sizeof(state->undo_rec); (void)buf_end;[m
[32m+[m[32m      IM_ASSERT(((char*)(state->undo_rec + state->redo_point)) >= buf_begin);[m
[32m+[m[32m      IM_ASSERT(((char*)(state->undo_rec + state->redo_point + 1) + move_size) <= buf_end);[m
[32m+[m[32m      STB_TEXTEDIT_memmove(state->undo_rec + state->redo_point+1, state->undo_rec + state->redo_point, move_size);[m
[32m+[m
[32m+[m[32m      // now move redo_point to point to the new one[m
[32m+[m[32m      ++state->redo_point;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars)[m
[32m+[m[32m{[m
[32m+[m[32m   // any time we create a new undo record, we discard redo[m
[32m+[m[32m   stb_textedit_flush_redo(state);[m
[32m+[m
[32m+[m[32m   // if we have no free records, we have to make room, by sliding the[m
[32m+[m[32m   // existing records down[m
[32m+[m[32m   if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)[m
[32m+[m[32m      stb_textedit_discard_undo(state);[m
[32m+[m
[32m+[m[32m   // if the characters to store won't possibly fit in the buffer, we can't undo[m
[32m+[m[32m   if (numchars > STB_TEXTEDIT_UNDOCHARCOUNT) {[m
[32m+[m[32m      state->undo_point = 0;[m
[32m+[m[32m      state->undo_char_point = 0;[m
[32m+[m[32m      return NULL;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   // if we don't have enough free characters in the buffer, we have to make room[m
[32m+[m[32m   while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)[m
[32m+[m[32m      stb_textedit_discard_undo(state);[m
[32m+[m
[32m+[m[32m   return &state->undo_rec[state->undo_point++];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic STB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len)[m
[32m+[m[32m{[m
[32m+[m[32m   StbUndoRecord *r = stb_text_create_undo_record(state, insert_len);[m
[32m+[m[32m   if (r == NULL)[m
[32m+[m[32m      return NULL;[m
[32m+[m
[32m+[m[32m   r->where = pos;[m
[32m+[m[32m   r->insert_length = (STB_TEXTEDIT_POSITIONTYPE) insert_len;[m
[32m+[m[32m   r->delete_length = (STB_TEXTEDIT_POSITIONTYPE) delete_len;[m
[32m+[m
[32m+[m[32m   if (insert_len == 0) {[m
[32m+[m[32m      r->char_storage = -1;[m
[32m+[m[32m      return NULL;[m
[32m+[m[32m   } else {[m
[32m+[m[32m      r->char_storage = state->undo_char_point;[m
[32m+[m[32m      state->undo_char_point += insert_len;[m
[32m+[m[32m      return &state->undo_char[r->char_storage];[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)[m
[32m+[m[32m{[m
[32m+[m[32m   StbUndoState *s = &state->undostate;[m
[32m+[m[32m   StbUndoRecord u, *r;[m
[32m+[m[32m   if (s->undo_point == 0)[m
[32m+[m[32m      return;[m
[32m+[m
[32m+[m[32m   // we need to do two things: apply the undo record, and create a redo record[m
[32m+[m[32m   u = s->undo_rec[s->undo_point-1];[m
[32m+[m[32m   r = &s->undo_rec[s->redo_point-1];[m
[32m+[m[32m   r->char_storage = -1;[m
[32m+[m
[32m+[m[32m   r->insert_length = u.delete_length;[m
[32m+[m[32m   r->delete_length = u.insert_length;[m
[32m+[m[32m   r->where = u.where;[m
[32m+[m
[32m+[m[32m   if (u.delete_length) {[m
[32m+[m[32m      // if the undo record says to delete characters, then the redo record will[m
[32m+[m[32m      // need to re-insert the characters that get deleted, so we need to store[m
[32m+[m[32m      // them.[m
[32m+[m
[32m+[m[32m      // there are three cases:[m
[32m+[m[32m      //    there's enough room to store the characters[m
[32m+[m[32m      //    characters stored for *redoing* don't leave room for redo[m
[32m+[m[32m      //    characters stored for *undoing* don't leave room for redo[m
[32m+[m[32m      // if the last is true, we have to bail[m
[32m+[m
[32m+[m[32m      if (s->undo_char_point + u.delete_length >= STB_TEXTEDIT_UNDOCHARCOUNT) {[m
[32m+[m[32m         // the undo records take up too much character space; there's no space to store the redo characters[m
[32m+[m[32m         r->insert_length = 0;[m
[32m+[m[32m      } else {[m
[32m+[m[32m         int i;[m
[32m+[m
[32m+[m[32m         // there's definitely room to store the characters eventually[m
[32m+[m[32m         while (s->undo_char_point + u.delete_length > s->redo_char_point) {[m
[32m+[m[32m            // should never happen:[m
[32m+[m[32m            if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)[m
[32m+[m[32m               return;[m
[32m+[m[32m            // there's currently not enough room, so discard a redo record[m
[32m+[m[32m            stb_textedit_discard_redo(s);[m
[32m+[m[32m         }[m
[32m+[m[32m         r = &s->undo_rec[s->redo_point-1];[m
[32m+[m
[32m+[m[32m         r->char_storage = s->redo_char_point - u.delete_length;[m
[32m+[m[32m         s->redo_char_point = s->redo_char_point - u.delete_length;[m
[32m+[m
[32m+[m[32m         // now save the characters[m
[32m+[m[32m         for (i=0; i < u.delete_length; ++i)[m
[32m+[m[32m            s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      // now we can carry out the deletion[m
[32m+[m[32m      STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   // check type of recorded action:[m
[32m+[m[32m   if (u.insert_length) {[m
[32m+[m[32m      // easy case: was a deletion, so we need to insert n characters[m
[32m+[m[32m      STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);[m
[32m+[m[32m      s->undo_char_point -= u.insert_length;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   state->cursor = u.where + u.insert_length;[m
[32m+[m
[32m+[m[32m   s->undo_point--;[m
[32m+[m[32m   s->redo_point--;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)[m
[32m+[m[32m{[m
[32m+[m[32m   StbUndoState *s = &state->undostate;[m
[32m+[m[32m   StbUndoRecord *u, r;[m
[32m+[m[32m   if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)[m
[32m+[m[32m      return;[m
[32m+[m
[32m+[m[32m   // we need to do two things: apply the redo record, and create an undo record[m
[32m+[m[32m   u = &s->undo_rec[s->undo_point];[m
[32m+[m[32m   r = s->undo_rec[s->redo_point];[m
[32m+[m
[32m+[m[32m   // we KNOW there must be room for the undo record, because the redo record[m
[32m+[m[32m   // was derived from an undo record[m
[32m+[m
[32m+[m[32m   u->delete_length = r.insert_length;[m
[32m+[m[32m   u->insert_length = r.delete_length;[m
[32m+[m[32m   u->where = r.where;[m
[32m+[m[32m   u->char_storage = -1;[m
[32m+[m
[32m+[m[32m   if (r.delete_length) {[m
[32m+[m[32m      // the redo record requires us to delete characters, so the undo record[m
[32m+[m[32m      // needs to store the characters[m
[32m+[m
[32m+[m[32m      if (s->undo_char_point + u->insert_length > s->redo_char_point) {[m
[32m+[m[32m         u->insert_length = 0;[m
[32m+[m[32m         u->delete_length = 0;[m
[32m+[m[32m      } else {[m
[32m+[m[32m         int i;[m
[32m+[m[32m         u->char_storage = s->undo_char_point;[m
[32m+[m[32m         s->undo_char_point = s->undo_char_point + u->insert_length;[m
[32m+[m
[32m+[m[32m         // now save the characters[m
[32m+[m[32m         for (i=0; i < u->insert_length; ++i)[m
[32m+[m[32m            s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   if (r.insert_length) {[m
[32m+[m[32m      // easy case: need to insert n characters[m
[32m+[m[32m      STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);[m
[32m+[m[32m      s->redo_char_point += r.insert_length;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   state->cursor = r.where + r.insert_length;[m
[32m+[m
[32m+[m[32m   s->undo_point++;[m
[32m+[m[32m   s->redo_point++;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)[m
[32m+[m[32m{[m
[32m+[m[32m   stb_text_createundo(&state->undostate, where, 0, length);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)[m
[32m+[m[32m{[m
[32m+[m[32m   int i;[m
[32m+[m[32m   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);[m
[32m+[m[32m   if (p) {[m
[32m+[m[32m      for (i=0; i < length; ++i)[m
[32m+[m[32m         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)[m
[32m+[m[32m{[m
[32m+[m[32m   int i;[m
[32m+[m[32m   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);[m
[32m+[m[32m   if (p) {[m
[32m+[m[32m      for (i=0; i < old_length; ++i)[m
[32m+[m[32m         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// reset the state to default[m
[32m+[m[32mstatic void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line)[m
[32m+[m[32m{[m
[32m+[m[32m   state->undostate.undo_point = 0;[m
[32m+[m[32m   state->undostate.undo_char_point = 0;[m
[32m+[m[32m   state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;[m
[32m+[m[32m   state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;[m
[32m+[m[32m   state->select_end = state->select_start = 0;[m
[32m+[m[32m   state->cursor = 0;[m
[32m+[m[32m   state->has_preferred_x = 0;[m
[32m+[m[32m   state->preferred_x = 0;[m
[32m+[m[32m   state->cursor_at_end_of_line = 0;[m
[32m+[m[32m   state->initialized = 1;[m
[32m+[m[32m   state->single_line = (unsigned char) is_single_line;[m
[32m+[m[32m   state->insert_mode = 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// API initialize[m
[32m+[m[32mstatic void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)[m
[32m+[m[32m{[m
[32m+[m[32m   stb_textedit_clear_state(state, is_single_line);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#if defined(__GNUC__) || defined(__clang__)[m
[32m+[m[32m#pragma GCC diagnostic push[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wcast-qual"[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32mstatic int stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE const *ctext, int len)[m
[32m+[m[32m{[m
[32m+[m[32m   return stb_textedit_paste_internal(str, state, (STB_TEXTEDIT_CHARTYPE *) ctext, len);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#if defined(__GNUC__) || defined(__clang__)[m
[32m+[m[32m#pragma GCC diagnostic pop[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif//STB_TEXTEDIT_IMPLEMENTATION[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m[32m------------------------------------------------------------------------------[m
[32m+[m[32mThis software is available under 2 licenses -- choose whichever you prefer.[m
[32m+[m[32m------------------------------------------------------------------------------[m
[32m+[m[32mALTERNATIVE A - MIT License[m
[32m+[m[32mCopyright (c) 2017 Sean Barrett[m
[32m+[m[32mPermission is hereby granted, free of charge, to any person obtaining a copy of[m[41m [m
[32m+[m[32mthis software and associated documentation files (the "Software"), to deal in[m[41m [m
[32m+[m[32mthe Software without restriction, including without limitation the rights to[m[41m [m
[32m+[m[32muse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies[m[41m [m
[32m+[m[32mof the Software, and to permit persons to whom the Software is furnished to do[m[41m [m
[32m+[m[32mso, subject to the following conditions:[m
[32m+[m[32mThe above copyright notice and this permission notice shall be included in all[m[41m [m
[32m+[m[32mcopies or substantial portions of the Software.[m
[32m+[m[32mTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR[m[41m [m
[32m+[m[32mIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,[m[41m [m
[32m+[m[32mFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE[m[41m [m
[32m+[m[32mAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER[m[41m [m
[32m+[m[32mLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,[m[41m [m
[32m+[m[32mOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE[m[41m [m
[32m+[m[32mSOFTWARE.[m
[32m+[m[32m------------------------------------------------------------------------------[m
[32m+[m[32mALTERNATIVE B - Public Domain (www.unlicense.org)[m
[32m+[m[32mThis is free and unencumbered software released into the public domain.[m
[32m+[m[32mAnyone is free to copy, modify, publish, use, compile, sell, or distribute this[m[41m [m
[32m+[m[32msoftware, either in source code form or as a compiled binary, for any purpose,[m[41m [m
[32m+[m[32mcommercial or non-commercial, and by any means.[m
[32m+[m[32mIn jurisdictions that recognize copyright laws, the author or authors of this[m[41m [m
[32m+[m[32msoftware dedicate any and all copyright interest in the software to the public[m[41m [m
[32m+[m[32mdomain. We make this dedication for the benefit of the public at large and to[m[41m [m
[32m+[m[32mthe detriment of our heirs and successors. We intend this dedication to be an[m[41m [m
[32m+[m[32movert act of relinquishment in perpetuity of all present and future rights to[m[41m [m
[32m+[m[32mthis software under copyright law.[m
[32m+[m[32mTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR[m[41m [m
[32m+[m[32mIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,[m[41m [m
[32m+[m[32mFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE[m[41m [m
[32m+[m[32mAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN[m[41m [m
[32m+[m[32mACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION[m[41m [m
[32m+[m[32mWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.[m
[32m+[m[32m------------------------------------------------------------------------------[m
[32m+[m[32m*/[m
[1mdiff --git a/vendor/source/ImGui/imstb_truetype.h b/vendor/source/ImGui/imstb_truetype.h[m
[1mnew file mode 100644[m
[1mindex 0000000..c1cdb18[m
[1m--- /dev/null[m
[1m+++ b/vendor/source/ImGui/imstb_truetype.h[m
[36m@@ -0,0 +1,4903 @@[m
[32m+[m[32m// [DEAR IMGUI][m[41m [m
[32m+[m[32m// This is a slightly modified version of stb_truetype.h 1.20.[m
[32m+[m[32m// Mostly fixing for compiler and static analyzer warnings.[m
[32m+[m[32m// Grep for [DEAR IMGUI] to find the changes.[m
[32m+[m
[32m+[m[32m// stb_truetype.h - v1.20 - public domain[m
[32m+[m[32m// authored from 2009-2016 by Sean Barrett / RAD Game Tools[m
[32m+[m[32m//[m
[32m+[m[32m//   This library processes TrueType files:[m
[32m+[m[32m//        parse files[m
[32m+[m[32m//        extract glyph metrics[m
[32m+[m[32m//        extract glyph shapes[m
[32m+[m[32m//        render glyphs to one-channel bitmaps with antialiasing (box filter)[m
[32m+[m[32m//        render glyphs to one-channel SDF bitmaps (signed-distance field/function)[m
[32m+[m[32m//[m
[32m+[m[32m//   Todo:[m
[32m+[m[32m//        non-MS cmaps[m
[32m+[m[32m//        crashproof on bad data[m
[32m+[m[32m//        hinting? (no longer patented)[m
[32m+[m[32m//        cleartype-style AA?[m
[32m+[m[32m//        optimize: use simple memory allocator for intermediates[m
[32m+[m[32m//        optimize: build edge-list directly from curves[m
[32m+[m[32m//        optimize: rasterize directly from curves?[m
[32m+[m[32m//[m
[32m+[m[32m// ADDITIONAL CONTRIBUTORS[m
[32m+[m[32m//[m
[32m+[m[32m//   Mikko Mononen: compound shape support, more cmap formats[m
[32m+[m[32m//   Tor Andersson: kerning, subpixel rendering[m
[32m+[m[32m//   Dougall Johnson: OpenType / Type 2 font handling[m
[32m+[m[32m//   Daniel Ribeiro Maciel: basic GPOS-based kerning[m
[32m+[m[32m//[m
[32m+[m[32m//   Misc other:[m
[32m+[m[32m//       Ryan Gordon[m
[32m+[m[32m//       Simon Glass[m
[32m+[m[32m//       github:IntellectualKitty[m
[32m+[m[32m//       Imanol Celaya[m
[32m+[m[32m//       Daniel Ribeiro Maciel[m
[32m+[m[32m//[m
[32m+[m[32m//   Bug/warning reports/fixes:[m
[32m+[m[32m//       "Zer" on mollyrocket       Fabian "ryg" Giesen[m
[32m+[m[32m//       Cass Everitt               Martins Mozeiko[m
[32m+[m[32m//       stoiko (Haemimont Games)   Cap Petschulat[m
[32m+[m[32m//       Brian Hook                 Omar Cornut[m
[32m+[m[32m//       Walter van Niftrik         github:aloucks[m
[32m+[m[32m//       David Gow                  Peter LaValle[m
[32m+[m[32m//       David Given                Sergey Popov[m
[32m+[m[32m//       Ivan-Assen Ivanov          Giumo X. Clanjor[m
[32m+[m[32m//       Anthony Pesch              Higor Euripedes[m
[32m+[m[32m//       Johan Duparc               Thomas Fields[m
[32m+[m[32m//       Hou Qiming                 Derek Vinyard[m
[32m+[m[32m//       Rob Loach                  Cort Stratton[m
[32m+[m[32m//       Kenney Phillis Jr.         github:oyvindjam[m
[32m+[m[32m//       Brian Costabile            github:vassvik[m
[32m+[m[32m//[m[41m       [m
[32m+[m[32m// VERSION HISTORY[m
[32m+[m[32m//[m
[32m+[m[32m//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()[m
[32m+[m[32m//   1.19 (2018-02-11) GPOS kerning, STBTT_fmod[m
[32m+[m[32m//   1.18 (2018-01-29) add missing function[m
[32m+[m[32m//   1.17 (2017-07-23) make more arguments const; doc fix[m
[32m+[m[32m//   1.16 (2017-07-12) SDF support[m
[32m+[m[32m//   1.15 (2017-03-03) make more arguments const[m
[32m+[m[32m//   1.14 (2017-01-16) num-fonts-in-TTC function[m
[32m+[m[32m//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts[m
[32m+[m[32m//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual[m
[32m+[m[32m//   1.11 (2016-04-02) fix unused-variable warning[m
[32m+[m[32m//   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef[m
[32m+[m[32m//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly[m
[32m+[m[32m//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges[m
[32m+[m[32m//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;[m
[32m+[m[32m//                     variant PackFontRanges to pack and render in separate phases;[m
[32m+[m[32m//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);[m
[32m+[m[32m//                     fixed an assert() bug in the new rasterizer[m
[32m+[m[32m//                     replace assert() with STBTT_assert() in new rasterizer[m
[32m+[m[32m//[m
[32m+[m[32m//   Full history can be found at the end of this file.[m
[32m+[m[32m//[m
[32m+[m[32m// LICENSE[m
[32m+[m[32m//[m
[32m+[m[32m//   See end of file for license information.[m
[32m+[m[32m//[m
[32m+[m[32m// USAGE[m
[32m+[m[32m//[m
[32m+[m[32m//   Include this file in whatever places need to refer to it. In ONE C/C++[m
[32m+[m[32m//   file, write:[m
[32m+[m[32m//      #define STB_TRUETYPE_IMPLEMENTATION[m
[32m+[m[32m//   before the #include of this file. This expands out the actual[m
[32m+[m[32m//   implementation into that C/C++ file.[m
[32m+[m[32m//[m
[32m+[m[32m//   To make the implementation private to the file that generates the implementation,[m
[32m+[m[32m//      #define STBTT_STATIC[m
[32m+[m[32m//[m
[32m+[m[32m//   Simple 3D API (don't ship this, but it's fine for tools and quick start)[m
[32m+[m[32m//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture[m
[32m+[m[32m//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char[m
[32m+[m[32m//[m
[32m+[m[32m//   Improved 3D API (more shippable):[m
[32m+[m[32m//           #include "stb_rect_pack.h"           -- optional, but you really want it[m
[32m+[m[32m//           stbtt_PackBegin()[m
[32m+[m[32m//           stbtt_PackSetOversampling()          -- for improved quality on small fonts[m
[32m+[m[32m//           stbtt_PackFontRanges()               -- pack and renders[m
[32m+[m[32m//           stbtt_PackEnd()[m
[32m+[m[32m//           stbtt_GetPackedQuad()[m
[32m+[m[32m//[m
[32m+[m[32m//   "Load" a font file from a memory buffer (you have to keep the buffer loaded)[m
[32m+[m[32m//           stbtt_InitFont()[m
[32m+[m[32m//           stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections[m
[32m+[m[32m//           stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections[m
[32m+[m[32m//[m
[32m+[m[32m//   Render a unicode codepoint to a bitmap[m
[32m+[m[32m//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap[m
[32m+[m[32m//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide[m
[32m+[m[32m//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be[m
[32m+[m[32m//[m
[32m+[m[32m//   Character advance/positioning[m
[32m+[m[32m//           stbtt_GetCodepointHMetrics()[m
[32m+[m[32m//           stbtt_GetFontVMetrics()[m
[32m+[m[32m//           stbtt_GetFontVMetricsOS2()[m
[32m+[m[32m//           stbtt_GetCodepointKernAdvance()[m
[32m+[m[32m//[m
[32m+[m[32m//   Starting with version 1.06, the rasterizer was replaced with a new,[m
[32m+[m[32m//   faster and generally-more-precise rasterizer. The new rasterizer more[m
[32m+[m[32m//   accurately measures pixel coverage for anti-aliasing, except in the case[m
[32m+[m[32m//   where multiple shapes overlap, in which case it overestimates the AA pixel[m
[32m+[m[32m//   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If[m
[32m+[m[32m//   this turns out to be a problem, you can re-enable the old rasterizer with[m
[32m+[m[32m//        #define STBTT_RASTERIZER_VERSION 1[m
[32m+[m[32m//   which will incur about a 15% speed hit.[m
[32m+[m[32m//[m
[32m+[m[32m// ADDITIONAL DOCUMENTATION[m
[32m+[m[32m//[m
[32m+[m[32m//   Immediately after this block comment are a series of sample programs.[m
[32m+[m[32m//[m
[32m+[m[32m//   After the sample programs is the "header file" section. This section[m
[32m+[m[32m//   includes documentation for each API function.[m
[32m+[m[32m//[m
[32m+[m[32m//   Some important concepts to understand to use this library:[m
[32m+[m[32m//[m
[32m+[m[32m//      Codepoint[m
[32m+[m[32m//         Characters are defined by unicode codepoints, e.g. 65 is[m
[32m+[m[32m//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is[m
[32m+[m[32m//         the hiragana for "ma".[m
[32m+[m[32m//[m
[32m+[m[32m//      Glyph[m
[32m+[m[32m//         A visual character shape (every codepoint is rendered as[m
[32m+[m[32m//         some glyph)[m
[32m+[m[32m//[m
[32m+[m[32m//      Glyph index[m
[32m+[m[32m//         A font-specific integer ID representing a glyph[m
[32m+[m[32m//[m
[32m+[m[32m//      Baseline[m
[32m+[m[32m//         Glyph shapes are defined relative to a baseline, which is the[m
[32m+[m[32m//         bottom of uppercase characters. Characters extend both above[m
[32m+[m[32m//         and below the baseline.[m
[32m+[m[32m//[m
[32m+[m[32m//      Current Point[m
[32m+[m[32m//         As you draw text to the screen, you keep track of a "current point"[m
[32m+[m[32m//         which is the origin of each character. The current point's vertical[m
[32m+[m[32m//         position is the baseline. Even "baked fonts" use this model.[m
[32m+[m[32m//[m
[32m+[m[32m//      Vertical Font Metrics[m
[32m+[m[32m//         The vertical qualities of the font, used to vertically position[m
[32m+[m[32m//         and space the characters. See docs for stbtt_GetFontVMetrics.[m
[32m+[m[32m//[m
[32m+[m[32m//      Font Size in Pixels or Points[m
[32m+[m[32m//         The preferred interface for specifying font sizes in stb_truetype[m
[32m+[m[32m//         is to specify how tall the font's vertical extent should be in pixels.[m
[32m+[m[32m//         If that sounds good enough, skip the next paragraph.[m
[32m+[m[32m//[m
[32m+[m[32m//         Most font APIs instead use "points", which are a common typographic[m
[32m+[m[32m//         measurement for describing font size, defined as 72 points per inch.[m
[32m+[m[32m//         stb_truetype provides a point API for compatibility. However, true[m
[32m+[m[32m//         "per inch" conventions don't make much sense on computer displays[m
[32m+[m[32m//         since different monitors have different number of pixels per[m
[32m+[m[32m//         inch. For example, Windows traditionally uses a convention that[m
[32m+[m[32m//         there are 96 pixels per inch, thus making 'inch' measurements have[m
[32m+[m[32m//         nothing to do with inches, and thus effectively defining a point to[m
[32m+[m[32m//         be 1.333 pixels. Additionally, the TrueType font data provides[m
[32m+[m[32m//         an explicit scale factor to scale a given font's glyphs to points,[m
[32m+[m[32m//         but the author has observed that this scale factor is often wrong[m
[32m+[m[32m//         for non-commercial fonts, thus making fonts scaled in points[m
[32m+[m[32m//         according to the TrueType spec incoherently sized in practice.[m
[32m+[m[32m//[m
[32m+[m[32m// DETAILED USAGE:[m
[32m+[m[32m//[m
[32m+[m[32m//  Scale:[m
[32m+[m[32m//    Select how high you want the font to be, in points or pixels.[m
[32m+[m[32m//    Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute[m
[32m+[m[32m//    a scale factor SF that will be used by all other functions.[m
[32m+[m[32m//[m
[32m+[m[32m//  Baseline:[m
[32m+[m[32m//    You need to select a y-coordinate that is the baseline of where[m
[32m+[m[32m//    your text will appear. Call GetFontBoundingBox to get the baseline-relative[m
[32m+[m[32m//    bounding box for all characters. SF*-y0 will be the distance in pixels[m
[32m+[m[32m//    that the worst-case character could extend above the baseline, so if[m
[32m+[m[32m//    you want the top edge of characters to appear at the top of the[m
[32m+[m[32m//    screen where y=0, then you would set the baseline to SF*-y0.[m
[32m+[m[32m//[m
[32m+[m[32m//  Current point:[m
[32m+[m[32m//    Set the current point where the first character will appear. The[m
[32m+[m[32m//    first character could extend left of the current point; this is font[m
[32m+[m[32m//    dependent. You can either choose a current point that is the leftmost[m
[32m+[m[32m//    point and hope, or add some padding, or check the bounding box or[m
[32m+[m[32m//    left-side-bearing of the first character to be displayed and set[m
[32m+[m[32m//    the current point based on that.[m
[32m+[m[32m//[m
[32m+[m[32m//  Displaying a character:[m
[32m+[m[32m//    Compute the bounding box of the character. It will contain signed values[m
[32m+[m[32m//    relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1,[m
[32m+[m[32m//    then the character should be displayed in the rectangle from[m
[32m+[m[32m//    <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1).[m
[32m+[m[32m//[m
[32m+[m[32m//  Advancing for the next character:[m
[32m+[m[32m//    Call GlyphHMetrics, and compute 'current_point += SF * advance'.[m
[32m+[m[32m//[m[41m [m
[32m+[m[32m//[m
[32m+[m[32m// ADVANCED USAGE[m
[32m+[m[32m//[m
[32m+[m[32m//   Quality:[m
[32m+[m[32m//[m
[32m+[m[32m//    - Use the functions with Subpixel at the end to allow your characters[m
[32m+[m[32m//      to have subpixel positioning. Since the font is anti-aliased, not[m
[32m+[m[32m//      hinted, this is very import for quality. (This is not possible with[m
[32m+[m[32m//      baked fonts.)[m
[32m+[m[32m//[m
[32m+[m[32m//    - Kerning is now supported, and if you're supporting subpixel rendering[m
[32m+[m[32m//      then kerning is worth using to give your text a polished look.[m
[32m+[m[32m//[m
[32m+[m[32m//   Performance:[m
[32m+[m[32m//[m
[32m+[m[32m//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;[m
[32m+[m[32m//      if you don't do this, stb_truetype is forced to do the conversion on[m
[32m+[m[32m//      every call.[m
[32m+[m[32m//[m
[32m+[m[32m//    - There are a lot of memory allocations. We should modify it to take[m
[32m+[m[32m//      a temp buffer and allocate from the temp buffer (without freeing),[m
[32m+[m[32m//      should help performance a lot.[m
[32m+[m[32m//[m
[32m+[m[32m// NOTES[m
[32m+[m[32m//[m
[32m+[m[32m//   The system uses the raw data found in the .ttf file without changing it[m
[32m+[m[32m//   and without building auxiliary data structures. This is a bit inefficient[m
[32m+[m[32m//   on little-endian systems (the data is big-endian), but assuming you're[m
[32m+[m[32m//   caching the bitmaps or glyph shapes this shouldn't be a big deal.[m
[32m+[m[32m//[m
[32m+[m[32m//   It appears to be very hard to programmatically determine what font a[m
[32m+[m[32m//   given file is in a general way. I provide an API for this, but I don't[m
[32m+[m[32m//   recommend it.[m
[32m+[m[32m//[m
[32m+[m[32m//[m
[32m+[m[32m// SOURCE STATISTICS (based on v0.6c, 2050 LOC)[m
[32m+[m[32m//[m
[32m+[m[32m//   Documentation & header file        520 LOC  \___ 660 LOC documentation[m
[32m+[m[32m//   Sample code                        140 LOC  /[m
[32m+[m[32m//   Truetype parsing                   620 LOC  ---- 620 LOC TrueType[m
[32m+[m[32m//   Software rasterization             240 LOC  \.[m
[32m+[m[32m//   Curve tessellation                 120 LOC   \__ 550 LOC Bitmap creation[m
[32m+[m[32m//   Bitmap management                  100 LOC   /[m
[32m+[m[32m//   Baked bitmap interface              70 LOC  /[m
[32m+[m[32m//   Font name matching & access        150 LOC  ---- 150[m[41m [m
[32m+[m[32m//   C runtime library abstraction       60 LOC  ----  60[m
[32m+[m[32m//[m
[32m+[m[32m//[m
[32m+[m[32m// PERFORMANCE MEASUREMENTS FOR 1.06:[m
[32m+[m[32m//[m
[32m+[m[32m//                      32-bit     64-bit[m
[32m+[m[32m//   Previous release:  8.83 s     7.68 s[m
[32m+[m[32m//   Pool allocations:  7.72 s     6.34 s[m
[32m+[m[32m//   Inline sort     :  6.54 s     5.65 s[m
[32m+[m[32m//   New rasterizer  :  5.63 s     5.00 s[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m////[m
[32m+[m[32m////  SAMPLE PROGRAMS[m
[32m+[m[32m////[m
[32m+[m[32m//[m
[32m+[m[32m//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless[m
[32m+[m[32m//[m
[32m+[m[32m#if 0[m
[32m+[m[32m#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation[m
[32m+[m[32m#include "stb_truetype.h"[m
[32m+[m
[32m+[m[32munsigned char ttf_buffer[1<<20];[m
[32m+[m[32munsigned char temp_bitmap[512*512];[m
[32m+[m
[32m+[m[32mstbtt_bakedchar cdata[96]; // ASCII 32..126 is 95 glyphs[m
[32m+[m[32mGLuint ftex;[m
[32m+[m
[32m+[m[32mvoid my_stbtt_initfont(void)[m
[32m+[m[32m{[m
[32m+[m[32m   fread(ttf_buffer, 1, 1<<20, fopen("c:/windows/fonts/times.ttf", "rb"));[m
[32m+[m[32m   stbtt_BakeFontBitmap(ttf_buffer,0, 32.0, temp_bitmap,512,512, 32,96, cdata); // no guarantee this fits![m
[32m+[m[32m   // can free ttf_buffer at this point[m
[32m+[m[32m   glGenTextures(1, &ftex);[m
[32m+[m[32m   glBindTexture(GL_TEXTURE_2D, ftex);[m
[32m+[m[32m   glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512,512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);[m
[32m+[m[32m   // can free temp_bitmap at this point[m
[32m+[m[32m   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid my_stbtt_print(float x, float y, char *text)[m
[32m+[m[32m{[m
[32m+[m[32m   // assume orthographic projection with units = screen pixels, origin at top left[m
[32m+[m[32m   glEnable(GL_TEXTURE_2D);[m
[32m+[m[32m   glBindTexture(GL_TEXTURE_2D, ftex);[m
[32m+[m[32m   glBegin(GL_QUADS);[m
[32m+[m[32m   while (*text) {[m
[32m+[m[32m      if (*text >= 32 && *text < 128) {[m
[32m+[m[32m         stbtt_aligned_quad q;[m
[32m+[m[32m         stbtt_GetBakedQuad(cdata, 512,512, *text-32, &x,&y,&q,1);//1=opengl & d3d10+,0=d3d9[m
[32m+[m[32m         glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y0);[m
[32m+[m[32m         glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y0);[m
[32m+[m[32m         glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y1);[m
[32m+[m[32m         glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y1);[m
[32m+[m[32m      }[m
[32m+[m[32m      ++text;[m
[32m+[m[32m   }[m
[32m+[m[32m   glEnd();[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m[32m//[m
[32m+[m[32m//[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// Complete program (this compiles): get a single bitmap, print as ASCII art[m
[32m+[m[32m//[m
[32m+[m[32m#if 0[m
[32m+[m[32m#include <stdio.h>[m
[32m+[m[32m#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation[m
[32m+[m[32m#include "stb_truetype.h"[m
[32m+[m
[32m+[m[32mchar ttf_buffer[1<<25];[m
[32m+[m
[32m+[m[32mint main(int argc, char **argv)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_fontinfo font;[m
[32m+[m[32m   unsigned char *bitmap;[m
[32m+[m[32m   int w,h,i,j,c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);[m
[32m+[m
[32m+[m[32m   fread(ttf_buffer, 1, 1<<25, fopen(argc > 3 ? argv[3] : "c:/windows/fonts/arialbd.ttf", "rb"));[m
[32m+[m
[32m+[m[32m   stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer,0));[m
[32m+[m[32m   bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0,0);[m
[32m+[m
[32m+[m[32m   for (j=0; j < h; ++j) {[m
[32m+[m[32m      for (i=0; i < w; ++i)[m
[32m+[m[32m         putchar(" .:ioVM@"[bitmap[j*w+i]>>5]);[m
[32m+[m[32m      putchar('\n');[m
[32m+[m[32m   }[m
[32m+[m[32m   return 0;[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m[41m [m
[32m+[m[32m//[m
[32m+[m[32m// Output:[m
[32m+[m[32m//[m
[32m+[m[32m//     .ii.[m
[32m+[m[32m//    @@@@@@.[m
[32m+[m[32m//   V@Mio@@o[m
[32m+[m[32m//   :i.  V@V[m
[32m+[m[32m//     :oM@@M[m
[32m+[m[32m//   :@@@MM@M[m
[32m+[m[32m//   @@o  o@M[m
[32m+[m[32m//  :@@.  M@M[m
[32m+[m[32m//   @@@o@@@@[m
[32m+[m[32m//   :M@@V:@@.[m
[32m+[m[32m//[m[41m  [m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m[41m [m
[32m+[m[32m// Complete program: print "Hello World!" banner, with bugs[m
[32m+[m[32m//[m
[32m+[m[32m#if 0[m
[32m+[m[32mchar buffer[24<<20];[m
[32m+[m[32munsigned char screen[20][79];[m
[32m+[m
[32m+[m[32mint main(int arg, char **argv)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_fontinfo font;[m
[32m+[m[32m   int i,j,ascent,baseline,ch=0;[m
[32m+[m[32m   float scale, xpos=2; // leave a little padding in case the character extends left[m
[32m+[m[32m   char *text = "Heljo World!"; // intentionally misspelled to show 'lj' brokenness[m
[32m+[m
[32m+[m[32m   fread(buffer, 1, 1000000, fopen("c:/windows/fonts/arialbd.ttf", "rb"));[m
[32m+[m[32m   stbtt_InitFont(&font, buffer, 0);[m
[32m+[m
[32m+[m[32m   scale = stbtt_ScaleForPixelHeight(&font, 15);[m
[32m+[m[32m   stbtt_GetFontVMetrics(&font, &ascent,0,0);[m
[32m+[m[32m   baseline = (int) (ascent*scale);[m
[32m+[m
[32m+[m[32m   while (text[ch]) {[m
[32m+[m[32m      int advance,lsb,x0,y0,x1,y1;[m
[32m+[m[32m      float x_shift = xpos - (float) floor(xpos);[m
[32m+[m[32m      stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);[m
[32m+[m[32m      stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale,scale,x_shift,0, &x0,&y0,&x1,&y1);[m
[32m+[m[32m      stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int) xpos + x0], x1-x0,y1-y0, 79, scale,scale,x_shift,0, text[ch]);[m
[32m+[m[32m      // note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong[m
[32m+[m[32m      // because this API is really for baking character bitmaps into textures. if you want to render[m
[32m+[m[32m      // a sequence of characters, you really need to render each bitmap to a temp buffer, then[m
[32m+[m[32m      // "alpha blend" that into the working buffer[m
[32m+[m[32m      xpos += (advance * scale);[m
[32m+[m[32m      if (text[ch+1])[m
[32m+[m[32m         xpos += scale*stbtt_GetCodepointKernAdvance(&font, text[ch],text[ch+1]);[m
[32m+[m[32m      ++ch;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   for (j=0; j < 20; ++j) {[m
[32m+[m[32m      for (i=0; i < 78; ++i)[m
[32m+[m[32m         putchar(" .:ioVM@"[screen[j][i]>>5]);[m
[32m+[m[32m      putchar('\n');[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   return 0;[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m////[m
[32m+[m[32m////   INTEGRATION WITH YOUR CODEBASE[m
[32m+[m[32m////[m
[32m+[m[32m////   The following sections allow you to supply alternate definitions[m
[32m+[m[32m////   of C library functions used by stb_truetype, e.g. if you don't[m
[32m+[m[32m////   link with the C runtime library.[m
[32m+[m
[32m+[m[32m#ifdef STB_TRUETYPE_IMPLEMENTATION[m
[32m+[m[32m   // #define your own (u)stbtt_int8/16/32 before including to override this[m
[32m+[m[32m   #ifndef stbtt_uint8[m
[32m+[m[32m   typedef unsigned char   stbtt_uint8;[m
[32m+[m[32m   typedef signed   char   stbtt_int8;[m
[32m+[m[32m   typedef unsigned short  stbtt_uint16;[m
[32m+[m[32m   typedef signed   short  stbtt_int16;[m
[32m+[m[32m   typedef unsigned int    stbtt_uint32;[m
[32m+[m[32m   typedef signed   int    stbtt_int32;[m
[32m+[m[32m   #endif[m
[32m+[m
[32m+[m[32m   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];[m
[32m+[m[32m   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];[m
[32m+[m
[32m+[m[32m   // e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h[m
[32m+[m[32m   #ifndef STBTT_ifloor[m
[32m+[m[32m   #include <math.h>[m
[32m+[m[32m   #define STBTT_ifloor(x)   ((int) floor(x))[m
[32m+[m[32m   #define STBTT_iceil(x)    ((int) ceil(x))[m
[32m+[m[32m   #endif[m
[32m+[m
[32m+[m[32m   #ifndef STBTT_sqrt[m
[32m+[m[32m   #include <math.h>[m
[32m+[m[32m   #define STBTT_sqrt(x)      sqrt(x)[m
[32m+[m[32m   #define STBTT_pow(x,y)     pow(x,y)[m
[32m+[m[32m   #endif[m
[32m+[m
[32m+[m[32m   #ifndef STBTT_fmod[m
[32m+[m[32m   #include <math.h>[m
[32m+[m[32m   #define STBTT_fmod(x,y)    fmod(x,y)[m
[32m+[m[32m   #endif[m
[32m+[m
[32m+[m[32m   #ifndef STBTT_cos[m
[32m+[m[32m   #include <math.h>[m
[32m+[m[32m   #define STBTT_cos(x)       cos(x)[m
[32m+[m[32m   #define STBTT_acos(x)      acos(x)[m
[32m+[m[32m   #endif[m
[32m+[m
[32m+[m[32m   #ifndef STBTT_fabs[m
[32m+[m[32m   #include <math.h>[m
[32m+[m[32m   #define STBTT_fabs(x)      fabs(x)[m
[32m+[m[32m   #endif[m
[32m+[m
[32m+[m[32m   // #define your own functions "STBTT_malloc" / "STBTT_free" to avoid malloc.h[m
[32m+[m[32m   #ifndef STBTT_malloc[m
[32m+[m[32m   #include <stdlib.h>[m
[32m+[m[32m   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))[m
[32m+[m[32m   #define STBTT_free(x,u)    ((void)(u),free(x))[m
[32m+[m[32m   #endif[m
[32m+[m
[32m+[m[32m   #ifndef STBTT_assert[m
[32m+[m[32m   #include <assert.h>[m
[32m+[m[32m   #define STBTT_assert(x)    assert(x)[m
[32m+[m[32m   #endif[m
[32m+[m
[32m+[m[32m   #ifndef STBTT_strlen[m
[32m+[m[32m   #include <string.h>[m
[32m+[m[32m   #define STBTT_strlen(x)    strlen(x)[m
[32m+[m[32m   #endif[m
[32m+[m
[32m+[m[32m   #ifndef STBTT_memcpy[m
[32m+[m[32m   #include <string.h>[m
[32m+[m[32m   #define STBTT_memcpy       memcpy[m
[32m+[m[32m   #define STBTT_memset       memset[m
[32m+[m[32m   #endif[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m///////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m///////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m////[m
[32m+[m[32m////   INTERFACE[m
[32m+[m[32m////[m
[32m+[m[32m////[m
[32m+[m
[32m+[m[32m#ifndef __STB_INCLUDE_STB_TRUETYPE_H__[m
[32m+[m[32m#define __STB_INCLUDE_STB_TRUETYPE_H__[m
[32m+[m
[32m+[m[32m#ifdef STBTT_STATIC[m
[32m+[m[32m#define STBTT_DEF static[m
[32m+[m[32m#else[m
[32m+[m[32m#define STBTT_DEF extern[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32mextern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m// private structure[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m   unsigned char *data;[m
[32m+[m[32m   int cursor;[m
[32m+[m[32m   int size;[m
[32m+[m[32m} stbtt__buf;[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// TEXTURE BAKING API[m
[32m+[m[32m//[m
[32m+[m[32m// If you use this API, you only have to call two functions ever.[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap[m
[32m+[m[32m   float xoff,yoff,xadvance;[m
[32m+[m[32m} stbtt_bakedchar;[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)[m
[32m+[m[32m                                float pixel_height,                     // height of font in pixels[m
[32m+[m[32m                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in[m
[32m+[m[32m                                int first_char, int num_chars,          // characters to bake[m
[32m+[m[32m                                stbtt_bakedchar *chardata);             // you allocate this, it's num_chars long[m
[32m+[m[32m// if return is positive, the first unused row of the bitmap[m
[32m+[m[32m// if return is negative, returns the negative of the number of characters that fit[m
[32m+[m[32m// if return is 0, no characters fit and no rows were used[m
[32m+[m[32m// This uses a very crappy packing.[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m   float x0,y0,s0,t0; // top-left[m
[32m+[m[32m   float x1,y1,s1,t1; // bottom-right[m
[32m+[m[32m} stbtt_aligned_quad;[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph,  // same data as above[m
[32m+[m[32m                               int char_index,             // character to display[m
[32m+[m[32m                               float *xpos, float *ypos,   // pointers to current position in screen pixel space[m
[32m+[m[32m                               stbtt_aligned_quad *q,      // output: quad to draw[m
[32m+[m[32m                               int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier[m
[32m+[m[32m// Call GetBakedQuad with char_index = 'character - first_char', and it[m
[32m+[m[32m// creates the quad you need to draw and advances the current position.[m
[32m+[m[32m//[m
[32m+[m[32m// The coordinate system used assumes y increases downwards.[m
[32m+[m[32m//[m
[32m+[m[32m// Characters will extend both above and below the current position;[m
[32m+[m[32m// see discussion of "BASELINE" above.[m
[32m+[m[32m//[m
[32m+[m[32m// It's inefficient; you might want to c&p it and optimize it.[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap);[m
[32m+[m[32m// Query the font vertical metrics without having to create a font first.[m
[32m+[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// NEW TEXTURE BAKING API[m
[32m+[m[32m//[m
[32m+[m[32m// This provides options for packing multiple fonts into one atlas, not[m
[32m+[m[32m// perfectly but better than nothing.[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap[m
[32m+[m[32m   float xoff,yoff,xadvance;[m
[32m+[m[32m   float xoff2,yoff2;[m
[32m+[m[32m} stbtt_packedchar;[m
[32m+[m
[32m+[m[32mtypedef struct stbtt_pack_context stbtt_pack_context;[m
[32m+[m[32mtypedef struct stbtt_fontinfo stbtt_fontinfo;[m
[32m+[m[32m#ifndef STB_RECT_PACK_VERSION[m
[32m+[m[32mtypedef struct stbrp_rect stbrp_rect;[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32mSTBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);[m
[32m+[m[32m// Initializes a packing context stored in the passed-in stbtt_pack_context.[m
[32m+[m[32m// Future calls using this context will pack characters into the bitmap passed[m
[32m+[m[32m// in here: a 1-channel bitmap that is width * height. stride_in_bytes is[m
[32m+[m[32m// the distance from one row to the next (or 0 to mean they are packed tightly[m
[32m+[m[32m// together). "padding" is the amount of padding to leave between each[m
[32m+[m[32m// character (normally you want '1' for bitmaps you'll use as textures with[m
[32m+[m[32m// bilinear filtering).[m
[32m+[m[32m//[m
[32m+[m[32m// Returns 0 on failure, 1 on success.[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);[m
[32m+[m[32m// Cleans up the packing context and frees all memory.[m
[32m+[m
[32m+[m[32m#define STBTT_POINT_SIZE(x)   (-(x))[m
[32m+[m
[32m+[m[32mSTBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,[m
[32m+[m[32m                                int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);[m
[32m+[m[32m// Creates character bitmaps from the font_index'th font found in fontdata (use[m
[32m+[m[32m// font_index=0 if you don't know what that is). It creates num_chars_in_range[m
[32m+[m[32m// bitmaps for characters with unicode values starting at first_unicode_char_in_range[m
[32m+[m[32m// and increasing. Data for how to render them is stored in chardata_for_range;[m
[32m+[m[32m// pass these to stbtt_GetPackedQuad to get back renderable quads.[m
[32m+[m[32m//[m
[32m+[m[32m// font_size is the full height of the character from ascender to descender,[m
[32m+[m[32m// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed[m
[32m+[m[32m// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()[m
[32m+[m[32m// and pass that result as 'font_size':[m
[32m+[m[32m//       ...,                  20 , ... // font max minus min y is 20 pixels tall[m
[32m+[m[32m//       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m   float font_size;[m
[32m+[m[32m   int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint[m
[32m+[m[32m   int *array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints[m
[32m+[m[32m   int num_chars;[m
[32m+[m[32m   stbtt_packedchar *chardata_for_range; // output[m
[32m+[m[32m   unsigned char h_oversample, v_oversample; // don't set these, they're used internally[m
[32m+[m[32m} stbtt_pack_range;[m
[32m+[m
[32m+[m[32mSTBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);[m
[32m+[m[32m// Creates character bitmaps from multiple ranges of characters stored in[m
[32m+[m[32m// ranges. This will usually create a better-packed bitmap than multiple[m
[32m+[m[32m// calls to stbtt_PackFontRange. Note that you can call this multiple[m
[32m+[m[32m// times within a single PackBegin/PackEnd.[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);[m
[32m+[m[32m// Oversampling a font increases the quality by allowing higher-quality subpixel[m
[32m+[m[32m// positioning, and is especially valuable at smaller text sizes.[m
[32m+[m[32m//[m
[32m+[m[32m// This function sets the amount of oversampling for all following calls to[m
[32m+[m[32m// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given[m
[32m+[m[32m// pack context. The default (no oversampling) is achieved by h_oversample=1[m
[32m+[m[32m// and v_oversample=1. The total number of pixels required is[m
[32m+[m[32m// h_oversample*v_oversample larger than the default; for example, 2x2[m
[32m+[m[32m// oversampling requires 4x the storage of 1x1. For best results, render[m
[32m+[m[32m// oversampled textures with bilinear filtering. Look at the readme in[m
[32m+[m[32m// stb/tests/oversample for information about oversampled fonts[m
[32m+[m[32m//[m
[32m+[m[32m// To use with PackFontRangesGather etc., you must set it before calls[m
[32m+[m[32m// call to PackFontRangesGatherRects.[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip);[m
[32m+[m[32m// If skip != 0, this tells stb_truetype to skip any codepoints for which[m
[32m+[m[32m// there is no corresponding glyph. If skip=0, which is the default, then[m
[32m+[m[32m// codepoints without a glyph recived the font's "missing character" glyph,[m
[32m+[m[32m// typically an empty box by convention.[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph,  // same data as above[m
[32m+[m[32m                               int char_index,             // character to display[m
[32m+[m[32m                               float *xpos, float *ypos,   // pointers to current position in screen pixel space[m
[32m+[m[32m                               stbtt_aligned_quad *q,      // output: quad to draw[m
[32m+[m[32m                               int align_to_integer);[m
[32m+[m
[32m+[m[32mSTBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);[m
[32m+[m[32mSTBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);[m
[32m+[m[32mSTBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);[m
[32m+[m[32m// Calling these functions in sequence is roughly equivalent to calling[m
[32m+[m[32m// stbtt_PackFontRanges(). If you more control over the packing of multiple[m
[32m+[m[32m// fonts, or if you want to pack custom data into a font texture, take a look[m
[32m+[m[32m// at the source to of stbtt_PackFontRanges() and create a custom version[m[41m [m
[32m+[m[32m// using these functions, e.g. call GatherRects multiple times,[m
[32m+[m[32m// building up a single array of rects, then call PackRects once,[m
[32m+[m[32m// then call RenderIntoRects repeatedly. This may result in a[m
[32m+[m[32m// better packing than calling PackFontRanges multiple times[m
[32m+[m[32m// (or it may not).[m
[32m+[m
[32m+[m[32m// this is an opaque structure that you shouldn't mess with which holds[m
[32m+[m[32m// all the context needed from PackBegin to PackEnd.[m
[32m+[m[32mstruct stbtt_pack_context {[m
[32m+[m[32m   void *user_allocator_context;[m
[32m+[m[32m   void *pack_info;[m
[32m+[m[32m   int   width;[m
[32m+[m[32m   int   height;[m
[32m+[m[32m   int   stride_in_bytes;[m
[32m+[m[32m   int   padding;[m
[32m+[m[32m   int   skip_missing;[m
[32m+[m[32m   unsigned int   h_oversample, v_oversample;[m
[32m+[m[32m   unsigned char *pixels;[m
[32m+[m[32m   void  *nodes;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// FONT LOADING[m
[32m+[m[32m//[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);[m
[32m+[m[32m// This function will determine the number of fonts in a font file.  TrueType[m
[32m+[m[32m// collection (.ttc) files may contain multiple fonts, while TrueType font[m
[32m+[m[32m// (.ttf) files only contain one font. The number of fonts can be used for[m
[32m+[m[32m// indexing with the previous function where the index is between zero and one[m
[32m+[m[32m// less than the total fonts. If an error occurs, -1 is returned.[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);[m
[32m+[m[32m// Each .ttf/.ttc file may have more than one font. Each font has a sequential[m
[32m+[m[32m// index number starting from 0. Call this function to get the font offset for[m
[32m+[m[32m// a given index; it returns -1 if the index is out of range. A regular .ttf[m
[32m+[m[32m// file will only define one font and it always be at offset 0, so it will[m
[32m+[m[32m// return '0' for index 0, and -1 for all other indices.[m
[32m+[m
[32m+[m[32m// The following structure is defined publicly so you can declare one on[m
[32m+[m[32m// the stack or as a global or etc, but you should treat it as opaque.[m
[32m+[m[32mstruct stbtt_fontinfo[m
[32m+[m[32m{[m
[32m+[m[32m   void           * userdata;[m
[32m+[m[32m   unsigned char  * data;              // pointer to .ttf file[m
[32m+[m[32m   int              fontstart;         // offset of start of font[m
[32m+[m
[32m+[m[32m   int numGlyphs;                     // number of glyphs, needed for range checking[m
[32m+[m
[32m+[m[32m   int loca,head,glyf,hhea,hmtx,kern,gpos; // table locations as offset from start of .ttf[m
[32m+[m[32m   int index_map;                     // a cmap mapping for our chosen character encoding[m
[32m+[m[32m   int indexToLocFormat;              // format needed to map from glyph index to glyph[m
[32m+[m
[32m+[m[32m   stbtt__buf cff;                    // cff font data[m
[32m+[m[32m   stbtt__buf charstrings;            // the charstring index[m
[32m+[m[32m   stbtt__buf gsubrs;                 // global charstring subroutines index[m
[32m+[m[32m   stbtt__buf subrs;                  // private charstring subroutines index[m
[32m+[m[32m   stbtt__buf fontdicts;              // array of font dicts[m
[32m+[m[32m   stbtt__buf fdselect;               // map from glyph to fontdict[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);[m
[32m+[m[32m// Given an offset into the file that defines a font, this function builds[m
[32m+[m[32m// the necessary cached info for the rest of the system. You must allocate[m
[32m+[m[32m// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't[m
[32m+[m[32m// need to do anything special to free it, because the contents are pure[m
[32m+[m[32m// value data with no additional data structures. Returns 0 on failure.[m
[32m+[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// CHARACTER TO GLYPH-INDEX CONVERSIOn[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);[m
[32m+[m[32m// If you're going to perform multiple operations on the same character[m
[32m+[m[32m// and you want a speed-up, call this function with the character you're[m
[32m+[m[32m// going to process, then use glyph-based functions instead of the[m
[32m+[m[32m// codepoint-based functions.[m
[32m+[m[32m// Returns 0 if the character codepoint is not defined in the font.[m
[32m+[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// CHARACTER PROPERTIES[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32mSTBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);[m
[32m+[m[32m// computes a scale factor to produce a font whose "height" is 'pixels' tall.[m
[32m+[m[32m// Height is measured as the distance from the highest ascender to the lowest[m
[32m+[m[32m// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics[m
[32m+[m[32m// and computing:[m
[32m+[m[32m//       scale = pixels / (ascent - descent)[m
[32m+[m[32m// so if you prefer to measure height by the ascent only, use a similar calculation.[m
[32m+[m
[32m+[m[32mSTBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);[m
[32m+[m[32m// computes a scale factor to produce a font whose EM size is mapped to[m
[32m+[m[32m// 'pixels' tall. This is probably what traditional APIs compute, but[m
[32m+[m[32m// I'm not positive.[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);[m
[32m+[m[32m// ascent is the coordinate above the baseline the font extends; descent[m
[32m+[m[32m// is the coordinate below the baseline the font extends (i.e. it is typically negative)[m
[32m+[m[32m// lineGap is the spacing between one row's descent and the next row's ascent...[m
[32m+[m[32m// so you should advance the vertical position by "*ascent - *descent + *lineGap"[m
[32m+[m[32m//   these are expressed in unscaled coordinates, so you must multiply by[m
[32m+[m[32m//   the scale factor for a given size[m
[32m+[m
[32m+[m[32mSTBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap);[m
[32m+[m[32m// analogous to GetFontVMetrics, but returns the "typographic" values from the OS/2[m
[32m+[m[32m// table (specific to MS/Windows TTF files).[m
[32m+[m[32m//[m
[32m+[m[32m// Returns 1 on success (table present), 0 on failure.[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);[m
[32m+[m[32m// the bounding box around all possible characters[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);[m
[32m+[m[32m// leftSideBearing is the offset from the current horizontal position to the left edge of the character[m
[32m+[m[32m// advanceWidth is the offset from the current horizontal position to the next horizontal position[m
[32m+[m[32m//   these are expressed in unscaled coordinates[m
[32m+[m
[32m+[m[32mSTBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);[m
[32m+[m[32m// an additional amount to add to the 'advance' value between ch1 and ch2[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);[m
[32m+[m[32m// Gets the bounding box of the visible part of the glyph, in unscaled coordinates[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);[m
[32m+[m[32mSTBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);[m
[32m+[m[32mSTBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);[m
[32m+[m[32m// as above, but takes one or more glyph indices for greater efficiency[m
[32m+[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// GLYPH SHAPES (you probably don't need these, but they have to go before[m
[32m+[m[32m// the bitmaps for C declaration-order reasons)[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32m#ifndef STBTT_vmove // you can predefine these to use different values (but why?)[m
[32m+[m[32m   enum {[m
[32m+[m[32m      STBTT_vmove=1,[m
[32m+[m[32m      STBTT_vline,[m
[32m+[m[32m      STBTT_vcurve,[m
[32m+[m[32m      STBTT_vcubic[m
[32m+[m[32m   };[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifndef stbtt_vertex // you can predefine this to use different values[m
[32m+[m[32m                   // (we share this with other code at RAD)[m
[32m+[m[32m   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file[m
[32m+[m[32m   typedef struct[m
[32m+[m[32m   {[m
[32m+[m[32m      stbtt_vertex_type x,y,cx,cy,cx1,cy1;[m
[32m+[m[32m      unsigned char type,padding;[m
[32m+[m[32m   } stbtt_vertex;[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);[m
[32m+[m[32m// returns non-zero if nothing is drawn for this glyph[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);[m
[32m+[m[32mSTBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);[m
[32m+[m[32m// returns # of vertices and fills *vertices with the pointer to them[m
[32m+[m[32m//   these are expressed in "unscaled" coordinates[m
[32m+[m[32m//[m
[32m+[m[32m// The shape is a series of contours. Each one starts with[m
[32m+[m[32m// a STBTT_moveto, then consists of a series of mixed[m
[32m+[m[32m// STBTT_lineto and STBTT_curveto segments. A lineto[m
[32m+[m[32m// draws a line from previous endpoint to its x,y; a curveto[m
[32m+[m[32m// draws a quadratic bezier from previous endpoint to[m
[32m+[m[32m// its x,y, using cx,cy as the bezier control point.[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);[m
[32m+[m[32m// frees the data allocated above[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// BITMAP RENDERING[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);[m
[32m+[m[32m// frees the bitmap allocated below[m
[32m+[m
[32m+[m[32mSTBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);[m
[32m+[m[32m// allocates a large-enough single-channel 8bpp bitmap and renders the[m
[32m+[m[32m// specified character/glyph at the specified scale into it, with[m
[32m+[m[32m// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).[m
[32m+[m[32m// *width & *height are filled out with the width & height of the bitmap,[m
[32m+[m[32m// which is stored left-to-right, top-to-bottom.[m
[32m+[m[32m//[m
[32m+[m[32m// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap[m
[32m+[m
[32m+[m[32mSTBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);[m
[32m+[m[32m// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel[m
[32m+[m[32m// shift for the character[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);[m
[32m+[m[32m// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap[m
[32m+[m[32m// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap[m
[32m+[m[32m// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the[m
[32m+[m[32m// width and height and positioning info for it first.[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);[m
[32m+[m[32m// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel[m
[32m+[m[32m// shift for the character[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint);[m
[32m+[m[32m// same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering[m
[32m+[m[32m// is performed (see stbtt_PackSetOversampling)[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);[m
[32m+[m[32m// get the bbox of the bitmap centered around the glyph origin; so the[m
[32m+[m[32m// bitmap width is ix1-ix0, height is iy1-iy0, and location to place[m
[32m+[m[32m// the bitmap top left is (leftSideBearing*scale,iy0).[m
[32m+[m[32m// (Note that the bitmap uses y-increases-down, but the shape uses[m
[32m+[m[32m// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);[m
[32m+[m[32m// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel[m
[32m+[m[32m// shift for the character[m
[32m+[m
[32m+[m[32m// the following functions are equivalent to the above functions, but operate[m
[32m+[m[32m// on glyph indices instead of Unicode codepoints (for efficiency)[m
[32m+[m[32mSTBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);[m
[32m+[m[32mSTBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);[m
[32m+[m[32mSTBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);[m
[32m+[m[32mSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);[m
[32m+[m[32mSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int glyph);[m
[32m+[m[32mSTBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);[m
[32m+[m[32mSTBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);[m
[32m+[m
[32m+[m
[32m+[m[32m// @TODO: don't expose this structure[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m   int w,h,stride;[m
[32m+[m[32m   unsigned char *pixels;[m
[32m+[m[32m} stbtt__bitmap;[m
[32m+[m
[32m+[m[32m// rasterize a shape with quadratic beziers into a bitmap[m
[32m+[m[32mSTBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into[m
[32m+[m[32m                               float flatness_in_pixels,     // allowable error of curve in pixels[m
[32m+[m[32m                               stbtt_vertex *vertices,       // array of vertices defining shape[m
[32m+[m[32m                               int num_verts,                // number of vertices in above array[m
[32m+[m[32m                               float scale_x, float scale_y, // scale applied to input vertices[m
[32m+[m[32m                               float shift_x, float shift_y, // translation applied to input vertices[m
[32m+[m[32m                               int x_off, int y_off,         // another translation applied to input[m
[32m+[m[32m                               int invert,                   // if non-zero, vertically flip shape[m
[32m+[m[32m                               void *userdata);              // context for to STBTT_MALLOC[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// Signed Distance Function (or Field) rendering[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata);[m
[32m+[m[32m// frees the SDF bitmap allocated below[m
[32m+[m
[32m+[m[32mSTBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);[m
[32m+[m[32mSTBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);[m
[32m+[m[32m// These functions compute a discretized SDF field for a single character, suitable for storing[m
[32m+[m[32m// in a single-channel texture, sampling with bilinear filtering, and testing against[m
[32m+[m[32m// larger than some threshold to produce scalable fonts.[m
[32m+[m[32m//        info              --  the font[m
[32m+[m[32m//        scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap[m
[32m+[m[32m//        glyph/codepoint   --  the character to generate the SDF for[m
[32m+[m[32m//        padding           --  extra "pixels" around the character which are filled with the distance to the character (not 0),[m
[32m+[m[32m//                                 which allows effects like bit outlines[m
[32m+[m[32m//        onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character)[m
[32m+[m[32m//        pixel_dist_scale  --  what value the SDF should increase by when moving one SDF "pixel" away from the edge (on the 0..255 scale)[m
[32m+[m[32m//                                 if positive, > onedge_value is inside; if negative, < onedge_value is inside[m
[32m+[m[32m//        width,height      --  output height & width of the SDF bitmap (including padding)[m
[32m+[m[32m//        xoff,yoff         --  output origin of the character[m
[32m+[m[32m//        return value      --  a 2D array of bytes 0..255, width*height in size[m
[32m+[m[32m//[m
[32m+[m[32m// pixel_dist_scale & onedge_value are a scale & bias that allows you to make[m
[32m+[m[32m// optimal use of the limited 0..255 for your application, trading off precision[m
[32m+[m[32m// and special effects. SDF values outside the range 0..255 are clamped to 0..255.[m
[32m+[m[32m//[m
[32m+[m[32m// Example:[m
[32m+[m[32m//      scale = stbtt_ScaleForPixelHeight(22)[m
[32m+[m[32m//      padding = 5[m
[32m+[m[32m//      onedge_value = 180[m
[32m+[m[32m//      pixel_dist_scale = 180/5.0 = 36.0[m
[32m+[m[32m//[m
[32m+[m[32m//      This will create an SDF bitmap in which the character is about 22 pixels[m
[32m+[m[32m//      high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled[m
[32m+[m[32m//      shape, sample the SDF at each pixel and fill the pixel if the SDF value[m
[32m+[m[32m//      is greater than or equal to 180/255. (You'll actually want to antialias,[m
[32m+[m[32m//      which is beyond the scope of this example.) Additionally, you can compute[m
[32m+[m[32m//      offset outlines (e.g. to stroke the character border inside & outside,[m
[32m+[m[32m//      or only outside). For example, to fill outside the character up to 3 SDF[m
[32m+[m[32m//      pixels, you would compare against (180-36.0*3)/255 = 72/255. The above[m
[32m+[m[32m//      choice of variables maps a range from 5 pixels outside the shape to[m
[32m+[m[32m//      2 pixels inside the shape to 0..255; this is intended primarily for apply[m
[32m+[m[32m//      outside effects only (the interior range is needed to allow proper[m
[32m+[m[32m//      antialiasing of the font at *smaller* sizes)[m
[32m+[m[32m//[m
[32m+[m[32m// The function computes the SDF analytically at each SDF pixel, not by e.g.[m
[32m+[m[32m// building a higher-res bitmap and approximating it. In theory the quality[m
[32m+[m[32m// should be as high as possible for an SDF of this size & representation, but[m
[32m+[m[32m// unclear if this is true in practice (perhaps building a higher-res bitmap[m
[32m+[m[32m// and computing from that can allow drop-out prevention).[m
[32m+[m[32m//[m
[32m+[m[32m// The algorithm has not been optimized at all, so expect it to be slow[m
[32m+[m[32m// if computing lots of characters or very large sizes.[m[41m [m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// Finding the right font...[m
[32m+[m[32m//[m
[32m+[m[32m// You should really just solve this offline, keep your own tables[m
[32m+[m[32m// of what font is what, and don't try to get it out of the .ttf file.[m
[32m+[m[32m// That's because getting it out of the .ttf file is really hard, because[m
[32m+[m[32m// the names in the file can appear in many possible encodings, in many[m
[32m+[m[32m// possible languages, and e.g. if you need a case-insensitive comparison,[m
[32m+[m[32m// the details of that depend on the encoding & language in a complex way[m
[32m+[m[32m// (actually underspecified in truetype, but also gigantic).[m
[32m+[m[32m//[m
[32m+[m[32m// But you can use the provided functions in two possible ways:[m
[32m+[m[32m//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on[m
[32m+[m[32m//             unicode-encoded names to try to find the font you want;[m
[32m+[m[32m//             you can run this before calling stbtt_InitFont()[m
[32m+[m[32m//[m
[32m+[m[32m//     stbtt_GetFontNameString() lets you get any of the various strings[m
[32m+[m[32m//             from the file yourself and do your own comparisons on them.[m
[32m+[m[32m//             You have to have called stbtt_InitFont() first.[m
[32m+[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);[m
[32m+[m[32m// returns the offset (not index) of the font that matches, or -1 if none[m
[32m+[m[32m//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like "Arial Bold".[m
[32m+[m[32m//   if you use any other flag, use a font name like "Arial"; this checks[m
[32m+[m[32m//     the 'macStyle' header field; i don't know if fonts set this consistently[m
[32m+[m[32m#define STBTT_MACSTYLE_DONTCARE     0[m
[32m+[m[32m#define STBTT_MACSTYLE_BOLD         1[m
[32m+[m[32m#define STBTT_MACSTYLE_ITALIC       2[m
[32m+[m[32m#define STBTT_MACSTYLE_UNDERSCORE   4[m
[32m+[m[32m#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);[m
[32m+[m[32m// returns 1/0 whether the first string interpreted as utf8 is identical to[m
[32m+[m[32m// the second string interpreted as big-endian utf16... useful for strings from next func[m
[32m+[m
[32m+[m[32mSTBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);[m
[32m+[m[32m// returns the string (which may be big-endian double byte, e.g. for unicode)[m
[32m+[m[32m// and puts the length in bytes in *length.[m
[32m+[m[32m//[m
[32m+[m[32m// some of the values for the IDs are below; for more see the truetype spec:[m
[32m+[m[32m//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html[m
[32m+[m[32m//     http://www.microsoft.com/typography/otspec/name.htm[m
[32m+[m
[32m+[m[32menum { // platformID[m
[32m+[m[32m   STBTT_PLATFORM_ID_UNICODE   =0,[m
[32m+[m[32m   STBTT_PLATFORM_ID_MAC       =1,[m
[32m+[m[32m   STBTT_PLATFORM_ID_ISO       =2,[m
[32m+[m[32m   STBTT_PLATFORM_ID_MICROSOFT =3[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum { // encodingID for STBTT_PLATFORM_ID_UNICODE[m
[32m+[m[32m   STBTT_UNICODE_EID_UNICODE_1_0    =0,[m
[32m+[m[32m   STBTT_UNICODE_EID_UNICODE_1_1    =1,[m
[32m+[m[32m   STBTT_UNICODE_EID_ISO_10646      =2,[m
[32m+[m[32m   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,[m
[32m+[m[32m   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT[m
[32m+[m[32m   STBTT_MS_EID_SYMBOL        =0,[m
[32m+[m[32m   STBTT_MS_EID_UNICODE_BMP   =1,[m
[32m+[m[32m   STBTT_MS_EID_SHIFTJIS      =2,[m
[32m+[m[32m   STBTT_MS_EID_UNICODE_FULL  =10[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes[m
[32m+[m[32m   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,[m
[32m+[m[32m   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,[m
[32m+[m[32m   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,[m
[32m+[m[32m   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...[m
[32m+[m[32m       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs[m
[32m+[m[32m   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,[m
[32m+[m[32m   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,[m
[32m+[m[32m   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,[m
[32m+[m[32m   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,[m
[32m+[m[32m   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,[m
[32m+[m[32m   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32menum { // languageID for STBTT_PLATFORM_ID_MAC[m
[32m+[m[32m   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,[m
[32m+[m[32m   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,[m
[32m+[m[32m   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,[m
[32m+[m[32m   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,[m
[32m+[m[32m   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,[m
[32m+[m[32m   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,[m
[32m+[m[32m   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif // __STB_INCLUDE_STB_TRUETYPE_H__[m
[32m+[m
[32m+[m[32m///////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m///////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m////[m
[32m+[m[32m////   IMPLEMENTATION[m
[32m+[m[32m////[m
[32m+[m[32m////[m
[32m+[m
[32m+[m[32m#ifdef STB_TRUETYPE_IMPLEMENTATION[m
[32m+[m
[32m+[m[32m#ifndef STBTT_MAX_OVERSAMPLE[m
[32m+[m[32m#define STBTT_MAX_OVERSAMPLE   8[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if STBTT_MAX_OVERSAMPLE > 255[m
[32m+[m[32m#error "STBTT_MAX_OVERSAMPLE cannot be > 255"[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32mtypedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];[m
[32m+[m
[32m+[m[32m#ifndef STBTT_RASTERIZER_VERSION[m
[32m+[m[32m#define STBTT_RASTERIZER_VERSION 2[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef _MSC_VER[m
[32m+[m[32m#define STBTT__NOTUSED(v)  (void)(v)[m
[32m+[m[32m#else[m
[32m+[m[32m#define STBTT__NOTUSED(v)  (void)sizeof(v)[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// stbtt__buf helpers to parse data from file[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32mstatic stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)[m
[32m+[m[32m{[m
[32m+[m[32m   if (b->cursor >= b->size)[m
[32m+[m[32m      return 0;[m
[32m+[m[32m   return b->data[b->cursor++];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)[m
[32m+[m[32m{[m
[32m+[m[32m   if (b->cursor >= b->size)[m
[32m+[m[32m      return 0;[m
[32m+[m[32m   return b->data[b->cursor];[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__buf_seek(stbtt__buf *b, int o)[m
[32m+[m[32m{[m
[32m+[m[32m   STBTT_assert(!(o > b->size || o < 0));[m
[32m+[m[32m   b->cursor = (o > b->size || o < 0) ? b->size : o;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__buf_skip(stbtt__buf *b, int o)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt__buf_seek(b, b->cursor + o);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_uint32 v = 0;[m
[32m+[m[32m   int i;[m
[32m+[m[32m   STBTT_assert(n >= 1 && n <= 4);[m
[32m+[m[32m   for (i = 0; i < n; i++)[m
[32m+[m[32m      v = (v << 8) | stbtt__buf_get8(b);[m
[32m+[m[32m   return v;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic stbtt__buf stbtt__new_buf(const void *p, size_t size)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt__buf r;[m
[32m+[m[32m   STBTT_assert(size < 0x40000000);[m
[32m+[m[32m   r.data = (stbtt_uint8*) p;[m
[32m+[m[32m   r.size = (int) size;[m
[32m+[m[32m   r.cursor = 0;[m
[32m+[m[32m   return r;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)[m
[32m+[m[32m#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)[m
[32m+[m
[32m+[m[32mstatic stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt__buf r = stbtt__new_buf(NULL, 0);[m
[32m+[m[32m   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;[m
[32m+[m[32m   r.data = b->data + o;[m
[32m+[m[32m   r.size = s;[m
[32m+[m[32m   return r;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic stbtt__buf stbtt__cff_get_index(stbtt__buf *b)[m
[32m+[m[32m{[m
[32m+[m[32m   int count, start, offsize;[m
[32m+[m[32m   start = b->cursor;[m
[32m+[m[32m   count = stbtt__buf_get16(b);[m
[32m+[m[32m   if (count) {[m
[32m+[m[32m      offsize = stbtt__buf_get8(b);[m
[32m+[m[32m      STBTT_assert(offsize >= 1 && offsize <= 4);[m
[32m+[m[32m      stbtt__buf_skip(b, offsize * count);[m
[32m+[m[32m      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);[m
[32m+[m[32m   }[m
[32m+[m[32m   return stbtt__buf_range(b, start, b->cursor - start);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic stbtt_uint32 stbtt__cff_int(stbtt__buf *b)[m
[32m+[m[32m{[m
[32m+[m[32m   int b0 = stbtt__buf_get8(b);[m
[32m+[m[32m   if (b0 >= 32 && b0 <= 246)       return b0 - 139;[m
[32m+[m[32m   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;[m
[32m+[m[32m   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;[m
[32m+[m[32m   else if (b0 == 28)               return stbtt__buf_get16(b);[m
[32m+[m[32m   else if (b0 == 29)               return stbtt__buf_get32(b);[m
[32m+[m[32m   STBTT_assert(0);[m
[32m+[m[32m   return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__cff_skip_operand(stbtt__buf *b) {[m
[32m+[m[32m   int v, b0 = stbtt__buf_peek8(b);[m
[32m+[m[32m   STBTT_assert(b0 >= 28);[m
[32m+[m[32m   if (b0 == 30) {[m
[32m+[m[32m      stbtt__buf_skip(b, 1);[m
[32m+[m[32m      while (b->cursor < b->size) {[m
[32m+[m[32m         v = stbtt__buf_get8(b);[m
[32m+[m[32m         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)[m
[32m+[m[32m            break;[m
[32m+[m[32m      }[m
[32m+[m[32m   } else {[m
[32m+[m[32m      stbtt__cff_int(b);[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt__buf_seek(b, 0);[m
[32m+[m[32m   while (b->cursor < b->size) {[m
[32m+[m[32m      int start = b->cursor, end, op;[m
[32m+[m[32m      while (stbtt__buf_peek8(b) >= 28)[m
[32m+[m[32m         stbtt__cff_skip_operand(b);[m
[32m+[m[32m      end = b->cursor;[m
[32m+[m[32m      op = stbtt__buf_get8(b);[m
[32m+[m[32m      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;[m
[32m+[m[32m      if (op == key) return stbtt__buf_range(b, start, end-start);[m
[32m+[m[32m   }[m
[32m+[m[32m   return stbtt__buf_range(b, 0, 0);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)[m
[32m+[m[32m{[m
[32m+[m[32m   int i;[m
[32m+[m[32m   stbtt__buf operands = stbtt__dict_get(b, key);[m
[32m+[m[32m   for (i = 0; i < outcount && operands.cursor < operands.size; i++)[m
[32m+[m[32m      out[i] = stbtt__cff_int(&operands);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int stbtt__cff_index_count(stbtt__buf *b)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt__buf_seek(b, 0);[m
[32m+[m[32m   return stbtt__buf_get16(b);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)[m
[32m+[m[32m{[m
[32m+[m[32m   int count, offsize, start, end;[m
[32m+[m[32m   stbtt__buf_seek(&b, 0);[m
[32m+[m[32m   count = stbtt__buf_get16(&b);[m
[32m+[m[32m   offsize = stbtt__buf_get8(&b);[m
[32m+[m[32m   STBTT_assert(i >= 0 && i < count);[m
[32m+[m[32m   STBTT_assert(offsize >= 1 && offsize <= 4);[m
[32m+[m[32m   stbtt__buf_skip(&b, i*offsize);[m
[32m+[m[32m   start = stbtt__buf_get(&b, offsize);[m
[32m+[m[32m   end = stbtt__buf_get(&b, offsize);[m
[32m+[m[32m   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// accessors to parse data from file[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32m// on platforms that don't allow misaligned reads, if we want to allow[m
[32m+[m[32m// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE[m
[32m+[m
[32m+[m[32m#define ttBYTE(p)     (* (stbtt_uint8 *) (p))[m
[32m+[m[32m#define ttCHAR(p)     (* (stbtt_int8 *) (p))[m
[32m+[m[32m#define ttFixed(p)    ttLONG(p)[m
[32m+[m
[32m+[m[32mstatic stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }[m
[32m+[m[32mstatic stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }[m
[32m+[m[32mstatic stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }[m
[32m+[m[32mstatic stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }[m
[32m+[m
[32m+[m[32m#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))[m
[32m+[m[32m#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])[m
[32m+[m
[32m+[m[32mstatic int stbtt__isfont(stbtt_uint8 *font)[m
[32m+[m[32m{[m
[32m+[m[32m   // check the version number[m
[32m+[m[32m   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1[m
[32m+[m[32m   if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this![m
[32m+[m[32m   if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF[m
[32m+[m[32m   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0[m
[32m+[m[32m   if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts[m
[32m+[m[32m   return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// @OPTIMIZE: binary search[m
[32m+[m[32mstatic stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);[m
[32m+[m[32m   stbtt_uint32 tabledir = fontstart + 12;[m
[32m+[m[32m   stbtt_int32 i;[m
[32m+[m[32m   for (i=0; i < num_tables; ++i) {[m
[32m+[m[32m      stbtt_uint32 loc = tabledir + 16*i;[m
[32m+[m[32m      if (stbtt_tag(data+loc+0, tag))[m
[32m+[m[32m         return ttULONG(data+loc+8);[m
[32m+[m[32m   }[m
[32m+[m[32m   return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)[m
[32m+[m[32m{[m
[32m+[m[32m   // if it's just a font, there's only one valid index[m
[32m+[m[32m   if (stbtt__isfont(font_collection))[m
[32m+[m[32m      return index == 0 ? 0 : -1;[m
[32m+[m
[32m+[m[32m   // check if it's a TTC[m
[32m+[m[32m   if (stbtt_tag(font_collection, "ttcf")) {[m
[32m+[m[32m      // version 1?[m
[32m+[m[32m      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {[m
[32m+[m[32m         stbtt_int32 n = ttLONG(font_collection+8);[m
[32m+[m[32m         if (index >= n)[m
[32m+[m[32m            return -1;[m
[32m+[m[32m         return ttULONG(font_collection+12+index*4);[m
[32m+[m[32m      }[m
[32m+[m[32m   }[m
[32m+[m[32m   return -1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)[m
[32m+[m[32m{[m
[32m+[m[32m   // if it's just a font, there's only one valid font[m
[32m+[m[32m   if (stbtt__isfont(font_collection))[m
[32m+[m[32m      return 1;[m
[32m+[m
[32m+[m[32m   // check if it's a TTC[m
[32m+[m[32m   if (stbtt_tag(font_collection, "ttcf")) {[m
[32m+[m[32m      // version 1?[m
[32m+[m[32m      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {[m
[32m+[m[32m         return ttLONG(font_collection+8);[m
[32m+[m[32m      }[m
[32m+[m[32m   }[m
[32m+[m[32m   return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };[m
[32m+[m[32m   stbtt__buf pdict;[m
[32m+[m[32m   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);[m
[32m+[m[32m   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);[m
[32m+[m[32m   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);[m
[32m+[m[32m   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);[m
[32m+[m[32m   if (!subrsoff) return stbtt__new_buf(NULL, 0);[m
[32m+[m[32m   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);[m
[32m+[m[32m   return stbtt__cff_get_index(&cff);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_uint32 cmap, t;[m
[32m+[m[32m   stbtt_int32 i,numTables;[m
[32m+[m
[32m+[m[32m   info->data = data;[m
[32m+[m[32m   info->fontstart = fontstart;[m
[32m+[m[32m   info->cff = stbtt__new_buf(NULL, 0);[m
[32m+[m
[32m+[m[32m   cmap = stbtt__find_table(data, fontstart, "cmap");       // required[m
[32m+[m[32m   info->loca = stbtt__find_table(data, fontstart, "loca"); // required[m
[32m+[m[32m   info->head = stbtt__find_table(data, fontstart, "head"); // required[m
[32m+[m[32m   info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required[m
[32m+[m[32m   info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required[m
[32m+[m[32m   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required[m
[32m+[m[32m   info->kern = stbtt__find_table(data, fontstart, "kern"); // not required[m
[32m+[m[32m   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required[m
[32m+[m
[32m+[m[32m   if (!cmap || !info->head || !info->hhea || !info->hmtx)[m
[32m+[m[32m      return 0;[m
[32m+[m[32m   if (info->glyf) {[m
[32m+[m[32m      // required for truetype[m
[32m+[m[32m      if (!info->loca) return 0;[m
[32m+[m[32m   } else {[m
[32m+[m[32m      // initialization for CFF / Type2 fonts (OTF)[m
[32m+[m[32m      stbtt__buf b, topdict, topdictidx;[m
[32m+[m[32m      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;[m
[32m+[m[32m      stbtt_uint32 cff;[m
[32m+[m
[32m+[m[32m      cff = stbtt__find_table(data, fontstart, "CFF ");[m
[32m+[m[32m      if (!cff) return 0;[m
[32m+[m
[32m+[m[32m      info->fontdicts = stbtt__new_buf(NULL, 0);[m
[32m+[m[32m      info->fdselect = stbtt__new_buf(NULL, 0);[m
[32m+[m
[32m+[m[32m      // @TODO this should use size from table (not 512MB)[m
[32m+[m[32m      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);[m
[32m+[m[32m      b = info->cff;[m
[32m+[m
[32m+[m[32m      // read the header[m
[32m+[m[32m      stbtt__buf_skip(&b, 2);[m
[32m+[m[32m      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize[m
[32m+[m
[32m+[m[32m      // @TODO the name INDEX could list multiple fonts,[m
[32m+[m[32m      // but we just use the first one.[m
[32m+[m[32m      stbtt__cff_get_index(&b);  // name INDEX[m
[32m+[m[32m      topdictidx = stbtt__cff_get_index(&b);[m
[32m+[m[32m      topdict = stbtt__cff_index_get(topdictidx, 0);[m
[32m+[m[32m      stbtt__cff_get_index(&b);  // string INDEX[m
[32m+[m[32m      info->gsubrs = stbtt__cff_get_index(&b);[m
[32m+[m
[32m+[m[32m      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);[m
[32m+[m[32m      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);[m
[32m+[m[32m      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);[m
[32m+[m[32m      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);[m
[32m+[m[32m      info->subrs = stbtt__get_subrs(b, topdict);[m
[32m+[m
[32m+[m[32m      // we only support Type 2 charstrings[m
[32m+[m[32m      if (cstype != 2) return 0;[m
[32m+[m[32m      if (charstrings == 0) return 0;[m
[32m+[m
[32m+[m[32m      if (fdarrayoff) {[m
[32m+[m[32m         // looks like a CID font[m
[32m+[m[32m         if (!fdselectoff) return 0;[m
[32m+[m[32m         stbtt__buf_seek(&b, fdarrayoff);[m
[32m+[m[32m         info->fontdicts = stbtt__cff_get_index(&b);[m
[32m+[m[32m         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      stbtt__buf_seek(&b, charstrings);[m
[32m+[m[32m      info->charstrings = stbtt__cff_get_index(&b);[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   t = stbtt__find_table(data, fontstart, "maxp");[m
[32m+[m[32m   if (t)[m
[32m+[m[32m      info->numGlyphs = ttUSHORT(data+t+4);[m
[32m+[m[32m   else[m
[32m+[m[32m      info->numGlyphs = 0xffff;[m
[32m+[m
[32m+[m[32m   // find a cmap encoding table we understand *now* to avoid searching[m
[32m+[m[32m   // later. (todo: could make this installable)[m
[32m+[m[32m   // the same regardless of glyph.[m
[32m+[m[32m   numTables = ttUSHORT(data + cmap + 2);[m
[32m+[m[32m   info->index_map = 0;[m
[32m+[m[32m   for (i=0; i < numTables; ++i) {[m
[32m+[m[32m      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;[m
[32m+[m[32m      // find an encoding we understand:[m
[32m+[m[32m      switch(ttUSHORT(data+encoding_record)) {[m
[32m+[m[32m         case STBTT_PLATFORM_ID_MICROSOFT:[m
[32m+[m[32m            switch (ttUSHORT(data+encoding_record+2)) {[m
[32m+[m[32m               case STBTT_MS_EID_UNICODE_BMP:[m
[32m+[m[32m               case STBTT_MS_EID_UNICODE_FULL:[m
[32m+[m[32m                  // MS/Unicode[m
[32m+[m[32m                  info->index_map = cmap + ttULONG(data+encoding_record+4);[m
[32m+[m[32m                  break;[m
[32m+[m[32m            }[m
[32m+[m[32m            break;[m
[32m+[m[32m        case STBTT_PLATFORM_ID_UNICODE:[m
[32m+[m[32m            // Mac/iOS has these[m
[32m+[m[32m            // all the encodingIDs are unicode, so we don't bother to check it[m
[32m+[m[32m            info->index_map = cmap + ttULONG(data+encoding_record+4);[m
[32m+[m[32m            break;[m
[32m+[m[32m      }[m
[32m+[m[32m   }[m
[32m+[m[32m   if (info->index_map == 0)[m
[32m+[m[32m      return 0;[m
[32m+[m
[32m+[m[32m   info->indexToLocFormat = ttUSHORT(data+info->head + 50);[m
[32m+[m[32m   return 1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_uint8 *data = info->data;[m
[32m+[m[32m   stbtt_uint32 index_map = info->index_map;[m
[32m+[m
[32m+[m[32m   stbtt_uint16 format = ttUSHORT(data + index_map + 0);[m
[32m+[m[32m   if (format == 0) { // apple byte encoding[m
[32m+[m[32m      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);[m
[32m+[m[32m      if (unicode_codepoint < bytes-6)[m
[32m+[m[32m         return ttBYTE(data + index_map + 6 + unicode_codepoint);[m
[32m+[m[32m      return 0;[m
[32m+[m[32m   } else if (format == 6) {[m
[32m+[m[32m      stbtt_uint32 first = ttUSHORT(data + index_map + 6);[m
[32m+[m[32m      stbtt_uint32 count = ttUSHORT(data + index_map + 8);[m
[32m+[m[32m      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)[m
[32m+[m[32m         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);[m
[32m+[m[32m      return 0;[m
[32m+[m[32m   } else if (format == 2) {[m
[32m+[m[32m      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean[m
[32m+[m[32m      return 0;[m
[32m+[m[32m   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges[m
[32m+[m[32m      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;[m
[32m+[m[32m      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;[m
[32m+[m[32m      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);[m
[32m+[m[32m      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;[m
[32m+[m
[32m+[m[32m      // do a binary search of the segments[m
[32m+[m[32m      stbtt_uint32 endCount = index_map + 14;[m
[32m+[m[32m      stbtt_uint32 search = endCount;[m
[32m+[m
[32m+[m[32m      if (unicode_codepoint > 0xffff)[m
[32m+[m[32m         return 0;[m
[32m+[m
[32m+[m[32m      // they lie from endCount .. endCount + segCount[m
[32m+[m[32m      // but searchRange is the nearest power of two, so...[m
[32m+[m[32m      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))[m
[32m+[m[32m         search += rangeShift*2;[m
[32m+[m
[32m+[m[32m      // now decrement to bias correctly to find smallest[m
[32m+[m[32m      search -= 2;[m
[32m+[m[32m      while (entrySelector) {[m
[32m+[m[32m         stbtt_uint16 end;[m
[32m+[m[32m         searchRange >>= 1;[m
[32m+[m[32m         end = ttUSHORT(data + search + searchRange*2);[m
[32m+[m[32m         if (unicode_codepoint > end)[m
[32m+[m[32m            search += searchRange*2;[m
[32m+[m[32m         --entrySelector;[m
[32m+[m[32m      }[m
[32m+[m[32m      search += 2;[m
[32m+[m
[32m+[m[32m      {[m
[32m+[m[32m         stbtt_uint16 offset, start;[m
[32m+[m[32m         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);[m
[32m+[m
[32m+[m[32m         STBTT_assert(unicode_codepoint <= ttUSHORT(data + endCount + 2*item));[m
[32m+[m[32m         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);[m
[32m+[m[32m         if (unicode_codepoint < start)[m
[32m+[m[32m            return 0;[m
[32m+[m
[32m+[m[32m         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);[m
[32m+[m[32m         if (offset == 0)[m
[32m+[m[32m            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));[m
[32m+[m
[32m+[m[32m         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);[m
[32m+[m[32m      }[m
[32m+[m[32m   } else if (format == 12 || format == 13) {[m
[32m+[m[32m      stbtt_uint32 ngroups = ttULONG(data+index_map+12);[m
[32m+[m[32m      stbtt_int32 low,high;[m
[32m+[m[32m      low = 0; high = (stbtt_int32)ngroups;[m
[32m+[m[32m      // Binary search the right group.[m
[32m+[m[32m      while (low < high) {[m
[32m+[m[32m         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high[m
[32m+[m[32m         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);[m
[32m+[m[32m         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);[m
[32m+[m[32m         if ((stbtt_uint32) unicode_codepoint < start_char)[m
[32m+[m[32m            high = mid;[m
[32m+[m[32m         else if ((stbtt_uint32) unicode_codepoint > end_char)[m
[32m+[m[32m            low = mid+1;[m
[32m+[m[32m         else {[m
[32m+[m[32m            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);[m
[32m+[m[32m            if (format == 12)[m
[32m+[m[32m               return start_glyph + unicode_codepoint-start_char;[m
[32m+[m[32m            else // format == 13[m
[32m+[m[32m               return start_glyph;[m
[32m+[m[32m         }[m
[32m+[m[32m      }[m
[32m+[m[32m      return 0; // not found[m
[32m+[m[32m   }[m
[32m+[m[32m   // @TODO[m
[32m+[m[32m   STBTT_assert(0);[m
[32m+[m[32m   return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)[m
[32m+[m[32m{[m
[32m+[m[32m   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)[m
[32m+[m[32m{[m
[32m+[m[32m   v->type = type;[m
[32m+[m[32m   v->x = (stbtt_int16) x;[m
[32m+[m[32m   v->y = (stbtt_int16) y;[m
[32m+[m[32m   v->cx = (stbtt_int16) cx;[m
[32m+[m[32m   v->cy = (stbtt_int16) cy;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)[m
[32m+[m[32m{[m
[32m+[m[32m   int g1,g2;[m
[32m+[m
[32m+[m[32m   STBTT_assert(!info->cff.size);[m
[32m+[m
[32m+[m[32m   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range[m
[32m+[m[32m   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format[m
[32m+[m
[32m+[m[32m   if (info->indexToLocFormat == 0) {[m
[32m+[m[32m      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;[m
[32m+[m[32m      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;[m
[32m+[m[32m   } else {[m
[32m+[m[32m      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);[m
[32m+[m[32m      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   return g1==g2 ? -1 : g1; // if length is 0, return -1[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)[m
[32m+[m[32m{[m
[32m+[m[32m   if (info->cff.size) {[m
[32m+[m[32m      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);[m
[32m+[m[32m   } else {[m
[32m+[m[32m      int g = stbtt__GetGlyfOffset(info, glyph_index);[m
[32m+[m[32m      if (g < 0) return 0;[m
[32m+[m
[32m+[m[32m      if (x0) *x0 = ttSHORT(info->data + g + 2);[m
[32m+[m[32m      if (y0) *y0 = ttSHORT(info->data + g + 4);[m
[32m+[m[32m      if (x1) *x1 = ttSHORT(info->data + g + 6);[m
[32m+[m[32m      if (y1) *y1 = ttSHORT(info->data + g + 8);[m
[32m+[m[32m   }[m
[32m+[m[32m   return 1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)[m
[32m+[m[32m{[m
[32m+[m[32m   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_int16 numberOfContours;[m
[32m+[m[32m   int g;[m
[32m+[m[32m   if (info->cff.size)[m
[32m+[m[32m      return stbtt__GetGlyphInfoT2(info, glyph_index, NULL, NULL, NULL, NULL) == 0;[m
[32m+[m[32m   g = stbtt__GetGlyfOffset(info, glyph_index);[m
[32m+[m[32m   if (g < 0) return 1;[m
[32m+[m[32m   numberOfContours = ttSHORT(info->data + g);[m
[32m+[m[32m   return numberOfContours == 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,[m
[32m+[m[32m    stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)[m
[32m+[m[32m{[m
[32m+[m[32m   if (start_off) {[m
[32m+[m[32m      if (was_off)[m
[32m+[m[32m         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);[m
[32m+[m[32m      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);[m
[32m+[m[32m   } else {[m
[32m+[m[32m      if (was_off)[m
[32m+[m[32m         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);[m
[32m+[m[32m      else[m
[32m+[m[32m         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);[m
[32m+[m[32m   }[m
[32m+[m[32m   return num_vertices;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_int16 numberOfContours;[m
[32m+[m[32m   stbtt_uint8 *endPtsOfContours;[m
[32m+[m[32m   stbtt_uint8 *data = info->data;[m
[32m+[m[32m   stbtt_vertex *vertices=0;[m
[32m+[m[32m   int num_vertices=0;[m
[32m+[m[32m   int g = stbtt__GetGlyfOffset(info, glyph_index);[m
[32m+[m
[32m+[m[32m   *pvertices = NULL;[m
[32m+[m
[32m+[m[32m   if (g < 0) return 0;[m
[32m+[m
[32m+[m[32m   numberOfContours = ttSHORT(data + g);[m
[32m+[m
[32m+[m[32m   if (numberOfContours > 0) {[m
[32m+[m[32m      stbtt_uint8 flags=0,flagcount;[m
[32m+[m[32m      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;[m
[32m+[m[32m      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;[m
[32m+[m[32m      stbtt_uint8 *points;[m
[32m+[m[32m      endPtsOfContours = (data + g + 10);[m
[32m+[m[32m      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);[m
[32m+[m[32m      points = data + g + 10 + numberOfContours * 2 + 2 + ins;[m
[32m+[m
[32m+[m[32m      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);[m
[32m+[m
[32m+[m[32m      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need[m
[32m+[m[32m      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);[m
[32m+[m[32m      if (vertices == 0)[m
[32m+[m[32m         return 0;[m
[32m+[m
[32m+[m[32m      next_move = 0;[m
[32m+[m[32m      flagcount=0;[m
[32m+[m
[32m+[m[32m      // in first pass, we load uninterpreted data into the allocated array[m
[32m+[m[32m      // above, shifted to the end of the array so we won't overwrite it when[m
[32m+[m[32m      // we create our final data starting from the front[m
[32m+[m
[32m+[m[32m      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated[m
[32m+[m
[32m+[m[32m      // first load flags[m
[32m+[m
[32m+[m[32m      for (i=0; i < n; ++i) {[m
[32m+[m[32m         if (flagcount == 0) {[m
[32m+[m[32m            flags = *points++;[m
[32m+[m[32m            if (flags & 8)[m
[32m+[m[32m               flagcount = *points++;[m
[32m+[m[32m         } else[m
[32m+[m[32m            --flagcount;[m
[32m+[m[32m         vertices[off+i].type = flags;[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      // now load x coordinates[m
[32m+[m[32m      x=0;[m
[32m+[m[32m      for (i=0; i < n; ++i) {[m
[32m+[m[32m         flags = vertices[off+i].type;[m
[32m+[m[32m         if (flags & 2) {[m
[32m+[m[32m            stbtt_int16 dx = *points++;[m
[32m+[m[32m            x += (flags & 16) ? dx : -dx; // ???[m
[32m+[m[32m         } else {[m
[32m+[m[32m            if (!(flags & 16)) {[m
[32m+[m[32m               x = x + (stbtt_int16) (points[0]*256 + points[1]);[m
[32m+[m[32m               points += 2;[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m
[32m+[m[32m         vertices[off+i].x = (stbtt_int16) x;[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      // now load y coordinates[m
[32m+[m[32m      y=0;[m
[32m+[m[32m      for (i=0; i < n; ++i) {[m
[32m+[m[32m         flags = vertices[off+i].type;[m
[32m+[m[32m         if (flags & 4) {[m
[32m+[m[32m            stbtt_int16 dy = *points++;[m
[32m+[m[32m            y += (flags & 32) ? dy : -dy; // ???[m
[32m+[m[32m         } else {[m
[32m+[m[32m            if (!(flags & 32)) {[m
[32m+[m[32m               y = y + (stbtt_int16) (points[0]*256 + points[1]);[m
[32m+[m[32m               points += 2;[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m
[32m+[m[32m         vertices[off+i].y = (stbtt_int16) y;[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      // now convert them to our format[m
[32m+[m[32m      num_vertices=0;[m
[32m+[m[32m      sx = sy = cx = cy = scx = scy = 0;[m
[32m+[m[32m      for (i=0; i < n; ++i) {[m
[32m+[m[32m         flags = vertices[off+i].type;[m
[32m+[m[32m         x     = (stbtt_int16) vertices[off+i].x;[m
[32m+[m[32m         y     = (stbtt_int16) vertices[off+i].y;[m
[32m+[m
[32m+[m[32m         if (next_move == i) {[m
[32m+[m[32m            if (i != 0)[m
[32m+[m[32m               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);[m
[32m+[m
[32m+[m[32m            // now start the new one[m[41m               [m
[32m+[m[32m            start_off = !(flags & 1);[m
[32m+[m[32m            if (start_off) {[m
[32m+[m[32m               // if we start off with an off-curve point, then when we need to find a point on the curve[m
[32m+[m[32m               // where we can start, and we need to save some state for when we wraparound.[m
[32m+[m[32m               scx = x;[m
[32m+[m[32m               scy = y;[m
[32m+[m[32m               if (!(vertices[off+i+1].type & 1)) {[m
[32m+[m[32m                  // next point is also a curve point, so interpolate an on-point curve[m
[32m+[m[32m                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;[m
[32m+[m[32m                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;[m
[32m+[m[32m               } else {[m
[32m+[m[32m                  // otherwise just use the next point as our start point[m
[32m+[m[32m                  sx = (stbtt_int32) vertices[off+i+1].x;[m
[32m+[m[32m                  sy = (stbtt_int32) vertices[off+i+1].y;[m
[32m+[m[32m                  ++i; // we're using point i+1 as the starting point, so skip it[m
[32m+[m[32m               }[m
[32m+[m[32m            } else {[m
[32m+[m[32m               sx = x;[m
[32m+[m[32m               sy = y;[m
[32m+[m[32m            }[m
[32m+[m[32m            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);[m
[32m+[m[32m            was_off = 0;[m
[32m+[m[32m            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);[m
[32m+[m[32m            ++j;[m
[32m+[m[32m         } else {[m
[32m+[m[32m            if (!(flags & 1)) { // if it's a curve[m
[32m+[m[32m               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint[m
[32m+[m[32m                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);[m
[32m+[m[32m               cx = x;[m
[32m+[m[32m               cy = y;[m
[32m+[m[32m               was_off = 1;[m
[32m+[m[32m            } else {[m
[32m+[m[32m               if (was_off)[m
[32m+[m[32m                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);[m
[32m+[m[32m               else[m
[32m+[m[32m                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);[m
[32m+[m[32m               was_off = 0;[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m
[32m+[m[32m      }[m
[32m+[m[32m      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);[m
[32m+[m[32m   } else if (numberOfContours == -1) {[m
[32m+[m[32m      // Compound shapes.[m
[32m+[m[32m      int more = 1;[m
[32m+[m[32m      stbtt_uint8 *comp = data + g + 10;[m
[32m+[m[32m      num_vertices = 0;[m
[32m+[m[32m      vertices = 0;[m
[32m+[m[32m      while (more) {[m
[32m+[m[32m         stbtt_uint16 flags, gidx;[m
[32m+[m[32m         int comp_num_verts = 0, i;[m
[32m+[m[32m         stbtt_vertex *comp_verts = 0, *tmp = 0;[m
[32m+[m[32m         float mtx[6] = {1,0,0,1,0,0}, m, n;[m
[32m+[m[41m         [m
[32m+[m[32m         flags = ttSHORT(comp); comp+=2;[m
[32m+[m[32m         gidx = ttSHORT(comp); comp+=2;[m
[32m+[m
[32m+[m[32m         if (flags & 2) { // XY values[m
[32m+[m[32m            if (flags & 1) { // shorts[m
[32m+[m[32m               mtx[4] = ttSHORT(comp); comp+=2;[m
[32m+[m[32m               mtx[5] = ttSHORT(comp); comp+=2;[m
[32m+[m[32m            } else {[m
[32m+[m[32m               mtx[4] = ttCHAR(comp); comp+=1;[m
[32m+[m[32m               mtx[5] = ttCHAR(comp); comp+=1;[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m
[32m+[m[32m         else {[m
[32m+[m[32m            // @TODO handle matching point[m
[32m+[m[32m            STBTT_assert(0);[m
[32m+[m[32m         }[m
[32m+[m[32m         if (flags & (1<<3)) { // WE_HAVE_A_SCALE[m
[32m+[m[32m            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;[m
[32m+[m[32m            mtx[1] = mtx[2] = 0;[m
[32m+[m[32m         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE[m
[32m+[m[32m            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;[m
[32m+[m[32m            mtx[1] = mtx[2] = 0;[m
[32m+[m[32m            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;[m
[32m+[m[32m         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO[m
[32m+[m[32m            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;[m
[32m+[m[32m            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;[m
[32m+[m[32m            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;[m
[32m+[m[32m            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;[m
[32m+[m[32m         }[m
[32m+[m[41m         [m
[32m+[m[32m         // Find transformation scales.[m
[32m+[m[32m         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);[m
[32m+[m[32m         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);[m
[32m+[m
[32m+[m[32m         // Get indexed glyph.[m
[32m+[m[32m         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);[m
[32m+[m[32m         if (comp_num_verts > 0) {[m
[32m+[m[32m            // Transform vertices.[m
[32m+[m[32m            for (i = 0; i < comp_num_verts; ++i) {[m
[32m+[m[32m               stbtt_vertex* v = &comp_verts[i];[m
[32m+[m[32m               stbtt_vertex_type x,y;[m
[32m+[m[32m               x=v->x; y=v->y;[m
[32m+[m[32m               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));[m
[32m+[m[32m               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));[m
[32m+[m[32m               x=v->cx; y=v->cy;[m
[32m+[m[32m               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));[m
[32m+[m[32m               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));[m
[32m+[m[32m            }[m
[32m+[m[32m            // Append vertices.[m
[32m+[m[32m            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);[m
[32m+[m[32m            if (!tmp) {[m
[32m+[m[32m               if (vertices) STBTT_free(vertices, info->userdata);[m
[32m+[m[32m               if (comp_verts) STBTT_free(comp_verts, info->userdata);[m
[32m+[m[32m               return 0;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (num_vertices > 0) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex)); //-V595[m
[32m+[m[32m            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));[m
[32m+[m[32m            if (vertices) STBTT_free(vertices, info->userdata);[m
[32m+[m[32m            vertices = tmp;[m
[32m+[m[32m            STBTT_free(comp_verts, info->userdata);[m
[32m+[m[32m            num_vertices += comp_num_verts;[m
[32m+[m[32m         }[m
[32m+[m[32m         // More components ?[m
[32m+[m[32m         more = flags & (1<<5);[m
[32m+[m[32m      }[m
[32m+[m[32m   } else if (numberOfContours < 0) {[m
[32m+[m[32m      // @TODO other compound variations?[m
[32m+[m[32m      STBTT_assert(0);[m
[32m+[m[32m   } else {[m
[32m+[m[32m      // numberOfCounters == 0, do nothing[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   *pvertices = vertices;[m
[32m+[m[32m   return num_vertices;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m   int bounds;[m
[32m+[m[32m   int started;[m
[32m+[m[32m   float first_x, first_y;[m
[32m+[m[32m   float x, y;[m
[32m+[m[32m   stbtt_int32 min_x, max_x, min_y, max_y;[m
[32m+[m
[32m+[m[32m   stbtt_vertex *pvertices;[m
[32m+[m[32m   int num_vertices;[m
[32m+[m[32m} stbtt__csctx;[m
[32m+[m
[32m+[m[32m#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}[m
[32m+[m
[32m+[m[32mstatic void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)[m
[32m+[m[32m{[m
[32m+[m[32m   if (x > c->max_x || !c->started) c->max_x = x;[m
[32m+[m[32m   if (y > c->max_y || !c->started) c->max_y = y;[m
[32m+[m[32m   if (x < c->min_x || !c->started) c->min_x = x;[m
[32m+[m[32m   if (y < c->min_y || !c->started) c->min_y = y;[m
[32m+[m[32m   c->started = 1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)[m
[32m+[m[32m{[m
[32m+[m[32m   if (c->bounds) {[m
[32m+[m[32m      stbtt__track_vertex(c, x, y);[m
[32m+[m[32m      if (type == STBTT_vcubic) {[m
[32m+[m[32m         stbtt__track_vertex(c, cx, cy);[m
[32m+[m[32m         stbtt__track_vertex(c, cx1, cy1);[m
[32m+[m[32m      }[m
[32m+[m[32m   } else {[m
[32m+[m[32m      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);[m
[32m+[m[32m      c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;[m
[32m+[m[32m      c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;[m
[32m+[m[32m   }[m
[32m+[m[32m   c->num_vertices++;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__csctx_close_shape(stbtt__csctx *ctx)[m
[32m+[m[32m{[m
[32m+[m[32m   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)[m
[32m+[m[32m      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt__csctx_close_shape(ctx);[m
[32m+[m[32m   ctx->first_x = ctx->x = ctx->x + dx;[m
[32m+[m[32m   ctx->first_y = ctx->y = ctx->y + dy;[m
[32m+[m[32m   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)[m
[32m+[m[32m{[m
[32m+[m[32m   ctx->x += dx;[m
[32m+[m[32m   ctx->y += dy;[m
[32m+[m[32m   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)[m
[32m+[m[32m{[m
[32m+[m[32m   float cx1 = ctx->x + dx1;[m
[32m+[m[32m   float cy1 = ctx->y + dy1;[m
[32m+[m[32m   float cx2 = cx1 + dx2;[m
[32m+[m[32m   float cy2 = cy1 + dy2;[m
[32m+[m[32m   ctx->x = cx2 + dx3;[m
[32m+[m[32m   ctx->y = cy2 + dy3;[m
[32m+[m[32m   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)[m
[32m+[m[32m{[m
[32m+[m[32m   int count = stbtt__cff_index_count(&idx);[m
[32m+[m[32m   int bias = 107;[m
[32m+[m[32m   if (count >= 33900)[m
[32m+[m[32m      bias = 32768;[m
[32m+[m[32m   else if (count >= 1240)[m
[32m+[m[32m      bias = 1131;[m
[32m+[m[32m   n += bias;[m
[32m+[m[32m   if (n < 0 || n >= count)[m
[32m+[m[32m      return stbtt__new_buf(NULL, 0);[m
[32m+[m[32m   return stbtt__cff_index_get(idx, n);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt__buf fdselect = info->fdselect;[m
[32m+[m[32m   int nranges, start, end, v, fmt, fdselector = -1, i;[m
[32m+[m
[32m+[m[32m   stbtt__buf_seek(&fdselect, 0);[m
[32m+[m[32m   fmt = stbtt__buf_get8(&fdselect);[m
[32m+[m[32m   if (fmt == 0) {[m
[32m+[m[32m      // untested[m
[32m+[m[32m      stbtt__buf_skip(&fdselect, glyph_index);[m
[32m+[m[32m      fdselector = stbtt__buf_get8(&fdselect);[m
[32m+[m[32m   } else if (fmt == 3) {[m
[32m+[m[32m      nranges = stbtt__buf_get16(&fdselect);[m
[32m+[m[32m      start = stbtt__buf_get16(&fdselect);[m
[32m+[m[32m      for (i = 0; i < nranges; i++) {[m
[32m+[m[32m         v = stbtt__buf_get8(&fdselect);[m
[32m+[m[32m         end = stbtt__buf_get16(&fdselect);[m
[32m+[m[32m         if (glyph_index >= start && glyph_index < end) {[m
[32m+[m[32m            fdselector = v;[m
[32m+[m[32m            break;[m
[32m+[m[32m         }[m
[32m+[m[32m         start = end;[m
[32m+[m[32m      }[m
[32m+[m[32m   }[m
[32m+[m[32m   if (fdselector == -1) stbtt__new_buf(NULL, 0);[m
[32m+[m[32m   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)[m
[32m+[m[32m{[m
[32m+[m[32m   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;[m
[32m+[m[32m   int has_subrs = 0, clear_stack;[m
[32m+[m[32m   float s[48];[m
[32m+[m[32m   stbtt__buf subr_stack[10], subrs = info->subrs, b;[m
[32m+[m[32m   float f;[m
[32m+[m
[32m+[m[32m#define STBTT__CSERR(s) (0)[m
[32m+[m
[32m+[m[32m   // this currently ignores the initial width value, which isn't needed if we have hmtx[m
[32m+[m[32m   b = stbtt__cff_index_get(info->charstrings, glyph_index);[m
[32m+[m[32m   while (b.cursor < b.size) {[m
[32m+[m[32m      i = 0;[m
[32m+[m[32m      clear_stack = 1;[m
[32m+[m[32m      b0 = stbtt__buf_get8(&b);[m
[32m+[m[32m      switch (b0) {[m
[32m+[m[32m      // @TODO implement hinting[m
[32m+[m[32m      case 0x13: // hintmask[m
[32m+[m[32m      case 0x14: // cntrmask[m
[32m+[m[32m         if (in_header)[m
[32m+[m[32m            maskbits += (sp / 2); // implicit "vstem"[m
[32m+[m[32m         in_header = 0;[m
[32m+[m[32m         stbtt__buf_skip(&b, (maskbits + 7) / 8);[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case 0x01: // hstem[m
[32m+[m[32m      case 0x03: // vstem[m
[32m+[m[32m      case 0x12: // hstemhm[m
[32m+[m[32m      case 0x17: // vstemhm[m
[32m+[m[32m         maskbits += (sp / 2);[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case 0x15: // rmoveto[m
[32m+[m[32m         in_header = 0;[m
[32m+[m[32m         if (sp < 2) return STBTT__CSERR("rmoveto stack");[m
[32m+[m[32m         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);[m
[32m+[m[32m         break;[m
[32m+[m[32m      case 0x04: // vmoveto[m
[32m+[m[32m         in_header = 0;[m
[32m+[m[32m         if (sp < 1) return STBTT__CSERR("vmoveto stack");[m
[32m+[m[32m         stbtt__csctx_rmove_to(c, 0, s[sp-1]);[m
[32m+[m[32m         break;[m
[32m+[m[32m      case 0x16: // hmoveto[m
[32m+[m[32m         in_header = 0;[m
[32m+[m[32m         if (sp < 1) return STBTT__CSERR("hmoveto stack");[m
[32m+[m[32m         stbtt__csctx_rmove_to(c, s[sp-1], 0);[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case 0x05: // rlineto[m
[32m+[m[32m         if (sp < 2) return STBTT__CSERR("rlineto stack");[m
[32m+[m[32m         for (; i + 1 < sp; i += 2)[m
[32m+[m[32m            stbtt__csctx_rline_to(c, s[i], s[i+1]);[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical[m
[32m+[m[32m      // starting from a different place.[m
[32m+[m
[32m+[m[32m      case 0x07: // vlineto[m
[32m+[m[32m         if (sp < 1) return STBTT__CSERR("vlineto stack");[m
[32m+[m[32m         goto vlineto;[m
[32m+[m[32m      case 0x06: // hlineto[m
[32m+[m[32m         if (sp < 1) return STBTT__CSERR("hlineto stack");[m
[32m+[m[32m         for (;;) {[m
[32m+[m[32m            if (i >= sp) break;[m
[32m+[m[32m            stbtt__csctx_rline_to(c, s[i], 0);[m
[32m+[m[32m            i++;[m
[32m+[m[32m      vlineto:[m
[32m+[m[32m            if (i >= sp) break;[m
[32m+[m[32m            stbtt__csctx_rline_to(c, 0, s[i]);[m
[32m+[m[32m            i++;[m
[32m+[m[32m         }[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case 0x1F: // hvcurveto[m
[32m+[m[32m         if (sp < 4) return STBTT__CSERR("hvcurveto stack");[m
[32m+[m[32m         goto hvcurveto;[m
[32m+[m[32m      case 0x1E: // vhcurveto[m
[32m+[m[32m         if (sp < 4) return STBTT__CSERR("vhcurveto stack");[m
[32m+[m[32m         for (;;) {[m
[32m+[m[32m            if (i + 3 >= sp) break;[m
[32m+[m[32m            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);[m
[32m+[m[32m            i += 4;[m
[32m+[m[32m      hvcurveto:[m
[32m+[m[32m            if (i + 3 >= sp) break;[m
[32m+[m[32m            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);[m
[32m+[m[32m            i += 4;[m
[32m+[m[32m         }[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case 0x08: // rrcurveto[m
[32m+[m[32m         if (sp < 6) return STBTT__CSERR("rcurveline stack");[m
[32m+[m[32m         for (; i + 5 < sp; i += 6)[m
[32m+[m[32m            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case 0x18: // rcurveline[m
[32m+[m[32m         if (sp < 8) return STBTT__CSERR("rcurveline stack");[m
[32m+[m[32m         for (; i + 5 < sp - 2; i += 6)[m
[32m+[m[32m            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);[m
[32m+[m[32m         if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");[m
[32m+[m[32m         stbtt__csctx_rline_to(c, s[i], s[i+1]);[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case 0x19: // rlinecurve[m
[32m+[m[32m         if (sp < 8) return STBTT__CSERR("rlinecurve stack");[m
[32m+[m[32m         for (; i + 1 < sp - 6; i += 2)[m
[32m+[m[32m            stbtt__csctx_rline_to(c, s[i], s[i+1]);[m
[32m+[m[32m         if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");[m
[32m+[m[32m         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case 0x1A: // vvcurveto[m
[32m+[m[32m      case 0x1B: // hhcurveto[m
[32m+[m[32m         if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");[m
[32m+[m[32m         f = 0.0;[m
[32m+[m[32m         if (sp & 1) { f = s[i]; i++; }[m
[32m+[m[32m         for (; i + 3 < sp; i += 4) {[m
[32m+[m[32m            if (b0 == 0x1B)[m
[32m+[m[32m               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);[m
[32m+[m[32m            else[m
[32m+[m[32m               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);[m
[32m+[m[32m            f = 0.0;[m
[32m+[m[32m         }[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case 0x0A: // callsubr[m
[32m+[m[32m         if (!has_subrs) {[m
[32m+[m[32m            if (info->fdselect.size)[m
[32m+[m[32m               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);[m
[32m+[m[32m            has_subrs = 1;[m
[32m+[m[32m         }[m
[32m+[m[32m         // fallthrough[m
[32m+[m[32m      case 0x1D: // callgsubr[m
[32m+[m[32m         if (sp < 1) return STBTT__CSERR("call(g|)subr stack");[m
[32m+[m[32m         v = (int) s[--sp];[m
[32m+[m[32m         if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");[m
[32m+[m[32m         subr_stack[subr_stack_height++] = b;[m
[32m+[m[32m         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);[m
[32m+[m[32m         if (b.size == 0) return STBTT__CSERR("subr not found");[m
[32m+[m[32m         b.cursor = 0;[m
[32m+[m[32m         clear_stack = 0;[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case 0x0B: // return[m
[32m+[m[32m         if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");[m
[32m+[m[32m         b = subr_stack[--subr_stack_height];[m
[32m+[m[32m         clear_stack = 0;[m
[32m+[m[32m         break;[m
[32m+[m
[32m+[m[32m      case 0x0E: // endchar[m
[32m+[m[32m         stbtt__csctx_close_shape(c);[m
[32m+[m[32m         return 1;[m
[32m+[m
[32m+[m[32m      case 0x0C: { // two-byte escape[m
[32m+[m[32m         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;[m
[32m+[m[32m         float dx, dy;[m
[32m+[m[32m         int b1 = stbtt__buf_get8(&b);[m
[32m+[m[32m         switch (b1) {[m
[32m+[m[32m         // @TODO These "flex" implementations ignore the flex-depth and resolution,[m
[32m+[m[32m         // and always draw beziers.[m
[32m+[m[32m         case 0x22: // hflex[m
[32m+[m[32m            if (sp < 7) return STBTT__CSERR("hflex stack");[m
[32m+[m[32m            dx1 = s[0];[m
[32m+[m[32m            dx2 = s[1];[m
[32m+[m[32m            dy2 = s[2];[m
[32m+[m[32m            dx3 = s[3];[m
[32m+[m[32m            dx4 = s[4];[m
[32m+[m[32m            dx5 = s[5];[m
[32m+[m[32m            dx6 = s[6];[m
[32m+[m[32m            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);[m
[32m+[m[32m            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);[m
[32m+[m[32m            break;[m
[32m+[m
[32m+[m[32m         case 0x23: // flex[m
[32m+[m[32m            if (sp < 13) return STBTT__CSERR("flex stack");[m
[32m+[m[32m            dx1 = s[0];[m
[32m+[m[32m            dy1 = s[1];[m
[32m+[m[32m            dx2 = s[2];[m
[32m+[m[32m            dy2 = s[3];[m
[32m+[m[32m            dx3 = s[4];[m
[32m+[m[32m            dy3 = s[5];[m
[32m+[m[32m            dx4 = s[6];[m
[32m+[m[32m            dy4 = s[7];[m
[32m+[m[32m            dx5 = s[8];[m
[32m+[m[32m            dy5 = s[9];[m
[32m+[m[32m            dx6 = s[10];[m
[32m+[m[32m            dy6 = s[11];[m
[32m+[m[32m            //fd is s[12][m
[32m+[m[32m            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);[m
[32m+[m[32m            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);[m
[32m+[m[32m            break;[m
[32m+[m
[32m+[m[32m         case 0x24: // hflex1[m
[32m+[m[32m            if (sp < 9) return STBTT__CSERR("hflex1 stack");[m
[32m+[m[32m            dx1 = s[0];[m
[32m+[m[32m            dy1 = s[1];[m
[32m+[m[32m            dx2 = s[2];[m
[32m+[m[32m            dy2 = s[3];[m
[32m+[m[32m            dx3 = s[4];[m
[32m+[m[32m            dx4 = s[5];[m
[32m+[m[32m            dx5 = s[6];[m
[32m+[m[32m            dy5 = s[7];[m
[32m+[m[32m            dx6 = s[8];[m
[32m+[m[32m            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);[m
[32m+[m[32m            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));[m
[32m+[m[32m            break;[m
[32m+[m
[32m+[m[32m         case 0x25: // flex1[m
[32m+[m[32m            if (sp < 11) return STBTT__CSERR("flex1 stack");[m
[32m+[m[32m            dx1 = s[0];[m
[32m+[m[32m            dy1 = s[1];[m
[32m+[m[32m            dx2 = s[2];[m
[32m+[m[32m            dy2 = s[3];[m
[32m+[m[32m            dx3 = s[4];[m
[32m+[m[32m            dy3 = s[5];[m
[32m+[m[32m            dx4 = s[6];[m
[32m+[m[32m            dy4 = s[7];[m
[32m+[m[32m            dx5 = s[8];[m
[32m+[m[32m            dy5 = s[9];[m
[32m+[m[32m            dx6 = dy6 = s[10];[m
[32m+[m[32m            dx = dx1+dx2+dx3+dx4+dx5;[m
[32m+[m[32m            dy = dy1+dy2+dy3+dy4+dy5;[m
[32m+[m[32m            if (STBTT_fabs(dx) > STBTT_fabs(dy))[m
[32m+[m[32m               dy6 = -dy;[m
[32m+[m[32m            else[m
[32m+[m[32m               dx6 = -dx;[m
[32m+[m[32m            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);[m
[32m+[m[32m            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);[m
[32m+[m[32m            break;[m
[32m+[m
[32m+[m[32m         default:[m
[32m+[m[32m            return STBTT__CSERR("unimplemented");[m
[32m+[m[32m         }[m
[32m+[m[32m      } break;[m
[32m+[m
[32m+[m[32m      default:[m
[32m+[m[32m         if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254)) //-V560[m
[32m+[m[32m            return STBTT__CSERR("reserved operator");[m
[32m+[m
[32m+[m[32m         // push immediate[m
[32m+[m[32m         if (b0 == 255) {[m
[32m+[m[32m            f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;[m
[32m+[m[32m         } else {[m
[32m+[m[32m            stbtt__buf_skip(&b, -1);[m
[32m+[m[32m            f = (float)(stbtt_int16)stbtt__cff_int(&b);[m
[32m+[m[32m         }[m
[32m+[m[32m         if (sp >= 48) return STBTT__CSERR("push stack overflow");[m
[32m+[m[32m         s[sp++] = f;[m
[32m+[m[32m         clear_stack = 0;[m
[32m+[m[32m         break;[m
[32m+[m[32m      }[m
[32m+[m[32m      if (clear_stack) sp = 0;[m
[32m+[m[32m   }[m
[32m+[m[32m   return STBTT__CSERR("no endchar");[m
[32m+[m
[32m+[m[32m#undef STBTT__CSERR[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)[m
[32m+[m[32m{[m
[32m+[m[32m   // runs the charstring twice, once to count and once to output (to avoid realloc)[m
[32m+[m[32m   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);[m
[32m+[m[32m   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);[m
[32m+[m[32m   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {[m
[32m+[m[32m      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);[m
[32m+[m[32m      output_ctx.pvertices = *pvertices;[m
[32m+[m[32m      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {[m
[32m+[m[32m         STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);[m
[32m+[m[32m         return output_ctx.num_vertices;[m
[32m+[m[32m      }[m
[32m+[m[32m   }[m
[32m+[m[32m   *pvertices = NULL;[m
[32m+[m[32m   return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt__csctx c = STBTT__CSCTX_INIT(1);[m
[32m+[m[32m   int r = stbtt__run_charstring(info, glyph_index, &c);[m
[32m+[m[32m   if (x0)  *x0 = r ? c.min_x : 0;[m
[32m+[m[32m   if (y0)  *y0 = r ? c.min_y : 0;[m
[32m+[m[32m   if (x1)  *x1 = r ? c.max_x : 0;[m
[32m+[m[32m   if (y1)  *y1 = r ? c.max_y : 0;[m
[32m+[m[32m   return r ? c.num_vertices : 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)[m
[32m+[m[32m{[m
[32m+[m[32m   if (!info->cff.size)[m
[32m+[m[32m      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);[m
[32m+[m[32m   else[m
[32m+[m[32m      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);[m
[32m+[m[32m   if (glyph_index < numOfLongHorMetrics) {[m
[32m+[m[32m      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);[m
[32m+[m[32m      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);[m
[32m+[m[32m   } else {[m
[32m+[m[32m      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));[m
[32m+[m[32m      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int  stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_uint8 *data = info->data + info->kern;[m
[32m+[m[32m   stbtt_uint32 needle, straw;[m
[32m+[m[32m   int l, r, m;[m
[32m+[m
[32m+[m[32m   // we only look at the first table. it must be 'horizontal' and format 0.[m
[32m+[m[32m   if (!info->kern)[m
[32m+[m[32m      return 0;[m
[32m+[m[32m   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1[m
[32m+[m[32m      return 0;[m
[32m+[m[32m   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format[m
[32m+[m[32m      return 0;[m
[32m+[m
[32m+[m[32m   l = 0;[m
[32m+[m[32m   r = ttUSHORT(data+10) - 1;[m
[32m+[m[32m   needle = glyph1 << 16 | glyph2;[m
[32m+[m[32m   while (l <= r) {[m
[32m+[m[32m      m = (l + r) >> 1;[m
[32m+[m[32m      straw = ttULONG(data+18+(m*6)); // note: unaligned read[m
[32m+[m[32m      if (needle < straw)[m
[32m+[m[32m         r = m - 1;[m
[32m+[m[32m      else if (needle > straw)[m
[32m+[m[32m         l = m + 1;[m
[32m+[m[32m      else[m
[32m+[m[32m         return ttSHORT(data+22+(m*6));[m
[32m+[m[32m   }[m
[32m+[m[32m   return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic stbtt_int32  stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)[m
[32m+[m[32m{[m
[32m+[m[32m    stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);[m
[32m+[m[32m    switch(coverageFormat) {[m
[32m+[m[32m        case 1: {[m
[32m+[m[32m            stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);[m
[32m+[m
[32m+[m[32m            // Binary search.[m
[32m+[m[32m            stbtt_int32 l=0, r=glyphCount-1, m;[m
[32m+[m[32m            int straw, needle=glyph;[m
[32m+[m[32m            while (l <= r) {[m
[32m+[m[32m                stbtt_uint8 *glyphArray = coverageTable + 4;[m
[32m+[m[32m                stbtt_uint16 glyphID;[m
[32m+[m[32m                m = (l + r) >> 1;[m
[32m+[m[32m                glyphID = ttUSHORT(glyphArray + 2 * m);[m
[32m+[m[32m                straw = glyphID;[m
[32m+[m[32m                if (needle < straw)[m
[32m+[m[32m                    r = m - 1;[m
[32m+[m[32m                else if (needle > straw)[m
[32m+[m[32m                    l = m + 1;[m
[32m+[m[32m                else {[m
[32m+[m[32m                     return m;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        } break;[m
[32m+[m
[32m+[m[32m        case 2: {[m
[32m+[m[32m            stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);[m
[32m+[m[32m            stbtt_uint8 *rangeArray = coverageTable + 4;[m
[32m+[m
[32m+[m[32m            // Binary search.[m
[32m+[m[32m            stbtt_int32 l=0, r=rangeCount-1, m;[m
[32m+[m[32m            int strawStart, strawEnd, needle=glyph;[m
[32m+[m[32m            while (l <= r) {[m
[32m+[m[32m                stbtt_uint8 *rangeRecord;[m
[32m+[m[32m                m = (l + r) >> 1;[m
[32m+[m[32m                rangeRecord = rangeArray + 6 * m;[m
[32m+[m[32m                strawStart = ttUSHORT(rangeRecord);[m
[32m+[m[32m                strawEnd = ttUSHORT(rangeRecord + 2);[m
[32m+[m[32m                if (needle < strawStart)[m
[32m+[m[32m                    r = m - 1;[m
[32m+[m[32m                else if (needle > strawEnd)[m
[32m+[m[32m                    l = m + 1;[m
[32m+[m[32m                else {[m
[32m+[m[32m                    stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);[m
[32m+[m[32m                    return startCoverageIndex + glyph - strawStart;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        } break;[m
[32m+[m
[32m+[m[32m        default: {[m
[32m+[m[32m            // There are no other cases.[m
[32m+[m[32m            STBTT_assert(0);[m
[32m+[m[32m        } break;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return -1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)[m
[32m+[m[32m{[m
[32m+[m[32m    stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);[m
[32m+[m[32m    switch(classDefFormat)[m
[32m+[m[32m    {[m
[32m+[m[32m        case 1: {[m
[32m+[m[32m            stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);[m
[32m+[m[32m            stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);[m
[32m+[m[32m            stbtt_uint8 *classDef1ValueArray = classDefTable + 6;[m
[32m+[m
[32m+[m[32m            if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)[m
[32m+[m[32m                return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));[m
[32m+[m
[32m+[m[32m            // [DEAR IMGUI] Commented to fix static analyzer warning[m
[32m+[m[32m            //classDefTable = classDef1ValueArray + 2 * glyphCount;[m
[32m+[m[32m        } break;[m
[32m+[m
[32m+[m[32m        case 2: {[m
[32m+[m[32m            stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);[m
[32m+[m[32m            stbtt_uint8 *classRangeRecords = classDefTable + 4;[m
[32m+[m
[32m+[m[32m            // Binary search.[m
[32m+[m[32m            stbtt_int32 l=0, r=classRangeCount-1, m;[m
[32m+[m[32m            int strawStart, strawEnd, needle=glyph;[m
[32m+[m[32m            while (l <= r) {[m
[32m+[m[32m                stbtt_uint8 *classRangeRecord;[m
[32m+[m[32m                m = (l + r) >> 1;[m
[32m+[m[32m                classRangeRecord = classRangeRecords + 6 * m;[m
[32m+[m[32m                strawStart = ttUSHORT(classRangeRecord);[m
[32m+[m[32m                strawEnd = ttUSHORT(classRangeRecord + 2);[m
[32m+[m[32m                if (needle < strawStart)[m
[32m+[m[32m                    r = m - 1;[m
[32m+[m[32m                else if (needle > strawEnd)[m
[32m+[m[32m                    l = m + 1;[m
[32m+[m[32m                else[m
[32m+[m[32m                    return (stbtt_int32)ttUSHORT(classRangeRecord + 4);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // [DEAR IMGUI] Commented to fix static analyzer warning[m
[32m+[m[32m            //classDefTable = classRangeRecords + 6 * classRangeCount;[m
[32m+[m[32m        } break;[m
[32m+[m
[32m+[m[32m        default: {[m
[32m+[m[32m            // There are no other cases.[m
[32m+[m[32m            STBTT_assert(0);[m
[32m+[m[32m        } break;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return -1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Define to STBTT_assert(x) if you want to break on unimplemented formats.[m
[32m+[m[32m#define STBTT_GPOS_TODO_assert(x)[m
[32m+[m
[32m+[m[32mstatic stbtt_int32  stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)[m
[32m+[m[32m{[m
[32m+[m[32m    stbtt_uint16 lookupListOffset;[m
[32m+[m[32m    stbtt_uint8 *lookupList;[m
[32m+[m[32m    stbtt_uint16 lookupCount;[m
[32m+[m[32m    stbtt_uint8 *data;[m
[32m+[m[32m    stbtt_int32 i;[m
[32m+[m
[32m+[m[32m    if (!info->gpos) return 0;[m
[32m+[m
[32m+[m[32m    data = info->data + info->gpos;[m
[32m+[m
[32m+[m[32m    if (ttUSHORT(data+0) != 1) return 0; // Major version 1[m
[32m+[m[32m    if (ttUSHORT(data+2) != 0) return 0; // Minor version 0[m
[32m+[m
[32m+[m[32m    lookupListOffset = ttUSHORT(data+8);[m
[32m+[m[32m    lookupList = data + lookupListOffset;[m
[32m+[m[32m    lookupCount = ttUSHORT(lookupList);[m
[32m+[m
[32m+[m[32m    for (i=0; i<lookupCount; ++i) {[m
[32m+[m[32m        stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);[m
[32m+[m[32m        stbtt_uint8 *lookupTable = lookupList + lookupOffset;[m
[32m+[m
[32m+[m[32m        stbtt_uint16 lookupType = ttUSHORT(lookupTable);[m
[32m+[m[32m        stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);[m
[32m+[m[32m        stbtt_uint8 *subTableOffsets = lookupTable + 6;[m
[32m+[m[32m        switch(lookupType) {[m
[32m+[m[32m            case 2: { // Pair Adjustment Positioning Subtable[m
[32m+[m[32m                stbtt_int32 sti;[m
[32m+[m[32m                for (sti=0; sti<subTableCount; sti++) {[m
[32m+[m[32m                    stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);[m
[32m+[m[32m                    stbtt_uint8 *table = lookupTable + subtableOffset;[m
[32m+[m[32m                    stbtt_uint16 posFormat = ttUSHORT(table);[m
[32m+[m[32m                    stbtt_uint16 coverageOffset = ttUSHORT(table + 2);[m
[32m+[m[32m                    stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);[m
[32m+[m[32m                    if (coverageIndex == -1) continue;[m
[32m+[m
[32m+[m[32m                    switch (posFormat) {[m
[32m+[m[32m                        case 1: {[m
[32m+[m[32m                            stbtt_int32 l, r, m;[m
[32m+[m[32m                            int straw, needle;[m
[32m+[m[32m                            stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);[m
[32m+[m[32m                            stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);[m
[32m+[m[32m                            stbtt_int32 valueRecordPairSizeInBytes = 2;[m
[32m+[m[32m                            stbtt_uint16 pairSetCount = ttUSHORT(table + 8);[m
[32m+[m[32m                            stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);[m
[32m+[m[32m                            stbtt_uint8 *pairValueTable = table + pairPosOffset;[m
[32m+[m[32m                            stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);[m
[32m+[m[32m                            stbtt_uint8 *pairValueArray = pairValueTable + 2;[m
[32m+[m[32m                            // TODO: Support more formats.[m
[32m+[m[32m                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);[m
[32m+[m[32m                            if (valueFormat1 != 4) return 0;[m
[32m+[m[32m                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);[m
[32m+[m[32m                            if (valueFormat2 != 0) return 0;[m
[32m+[m
[32m+[m[32m                            STBTT_assert(coverageIndex < pairSetCount);[m
[32m+[m[32m                            STBTT__NOTUSED(pairSetCount);[m
[32m+[m
[32m+[m[32m                            needle=glyph2;[m
[32m+[m[32m                            r=pairValueCount-1;[m
[32m+[m[32m                            l=0;[m
[32m+[m
[32m+[m[32m                            // Binary search.[m
[32m+[m[32m                            while (l <= r) {[m
[32m+[m[32m                                stbtt_uint16 secondGlyph;[m
[32m+[m[32m                                stbtt_uint8 *pairValue;[m
[32m+[m[32m                                m = (l + r) >> 1;[m
[32m+[m[32m                                pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;[m
[32m+[m[32m                                secondGlyph = ttUSHORT(pairValue);[m
[32m+[m[32m                                straw = secondGlyph;[m
[32m+[m[32m                                if (needle < straw)[m
[32m+[m[32m                                    r = m - 1;[m
[32m+[m[32m                                else if (needle > straw)[m
[32m+[m[32m                                    l = m + 1;[m
[32m+[m[32m                                else {[m
[32m+[m[32m                                    stbtt_int16 xAdvance = ttSHORT(pairValue + 2);[m
[32m+[m[32m                                    return xAdvance;[m
[32m+[m[32m                                }[m
[32m+[m[32m                            }[m
[32m+[m[32m                        } break;[m
[32m+[m
[32m+[m[32m                        case 2: {[m
[32m+[m[32m                            stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);[m
[32m+[m[32m                            stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);[m
[32m+[m
[32m+[m[32m                            stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);[m
[32m+[m[32m                            stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);[m
[32m+[m[32m                            int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);[m
[32m+[m[32m                            int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);[m
[32m+[m
[32m+[m[32m                            stbtt_uint16 class1Count = ttUSHORT(table + 12);[m
[32m+[m[32m                            stbtt_uint16 class2Count = ttUSHORT(table + 14);[m
[32m+[m[32m                            STBTT_assert(glyph1class < class1Count);[m
[32m+[m[32m                            STBTT_assert(glyph2class < class2Count);[m
[32m+[m
[32m+[m[32m                            // TODO: Support more formats.[m
[32m+[m[32m                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);[m
[32m+[m[32m                            if (valueFormat1 != 4) return 0;[m
[32m+[m[32m                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);[m
[32m+[m[32m                            if (valueFormat2 != 0) return 0;[m
[32m+[m
[32m+[m[32m                            if (glyph1class >= 0 && glyph1class < class1Count && glyph2class >= 0 && glyph2class < class2Count) {[m
[32m+[m[32m                                stbtt_uint8 *class1Records = table + 16;[m
[32m+[m[32m                                stbtt_uint8 *class2Records = class1Records + 2 * (glyph1class * class2Count);[m
[32m+[m[32m                                stbtt_int16 xAdvance = ttSHORT(class2Records + 2 * glyph2class);[m
[32m+[m[32m                                return xAdvance;[m
[32m+[m[32m                            }[m
[32m+[m[32m                        } break;[m
[32m+[m
[32m+[m[32m                        default: {[m
[32m+[m[32m                            // There are no other cases.[m
[32m+[m[32m                            STBTT_assert(0);[m
[32m+[m[32m                            break;[m
[32m+[m[32m                        };[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                break;[m
[32m+[m[32m            };[m
[32m+[m
[32m+[m[32m            default:[m
[32m+[m[32m                // TODO: Implement other stuff.[m
[32m+[m[32m                break;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)[m
[32m+[m[32m{[m
[32m+[m[32m   int xAdvance = 0;[m
[32m+[m
[32m+[m[32m   if (info->gpos)[m
[32m+[m[32m      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);[m
[32m+[m
[32m+[m[32m   if (info->kern)[m
[32m+[m[32m      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);[m
[32m+[m
[32m+[m[32m   return xAdvance;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)[m
[32m+[m[32m{[m
[32m+[m[32m   if (!info->kern && !info->gpos) // if no kerning table, don't waste time looking up both codepoint->glyphs[m
[32m+[m[32m      return 0;[m
[32m+[m[32m   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)[m
[32m+[m[32m{[m
[32m+[m[32m   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);[m
[32m+[m[32m   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);[m
[32m+[m[32m   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)[m
[32m+[m[32m{[m
[32m+[m[32m   int tab = stbtt__find_table(info->data, info->fontstart, "OS/2");[m
[32m+[m[32m   if (!tab)[m
[32m+[m[32m      return 0;[m
[32m+[m[32m   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);[m
[32m+[m[32m   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);[m
[32m+[m[32m   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);[m
[32m+[m[32m   return 1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)[m
[32m+[m[32m{[m
[32m+[m[32m   *x0 = ttSHORT(info->data + info->head + 36);[m
[32m+[m[32m   *y0 = ttSHORT(info->data + info->head + 38);[m
[32m+[m[32m   *x1 = ttSHORT(info->data + info->head + 40);[m
[32m+[m[32m   *y1 = ttSHORT(info->data + info->head + 42);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)[m
[32m+[m[32m{[m
[32m+[m[32m   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);[m
[32m+[m[32m   return (float) height / fheight;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)[m
[32m+[m[32m{[m
[32m+[m[32m   int unitsPerEm = ttUSHORT(info->data + info->head + 18);[m
[32m+[m[32m   return pixels / unitsPerEm;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)[m
[32m+[m[32m{[m
[32m+[m[32m   STBTT_free(v, info->userdata);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// antialiasing software rasterizer[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)[m
[32m+[m[32m{[m
[32m+[m[32m   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning[m
[32m+[m[32m   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {[m
[32m+[m[32m      // e.g. space character[m
[32m+[m[32m      if (ix0) *ix0 = 0;[m
[32m+[m[32m      if (iy0) *iy0 = 0;[m
[32m+[m[32m      if (ix1) *ix1 = 0;[m
[32m+[m[32m      if (iy1) *iy1 = 0;[m
[32m+[m[32m   } else {[m
[32m+[m[32m      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?[m
[32m+[m[32m      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);[m
[32m+[m[32m      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);[m
[32m+[m[32m      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);[m
[32m+[m[32m      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m//  Rasterizer[m
[32m+[m
[32m+[m[32mtypedef struct stbtt__hheap_chunk[m
[32m+[m[32m{[m
[32m+[m[32m   struct stbtt__hheap_chunk *next;[m
[32m+[m[32m} stbtt__hheap_chunk;[m
[32m+[m
[32m+[m[32mtypedef struct stbtt__hheap[m
[32m+[m[32m{[m
[32m+[m[32m   struct stbtt__hheap_chunk *head;[m
[32m+[m[32m   void   *first_free;[m
[32m+[m[32m   int    num_remaining_in_head_chunk;[m
[32m+[m[32m} stbtt__hheap;[m
[32m+[m
[32m+[m[32mstatic void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)[m
[32m+[m[32m{[m
[32m+[m[32m   if (hh->first_free) {[m
[32m+[m[32m      void *p = hh->first_free;[m
[32m+[m[32m      hh->first_free = * (void **) p;[m
[32m+[m[32m      return p;[m
[32m+[m[32m   } else {[m
[32m+[m[32m      if (hh->num_remaining_in_head_chunk == 0) {[m
[32m+[m[32m         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);[m
[32m+[m[32m         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);[m
[32m+[m[32m         if (c == NULL)[m
[32m+[m[32m            return NULL;[m
[32m+[m[32m         c->next = hh->head;[m
[32m+[m[32m         hh->head = c;[m
[32m+[m[32m         hh->num_remaining_in_head_chunk = count;[m
[32m+[m[32m      }[m
[32m+[m[32m      --hh->num_remaining_in_head_chunk;[m
[32m+[m[32m      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__hheap_free(stbtt__hheap *hh, void *p)[m
[32m+[m[32m{[m
[32m+[m[32m   *(void **) p = hh->first_free;[m
[32m+[m[32m   hh->first_free = p;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt__hheap_chunk *c = hh->head;[m
[32m+[m[32m   while (c) {[m
[32m+[m[32m      stbtt__hheap_chunk *n = c->next;[m
[32m+[m[32m      STBTT_free(c, userdata);[m
[32m+[m[32m      c = n;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mtypedef struct stbtt__edge {[m
[32m+[m[32m   float x0,y0, x1,y1;[m
[32m+[m[32m   int invert;[m
[32m+[m[32m} stbtt__edge;[m
[32m+[m
[32m+[m
[32m+[m[32mtypedef struct stbtt__active_edge[m
[32m+[m[32m{[m
[32m+[m[32m   struct stbtt__active_edge *next;[m
[32m+[m[32m   #if STBTT_RASTERIZER_VERSION==1[m
[32m+[m[32m   int x,dx;[m
[32m+[m[32m   float ey;[m
[32m+[m[32m   int direction;[m
[32m+[m[32m   #elif STBTT_RASTERIZER_VERSION==2[m
[32m+[m[32m   float fx,fdx,fdy;[m
[32m+[m[32m   float direction;[m
[32m+[m[32m   float sy;[m
[32m+[m[32m   float ey;[m
[32m+[m[32m   #else[m
[32m+[m[32m   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"[m
[32m+[m[32m   #endif[m
[32m+[m[32m} stbtt__active_edge;[m
[32m+[m
[32m+[m[32m#if STBTT_RASTERIZER_VERSION == 1[m
[32m+[m[32m#define STBTT_FIXSHIFT   10[m
[32m+[m[32m#define STBTT_FIX        (1 << STBTT_FIXSHIFT)[m
[32m+[m[32m#define STBTT_FIXMASK    (STBTT_FIX-1)[m
[32m+[m
[32m+[m[32mstatic stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);[m
[32m+[m[32m   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);[m
[32m+[m[32m   STBTT_assert(z != NULL);[m
[32m+[m[32m   if (!z) return z;[m
[32m+[m[41m   [m
[32m+[m[32m   // round dx down to avoid overshooting[m
[32m+[m[32m   if (dxdy < 0)[m
[32m+[m[32m      z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);[m
[32m+[m[32m   else[m
[32m+[m[32m      z->dx = STBTT_ifloor(STBTT_FIX * dxdy);[m
[32m+[m
[32m+[m[32m   z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount[m
[32m+[m[32m   z->x -= off_x * STBTT_FIX;[m
[32m+[m
[32m+[m[32m   z->ey = e->y1;[m
[32m+[m[32m   z->next = 0;[m
[32m+[m[32m   z->direction = e->invert ? 1 : -1;[m
[32m+[m[32m   return z;[m
[32m+[m[32m}[m
[32m+[m[32m#elif STBTT_RASTERIZER_VERSION == 2[m
[32m+[m[32mstatic stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);[m
[32m+[m[32m   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);[m
[32m+[m[32m   STBTT_assert(z != NULL);[m
[32m+[m[32m   //STBTT_assert(e->y0 <= start_point);[m
[32m+[m[32m   if (!z) return z;[m
[32m+[m[32m   z->fdx = dxdy;[m
[32m+[m[32m   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;[m
[32m+[m[32m   z->fx = e->x0 + dxdy * (start_point - e->y0);[m
[32m+[m[32m   z->fx -= off_x;[m
[32m+[m[32m   z->direction = e->invert ? 1.0f : -1.0f;[m
[32m+[m[32m   z->sy = e->y0;[m
[32m+[m[32m   z->ey = e->y1;[m
[32m+[m[32m   z->next = 0;[m
[32m+[m[32m   return z;[m
[32m+[m[32m}[m
[32m+[m[32m#else[m
[32m+[m[32m#error "Unrecognized value of STBTT_RASTERIZER_VERSION"[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if STBTT_RASTERIZER_VERSION == 1[m
[32m+[m[32m// note: this routine clips fills that extend off the edges... ideally this[m
[32m+[m[32m// wouldn't happen, but it could happen if the truetype glyph bounding boxes[m
[32m+[m[32m// are wrong, or if the user supplies a too-small bitmap[m
[32m+[m[32mstatic void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)[m
[32m+[m[32m{[m
[32m+[m[32m   // non-zero winding fill[m
[32m+[m[32m   int x0=0, w=0;[m
[32m+[m
[32m+[m[32m   while (e) {[m
[32m+[m[32m      if (w == 0) {[m
[32m+[m[32m         // if we're currently at zero, we need to record the edge start point[m
[32m+[m[32m         x0 = e->x; w += e->direction;[m
[32m+[m[32m      } else {[m
[32m+[m[32m         int x1 = e->x; w += e->direction;[m
[32m+[m[32m         // if we went to zero, we need to draw[m
[32m+[m[32m         if (w == 0) {[m
[32m+[m[32m            int i = x0 >> STBTT_FIXSHIFT;[m
[32m+[m[32m            int j = x1 >> STBTT_FIXSHIFT;[m
[32m+[m
[32m+[m[32m            if (i < len && j >= 0) {[m
[32m+[m[32m               if (i == j) {[m
[32m+[m[32m                  // x0,x1 are the same pixel, so compute combined coverage[m
[32m+[m[32m                  scanline[i] = scanline[i] + (stbtt_uint8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);[m
[32m+[m[32m               } else {[m
[32m+[m[32m                  if (i >= 0) // add antialiasing for x0[m
[32m+[m[32m                     scanline[i] = scanline[i] + (stbtt_uint8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);[m
[32m+[m[32m                  else[m
[32m+[m[32m                     i = -1; // clip[m
[32m+[m
[32m+[m[32m                  if (j < len) // add antialiasing for x1[m
[32m+[m[32m                     scanline[j] = scanline[j] + (stbtt_uint8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);[m
[32m+[m[32m                  else[m
[32m+[m[32m                     j = len; // clip[m
[32m+[m
[32m+[m[32m                  for (++i; i < j; ++i) // fill pixels between x0 and x1[m
[32m+[m[32m                     scanline[i] = scanline[i] + (stbtt_uint8) max_weight;[m
[32m+[m[32m               }[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m
[32m+[m[32m      }[m
[32m+[m[41m      [m
[32m+[m[32m      e = e->next;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt__hheap hh = { 0, 0, 0 };[m
[32m+[m[32m   stbtt__active_edge *active = NULL;[m
[32m+[m[32m   int y,j=0;[m
[32m+[m[32m   int max_weight = (255 / vsubsample);  // weight per vertical scanline[m
[32m+[m[32m   int s; // vertical subsample index[m
[32m+[m[32m   unsigned char scanline_data[512], *scanline;[m
[32m+[m
[32m+[m[32m   if (result->w > 512)[m
[32m+[m[32m      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);[m
[32m+[m[32m   else[m
[32m+[m[32m      scanline = scanline_data;[m
[32m+[m
[32m+[m[32m   y = off_y * vsubsample;[m
[32m+[m[32m   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;[m
[32m+[m
[32m+[m[32m   while (j < result->h) {[m
[32m+[m[32m      STBTT_memset(scanline, 0, result->w);[m
[32m+[m[32m      for (s=0; s < vsubsample; ++s) {[m
[32m+[m[32m         // find center of pixel for this scanline[m
[32m+[m[32m         float scan_y = y + 0.5f;[m
[32m+[m[32m         stbtt__active_edge **step = &active;[m
[32m+[m
[32m+[m[32m         // update all active edges;[m
[32m+[m[32m         // remove all active edges that terminate before the center of this scanline[m
[32m+[m[32m         while (*step) {[m
[32m+[m[32m            stbtt__active_edge * z = *step;[m
[32m+[m[32m            if (z->ey <= scan_y) {[m
[32m+[m[32m               *step = z->next; // delete from list[m
[32m+[m[32m               STBTT_assert(z->direction);[m
[32m+[m[32m               z->direction = 0;[m
[32m+[m[32m               stbtt__hheap_free(&hh, z);[m
[32m+[m[32m            } else {[m
[32m+[m[32m               z->x += z->dx; // advance to position for current scanline[m
[32m+[m[32m               step = &((*step)->next); // advance through list[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m
[32m+[m
[32m+[m[32m         // resort the list if needed[m
[32m+[m[32m         for(;;) {[m
[32m+[m[32m            int changed=0;[m
[32m+[m[32m            step = &active;[m
[32m+[m[32m            while (*step && (*step)->next) {[m
[32m+[m[32m               if ((*step)->x > (*step)->next->x) {[m
[32m+[m[32m                  stbtt__active_edge *t = *step;[m
[32m+[m[32m                  stbtt__active_edge *q = t->next;[m
[32m+[m
[32m+[m[32m                  t->next = q->next;[m
[32m+[m[32m                  q->next = t;[m
[32m+[m[32m                  *step = q;[m
[32m+[m[32m                  changed = 1;[m
[32m+[m[32m               }[m
[32m+[m[32m               step = &(*step)->next;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (!changed) break;[m
[32m+[m[32m         }[m
[32m+[m
[32m+[m[32m         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline[m
[32m+[m[32m         while (e->y0 <= scan_y) {[m
[32m+[m[32m            if (e->y1 > scan_y) {[m
[32m+[m[32m               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);[m
[32m+[m[32m               if (z != NULL) {[m
[32m+[m[32m                  // find insertion point[m
[32m+[m[32m                  if (active == NULL)[m
[32m+[m[32m                     active = z;[m
[32m+[m[32m                  else if (z->x < active->x) {[m
[32m+[m[32m                     // insert at front[m
[32m+[m[32m                     z->next = active;[m
[32m+[m[32m                     active = z;[m
[32m+[m[32m                  } else {[m
[32m+[m[32m                     // find thing to insert AFTER[m
[32m+[m[32m                     stbtt__active_edge *p = active;[m
[32m+[m[32m                     while (p->next && p->next->x < z->x)[m
[32m+[m[32m                        p = p->next;[m
[32m+[m[32m                     // at this point, p->next->x is NOT < z->x[m
[32m+[m[32m                     z->next = p->next;[m
[32m+[m[32m                     p->next = z;[m
[32m+[m[32m                  }[m
[32m+[m[32m               }[m
[32m+[m[32m            }[m
[32m+[m[32m            ++e;[m
[32m+[m[32m         }[m
[32m+[m
[32m+[m[32m         // now process all active edges in XOR fashion[m
[32m+[m[32m         if (active)[m
[32m+[m[32m            stbtt__fill_active_edges(scanline, result->w, active, max_weight);[m
[32m+[m
[32m+[m[32m         ++y;[m
[32m+[m[32m      }[m
[32m+[m[32m      STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);[m
[32m+[m[32m      ++j;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   stbtt__hheap_cleanup(&hh, userdata);[m
[32m+[m
[32m+[m[32m   if (scanline != scanline_data)[m
[32m+[m[32m      STBTT_free(scanline, userdata);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#elif STBTT_RASTERIZER_VERSION == 2[m
[32m+[m
[32m+[m[32m// the edge passed in here does not cross the vertical line at x or the vertical line at x+1[m
[32m+[m[32m// (i.e. it has already been clipped to those)[m
[32m+[m[32mstatic void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)[m
[32m+[m[32m{[m
[32m+[m[32m   if (y0 == y1) return;[m
[32m+[m[32m   STBTT_assert(y0 < y1);[m
[32m+[m[32m   STBTT_assert(e->sy <= e->ey);[m
[32m+[m[32m   if (y0 > e->ey) return;[m
[32m+[m[32m   if (y1 < e->sy) return;[m
[32m+[m[32m   if (y0 < e->sy) {[m
[32m+[m[32m      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);[m
[32m+[m[32m      y0 = e->sy;[m
[32m+[m[32m   }[m
[32m+[m[32m   if (y1 > e->ey) {[m
[32m+[m[32m      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);[m
[32m+[m[32m      y1 = e->ey;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   if (x0 == x)[m
[32m+[m[32m      STBTT_assert(x1 <= x+1);[m
[32m+[m[32m   else if (x0 == x+1)[m
[32m+[m[32m      STBTT_assert(x1 >= x);[m
[32m+[m[32m   else if (x0 <= x)[m
[32m+[m[32m      STBTT_assert(x1 <= x);[m
[32m+[m[32m   else if (x0 >= x+1)[m
[32m+[m[32m      STBTT_assert(x1 >= x+1);[m
[32m+[m[32m   else[m
[32m+[m[32m      STBTT_assert(x1 >= x && x1 <= x+1);[m
[32m+[m
[32m+[m[32m   if (x0 <= x && x1 <= x)[m
[32m+[m[32m      scanline[x] += e->direction * (y1-y0);[m
[32m+[m[32m   else if (x0 >= x+1 && x1 >= x+1)[m
[32m+[m[32m      ;[m
[32m+[m[32m   else {[m
[32m+[m[32m      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);[m
[32m+[m[32m      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)[m
[32m+[m[32m{[m
[32m+[m[32m   float y_bottom = y_top+1;[m
[32m+[m
[32m+[m[32m   while (e) {[m
[32m+[m[32m      // brute force every pixel[m
[32m+[m
[32m+[m[32m      // compute intersection points with top & bottom[m
[32m+[m[32m      STBTT_assert(e->ey >= y_top);[m
[32m+[m
[32m+[m[32m      if (e->fdx == 0) {[m
[32m+[m[32m         float x0 = e->fx;[m
[32m+[m[32m         if (x0 < len) {[m
[32m+[m[32m            if (x0 >= 0) {[m
[32m+[m[32m               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);[m
[32m+[m[32m               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);[m
[32m+[m[32m            } else {[m
[32m+[m[32m               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m
[32m+[m[32m      } else {[m
[32m+[m[32m         float x0 = e->fx;[m
[32m+[m[32m         float dx = e->fdx;[m
[32m+[m[32m         float xb = x0 + dx;[m
[32m+[m[32m         float x_top, x_bottom;[m
[32m+[m[32m         float sy0,sy1;[m
[32m+[m[32m         float dy = e->fdy;[m
[32m+[m[32m         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);[m
[32m+[m
[32m+[m[32m         // compute endpoints of line segment clipped to this scanline (if the[m
[32m+[m[32m         // line segment starts on this scanline. x0 is the intersection of the[m
[32m+[m[32m         // line with y_top, but that may be off the line segment.[m
[32m+[m[32m         if (e->sy > y_top) {[m
[32m+[m[32m            x_top = x0 + dx * (e->sy - y_top);[m
[32m+[m[32m            sy0 = e->sy;[m
[32m+[m[32m         } else {[m
[32m+[m[32m            x_top = x0;[m
[32m+[m[32m            sy0 = y_top;[m
[32m+[m[32m         }[m
[32m+[m[32m         if (e->ey < y_bottom) {[m
[32m+[m[32m            x_bottom = x0 + dx * (e->ey - y_top);[m
[32m+[m[32m            sy1 = e->ey;[m
[32m+[m[32m         } else {[m
[32m+[m[32m            x_bottom = xb;[m
[32m+[m[32m            sy1 = y_bottom;[m
[32m+[m[32m         }[m
[32m+[m
[32m+[m[32m         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {[m
[32m+[m[32m            // from here on, we don't have to range check x values[m
[32m+[m
[32m+[m[32m            if ((int) x_top == (int) x_bottom) {[m
[32m+[m[32m               float height;[m
[32m+[m[32m               // simple case, only spans one pixel[m
[32m+[m[32m               int x = (int) x_top;[m
[32m+[m[32m               height = sy1 - sy0;[m
[32m+[m[32m               STBTT_assert(x >= 0 && x < len);[m
[32m+[m[32m               scanline[x] += e->direction * (1-((x_top - x) + (x_bottom-x))/2)  * height;[m
[32m+[m[32m               scanline_fill[x] += e->direction * height; // everything right of this pixel is filled[m
[32m+[m[32m            } else {[m
[32m+[m[32m               int x,x1,x2;[m
[32m+[m[32m               float y_crossing, step, sign, area;[m
[32m+[m[32m               // covers 2+ pixels[m
[32m+[m[32m               if (x_top > x_bottom) {[m
[32m+[m[32m                  // flip scanline vertically; signed area is the same[m
[32m+[m[32m                  float t;[m
[32m+[m[32m                  sy0 = y_bottom - (sy0 - y_top);[m
[32m+[m[32m                  sy1 = y_bottom - (sy1 - y_top);[m
[32m+[m[32m                  t = sy0, sy0 = sy1, sy1 = t;[m
[32m+[m[32m                  t = x_bottom, x_bottom = x_top, x_top = t;[m
[32m+[m[32m                  dx = -dx;[m
[32m+[m[32m                  dy = -dy;[m
[32m+[m[32m                  t = x0, x0 = xb, xb = t;[m
[32m+[m[32m                  // [DEAR IMGUI] Fix static analyzer warning[m
[32m+[m[32m                  (void)dx; // [ImGui: fix static analyzer warning][m
[32m+[m[32m               }[m
[32m+[m
[32m+[m[32m               x1 = (int) x_top;[m
[32m+[m[32m               x2 = (int) x_bottom;[m
[32m+[m[32m               // compute intersection with y axis at x1+1[m
[32m+[m[32m               y_crossing = (x1+1 - x0) * dy + y_top;[m
[32m+[m
[32m+[m[32m               sign = e->direction;[m
[32m+[m[32m               // area of the rectangle covered from y0..y_crossing[m
[32m+[m[32m               area = sign * (y_crossing-sy0);[m
[32m+[m[32m               // area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)[m
[32m+[m[32m               scanline[x1] += area * (1-((x_top - x1)+(x1+1-x1))/2);[m
[32m+[m
[32m+[m[32m               step = sign * dy;[m
[32m+[m[32m               for (x = x1+1; x < x2; ++x) {[m
[32m+[m[32m                  scanline[x] += area + step/2;[m
[32m+[m[32m                  area += step;[m
[32m+[m[32m               }[m
[32m+[m[32m               y_crossing += dy * (x2 - (x1+1));[m
[32m+[m
[32m+[m[32m               STBTT_assert(STBTT_fabs(area) <= 1.01f);[m
[32m+[m
[32m+[m[32m               scanline[x2] += area + sign * (1-((x2-x2)+(x_bottom-x2))/2) * (sy1-y_crossing);[m
[32m+[m
[32m+[m[32m               scanline_fill[x2] += sign * (sy1-sy0);[m
[32m+[m[32m            }[m
[32m+[m[32m         } else {[m
[32m+[m[32m            // if edge goes outside of box we're drawing, we require[m
[32m+[m[32m            // clipping logic. since this does not match the intended use[m
[32m+[m[32m            // of this library, we use a different, very slow brute[m
[32m+[m[32m            // force implementation[m
[32m+[m[32m            int x;[m
[32m+[m[32m            for (x=0; x < len; ++x) {[m
[32m+[m[32m               // cases:[m
[32m+[m[32m               //[m
[32m+[m[32m               // there can be up to two intersections with the pixel. any intersection[m
[32m+[m[32m               // with left or right edges can be handled by splitting into two (or three)[m
[32m+[m[32m               // regions. intersections with top & bottom do not necessitate case-wise logic.[m
[32m+[m[32m               //[m
[32m+[m[32m               // the old way of doing this found the intersections with the left & right edges,[m
[32m+[m[32m               // then used some simple logic to produce up to three segments in sorted order[m
[32m+[m[32m               // from top-to-bottom. however, this had a problem: if an x edge was epsilon[m
[32m+[m[32m               // across the x border, then the corresponding y position might not be distinct[m
[32m+[m[32m               // from the other y segment, and it might ignored as an empty segment. to avoid[m
[32m+[m[32m               // that, we need to explicitly produce segments based on x positions.[m
[32m+[m
[32m+[m[32m               // rename variables to clearly-defined pairs[m
[32m+[m[32m               float y0 = y_top;[m
[32m+[m[32m               float x1 = (float) (x);[m
[32m+[m[32m               float x2 = (float) (x+1);[m
[32m+[m[32m               float x3 = xb;[m
[32m+[m[32m               float y3 = y_bottom;[m
[32m+[m
[32m+[m[32m               // x = e->x + e->dx * (y-y_top)[m
[32m+[m[32m               // (y-y_top) = (x - e->x) / e->dx[m
[32m+[m[32m               // y = (x - e->x) / e->dx + y_top[m
[32m+[m[32m               float y1 = (x - x0) / dx + y_top;[m
[32m+[m[32m               float y2 = (x+1 - x0) / dx + y_top;[m
[32m+[m
[32m+[m[32m               if (x0 < x1 && x3 > x2) {         // three segments descending down-right[m
[32m+[m[32m                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);[m
[32m+[m[32m                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);[m
[32m+[m[32m                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);[m
[32m+[m[32m               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left[m
[32m+[m[32m                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);[m
[32m+[m[32m                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);[m
[32m+[m[32m                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);[m
[32m+[m[32m               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right[m
[32m+[m[32m                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);[m
[32m+[m[32m                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);[m
[32m+[m[32m               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left[m
[32m+[m[32m                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);[m
[32m+[m[32m                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);[m
[32m+[m[32m               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right[m
[32m+[m[32m                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);[m
[32m+[m[32m                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);[m
[32m+[m[32m               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left[m
[32m+[m[32m                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);[m
[32m+[m[32m                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);[m
[32m+[m[32m               } else {  // one segment[m
[32m+[m[32m                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);[m
[32m+[m[32m               }[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m
[32m+[m[32m      }[m
[32m+[m[32m      e = e->next;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// directly AA rasterize edges w/o supersampling[m
[32m+[m[32mstatic void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt__hheap hh = { 0, 0, 0 };[m
[32m+[m[32m   stbtt__active_edge *active = NULL;[m
[32m+[m[32m   int y,j=0, i;[m
[32m+[m[32m   float scanline_data[129], *scanline, *scanline2;[m
[32m+[m
[32m+[m[32m   STBTT__NOTUSED(vsubsample);[m
[32m+[m
[32m+[m[32m   if (result->w > 64)[m
[32m+[m[32m      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);[m
[32m+[m[32m   else[m
[32m+[m[32m      scanline = scanline_data;[m
[32m+[m
[32m+[m[32m   scanline2 = scanline + result->w;[m
[32m+[m
[32m+[m[32m   y = off_y;[m
[32m+[m[32m   e[n].y0 = (float) (off_y + result->h) + 1;[m
[32m+[m
[32m+[m[32m   while (j < result->h) {[m
[32m+[m[32m      // find center of pixel for this scanline[m
[32m+[m[32m      float scan_y_top    = y + 0.0f;[m
[32m+[m[32m      float scan_y_bottom = y + 1.0f;[m
[32m+[m[32m      stbtt__active_edge **step = &active;[m
[32m+[m
[32m+[m[32m      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));[m
[32m+[m[32m      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));[m
[32m+[m
[32m+[m[32m      // update all active edges;[m
[32m+[m[32m      // remove all active edges that terminate before the top of this scanline[m
[32m+[m[32m      while (*step) {[m
[32m+[m[32m         stbtt__active_edge * z = *step;[m
[32m+[m[32m         if (z->ey <= scan_y_top) {[m
[32m+[m[32m            *step = z->next; // delete from list[m
[32m+[m[32m            STBTT_assert(z->direction);[m
[32m+[m[32m            z->direction = 0;[m
[32m+[m[32m            stbtt__hheap_free(&hh, z);[m
[32m+[m[32m         } else {[m
[32m+[m[32m            step = &((*step)->next); // advance through list[m
[32m+[m[32m         }[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      // insert all edges that start before the bottom of this scanline[m
[32m+[m[32m      while (e->y0 <= scan_y_bottom) {[m
[32m+[m[32m         if (e->y0 != e->y1) {[m
[32m+[m[32m            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);[m
[32m+[m[32m            if (z != NULL) {[m
[32m+[m[32m               if (j == 0 && off_y != 0) {[m
[32m+[m[32m                  if (z->ey < scan_y_top) {[m
[32m+[m[32m                     // this can happen due to subpixel positioning and some kind of fp rounding error i think[m
[32m+[m[32m                     z->ey = scan_y_top;[m
[32m+[m[32m                  }[m
[32m+[m[32m               }[m
[32m+[m[32m               STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds[m
[32m+[m[32m               // insert at front[m
[32m+[m[32m               z->next = active;[m
[32m+[m[32m               active = z;[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m
[32m+[m[32m         ++e;[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      // now process all active edges[m
[32m+[m[32m      if (active)[m
[32m+[m[32m         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);[m
[32m+[m
[32m+[m[32m      {[m
[32m+[m[32m         float sum = 0;[m
[32m+[m[32m         for (i=0; i < result->w; ++i) {[m
[32m+[m[32m            float k;[m
[32m+[m[32m            int m;[m
[32m+[m[32m            sum += scanline2[i];[m
[32m+[m[32m            k = scanline[i] + sum;[m
[32m+[m[32m            k = (float) STBTT_fabs(k)*255 + 0.5f;[m
[32m+[m[32m            m = (int) k;[m
[32m+[m[32m            if (m > 255) m = 255;[m
[32m+[m[32m            result->pixels[j*result->stride + i] = (unsigned char) m;[m
[32m+[m[32m         }[m
[32m+[m[32m      }[m
[32m+[m[32m      // advance all the edges[m
[32m+[m[32m      step = &active;[m
[32m+[m[32m      while (*step) {[m
[32m+[m[32m         stbtt__active_edge *z = *step;[m
[32m+[m[32m         z->fx += z->fdx; // advance to position for current scanline[m
[32m+[m[32m         step = &((*step)->next); // advance through list[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      ++y;[m
[32m+[m[32m      ++j;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   stbtt__hheap_cleanup(&hh, userdata);[m
[32m+[m
[32m+[m[32m   if (scanline != scanline_data)[m
[32m+[m[32m      STBTT_free(scanline, userdata);[m
[32m+[m[32m}[m
[32m+[m[32m#else[m
[32m+[m[32m#error "Unrecognized value of STBTT_RASTERIZER_VERSION"[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)[m
[32m+[m
[32m+[m[32mstatic void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)[m
[32m+[m[32m{[m
[32m+[m[32m   int i,j;[m
[32m+[m[32m   for (i=1; i < n; ++i) {[m
[32m+[m[32m      stbtt__edge t = p[i], *a = &t;[m
[32m+[m[32m      j = i;[m
[32m+[m[32m      while (j > 0) {[m
[32m+[m[32m         stbtt__edge *b = &p[j-1];[m
[32m+[m[32m         int c = STBTT__COMPARE(a,b);[m
[32m+[m[32m         if (!c) break;[m
[32m+[m[32m         p[j] = p[j-1];[m
[32m+[m[32m         --j;[m
[32m+[m[32m      }[m
[32m+[m[32m      if (i != j)[m
[32m+[m[32m         p[j] = t;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)[m
[32m+[m[32m{[m
[32m+[m[32m   /* threshold for transitioning to insertion sort */[m
[32m+[m[32m   while (n > 12) {[m
[32m+[m[32m      stbtt__edge t;[m
[32m+[m[32m      int c01,c12,c,m,i,j;[m
[32m+[m
[32m+[m[32m      /* compute median of three */[m
[32m+[m[32m      m = n >> 1;[m
[32m+[m[32m      c01 = STBTT__COMPARE(&p[0],&p[m]);[m
[32m+[m[32m      c12 = STBTT__COMPARE(&p[m],&p[n-1]);[m
[32m+[m[32m      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */[m
[32m+[m[32m      if (c01 != c12) {[m
[32m+[m[32m         /* otherwise, we'll need to swap something else to middle */[m
[32m+[m[32m         int z;[m
[32m+[m[32m         c = STBTT__COMPARE(&p[0],&p[n-1]);[m
[32m+[m[32m         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */[m
[32m+[m[32m         /* 0<mid && mid>n:  0>n => 0; 0<n => n */[m
[32m+[m[32m         z = (c == c12) ? 0 : n-1;[m
[32m+[m[32m         t = p[z];[m
[32m+[m[32m         p[z] = p[m];[m
[32m+[m[32m         p[m] = t;[m
[32m+[m[32m      }[m
[32m+[m[32m      /* now p[m] is the median-of-three */[m
[32m+[m[32m      /* swap it to the beginning so it won't move around */[m
[32m+[m[32m      t = p[0];[m
[32m+[m[32m      p[0] = p[m];[m
[32m+[m[32m      p[m] = t;[m
[32m+[m
[32m+[m[32m      /* partition loop */[m
[32m+[m[32m      i=1;[m
[32m+[m[32m      j=n-1;[m
[32m+[m[32m      for(;;) {[m
[32m+[m[32m         /* handling of equality is crucial here */[m
[32m+[m[32m         /* for sentinels & efficiency with duplicates */[m
[32m+[m[32m         for (;;++i) {[m
[32m+[m[32m            if (!STBTT__COMPARE(&p[i], &p[0])) break;[m
[32m+[m[32m         }[m
[32m+[m[32m         for (;;--j) {[m
[32m+[m[32m            if (!STBTT__COMPARE(&p[0], &p[j])) break;[m
[32m+[m[32m         }[m
[32m+[m[32m         /* make sure we haven't crossed */[m
[32m+[m[32m         if (i >= j) break;[m
[32m+[m[32m         t = p[i];[m
[32m+[m[32m         p[i] = p[j];[m
[32m+[m[32m         p[j] = t;[m
[32m+[m
[32m+[m[32m         ++i;[m
[32m+[m[32m         --j;[m
[32m+[m[32m      }[m
[32m+[m[32m      /* recurse on smaller side, iterate on larger */[m
[32m+[m[32m      if (j < (n-i)) {[m
[32m+[m[32m         stbtt__sort_edges_quicksort(p,j);[m
[32m+[m[32m         p = p+i;[m
[32m+[m[32m         n = n-i;[m
[32m+[m[32m      } else {[m
[32m+[m[32m         stbtt__sort_edges_quicksort(p+i, n-i);[m
[32m+[m[32m         n = j;[m
[32m+[m[32m      }[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__sort_edges(stbtt__edge *p, int n)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt__sort_edges_quicksort(p, n);[m
[32m+[m[32m   stbtt__sort_edges_ins_sort(p, n);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m   float x,y;[m
[32m+[m[32m} stbtt__point;[m
[32m+[m
[32m+[m[32mstatic void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)[m
[32m+[m[32m{[m
[32m+[m[32m   float y_scale_inv = invert ? -scale_y : scale_y;[m
[32m+[m[32m   stbtt__edge *e;[m
[32m+[m[32m   int n,i,j,k,m;[m
[32m+[m[32m#if STBTT_RASTERIZER_VERSION == 1[m
[32m+[m[32m   int vsubsample = result->h < 8 ? 15 : 5;[m
[32m+[m[32m#elif STBTT_RASTERIZER_VERSION == 2[m
[32m+[m[32m   int vsubsample = 1;[m
[32m+[m[32m#else[m
[32m+[m[32m   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"[m
[32m+[m[32m#endif[m
[32m+[m[32m   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity[m
[32m+[m
[32m+[m[32m   // now we have to blow out the windings into explicit edge lists[m
[32m+[m[32m   n = 0;[m
[32m+[m[32m   for (i=0; i < windings; ++i)[m
[32m+[m[32m      n += wcount[i];[m
[32m+[m
[32m+[m[32m   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel[m
[32m+[m[32m   if (e == 0) return;[m
[32m+[m[32m   n = 0;[m
[32m+[m
[32m+[m[32m   m=0;[m
[32m+[m[32m   for (i=0; i < windings; ++i) {[m
[32m+[m[32m      stbtt__point *p = pts + m;[m
[32m+[m[32m      m += wcount[i];[m
[32m+[m[32m      j = wcount[i]-1;[m
[32m+[m[32m      for (k=0; k < wcount[i]; j=k++) {[m
[32m+[m[32m         int a=k,b=j;[m
[32m+[m[32m         // skip the edge if horizontal[m
[32m+[m[32m         if (p[j].y == p[k].y)[m
[32m+[m[32m            continue;[m
[32m+[m[32m         // add edge from j to k to the list[m
[32m+[m[32m         e[n].invert = 0;[m
[32m+[m[32m         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {[m
[32m+[m[32m            e[n].invert = 1;[m
[32m+[m[32m            a=j,b=k;[m
[32m+[m[32m         }[m
[32m+[m[32m         e[n].x0 = p[a].x * scale_x + shift_x;[m
[32m+[m[32m         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;[m
[32m+[m[32m         e[n].x1 = p[b].x * scale_x + shift_x;[m
[32m+[m[32m         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;[m
[32m+[m[32m         ++n;[m
[32m+[m[32m      }[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   // now sort the edges by their highest point (should snap to integer, and then by x)[m
[32m+[m[32m   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);[m
[32m+[m[32m   stbtt__sort_edges(e, n);[m
[32m+[m
[32m+[m[32m   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule[m
[32m+[m[32m   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);[m
[32m+[m
[32m+[m[32m   STBTT_free(e, userdata);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__add_point(stbtt__point *points, int n, float x, float y)[m
[32m+[m[32m{[m
[32m+[m[32m   if (!points) return; // during first pass, it's unallocated[m
[32m+[m[32m   points[n].x = x;[m
[32m+[m[32m   points[n].y = y;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// tessellate until threshold p is happy... @TODO warped to compensate for non-linear stretching[m
[32m+[m[32mstatic int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)[m
[32m+[m[32m{[m
[32m+[m[32m   // midpoint[m
[32m+[m[32m   float mx = (x0 + 2*x1 + x2)/4;[m
[32m+[m[32m   float my = (y0 + 2*y1 + y2)/4;[m
[32m+[m[32m   // versus directly drawn line[m
[32m+[m[32m   float dx = (x0+x2)/2 - mx;[m
[32m+[m[32m   float dy = (y0+y2)/2 - my;[m
[32m+[m[32m   if (n > 16) // 65536 segments on one curve better be enough![m
[32m+[m[32m      return 1;[m
[32m+[m[32m   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA[m
[32m+[m[32m      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);[m
[32m+[m[32m      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);[m
[32m+[m[32m   } else {[m
[32m+[m[32m      stbtt__add_point(points, *num_points,x2,y2);[m
[32m+[m[32m      *num_points = *num_points+1;[m
[32m+[m[32m   }[m
[32m+[m[32m   return 1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)[m
[32m+[m[32m{[m
[32m+[m[32m   // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough[m
[32m+[m[32m   float dx0 = x1-x0;[m
[32m+[m[32m   float dy0 = y1-y0;[m
[32m+[m[32m   float dx1 = x2-x1;[m
[32m+[m[32m   float dy1 = y2-y1;[m
[32m+[m[32m   float dx2 = x3-x2;[m
[32m+[m[32m   float dy2 = y3-y2;[m
[32m+[m[32m   float dx = x3-x0;[m
[32m+[m[32m   float dy = y3-y0;[m
[32m+[m[32m   float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));[m
[32m+[m[32m   float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);[m
[32m+[m[32m   float flatness_squared = longlen*longlen-shortlen*shortlen;[m
[32m+[m
[32m+[m[32m   if (n > 16) // 65536 segments on one curve better be enough![m
[32m+[m[32m      return;[m
[32m+[m
[32m+[m[32m   if (flatness_squared > objspace_flatness_squared) {[m
[32m+[m[32m      float x01 = (x0+x1)/2;[m
[32m+[m[32m      float y01 = (y0+y1)/2;[m
[32m+[m[32m      float x12 = (x1+x2)/2;[m
[32m+[m[32m      float y12 = (y1+y2)/2;[m
[32m+[m[32m      float x23 = (x2+x3)/2;[m
[32m+[m[32m      float y23 = (y2+y3)/2;[m
[32m+[m
[32m+[m[32m      float xa = (x01+x12)/2;[m
[32m+[m[32m      float ya = (y01+y12)/2;[m
[32m+[m[32m      float xb = (x12+x23)/2;[m
[32m+[m[32m      float yb = (y12+y23)/2;[m
[32m+[m
[32m+[m[32m      float mx = (xa+xb)/2;[m
[32m+[m[32m      float my = (ya+yb)/2;[m
[32m+[m
[32m+[m[32m      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);[m
[32m+[m[32m      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);[m
[32m+[m[32m   } else {[m
[32m+[m[32m      stbtt__add_point(points, *num_points,x3,y3);[m
[32m+[m[32m      *num_points = *num_points+1;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// returns number of contours[m
[32m+[m[32mstatic stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt__point *points=0;[m
[32m+[m[32m   int num_points=0;[m
[32m+[m
[32m+[m[32m   float objspace_flatness_squared = objspace_flatness * objspace_flatness;[m
[32m+[m[32m   int i,n=0,start=0, pass;[m
[32m+[m
[32m+[m[32m   // count how many "moves" there are to get the contour count[m
[32m+[m[32m   for (i=0; i < num_verts; ++i)[m
[32m+[m[32m      if (vertices[i].type == STBTT_vmove)[m
[32m+[m[32m         ++n;[m
[32m+[m
[32m+[m[32m   *num_contours = n;[m
[32m+[m[32m   if (n == 0) return 0;[m
[32m+[m
[32m+[m[32m   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);[m
[32m+[m
[32m+[m[32m   if (*contour_lengths == 0) {[m
[32m+[m[32m      *num_contours = 0;[m
[32m+[m[32m      return 0;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   // make two passes through the points so we don't need to realloc[m
[32m+[m[32m   for (pass=0; pass < 2; ++pass) {[m
[32m+[m[32m      float x=0,y=0;[m
[32m+[m[32m      if (pass == 1) {[m
[32m+[m[32m         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);[m
[32m+[m[32m         if (points == NULL) goto error;[m
[32m+[m[32m      }[m
[32m+[m[32m      num_points = 0;[m
[32m+[m[32m      n= -1;[m
[32m+[m[32m      for (i=0; i < num_verts; ++i) {[m
[32m+[m[32m         switch (vertices[i].type) {[m
[32m+[m[32m            case STBTT_vmove:[m
[32m+[m[32m               // start the next contour[m
[32m+[m[32m               if (n >= 0)[m
[32m+[m[32m                  (*contour_lengths)[n] = num_points - start;[m
[32m+[m[32m               ++n;[m
[32m+[m[32m               start = num_points;[m
[32m+[m
[32m+[m[32m               x = vertices[i].x, y = vertices[i].y;[m
[32m+[m[32m               stbtt__add_point(points, num_points++, x,y);[m
[32m+[m[32m               break;[m
[32m+[m[32m            case STBTT_vline:[m
[32m+[m[32m               x = vertices[i].x, y = vertices[i].y;[m
[32m+[m[32m               stbtt__add_point(points, num_points++, x, y);[m
[32m+[m[32m               break;[m
[32m+[m[32m            case STBTT_vcurve:[m
[32m+[m[32m               stbtt__tesselate_curve(points, &num_points, x,y,[m
[32m+[m[32m                                        vertices[i].cx, vertices[i].cy,[m
[32m+[m[32m                                        vertices[i].x,  vertices[i].y,[m
[32m+[m[32m                                        objspace_flatness_squared, 0);[m
[32m+[m[32m               x = vertices[i].x, y = vertices[i].y;[m
[32m+[m[32m               break;[m
[32m+[m[32m            case STBTT_vcubic:[m
[32m+[m[32m               stbtt__tesselate_cubic(points, &num_points, x,y,[m
[32m+[m[32m                                        vertices[i].cx, vertices[i].cy,[m
[32m+[m[32m                                        vertices[i].cx1, vertices[i].cy1,[m
[32m+[m[32m                                        vertices[i].x,  vertices[i].y,[m
[32m+[m[32m                                        objspace_flatness_squared, 0);[m
[32m+[m[32m               x = vertices[i].x, y = vertices[i].y;[m
[32m+[m[32m               break;[m
[32m+[m[32m         }[m
[32m+[m[32m      }[m
[32m+[m[32m      (*contour_lengths)[n] = num_points - start;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   return points;[m
[32m+[m[32merror:[m
[32m+[m[32m   STBTT_free(points, userdata);[m
[32m+[m[32m   STBTT_free(*contour_lengths, userdata);[m
[32m+[m[32m   *contour_lengths = 0;[m
[32m+[m[32m   *num_contours = 0;[m
[32m+[m[32m   return NULL;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)[m
[32m+[m[32m{[m
[32m+[m[32m   float scale            = scale_x > scale_y ? scale_y : scale_x;[m
[32m+[m[32m   int winding_count      = 0;[m
[32m+[m[32m   int *winding_lengths   = NULL;[m
[32m+[m[32m   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);[m
[32m+[m[32m   if (windings) {[m
[32m+[m[32m      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);[m
[32m+[m[32m      STBTT_free(winding_lengths, userdata);[m
[32m+[m[32m      STBTT_free(windings, userdata);[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)[m
[32m+[m[32m{[m
[32m+[m[32m   STBTT_free(bitmap, userdata);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)[m
[32m+[m[32m{[m
[32m+[m[32m   int ix0,iy0,ix1,iy1;[m
[32m+[m[32m   stbtt__bitmap gbm;[m
[32m+[m[32m   stbtt_vertex *vertices;[m[41m   [m
[32m+[m[32m   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);[m
[32m+[m
[32m+[m[32m   if (scale_x == 0) scale_x = scale_y;[m
[32m+[m[32m   if (scale_y == 0) {[m
[32m+[m[32m      if (scale_x == 0) {[m
[32m+[m[32m         STBTT_free(vertices, info->userdata);[m
[32m+[m[32m         return NULL;[m
[32m+[m[32m      }[m
[32m+[m[32m      scale_y = scale_x;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);[m
[32m+[m
[32m+[m[32m   // now we get the size[m
[32m+[m[32m   gbm.w = (ix1 - ix0);[m
[32m+[m[32m   gbm.h = (iy1 - iy0);[m
[32m+[m[32m   gbm.pixels = NULL; // in case we error[m
[32m+[m
[32m+[m[32m   if (width ) *width  = gbm.w;[m
[32m+[m[32m   if (height) *height = gbm.h;[m
[32m+[m[32m   if (xoff  ) *xoff   = ix0;[m
[32m+[m[32m   if (yoff  ) *yoff   = iy0;[m
[32m+[m[41m   [m
[32m+[m[32m   if (gbm.w && gbm.h) {[m
[32m+[m[32m      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);[m
[32m+[m[32m      if (gbm.pixels) {[m
[32m+[m[32m         gbm.stride = gbm.w;[m
[32m+[m
[32m+[m[32m         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);[m
[32m+[m[32m      }[m
[32m+[m[32m   }[m
[32m+[m[32m   STBTT_free(vertices, info->userdata);[m
[32m+[m[32m   return gbm.pixels;[m
[32m+[m[32m}[m[41m   [m
[32m+[m
[32m+[m[32mSTBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)[m
[32m+[m[32m{[m
[32m+[m[32m   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)[m
[32m+[m[32m{[m
[32m+[m[32m   int ix0,iy0;[m
[32m+[m[32m   stbtt_vertex *vertices;[m
[32m+[m[32m   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);[m
[32m+[m[32m   stbtt__bitmap gbm;[m[41m   [m
[32m+[m
[32m+[m[32m   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);[m
[32m+[m[32m   gbm.pixels = output;[m
[32m+[m[32m   gbm.w = out_w;[m
[32m+[m[32m   gbm.h = out_h;[m
[32m+[m[32m   gbm.stride = out_stride;[m
[32m+[m
[32m+[m[32m   if (gbm.w && gbm.h)[m
[32m+[m[32m      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);[m
[32m+[m
[32m+[m[32m   STBTT_free(vertices, info->userdata);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)[m
[32m+[m[32m{[m
[32m+[m[32m   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);[m
[32m+[m[32m}[m[41m   [m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex(info,codepoint));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)[m
[32m+[m[32m{[m
[32m+[m[32m   return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);[m
[32m+[m[32m}[m[41m   [m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// bitmap baking[m
[32m+[m[32m//[m
[32m+[m[32m// This is SUPER-CRAPPY packing to keep source code small[m
[32m+[m
[32m+[m[32mstatic int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)[m
[32m+[m[32m                                float pixel_height,                     // height of font in pixels[m
[32m+[m[32m                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in[m
[32m+[m[32m                                int first_char, int num_chars,          // characters to bake[m
[32m+[m[32m                                stbtt_bakedchar *chardata)[m
[32m+[m[32m{[m
[32m+[m[32m   float scale;[m
[32m+[m[32m   int x,y,bottom_y, i;[m
[32m+[m[32m   stbtt_fontinfo f;[m
[32m+[m[32m   f.userdata = NULL;[m
[32m+[m[32m   if (!stbtt_InitFont(&f, data, offset))[m
[32m+[m[32m      return -1;[m
[32m+[m[32m   STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels[m
[32m+[m[32m   x=y=1;[m
[32m+[m[32m   bottom_y = 1;[m
[32m+[m
[32m+[m[32m   scale = stbtt_ScaleForPixelHeight(&f, pixel_height);[m
[32m+[m
[32m+[m[32m   for (i=0; i < num_chars; ++i) {[m
[32m+[m[32m      int advance, lsb, x0,y0,x1,y1,gw,gh;[m
[32m+[m[32m      int g = stbtt_FindGlyphIndex(&f, first_char + i);[m
[32m+[m[32m      stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);[m
[32m+[m[32m      stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);[m
[32m+[m[32m      gw = x1-x0;[m
[32m+[m[32m      gh = y1-y0;[m
[32m+[m[32m      if (x + gw + 1 >= pw)[m
[32m+[m[32m         y = bottom_y, x = 1; // advance to next row[m
[32m+[m[32m      if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row[m
[32m+[m[32m         return -i;[m
[32m+[m[32m      STBTT_assert(x+gw < pw);[m
[32m+[m[32m      STBTT_assert(y+gh < ph);[m
[32m+[m[32m      stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);[m
[32m+[m[32m      chardata[i].x0 = (stbtt_int16) x;[m
[32m+[m[32m      chardata[i].y0 = (stbtt_int16) y;[m
[32m+[m[32m      chardata[i].x1 = (stbtt_int16) (x + gw);[m
[32m+[m[32m      chardata[i].y1 = (stbtt_int16) (y + gh);[m
[32m+[m[32m      chardata[i].xadvance = scale * advance;[m
[32m+[m[32m      chardata[i].xoff     = (float) x0;[m
[32m+[m[32m      chardata[i].yoff     = (float) y0;[m
[32m+[m[32m      x = x + gw + 1;[m
[32m+[m[32m      if (y+gh+1 > bottom_y)[m
[32m+[m[32m         bottom_y = y+gh+1;[m
[32m+[m[32m   }[m
[32m+[m[32m   return bottom_y;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)[m
[32m+[m[32m{[m
[32m+[m[32m   float d3d_bias = opengl_fillrule ? 0 : -0.5f;[m
[32m+[m[32m   float ipw = 1.0f / pw, iph = 1.0f / ph;[m
[32m+[m[32m   const stbtt_bakedchar *b = chardata + char_index;[m
[32m+[m[32m   int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);[m
[32m+[m[32m   int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);[m
[32m+[m
[32m+[m[32m   q->x0 = round_x + d3d_bias;[m
[32m+[m[32m   q->y0 = round_y + d3d_bias;[m
[32m+[m[32m   q->x1 = round_x + b->x1 - b->x0 + d3d_bias;[m
[32m+[m[32m   q->y1 = round_y + b->y1 - b->y0 + d3d_bias;[m
[32m+[m
[32m+[m[32m   q->s0 = b->x0 * ipw;[m
[32m+[m[32m   q->t0 = b->y0 * iph;[m
[32m+[m[32m   q->s1 = b->x1 * ipw;[m
[32m+[m[32m   q->t1 = b->y1 * iph;[m
[32m+[m
[32m+[m[32m   *xpos += b->xadvance;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// rectangle packing replacement routines if you don't have stb_rect_pack.h[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32m#ifndef STB_RECT_PACK_VERSION[m
[32m+[m
[32m+[m[32mtypedef int stbrp_coord;[m
[32m+[m
[32m+[m[32m////////////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//                                                                                //[m
[32m+[m[32m//                                                                                //[m
[32m+[m[32m// COMPILER WARNING ?!?!?                                                         //[m
[32m+[m[32m//                                                                                //[m
[32m+[m[32m//                                                                                //[m
[32m+[m[32m// if you get a compile warning due to these symbols being defined more than      //[m
[32m+[m[32m// once, move #include "stb_rect_pack.h" before #include "stb_truetype.h"         //[m
[32m+[m[32m//                                                                                //[m
[32m+[m[32m////////////////////////////////////////////////////////////////////////////////////[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m   int width,height;[m
[32m+[m[32m   int x,y,bottom_y;[m
[32m+[m[32m} stbrp_context;[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m   unsigned char x;[m
[32m+[m[32m} stbrp_node;[m
[32m+[m
[32m+[m[32mstruct stbrp_rect[m
[32m+[m[32m{[m
[32m+[m[32m   stbrp_coord x,y;[m
[32m+[m[32m   int id,w,h,was_packed;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstatic void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)[m
[32m+[m[32m{[m
[32m+[m[32m   con->width  = pw;[m
[32m+[m[32m   con->height = ph;[m
[32m+[m[32m   con->x = 0;[m
[32m+[m[32m   con->y = 0;[m
[32m+[m[32m   con->bottom_y = 0;[m
[32m+[m[32m   STBTT__NOTUSED(nodes);[m
[32m+[m[32m   STBTT__NOTUSED(num_nodes);[m[41m   [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)[m
[32m+[m[32m{[m
[32m+[m[32m   int i;[m
[32m+[m[32m   for (i=0; i < num_rects; ++i) {[m
[32m+[m[32m      if (con->x + rects[i].w > con->width) {[m
[32m+[m[32m         con->x = 0;[m
[32m+[m[32m         con->y = con->bottom_y;[m
[32m+[m[32m      }[m
[32m+[m[32m      if (con->y + rects[i].h > con->height)[m
[32m+[m[32m         break;[m
[32m+[m[32m      rects[i].x = con->x;[m
[32m+[m[32m      rects[i].y = con->y;[m
[32m+[m[32m      rects[i].was_packed = 1;[m
[32m+[m[32m      con->x += rects[i].w;[m
[32m+[m[32m      if (con->y + rects[i].h > con->bottom_y)[m
[32m+[m[32m         con->bottom_y = con->y + rects[i].h;[m
[32m+[m[32m   }[m
[32m+[m[32m   for (   ; i < num_rects; ++i)[m
[32m+[m[32m      rects[i].was_packed = 0;[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// bitmap baking[m
[32m+[m[32m//[m
[32m+[m[32m// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If[m
[32m+[m[32m// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)[m
[32m+[m[32m{[m
[32m+[m[32m   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);[m
[32m+[m[32m   int            num_nodes = pw - padding;[m
[32m+[m[32m   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);[m
[32m+[m
[32m+[m[32m   if (context == NULL || nodes == NULL) {[m
[32m+[m[32m      if (context != NULL) STBTT_free(context, alloc_context);[m
[32m+[m[32m      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);[m
[32m+[m[32m      return 0;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   spc->user_allocator_context = alloc_context;[m
[32m+[m[32m   spc->width = pw;[m
[32m+[m[32m   spc->height = ph;[m
[32m+[m[32m   spc->pixels = pixels;[m
[32m+[m[32m   spc->pack_info = context;[m
[32m+[m[32m   spc->nodes = nodes;[m
[32m+[m[32m   spc->padding = padding;[m
[32m+[m[32m   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;[m
[32m+[m[32m   spc->h_oversample = 1;[m
[32m+[m[32m   spc->v_oversample = 1;[m
[32m+[m[32m   spc->skip_missing = 0;[m
[32m+[m
[32m+[m[32m   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);[m
[32m+[m
[32m+[m[32m   if (pixels)[m
[32m+[m[32m      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels[m
[32m+[m
[32m+[m[32m   return 1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)[m
[32m+[m[32m{[m
[32m+[m[32m   STBTT_free(spc->nodes    , spc->user_allocator_context);[m
[32m+[m[32m   STBTT_free(spc->pack_info, spc->user_allocator_context);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)[m
[32m+[m[32m{[m
[32m+[m[32m   STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);[m
[32m+[m[32m   STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);[m
[32m+[m[32m   if (h_oversample <= STBTT_MAX_OVERSAMPLE)[m
[32m+[m[32m      spc->h_oversample = h_oversample;[m
[32m+[m[32m   if (v_oversample <= STBTT_MAX_OVERSAMPLE)[m
[32m+[m[32m      spc->v_oversample = v_oversample;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip)[m
[32m+[m[32m{[m
[32m+[m[32m   spc->skip_missing = skip;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)[m
[32m+[m
[32m+[m[32mstatic void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)[m
[32m+[m[32m{[m
[32m+[m[32m   unsigned char buffer[STBTT_MAX_OVERSAMPLE];[m
[32m+[m[32m   int safe_w = w - kernel_width;[m
[32m+[m[32m   int j;[m
[32m+[m[32m   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze[m
[32m+[m[32m   for (j=0; j < h; ++j) {[m
[32m+[m[32m      int i;[m
[32m+[m[32m      unsigned int total;[m
[32m+[m[32m      STBTT_memset(buffer, 0, kernel_width);[m
[32m+[m
[32m+[m[32m      total = 0;[m
[32m+[m
[32m+[m[32m      // make kernel_width a constant in common cases so compiler can optimize out the divide[m
[32m+[m[32m      switch (kernel_width) {[m
[32m+[m[32m         case 2:[m
[32m+[m[32m            for (i=0; i <= safe_w; ++i) {[m
[32m+[m[32m               total += pixels[i] - buffer[i & STBTT__OVER_MASK];[m
[32m+[m[32m               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];[m
[32m+[m[32m               pixels[i] = (unsigned char) (total / 2);[m
[32m+[m[32m            }[m
[32m+[m[32m            break;[m
[32m+[m[32m         case 3:[m
[32m+[m[32m            for (i=0; i <= safe_w; ++i) {[m
[32m+[m[32m               total += pixels[i] - buffer[i & STBTT__OVER_MASK];[m
[32m+[m[32m               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];[m
[32m+[m[32m               pixels[i] = (unsigned char) (total / 3);[m
[32m+[m[32m            }[m
[32m+[m[32m            break;[m
[32m+[m[32m         case 4:[m
[32m+[m[32m            for (i=0; i <= safe_w; ++i) {[m
[32m+[m[32m               total += pixels[i] - buffer[i & STBTT__OVER_MASK];[m
[32m+[m[32m               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];[m
[32m+[m[32m               pixels[i] = (unsigned char) (total / 4);[m
[32m+[m[32m            }[m
[32m+[m[32m            break;[m
[32m+[m[32m         case 5:[m
[32m+[m[32m            for (i=0; i <= safe_w; ++i) {[m
[32m+[m[32m               total += pixels[i] - buffer[i & STBTT__OVER_MASK];[m
[32m+[m[32m               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];[m
[32m+[m[32m               pixels[i] = (unsigned char) (total / 5);[m
[32m+[m[32m            }[m
[32m+[m[32m            break;[m
[32m+[m[32m         default:[m
[32m+[m[32m            for (i=0; i <= safe_w; ++i) {[m
[32m+[m[32m               total += pixels[i] - buffer[i & STBTT__OVER_MASK];[m
[32m+[m[32m               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];[m
[32m+[m[32m               pixels[i] = (unsigned char) (total / kernel_width);[m
[32m+[m[32m            }[m
[32m+[m[32m            break;[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      for (; i < w; ++i) {[m
[32m+[m[32m         STBTT_assert(pixels[i] == 0);[m
[32m+[m[32m         total -= buffer[i & STBTT__OVER_MASK];[m
[32m+[m[32m         pixels[i] = (unsigned char) (total / kernel_width);[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      pixels += stride_in_bytes;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)[m
[32m+[m[32m{[m
[32m+[m[32m   unsigned char buffer[STBTT_MAX_OVERSAMPLE];[m
[32m+[m[32m   int safe_h = h - kernel_width;[m
[32m+[m[32m   int j;[m
[32m+[m[32m   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze[m
[32m+[m[32m   for (j=0; j < w; ++j) {[m
[32m+[m[32m      int i;[m
[32m+[m[32m      unsigned int total;[m
[32m+[m[32m      STBTT_memset(buffer, 0, kernel_width);[m
[32m+[m
[32m+[m[32m      total = 0;[m
[32m+[m
[32m+[m[32m      // make kernel_width a constant in common cases so compiler can optimize out the divide[m
[32m+[m[32m      switch (kernel_width) {[m
[32m+[m[32m         case 2:[m
[32m+[m[32m            for (i=0; i <= safe_h; ++i) {[m
[32m+[m[32m               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];[m
[32m+[m[32m               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];[m
[32m+[m[32m               pixels[i*stride_in_bytes] = (unsigned char) (total / 2);[m
[32m+[m[32m            }[m
[32m+[m[32m            break;[m
[32m+[m[32m         case 3:[m
[32m+[m[32m            for (i=0; i <= safe_h; ++i) {[m
[32m+[m[32m               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];[m
[32m+[m[32m               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];[m
[32m+[m[32m               pixels[i*stride_in_bytes] = (unsigned char) (total / 3);[m
[32m+[m[32m            }[m
[32m+[m[32m            break;[m
[32m+[m[32m         case 4:[m
[32m+[m[32m            for (i=0; i <= safe_h; ++i) {[m
[32m+[m[32m               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];[m
[32m+[m[32m               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];[m
[32m+[m[32m               pixels[i*stride_in_bytes] = (unsigned char) (total / 4);[m
[32m+[m[32m            }[m
[32m+[m[32m            break;[m
[32m+[m[32m         case 5:[m
[32m+[m[32m            for (i=0; i <= safe_h; ++i) {[m
[32m+[m[32m               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];[m
[32m+[m[32m               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];[m
[32m+[m[32m               pixels[i*stride_in_bytes] = (unsigned char) (total / 5);[m
[32m+[m[32m            }[m
[32m+[m[32m            break;[m
[32m+[m[32m         default:[m
[32m+[m[32m            for (i=0; i <= safe_h; ++i) {[m
[32m+[m[32m               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];[m
[32m+[m[32m               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];[m
[32m+[m[32m               pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);[m
[32m+[m[32m            }[m
[32m+[m[32m            break;[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      for (; i < h; ++i) {[m
[32m+[m[32m         STBTT_assert(pixels[i*stride_in_bytes] == 0);[m
[32m+[m[32m         total -= buffer[i & STBTT__OVER_MASK];[m
[32m+[m[32m         pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      pixels += 1;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic float stbtt__oversample_shift(int oversample)[m
[32m+[m[32m{[m
[32m+[m[32m   if (!oversample)[m
[32m+[m[32m      return 0.0f;[m
[32m+[m
[32m+[m[32m   // The prefilter is a box filter of width "oversample",[m
[32m+[m[32m   // which shifts phase by (oversample - 1)/2 pixels in[m
[32m+[m[32m   // oversampled space. We want to shift in the opposite[m
[32m+[m[32m   // direction to counter this.[m
[32m+[m[32m   return (float)-(oversample - 1) / (2.0f * (float)oversample);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// rects array must be big enough to accommodate all characters in the given ranges[m
[32m+[m[32mSTBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)[m
[32m+[m[32m{[m
[32m+[m[32m   int i,j,k;[m
[32m+[m
[32m+[m[32m   k=0;[m
[32m+[m[32m   for (i=0; i < num_ranges; ++i) {[m
[32m+[m[32m      float fh = ranges[i].font_size;[m
[32m+[m[32m      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);[m
[32m+[m[32m      ranges[i].h_oversample = (unsigned char) spc->h_oversample;[m
[32m+[m[32m      ranges[i].v_oversample = (unsigned char) spc->v_oversample;[m
[32m+[m[32m      for (j=0; j < ranges[i].num_chars; ++j) {[m
[32m+[m[32m         int x0,y0,x1,y1;[m
[32m+[m[32m         int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];[m
[32m+[m[32m         int glyph = stbtt_FindGlyphIndex(info, codepoint);[m
[32m+[m[32m         if (glyph == 0 && spc->skip_missing) {[m
[32m+[m[32m            rects[k].w = rects[k].h = 0;[m
[32m+[m[32m         } else {[m
[32m+[m[32m            stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,[m
[32m+[m[32m                                            scale * spc->h_oversample,[m
[32m+[m[32m                                            scale * spc->v_oversample,[m
[32m+[m[32m                                            0,0,[m
[32m+[m[32m                                            &x0,&y0,&x1,&y1);[m
[32m+[m[32m            rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);[m
[32m+[m[32m            rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);[m
[32m+[m[32m         }[m
[32m+[m[32m         ++k;[m
[32m+[m[32m      }[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   return k;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_MakeGlyphBitmapSubpixel(info,[m
[32m+[m[32m                                 output,[m
[32m+[m[32m                                 out_w - (prefilter_x - 1),[m
[32m+[m[32m                                 out_h - (prefilter_y - 1),[m
[32m+[m[32m                                 out_stride,[m
[32m+[m[32m                                 scale_x,[m
[32m+[m[32m                                 scale_y,[m
[32m+[m[32m                                 shift_x,[m
[32m+[m[32m                                 shift_y,[m
[32m+[m[32m                                 glyph);[m
[32m+[m
[32m+[m[32m   if (prefilter_x > 1)[m
[32m+[m[32m      stbtt__h_prefilter(output, out_w, out_h, out_stride, prefilter_x);[m
[32m+[m
[32m+[m[32m   if (prefilter_y > 1)[m
[32m+[m[32m      stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);[m
[32m+[m
[32m+[m[32m   *sub_x = stbtt__oversample_shift(prefilter_x);[m
[32m+[m[32m   *sub_y = stbtt__oversample_shift(prefilter_y);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// rects array must be big enough to accommodate all characters in the given ranges[m
[32m+[m[32mSTBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)[m
[32m+[m[32m{[m
[32m+[m[32m   int i,j,k, return_value = 1;[m
[32m+[m
[32m+[m[32m   // save current values[m
[32m+[m[32m   int old_h_over = spc->h_oversample;[m
[32m+[m[32m   int old_v_over = spc->v_oversample;[m
[32m+[m
[32m+[m[32m   k = 0;[m
[32m+[m[32m   for (i=0; i < num_ranges; ++i) {[m
[32m+[m[32m      float fh = ranges[i].font_size;[m
[32m+[m[32m      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);[m
[32m+[m[32m      float recip_h,recip_v,sub_x,sub_y;[m
[32m+[m[32m      spc->h_oversample = ranges[i].h_oversample;[m
[32m+[m[32m      spc->v_oversample = ranges[i].v_oversample;[m
[32m+[m[32m      recip_h = 1.0f / spc->h_oversample;[m
[32m+[m[32m      recip_v = 1.0f / spc->v_oversample;[m
[32m+[m[32m      sub_x = stbtt__oversample_shift(spc->h_oversample);[m
[32m+[m[32m      sub_y = stbtt__oversample_shift(spc->v_oversample);[m
[32m+[m[32m      for (j=0; j < ranges[i].num_chars; ++j) {[m
[32m+[m[32m         stbrp_rect *r = &rects[k];[m
[32m+[m[32m         if (r->was_packed && r->w != 0 && r->h != 0) {[m
[32m+[m[32m            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];[m
[32m+[m[32m            int advance, lsb, x0,y0,x1,y1;[m
[32m+[m[32m            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];[m
[32m+[m[32m            int glyph = stbtt_FindGlyphIndex(info, codepoint);[m
[32m+[m[32m            stbrp_coord pad = (stbrp_coord) spc->padding;[m
[32m+[m
[32m+[m[32m            // pad on left and top[m
[32m+[m[32m            r->x += pad;[m
[32m+[m[32m            r->y += pad;[m
[32m+[m[32m            r->w -= pad;[m
[32m+[m[32m            r->h -= pad;[m
[32m+[m[32m            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);[m
[32m+[m[32m            stbtt_GetGlyphBitmapBox(info, glyph,[m
[32m+[m[32m                                    scale * spc->h_oversample,[m
[32m+[m[32m                                    scale * spc->v_oversample,[m
[32m+[m[32m                                    &x0,&y0,&x1,&y1);[m
[32m+[m[32m            stbtt_MakeGlyphBitmapSubpixel(info,[m
[32m+[m[32m                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,[m
[32m+[m[32m                                          r->w - spc->h_oversample+1,[m
[32m+[m[32m                                          r->h - spc->v_oversample+1,[m
[32m+[m[32m                                          spc->stride_in_bytes,[m
[32m+[m[32m                                          scale * spc->h_oversample,[m
[32m+[m[32m                                          scale * spc->v_oversample,[m
[32m+[m[32m                                          0,0,[m
[32m+[m[32m                                          glyph);[m
[32m+[m
[32m+[m[32m            if (spc->h_oversample > 1)[m
[32m+[m[32m               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,[m
[32m+[m[32m                                  r->w, r->h, spc->stride_in_bytes,[m
[32m+[m[32m                                  spc->h_oversample);[m
[32m+[m
[32m+[m[32m            if (spc->v_oversample > 1)[m
[32m+[m[32m               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,[m
[32m+[m[32m                                  r->w, r->h, spc->stride_in_bytes,[m
[32m+[m[32m                                  spc->v_oversample);[m
[32m+[m
[32m+[m[32m            bc->x0       = (stbtt_int16)  r->x;[m
[32m+[m[32m            bc->y0       = (stbtt_int16)  r->y;[m
[32m+[m[32m            bc->x1       = (stbtt_int16) (r->x + r->w);[m
[32m+[m[32m            bc->y1       = (stbtt_int16) (r->y + r->h);[m
[32m+[m[32m            bc->xadvance =                scale * advance;[m
[32m+[m[32m            bc->xoff     =       (float)  x0 * recip_h + sub_x;[m
[32m+[m[32m            bc->yoff     =       (float)  y0 * recip_v + sub_y;[m
[32m+[m[32m            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;[m
[32m+[m[32m            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;[m
[32m+[m[32m         } else {[m
[32m+[m[32m            return_value = 0; // if any fail, report failure[m
[32m+[m[32m         }[m
[32m+[m
[32m+[m[32m         ++k;[m
[32m+[m[32m      }[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   // restore original values[m
[32m+[m[32m   spc->h_oversample = old_h_over;[m
[32m+[m[32m   spc->v_oversample = old_v_over;[m
[32m+[m
[32m+[m[32m   return return_value;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)[m
[32m+[m[32m{[m
[32m+[m[32m   stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_fontinfo info;[m
[32m+[m[32m   int i,j,n, return_value = 1;[m
[32m+[m[32m   //stbrp_context *context = (stbrp_context *) spc->pack_info;[m
[32m+[m[32m   stbrp_rect    *rects;[m
[32m+[m
[32m+[m[32m   // flag all characters as NOT packed[m
[32m+[m[32m   for (i=0; i < num_ranges; ++i)[m
[32m+[m[32m      for (j=0; j < ranges[i].num_chars; ++j)[m
[32m+[m[32m         ranges[i].chardata_for_range[j].x0 =[m
[32m+[m[32m         ranges[i].chardata_for_range[j].y0 =[m
[32m+[m[32m         ranges[i].chardata_for_range[j].x1 =[m
[32m+[m[32m         ranges[i].chardata_for_range[j].y1 = 0;[m
[32m+[m
[32m+[m[32m   n = 0;[m
[32m+[m[32m   for (i=0; i < num_ranges; ++i)[m
[32m+[m[32m      n += ranges[i].num_chars;[m
[32m+[m[41m         [m
[32m+[m[32m   rects = (stbrp_rect *) STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);[m
[32m+[m[32m   if (rects == NULL)[m
[32m+[m[32m      return 0;[m
[32m+[m
[32m+[m[32m   info.userdata = spc->user_allocator_context;[m
[32m+[m[32m   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));[m
[32m+[m
[32m+[m[32m   n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);[m
[32m+[m
[32m+[m[32m   stbtt_PackFontRangesPackRects(spc, rects, n);[m
[32m+[m[41m  [m
[32m+[m[32m   return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);[m
[32m+[m
[32m+[m[32m   STBTT_free(rects, spc->user_allocator_context);[m
[32m+[m[32m   return return_value;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,[m
[32m+[m[32m            int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_pack_range range;[m
[32m+[m[32m   range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;[m
[32m+[m[32m   range.array_of_unicode_codepoints = NULL;[m
[32m+[m[32m   range.num_chars                   = num_chars_in_range;[m
[32m+[m[32m   range.chardata_for_range          = chardata_for_range;[m
[32m+[m[32m   range.font_size                   = font_size;[m
[32m+[m[32m   return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap)[m
[32m+[m[32m{[m
[32m+[m[32m   int i_ascent, i_descent, i_lineGap;[m
[32m+[m[32m   float scale;[m
[32m+[m[32m   stbtt_fontinfo info;[m
[32m+[m[32m   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata, index));[m
[32m+[m[32m   scale = size > 0 ? stbtt_ScaleForPixelHeight(&info, size) : stbtt_ScaleForMappingEmToPixels(&info, -size);[m
[32m+[m[32m   stbtt_GetFontVMetrics(&info, &i_ascent, &i_descent, &i_lineGap);[m
[32m+[m[32m   *ascent  = (float) i_ascent  * scale;[m
[32m+[m[32m   *descent = (float) i_descent * scale;[m
[32m+[m[32m   *lineGap = (float) i_lineGap * scale;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)[m
[32m+[m[32m{[m
[32m+[m[32m   float ipw = 1.0f / pw, iph = 1.0f / ph;[m
[32m+[m[32m   const stbtt_packedchar *b = chardata + char_index;[m
[32m+[m
[32m+[m[32m   if (align_to_integer) {[m
[32m+[m[32m      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);[m
[32m+[m[32m      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);[m
[32m+[m[32m      q->x0 = x;[m
[32m+[m[32m      q->y0 = y;[m
[32m+[m[32m      q->x1 = x + b->xoff2 - b->xoff;[m
[32m+[m[32m      q->y1 = y + b->yoff2 - b->yoff;[m
[32m+[m[32m   } else {[m
[32m+[m[32m      q->x0 = *xpos + b->xoff;[m
[32m+[m[32m      q->y0 = *ypos + b->yoff;[m
[32m+[m[32m      q->x1 = *xpos + b->xoff2;[m
[32m+[m[32m      q->y1 = *ypos + b->yoff2;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   q->s0 = b->x0 * ipw;[m
[32m+[m[32m   q->t0 = b->y0 * iph;[m
[32m+[m[32m   q->s1 = b->x1 * ipw;[m
[32m+[m[32m   q->t1 = b->y1 * iph;[m
[32m+[m
[32m+[m[32m   *xpos += b->xadvance;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// sdf computation[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32m#define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))[m
[32m+[m[32m#define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))[m
[32m+[m
[32m+[m[32mstatic int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])[m
[32m+[m[32m{[m
[32m+[m[32m   float q0perp = q0[1]*ray[0] - q0[0]*ray[1];[m
[32m+[m[32m   float q1perp = q1[1]*ray[0] - q1[0]*ray[1];[m
[32m+[m[32m   float q2perp = q2[1]*ray[0] - q2[0]*ray[1];[m
[32m+[m[32m   float roperp = orig[1]*ray[0] - orig[0]*ray[1];[m
[32m+[m
[32m+[m[32m   float a = q0perp - 2*q1perp + q2perp;[m
[32m+[m[32m   float b = q1perp - q0perp;[m
[32m+[m[32m   float c = q0perp - roperp;[m
[32m+[m
[32m+[m[32m   float s0 = 0., s1 = 0.;[m
[32m+[m[32m   int num_s = 0;[m
[32m+[m
[32m+[m[32m   if (a != 0.0) {[m
[32m+[m[32m      float discr = b*b - a*c;[m
[32m+[m[32m      if (discr > 0.0) {[m
[32m+[m[32m         float rcpna = -1 / a;[m
[32m+[m[32m         float d = (float) STBTT_sqrt(discr);[m
[32m+[m[32m         s0 = (b+d) * rcpna;[m
[32m+[m[32m         s1 = (b-d) * rcpna;[m
[32m+[m[32m         if (s0 >= 0.0 && s0 <= 1.0)[m
[32m+[m[32m            num_s = 1;[m
[32m+[m[32m         if (d > 0.0 && s1 >= 0.0 && s1 <= 1.0) {[m
[32m+[m[32m            if (num_s == 0) s0 = s1;[m
[32m+[m[32m            ++num_s;[m
[32m+[m[32m         }[m
[32m+[m[32m      }[m
[32m+[m[32m   } else {[m
[32m+[m[32m      // 2*b*s + c = 0[m
[32m+[m[32m      // s = -c / (2*b)[m
[32m+[m[32m      s0 = c / (-2 * b);[m
[32m+[m[32m      if (s0 >= 0.0 && s0 <= 1.0)[m
[32m+[m[32m         num_s = 1;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   if (num_s == 0)[m
[32m+[m[32m      return 0;[m
[32m+[m[32m   else {[m
[32m+[m[32m      float rcp_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);[m
[32m+[m[32m      float rayn_x = ray[0] * rcp_len2, rayn_y = ray[1] * rcp_len2;[m
[32m+[m
[32m+[m[32m      float q0d =   q0[0]*rayn_x +   q0[1]*rayn_y;[m
[32m+[m[32m      float q1d =   q1[0]*rayn_x +   q1[1]*rayn_y;[m
[32m+[m[32m      float q2d =   q2[0]*rayn_x +   q2[1]*rayn_y;[m
[32m+[m[32m      float rod = orig[0]*rayn_x + orig[1]*rayn_y;[m
[32m+[m
[32m+[m[32m      float q10d = q1d - q0d;[m
[32m+[m[32m      float q20d = q2d - q0d;[m
[32m+[m[32m      float q0rd = q0d - rod;[m
[32m+[m
[32m+[m[32m      hits[0][0] = q0rd + s0*(2.0f - 2.0f*s0)*q10d + s0*s0*q20d;[m
[32m+[m[32m      hits[0][1] = a*s0+b;[m
[32m+[m
[32m+[m[32m      if (num_s > 1) {[m
[32m+[m[32m         hits[1][0] = q0rd + s1*(2.0f - 2.0f*s1)*q10d + s1*s1*q20d;[m
[32m+[m[32m         hits[1][1] = a*s1+b;[m
[32m+[m[32m         return 2;[m
[32m+[m[32m      } else {[m
[32m+[m[32m         return 1;[m
[32m+[m[32m      }[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int equal(float *a, float *b)[m
[32m+[m[32m{[m
[32m+[m[32m   return (a[0] == b[0] && a[1] == b[1]);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)[m
[32m+[m[32m{[m
[32m+[m[32m   int i;[m
[32m+[m[32m   float orig[2], ray[2] = { 1, 0 };[m
[32m+[m[32m   float y_frac;[m
[32m+[m[32m   int winding = 0;[m
[32m+[m
[32m+[m[32m   orig[0] = x;[m
[32m+[m[32m   //orig[1] = y; // [DEAR IMGUI] commmented double assignment[m
[32m+[m
[32m+[m[32m   // make sure y never passes through a vertex of the shape[m
[32m+[m[32m   y_frac = (float) STBTT_fmod(y, 1.0f);[m
[32m+[m[32m   if (y_frac < 0.01f)[m
[32m+[m[32m      y += 0.01f;[m
[32m+[m[32m   else if (y_frac > 0.99f)[m
[32m+[m[32m      y -= 0.01f;[m
[32m+[m[32m   orig[1] = y;[m
[32m+[m
[32m+[m[32m   // test a ray from (-infinity,y) to (x,y)[m
[32m+[m[32m   for (i=0; i < nverts; ++i) {[m
[32m+[m[32m      if (verts[i].type == STBTT_vline) {[m
[32m+[m[32m         int x0 = (int) verts[i-1].x, y0 = (int) verts[i-1].y;[m
[32m+[m[32m         int x1 = (int) verts[i  ].x, y1 = (int) verts[i  ].y;[m
[32m+[m[32m         if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {[m
[32m+[m[32m            float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;[m
[32m+[m[32m            if (x_inter < x)[m[41m  [m
[32m+[m[32m               winding += (y0 < y1) ? 1 : -1;[m
[32m+[m[32m         }[m
[32m+[m[32m      }[m
[32m+[m[32m      if (verts[i].type == STBTT_vcurve) {[m
[32m+[m[32m         int x0 = (int) verts[i-1].x , y0 = (int) verts[i-1].y ;[m
[32m+[m[32m         int x1 = (int) verts[i  ].cx, y1 = (int) verts[i  ].cy;[m
[32m+[m[32m         int x2 = (int) verts[i  ].x , y2 = (int) verts[i  ].y ;[m
[32m+[m[32m         int ax = STBTT_min(x0,STBTT_min(x1,x2)), ay = STBTT_min(y0,STBTT_min(y1,y2));[m
[32m+[m[32m         int by = STBTT_max(y0,STBTT_max(y1,y2));[m
[32m+[m[32m         if (y > ay && y < by && x > ax) {[m
[32m+[m[32m            float q0[2],q1[2],q2[2];[m
[32m+[m[32m            float hits[2][2];[m
[32m+[m[32m            q0[0] = (float)x0;[m
[32m+[m[32m            q0[1] = (float)y0;[m
[32m+[m[32m            q1[0] = (float)x1;[m
[32m+[m[32m            q1[1] = (float)y1;[m
[32m+[m[32m            q2[0] = (float)x2;[m
[32m+[m[32m            q2[1] = (float)y2;[m
[32m+[m[32m            if (equal(q0,q1) || equal(q1,q2)) {[m
[32m+[m[32m               x0 = (int)verts[i-1].x;[m
[32m+[m[32m               y0 = (int)verts[i-1].y;[m
[32m+[m[32m               x1 = (int)verts[i  ].x;[m
[32m+[m[32m               y1 = (int)verts[i  ].y;[m
[32m+[m[32m               if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {[m
[32m+[m[32m                  float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;[m
[32m+[m[32m                  if (x_inter < x)[m[41m  [m
[32m+[m[32m                     winding += (y0 < y1) ? 1 : -1;[m
[32m+[m[32m               }[m
[32m+[m[32m            } else {[m
[32m+[m[32m               int num_hits = stbtt__ray_intersect_bezier(orig, ray, q0, q1, q2, hits);[m
[32m+[m[32m               if (num_hits >= 1)[m
[32m+[m[32m                  if (hits[0][0] < 0)[m
[32m+[m[32m                     winding += (hits[0][1] < 0 ? -1 : 1);[m
[32m+[m[32m               if (num_hits >= 2)[m
[32m+[m[32m                  if (hits[1][0] < 0)[m
[32m+[m[32m                     winding += (hits[1][1] < 0 ? -1 : 1);[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m[41m [m
[32m+[m[32m      }[m
[32m+[m[32m   }[m
[32m+[m[32m   return winding;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic float stbtt__cuberoot( float x )[m
[32m+[m[32m{[m
[32m+[m[32m   if (x<0)[m
[32m+[m[32m      return -(float) STBTT_pow(-x,1.0f/3.0f);[m
[32m+[m[32m   else[m
[32m+[m[32m      return  (float) STBTT_pow( x,1.0f/3.0f);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// x^3 + c*x^2 + b*x + a = 0[m
[32m+[m[32mstatic int stbtt__solve_cubic(float a, float b, float c, float* r)[m
[32m+[m[32m{[m
[32m+[m	[32mfloat s = -a / 3;[m
[32m+[m	[32mfloat p = b - a*a / 3;[m
[32m+[m	[32mfloat q = a * (2*a*a - 9*b) / 27 + c;[m
[32m+[m[32m   float p3 = p*p*p;[m
[32m+[m	[32mfloat d = q*q + 4*p3 / 27;[m
[32m+[m	[32mif (d >= 0) {[m
[32m+[m		[32mfloat z = (float) STBTT_sqrt(d);[m
[32m+[m		[32mfloat u = (-q + z) / 2;[m
[32m+[m		[32mfloat v = (-q - z) / 2;[m
[32m+[m		[32mu = stbtt__cuberoot(u);[m
[32m+[m		[32mv = stbtt__cuberoot(v);[m
[32m+[m		[32mr[0] = s + u + v;[m
[32m+[m		[32mreturn 1;[m
[32m+[m	[32m} else {[m
[32m+[m	[32m   float u = (float) STBTT_sqrt(-p/3);[m
[32m+[m	[32m   float v = (float) STBTT_acos(-STBTT_sqrt(-27/p3) * q / 2) / 3; // p3 must be negative, since d is negative[m
[32m+[m	[32m   float m = (float) STBTT_cos(v);[m
[32m+[m[32m      float n = (float) STBTT_cos(v-3.141592/2)*1.732050808f;[m
[32m+[m	[32m   r[0] = s + u * 2 * m;[m
[32m+[m	[32m   r[1] = s - u * (m + n);[m
[32m+[m	[32m   r[2] = s - u * (m - n);[m
[32m+[m
[32m+[m[32m      //STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?[m
[32m+[m[32m      //STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);[m
[32m+[m[32m      //STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);[m
[32m+[m[41m   [m	[32mreturn 3;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)[m
[32m+[m[32m{[m
[32m+[m[32m   float scale_x = scale, scale_y = scale;[m
[32m+[m[32m   int ix0,iy0,ix1,iy1;[m
[32m+[m[32m   int w,h;[m
[32m+[m[32m   unsigned char *data;[m
[32m+[m
[32m+[m[32m   // if one scale is 0, use same scale for both[m
[32m+[m[32m   if (scale_x == 0) scale_x = scale_y;[m
[32m+[m[32m   if (scale_y == 0) {[m
[32m+[m[32m      if (scale_x == 0) return NULL;  // if both scales are 0, return NULL[m
[32m+[m[32m      scale_y = scale_x;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, &ix0,&iy0,&ix1,&iy1);[m
[32m+[m
[32m+[m[32m   // if empty, return NULL[m
[32m+[m[32m   if (ix0 == ix1 || iy0 == iy1)[m
[32m+[m[32m      return NULL;[m
[32m+[m
[32m+[m[32m   ix0 -= padding;[m
[32m+[m[32m   iy0 -= padding;[m
[32m+[m[32m   ix1 += padding;[m
[32m+[m[32m   iy1 += padding;[m
[32m+[m
[32m+[m[32m   w = (ix1 - ix0);[m
[32m+[m[32m   h = (iy1 - iy0);[m
[32m+[m
[32m+[m[32m   if (width ) *width  = w;[m
[32m+[m[32m   if (height) *height = h;[m
[32m+[m[32m   if (xoff  ) *xoff   = ix0;[m
[32m+[m[32m   if (yoff  ) *yoff   = iy0;[m
[32m+[m
[32m+[m[32m   // invert for y-downwards bitmaps[m
[32m+[m[32m   scale_y = -scale_y;[m
[32m+[m[41m      [m
[32m+[m[32m   {[m
[32m+[m[32m      int x,y,i,j;[m
[32m+[m[32m      float *precompute;[m
[32m+[m[32m      stbtt_vertex *verts;[m
[32m+[m[32m      int num_verts = stbtt_GetGlyphShape(info, glyph, &verts);[m
[32m+[m[32m      data = (unsigned char *) STBTT_malloc(w * h, info->userdata);[m
[32m+[m[32m      precompute = (float *) STBTT_malloc(num_verts * sizeof(float), info->userdata);[m
[32m+[m
[32m+[m[32m      for (i=0,j=num_verts-1; i < num_verts; j=i++) {[m
[32m+[m[32m         if (verts[i].type == STBTT_vline) {[m
[32m+[m[32m            float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;[m
[32m+[m[32m            float x1 = verts[j].x*scale_x, y1 = verts[j].y*scale_y;[m
[32m+[m[32m            float dist = (float) STBTT_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));[m
[32m+[m[32m            precompute[i] = (dist == 0) ? 0.0f : 1.0f / dist;[m
[32m+[m[32m         } else if (verts[i].type == STBTT_vcurve) {[m
[32m+[m[32m            float x2 = verts[j].x *scale_x, y2 = verts[j].y *scale_y;[m
[32m+[m[32m            float x1 = verts[i].cx*scale_x, y1 = verts[i].cy*scale_y;[m
[32m+[m[32m            float x0 = verts[i].x *scale_x, y0 = verts[i].y *scale_y;[m
[32m+[m[32m            float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;[m
[32m+[m[32m            float len2 = bx*bx + by*by;[m
[32m+[m[32m            if (len2 != 0.0f)[m
[32m+[m[32m               precompute[i] = 1.0f / (bx*bx + by*by);[m
[32m+[m[32m            else[m
[32m+[m[32m               precompute[i] = 0.0f;[m
[32m+[m[32m         } else[m
[32m+[m[32m            precompute[i] = 0.0f;[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      for (y=iy0; y < iy1; ++y) {[m
[32m+[m[32m         for (x=ix0; x < ix1; ++x) {[m
[32m+[m[32m            float val;[m
[32m+[m[32m            float min_dist = 999999.0f;[m
[32m+[m[32m            float sx = (float) x + 0.5f;[m
[32m+[m[32m            float sy = (float) y + 0.5f;[m
[32m+[m[32m            float x_gspace = (sx / scale_x);[m
[32m+[m[32m            float y_gspace = (sy / scale_y);[m
[32m+[m
[32m+[m[32m            int winding = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, verts); // @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path[m
[32m+[m
[32m+[m[32m            for (i=0; i < num_verts; ++i) {[m
[32m+[m[32m               float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;[m
[32m+[m
[32m+[m[32m               // check against every point here rather than inside line/curve primitives -- @TODO: wrong if multiple 'moves' in a row produce a garbage point, and given culling, probably more efficient to do within line/curve[m
[32m+[m[32m               float dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);[m
[32m+[m[32m               if (dist2 < min_dist*min_dist)[m
[32m+[m[32m                  min_dist = (float) STBTT_sqrt(dist2);[m
[32m+[m
[32m+[m[32m               if (verts[i].type == STBTT_vline) {[m
[32m+[m[32m                  float x1 = verts[i-1].x*scale_x, y1 = verts[i-1].y*scale_y;[m
[32m+[m
[32m+[m[32m                  // coarse culling against bbox[m
[32m+[m[32m                  //if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&[m
[32m+[m[32m                  //    sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)[m
[32m+[m[32m                  float dist = (float) STBTT_fabs((x1-x0)*(y0-sy) - (y1-y0)*(x0-sx)) * precompute[i];[m
[32m+[m[32m                  STBTT_assert(i != 0);[m
[32m+[m[32m                  if (dist < min_dist) {[m
[32m+[m[32m                     // check position along line[m
[32m+[m[32m                     // x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)[m
[32m+[m[32m                     // minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)[m
[32m+[m[32m                     float dx = x1-x0, dy = y1-y0;[m
[32m+[m[32m                     float px = x0-sx, py = y0-sy;[m
[32m+[m[32m                     // minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy[m
[32m+[m[32m                     // derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve[m
[32m+[m[32m                     float t = -(px*dx + py*dy) / (dx*dx + dy*dy);[m
[32m+[m[32m                     if (t >= 0.0f && t <= 1.0f)[m
[32m+[m[32m                        min_dist = dist;[m
[32m+[m[32m                  }[m
[32m+[m[32m               } else if (verts[i].type == STBTT_vcurve) {[m
[32m+[m[32m                  float x2 = verts[i-1].x *scale_x, y2 = verts[i-1].y *scale_y;[m
[32m+[m[32m                  float x1 = verts[i  ].cx*scale_x, y1 = verts[i  ].cy*scale_y;[m
[32m+[m[32m                  float box_x0 = STBTT_min(STBTT_min(x0,x1),x2);[m
[32m+[m[32m                  float box_y0 = STBTT_min(STBTT_min(y0,y1),y2);[m
[32m+[m[32m                  float box_x1 = STBTT_max(STBTT_max(x0,x1),x2);[m
[32m+[m[32m                  float box_y1 = STBTT_max(STBTT_max(y0,y1),y2);[m
[32m+[m[32m                  // coarse culling against bbox to avoid computing cubic unnecessarily[m
[32m+[m[32m                  if (sx > box_x0-min_dist && sx < box_x1+min_dist && sy > box_y0-min_dist && sy < box_y1+min_dist) {[m
[32m+[m[32m                     int num=0;[m
[32m+[m[32m                     float ax = x1-x0, ay = y1-y0;[m
[32m+[m[32m                     float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;[m
[32m+[m[32m                     float mx = x0 - sx, my = y0 - sy;[m
[32m+[m[32m                     float res[3],px,py,t,it;[m
[32m+[m[32m                     float a_inv = precompute[i];[m
[32m+[m[32m                     if (a_inv == 0.0) { // if a_inv is 0, it's 2nd degree so use quadratic formula[m
[32m+[m[32m                        float a = 3*(ax*bx + ay*by);[m
[32m+[m[32m                        float b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);[m
[32m+[m[32m                        float c = mx*ax+my*ay;[m
[32m+[m[32m                        if (a == 0.0) { // if a is 0, it's linear[m
[32m+[m[32m                           if (b != 0.0) {[m
[32m+[m[32m                              res[num++] = -c/b;[m
[32m+[m[32m                           }[m
[32m+[m[32m                        } else {[m
[32m+[m[32m                           float discriminant = b*b - 4*a*c;[m
[32m+[m[32m                           if (discriminant < 0)[m
[32m+[m[32m                              num = 0;[m
[32m+[m[32m                           else {[m
[32m+[m[32m                              float root = (float) STBTT_sqrt(discriminant);[m
[32m+[m[32m                              res[0] = (-b - root)/(2*a);[m
[32m+[m[32m                              res[1] = (-b + root)/(2*a);[m
[32m+[m[32m                              num = 2; // don't bother distinguishing 1-solution case, as code below will still work[m
[32m+[m[32m                           }[m
[32m+[m[32m                        }[m
[32m+[m[32m                     } else {[m
[32m+[m[32m                        float b = 3*(ax*bx + ay*by) * a_inv; // could precompute this as it doesn't depend on sample point[m
[32m+[m[32m                        float c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a_inv;[m
[32m+[m[32m                        float d = (mx*ax+my*ay) * a_inv;[m
[32m+[m[32m                        num = stbtt__solve_cubic(b, c, d, res);[m
[32m+[m[32m                     }[m
[32m+[m[32m                     if (num >= 1 && res[0] >= 0.0f && res[0] <= 1.0f) {[m
[32m+[m[32m                        t = res[0], it = 1.0f - t;[m
[32m+[m[32m                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;[m
[32m+[m[32m                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;[m
[32m+[m[32m                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);[m
[32m+[m[32m                        if (dist2 < min_dist * min_dist)[m
[32m+[m[32m                           min_dist = (float) STBTT_sqrt(dist2);[m
[32m+[m[32m                     }[m
[32m+[m[32m                     if (num >= 2 && res[1] >= 0.0f && res[1] <= 1.0f) {[m
[32m+[m[32m                        t = res[1], it = 1.0f - t;[m
[32m+[m[32m                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;[m
[32m+[m[32m                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;[m
[32m+[m[32m                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);[m
[32m+[m[32m                        if (dist2 < min_dist * min_dist)[m
[32m+[m[32m                           min_dist = (float) STBTT_sqrt(dist2);[m
[32m+[m[32m                     }[m
[32m+[m[32m                     if (num >= 3 && res[2] >= 0.0f && res[2] <= 1.0f) {[m
[32m+[m[32m                        t = res[2], it = 1.0f - t;[m
[32m+[m[32m                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;[m
[32m+[m[32m                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;[m
[32m+[m[32m                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);[m
[32m+[m[32m                        if (dist2 < min_dist * min_dist)[m
[32m+[m[32m                           min_dist = (float) STBTT_sqrt(dist2);[m
[32m+[m[32m                     }[m
[32m+[m[32m                  }[m
[32m+[m[32m               }[m
[32m+[m[32m            }[m
[32m+[m[32m            if (winding == 0)[m
[32m+[m[32m               min_dist = -min_dist;  // if outside the shape, value is negative[m
[32m+[m[32m            val = onedge_value + pixel_dist_scale * min_dist;[m
[32m+[m[32m            if (val < 0)[m
[32m+[m[32m               val = 0;[m
[32m+[m[32m            else if (val > 255)[m
[32m+[m[32m               val = 255;[m
[32m+[m[32m            data[(y-iy0)*w+(x-ix0)] = (unsigned char) val;[m
[32m+[m[32m         }[m
[32m+[m[32m      }[m
[32m+[m[32m      STBTT_free(precompute, info->userdata);[m
[32m+[m[32m      STBTT_free(verts, info->userdata);[m
[32m+[m[32m   }[m
[32m+[m[32m   return data;[m
[32m+[m[32m}[m[41m   [m
[32m+[m
[32m+[m[32mSTBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)[m
[32m+[m[32m{[m
[32m+[m[32m   return stbtt_GetGlyphSDF(info, scale, stbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)[m
[32m+[m[32m{[m
[32m+[m[32m   STBTT_free(bitmap, userdata);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// font name matching -- recommended not to use this[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32m// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string[m
[32m+[m[32mstatic stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2)[m[41m [m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_int32 i=0;[m
[32m+[m
[32m+[m[32m   // convert utf16 to utf8 and compare the results while converting[m
[32m+[m[32m   while (len2) {[m
[32m+[m[32m      stbtt_uint16 ch = s2[0]*256 + s2[1];[m
[32m+[m[32m      if (ch < 0x80) {[m
[32m+[m[32m         if (i >= len1) return -1;[m
[32m+[m[32m         if (s1[i++] != ch) return -1;[m
[32m+[m[32m      } else if (ch < 0x800) {[m
[32m+[m[32m         if (i+1 >= len1) return -1;[m
[32m+[m[32m         if (s1[i++] != 0xc0 + (ch >> 6)) return -1;[m
[32m+[m[32m         if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;[m
[32m+[m[32m      } else if (ch >= 0xd800 && ch < 0xdc00) {[m
[32m+[m[32m         stbtt_uint32 c;[m
[32m+[m[32m         stbtt_uint16 ch2 = s2[2]*256 + s2[3];[m
[32m+[m[32m         if (i+3 >= len1) return -1;[m
[32m+[m[32m         c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;[m
[32m+[m[32m         if (s1[i++] != 0xf0 + (c >> 18)) return -1;[m
[32m+[m[32m         if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;[m
[32m+[m[32m         if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;[m
[32m+[m[32m         if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;[m
[32m+[m[32m         s2 += 2; // plus another 2 below[m
[32m+[m[32m         len2 -= 2;[m
[32m+[m[32m      } else if (ch >= 0xdc00 && ch < 0xe000) {[m
[32m+[m[32m         return -1;[m
[32m+[m[32m      } else {[m
[32m+[m[32m         if (i+2 >= len1) return -1;[m
[32m+[m[32m         if (s1[i++] != 0xe0 + (ch >> 12)) return -1;[m
[32m+[m[32m         if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;[m
[32m+[m[32m         if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;[m
[32m+[m[32m      }[m
[32m+[m[32m      s2 += 2;[m
[32m+[m[32m      len2 -= 2;[m
[32m+[m[32m   }[m
[32m+[m[32m   return i;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2)[m[41m [m
[32m+[m[32m{[m
[32m+[m[32m   return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*) s1, len1, (stbtt_uint8*) s2, len2);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// returns results in whatever encoding you request... but note that 2-byte encodings[m
[32m+[m[32m// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare[m
[32m+[m[32mSTBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_int32 i,count,stringOffset;[m
[32m+[m[32m   stbtt_uint8 *fc = font->data;[m
[32m+[m[32m   stbtt_uint32 offset = font->fontstart;[m
[32m+[m[32m   stbtt_uint32 nm = stbtt__find_table(fc, offset, "name");[m
[32m+[m[32m   if (!nm) return NULL;[m
[32m+[m
[32m+[m[32m   count = ttUSHORT(fc+nm+2);[m
[32m+[m[32m   stringOffset = nm + ttUSHORT(fc+nm+4);[m
[32m+[m[32m   for (i=0; i < count; ++i) {[m
[32m+[m[32m      stbtt_uint32 loc = nm + 6 + 12 * i;[m
[32m+[m[32m      if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)[m
[32m+[m[32m          && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {[m
[32m+[m[32m         *length = ttUSHORT(fc+loc+8);[m
[32m+[m[32m         return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));[m
[32m+[m[32m      }[m
[32m+[m[32m   }[m
[32m+[m[32m   return NULL;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_int32 i;[m
[32m+[m[32m   stbtt_int32 count = ttUSHORT(fc+nm+2);[m
[32m+[m[32m   stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);[m
[32m+[m
[32m+[m[32m   for (i=0; i < count; ++i) {[m
[32m+[m[32m      stbtt_uint32 loc = nm + 6 + 12 * i;[m
[32m+[m[32m      stbtt_int32 id = ttUSHORT(fc+loc+6);[m
[32m+[m[32m      if (id == target_id) {[m
[32m+[m[32m         // find the encoding[m
[32m+[m[32m         stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);[m
[32m+[m
[32m+[m[32m         // is this a Unicode encoding?[m
[32m+[m[32m         if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {[m
[32m+[m[32m            stbtt_int32 slen = ttUSHORT(fc+loc+8);[m
[32m+[m[32m            stbtt_int32 off = ttUSHORT(fc+loc+10);[m
[32m+[m
[32m+[m[32m            // check if there's a prefix match[m
[32m+[m[32m            stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);[m
[32m+[m[32m            if (matchlen >= 0) {[m
[32m+[m[32m               // check for target_id+1 immediately following, with same encoding & language[m
[32m+[m[32m               if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {[m
[32m+[m[32m                  slen = ttUSHORT(fc+loc+12+8);[m
[32m+[m[32m                  off = ttUSHORT(fc+loc+12+10);[m
[32m+[m[32m                  if (slen == 0) {[m
[32m+[m[32m                     if (matchlen == nlen)[m
[32m+[m[32m                        return 1;[m
[32m+[m[32m                  } else if (matchlen < nlen && name[matchlen] == ' ') {[m
[32m+[m[32m                     ++matchlen;[m
[32m+[m[32m                     if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))[m
[32m+[m[32m                        return 1;[m
[32m+[m[32m                  }[m
[32m+[m[32m               } else {[m
[32m+[m[32m                  // if nothing immediately following[m
[32m+[m[32m                  if (matchlen == nlen)[m
[32m+[m[32m                     return 1;[m
[32m+[m[32m               }[m
[32m+[m[32m            }[m
[32m+[m[32m         }[m
[32m+[m
[32m+[m[32m         // @TODO handle other encodings[m
[32m+[m[32m      }[m
[32m+[m[32m   }[m
[32m+[m[32m   return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);[m
[32m+[m[32m   stbtt_uint32 nm,hd;[m
[32m+[m[32m   if (!stbtt__isfont(fc+offset)) return 0;[m
[32m+[m
[32m+[m[32m   // check italics/bold/underline flags in macStyle...[m
[32m+[m[32m   if (flags) {[m
[32m+[m[32m      hd = stbtt__find_table(fc, offset, "head");[m
[32m+[m[32m      if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   nm = stbtt__find_table(fc, offset, "name");[m
[32m+[m[32m   if (!nm) return 0;[m
[32m+[m
[32m+[m[32m   if (flags) {[m
[32m+[m[32m      // if we checked the macStyle flags, then just check the family and ignore the subfamily[m
[32m+[m[32m      if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;[m
[32m+[m[32m      if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;[m
[32m+[m[32m      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;[m
[32m+[m[32m   } else {[m
[32m+[m[32m      if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;[m
[32m+[m[32m      if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;[m
[32m+[m[32m      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m   return 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)[m
[32m+[m[32m{[m
[32m+[m[32m   stbtt_int32 i;[m
[32m+[m[32m   for (i=0;;++i) {[m
[32m+[m[32m      stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);[m
[32m+[m[32m      if (off < 0) return off;[m
[32m+[m[32m      if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))[m
[32m+[m[32m         return off;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#if defined(__GNUC__) || defined(__clang__)[m
[32m+[m[32m#pragma GCC diagnostic push[m
[32m+[m[32m#pragma GCC diagnostic ignored "-Wcast-qual"[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,[m
[32m+[m[32m                                float pixel_height, unsigned char *pixels, int pw, int ph,[m
[32m+[m[32m                                int first_char, int num_chars, stbtt_bakedchar *chardata)[m
[32m+[m[32m{[m
[32m+[m[32m   return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)[m
[32m+[m[32m{[m
[32m+[m[32m   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);[m[41m   [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)[m
[32m+[m[32m{[m
[32m+[m[32m   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)[m
[32m+[m[32m{[m
[32m+[m[32m   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)[m
[32m+[m[32m{[m
[32m+[m[32m   return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mSTBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)[m
[32m+[m[32m{[m
[32m+[m[32m   return stbtt_CompareUTF8toUTF16_bigendian_internal((char *) s1, len1, (char *) s2, len2);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#if defined(__GNUC__) || defined(__clang__)[m
[32m+[m[32m#pragma GCC diagnostic pop[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif // STB_TRUETYPE_IMPLEMENTATION[m
[32m+[m
[32m+[m
[32m+[m[32m// FULL VERSION HISTORY[m
[32m+[m[32m//[m
[32m+[m[32m//   1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod[m
[32m+[m[32m//   1.18 (2018-01-29) add missing function[m
[32m+[m[32m//   1.17 (2017-07-23) make more arguments const; doc fix[m
[32m+[m[32m//   1.16 (2017-07-12) SDF support[m
[32m+[m[32m//   1.15 (2017-03-03) make more arguments const[m
[32m+[m[32m//   1.14 (2017-01-16) num-fonts-in-TTC function[m
[32m+[m[32m//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts[m
[32m+[m[32m//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual[m
[32m+[m[32m//   1.11 (2016-04-02) fix unused-variable warning[m
[32m+[m[32m//   1.10 (2016-04-02) allow user-defined fabs() replacement[m
[32m+[m[32m//                     fix memory leak if fontsize=0.0[m
[32m+[m[32m//                     fix warning from duplicate typedef[m
[32m+[m[32m//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges[m
[32m+[m[32m//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges[m
[32m+[m[32m//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;[m
[32m+[m[32m//                     allow PackFontRanges to pack and render in separate phases;[m
[32m+[m[32m//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);[m
[32m+[m[32m//                     fixed an assert() bug in the new rasterizer[m
[32m+[m[32m//                     replace assert() with STBTT_assert() in new rasterizer[m
[32m+[m[32m//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)[m
[32m+[m[32m//                     also more precise AA rasterizer, except if shapes overlap[m
[32m+[m[32m//                     remove need for STBTT_sort[m
[32m+[m[32m//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC[m
[32m+[m[32m//   1.04 (2015-04-15) typo in example[m
[32m+[m[32m//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes[m
[32m+[m[32m//   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++[m
[32m+[m[32m//   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match[m
[32m+[m[32m//                        non-oversampled; STBTT_POINT_SIZE for packed case only[m
[32m+[m[32m//   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling[m
[32m+[m[32m//   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)[m
[32m+[m[32m//   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID[m
[32m+[m[32m//   0.8b (2014-07-07) fix a warning[m
[32m+[m[32m//   0.8  (2014-05-25) fix a few more warnings[m
[32m+[m[32m//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back[m
[32m+[m[32m//   0.6c (2012-07-24) improve documentation[m
[32m+[m[32m//   0.6b (2012-07-20) fix a few more warnings[m
[32m+[m[32m//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,[m
[32m+[m[32m//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty[m
[32m+[m[32m//   0.5  (2011-12-09) bugfixes:[m
[32m+[m[32m//                        subpixel glyph renderer computed wrong bounding box[m
[32m+[m[32m//                        first vertex of shape can be off-curve (FreeSans)[m
[32m+[m[32m//   0.4b (2011-12-03) fixed an error in the font baking example[m
[32m+[m[32m//   0.4  (2011-12-01) kerning, subpixel rendering (tor)[m
[32m+[m[32m//                    bugfixes for:[m
[32m+[m[32m//                        codepoint-to-glyph conversion using table fmt=12[m
[32m+[m[32m//                        codepoint-to-glyph conversion using table fmt=4[m
[32m+[m[32m//                        stbtt_GetBakedQuad with non-square texture (Zer)[m
[32m+[m[32m//                    updated Hello World! sample to use kerning and subpixel[m
[32m+[m[32m//                    fixed some warnings[m
[32m+[m[32m//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)[m
[32m+[m[32m//                    userdata, malloc-from-userdata, non-zero fill (stb)[m
[32m+[m[32m//   0.2  (2009-03-11) Fix unsigned/signed char warnings[m
[32m+[m[32m//   0.1  (2009-03-09) First public release[m
[32m+[m[32m//[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m[32m------------------------------------------------------------------------------[m
[32m+[m[32mThis software is available under 2 licenses -- choose whichever you prefer.[m
[32m+[m[32m------------------------------------------------------------------------------[m
[32m+[m[32mALTERNATIVE A - MIT License[m
[32m+[m[32mCopyright (c) 2017 Sean Barrett[m
[32m+[m[32mPermission is hereby granted, free of charge, to any person obtaining a copy of[m[41m [m
[32m+[m[32mthis software and associated documentation files (the "Software"), to deal in[m[41m [m
[32m+[m[32mthe Software without restriction, including without limitation the rights to[m[41m [m
[32m+[m[32muse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies[m[41m [m
[32m+[m[32mof the Software, and to permit persons to whom the Software is furnished to do[m[41m [m
[32m+[m[32mso, subject to the following conditions:[m
[32m+[m[32mThe above copyright notice and this permission notice shall be included in all[m[41m [m
[32m+[m[32mcopies or substantial portions of the Software.[m
[32m+[m[32mTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR[m[41m [m
[32m+[m[32mIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,[m[41m [m
[32m+[m[32mFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE[m[41m [m
[32m+[m[32mAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER[m[41m [m
[32m+[m[32mLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,[m[41m [m
[32m+[m[32mOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE[m[41m [m
[32m+[m[32mSOFTWARE.[m
[32m+[m[32m------------------------------------------------------------------------------[m
[32m+[m[32mALTERNATIVE B - Public Domain (www.unlicense.org)[m
[32m+[m[32mThis is free and unencumbered software released into the public domain.[m
[32m+[m[32mAnyone is free to copy, modify, publish, use, compile, sell, or distribute this[m[41m [m
[32m+[m[32msoftware, either in source code form or as a compiled binary, for any purpose,[m[41m [m
[32m+[m[32mcommercial or non-commercial, and by any means.[m
[32m+[m[32mIn jurisdictions that recognize copyright laws, the author or authors of this[m[41m [m
[32m+[m[32msoftware dedicate any and all copyright interest in the software to the public[m[41m [m
[32m+[m[32mdomain. We make this dedication for the benefit of the public at large and to[m[41m [m
[32m+[m[32mthe detriment of our heirs and successors. We intend this dedication to be an[m[41m [m
[32m+[m[32movert act of relinquishment in perpetuity of all present and future rights to[m[41m [m
[32m+[m[32mthis software under copyright law.[m
[32m+[m[32mTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR[m[41m [m
[32m+[m[32mIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,[m[41m [m
[32m+[m[32mFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE[m[41m [m
[32m+[m[32mAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN[m[41m [m
[32m+[m[32mACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION[m[41m [m
[32m+[m[32mWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.[m
[32m+[m[32m------------------------------------------------------------------------------[m
[32m+[m[32m*/[m
